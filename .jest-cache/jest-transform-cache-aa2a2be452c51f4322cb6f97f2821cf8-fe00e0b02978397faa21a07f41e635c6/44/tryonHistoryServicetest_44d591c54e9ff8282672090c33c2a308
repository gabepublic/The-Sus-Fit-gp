f85be2ec079ad02e33fd2ff0f3c99edc
/**
 * @jest-environment jsdom
 */ "use strict";
// Mock compression utilities
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        compressBase64: jest.fn((base64)=>Promise.resolve(base64)),
        getBase64Size: jest.fn(()=>1024),
        CompressionFailedError: class extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _tryonHistoryService = require("../../../src/business-layer/services/tryonHistoryService");
// Mock localStorage with complete interface
const mockLocalStorage = (()=>{
    let store = {};
    return {
        getItem: jest.fn((key)=>store[key] || null),
        setItem: jest.fn((key, value)=>{
            store[key] = value;
        }),
        removeItem: jest.fn((key)=>{
            delete store[key];
        }),
        clear: jest.fn(()=>{
            store = {};
        }),
        get length () {
            return Object.keys(store).length;
        },
        key: jest.fn((index)=>{
            const keys = Object.keys(store);
            return keys[index] || null;
        })
    };
})();
// Ensure localStorage is properly available for the service's existence check
Object.defineProperty(window, 'localStorage', {
    value: mockLocalStorage,
    writable: true,
    configurable: true,
    enumerable: true
});
// Also set on global for extra compatibility
Object.defineProperty(global, 'localStorage', {
    value: mockLocalStorage,
    writable: true,
    configurable: true,
    enumerable: true
});
describe('LocalStorageTryonHistoryService', ()=>{
    let historyService;
    const sampleHistoryEntry = {
        generatedImage: 'data:image/jpeg;base64,generated-image-data',
        modelImage: 'data:image/jpeg;base64,model-image-data',
        apparelImages: [
            'data:image/jpeg;base64,apparel-image-data'
        ],
        processingTime: 5000,
        metadata: {
            modelVersion: '1.0.0',
            appliedQuality: 'high'
        },
        tags: [
            'test',
            'sample'
        ],
        notes: 'Test history entry'
    };
    beforeEach(()=>{
        // Clear localStorage
        mockLocalStorage.clear();
        jest.clearAllMocks();
        // Create new service instance
        historyService = new _tryonHistoryService.LocalStorageTryonHistoryService();
    });
    describe('Initialization', ()=>{
        it('should initialize localStorage with default values', async ()=>{
            // Force initialization by calling a method
            await historyService.getEntries();
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_config', expect.stringContaining('localStorage'));
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_entries', '[]');
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_metadata', expect.stringContaining('version'));
        });
        it('should use custom configuration when provided', ()=>{
            const customConfig = {
                maxEntries: 100,
                compressImages: false
            };
            const customService = new _tryonHistoryService.LocalStorageTryonHistoryService(customConfig);
            expect(customService.getConfig().maxEntries).toBe(100);
            expect(customService.getConfig().compressImages).toBe(false);
        });
        it('should handle localStorage unavailability gracefully', async ()=>{
            // Mock localStorage as undefined
            Object.defineProperty(window, 'localStorage', {
                value: undefined,
                configurable: true
            });
            const testService = new _tryonHistoryService.LocalStorageTryonHistoryService();
            await expect(testService.getEntries()).rejects.toThrow('History storage initialization failed');
            // Restore localStorage
            Object.defineProperty(window, 'localStorage', {
                value: mockLocalStorage,
                configurable: true
            });
        });
    });
    describe('Adding History Entries', ()=>{
        it('should add a new history entry successfully', async ()=>{
            const entry = await historyService.addEntry(sampleHistoryEntry);
            expect(entry.id).toBeDefined();
            expect(entry.timestamp).toBeDefined();
            expect(entry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
            expect(entry.modelImage).toBe(sampleHistoryEntry.modelImage);
            expect(entry.apparelImages).toEqual(sampleHistoryEntry.apparelImages);
            expect(entry.processingTime).toBe(sampleHistoryEntry.processingTime);
            expect(entry.tags).toEqual(sampleHistoryEntry.tags);
            expect(entry.notes).toBe(sampleHistoryEntry.notes);
            // Verify localStorage was updated
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_entries', expect.stringContaining(entry.id));
        });
        it('should generate unique IDs for entries', async ()=>{
            const entry1 = await historyService.addEntry(sampleHistoryEntry);
            const entry2 = await historyService.addEntry(sampleHistoryEntry);
            expect(entry1.id).not.toBe(entry2.id);
        });
        it('should apply default values for optional fields', async ()=>{
            const minimalEntry = {
                generatedImage: 'generated',
                modelImage: 'model',
                apparelImages: [
                    'apparel'
                ]
            };
            const entry = await historyService.addEntry(minimalEntry);
            expect(entry.tags).toEqual([]);
            expect(entry.isFavorite).toBe(false);
            expect(entry.notes).toBe('');
        });
        it('should handle compression when enabled', async ()=>{
            const compressEnabledService = new _tryonHistoryService.LocalStorageTryonHistoryService({
                compressImages: true,
                compressionQuality: 0.8
            });
            const entry = await compressEnabledService.addEntry(sampleHistoryEntry);
            expect(entry.id).toBeDefined();
            // Compression mock should have been called
            const { compressBase64 } = require('../../../src/utils/image');
            expect(compressBase64).toHaveBeenCalled();
        });
    });
    describe('Retrieving History Entries', ()=>{
        beforeEach(async ()=>{
            // Add some test entries
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag1'
                ],
                notes: 'First entry'
            });
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag2'
                ],
                notes: 'Second entry',
                isFavorite: true
            });
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag1',
                    'tag2'
                ],
                notes: 'Third entry'
            });
        });
        it('should retrieve all entries without options', async ()=>{
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(3);
            expect(result.totalCount).toBe(3);
            expect(result.currentPage).toBe(0);
            expect(result.hasMore).toBe(false);
        });
        it('should apply pagination correctly', async ()=>{
            const options = {
                page: 0,
                pageSize: 2
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(2);
            expect(result.totalCount).toBe(3);
            expect(result.currentPage).toBe(0);
            expect(result.pageSize).toBe(2);
            expect(result.hasMore).toBe(true);
        });
        it('should filter by favorites only', async ()=>{
            const options = {
                favoritesOnly: true
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].isFavorite).toBe(true);
        });
        it('should filter by search term', async ()=>{
            const options = {
                searchTerm: 'Second'
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].notes).toContain('Second');
        });
        it('should sort entries correctly', async ()=>{
            const options = {
                sortBy: 'timestamp',
                sortDirection: 'asc'
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(3);
            // Should be in ascending order
            const timestamps = result.entries.map((e)=>new Date(e.timestamp).getTime());
            expect(timestamps[0]).toBeLessThanOrEqual(timestamps[1]);
            expect(timestamps[1]).toBeLessThanOrEqual(timestamps[2]);
        });
    });
    describe('Single Entry Operations', ()=>{
        let entryId;
        beforeEach(async ()=>{
            const entry = await historyService.addEntry(sampleHistoryEntry);
            entryId = entry.id;
        });
        it('should retrieve a specific entry by ID', async ()=>{
            const entry = await historyService.getEntry(entryId);
            expect(entry).not.toBeNull();
            expect(entry.id).toBe(entryId);
            expect(entry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
        });
        it('should return null for non-existent entry', async ()=>{
            const entry = await historyService.getEntry('non-existent-id');
            expect(entry).toBeNull();
        });
        it('should update an existing entry', async ()=>{
            const updates = {
                notes: 'Updated notes',
                isFavorite: true,
                tags: [
                    'updated',
                    'tags'
                ]
            };
            const updatedEntry = await historyService.updateEntry(entryId, updates);
            expect(updatedEntry.id).toBe(entryId);
            expect(updatedEntry.notes).toBe('Updated notes');
            expect(updatedEntry.isFavorite).toBe(true);
            expect(updatedEntry.tags).toEqual([
                'updated',
                'tags'
            ]);
            // Original data should be preserved
            expect(updatedEntry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
        });
        it('should throw error when updating non-existent entry', async ()=>{
            await expect(historyService.updateEntry('non-existent-id', {
                notes: 'test'
            })).rejects.toThrow('History entry with ID non-existent-id not found');
        });
        it('should delete an entry successfully', async ()=>{
            const deleted = await historyService.deleteEntry(entryId);
            expect(deleted).toBe(true);
            // Entry should no longer exist
            const entry = await historyService.getEntry(entryId);
            expect(entry).toBeNull();
        });
        it('should return false when deleting non-existent entry', async ()=>{
            const deleted = await historyService.deleteEntry('non-existent-id');
            expect(deleted).toBe(false);
        });
    });
    describe('Bulk Operations', ()=>{
        beforeEach(async ()=>{
            // Add multiple test entries
            for(let i = 0; i < 5; i++){
                await historyService.addEntry({
                    ...sampleHistoryEntry,
                    notes: `Entry ${i}`
                });
            }
        });
        it('should clear all entries', async ()=>{
            const cleared = await historyService.clearAll();
            expect(cleared).toBe(true);
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(0);
        });
        it('should export all history data', async ()=>{
            const exported = await historyService.exportHistory();
            expect(exported).toHaveLength(5);
            expect(exported[0].notes).toContain('Entry');
        });
        it('should import history data', async ()=>{
            // Clear existing entries
            await historyService.clearAll();
            // Create import data
            const importData = [
                {
                    id: 'import-1',
                    timestamp: new Date().toISOString(),
                    generatedImage: 'imported-generated',
                    modelImage: 'imported-model',
                    apparelImages: [
                        'imported-apparel'
                    ],
                    tags: [
                        'imported'
                    ],
                    notes: 'Imported entry',
                    isFavorite: false
                }
            ];
            const importedCount = await historyService.importHistory(importData);
            expect(importedCount).toBe(1);
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].id).toBe('import-1');
        });
        it('should not import duplicate entries', async ()=>{
            const existingEntries = await historyService.exportHistory();
            const duplicateImport = existingEntries.slice(0, 2); // Try to import first 2 existing entries
            const importedCount = await historyService.importHistory(duplicateImport);
            expect(importedCount).toBe(0); // No new entries should be imported
        });
    });
    describe('Storage Statistics', ()=>{
        beforeEach(async ()=>{
            // Add test entries with different timestamps
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'First entry'
            });
            // Add slight delay to ensure different timestamps
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Last entry'
            });
        });
        it('should return accurate storage statistics', async ()=>{
            const stats = await historyService.getStorageStats();
            expect(stats.totalEntries).toBe(2);
            expect(stats.totalSizeKB).toBeGreaterThan(0);
            expect(stats.oldestEntry).toBeDefined();
            expect(stats.newestEntry).toBeDefined();
            expect(new Date(stats.oldestEntry).getTime()).toBeLessThanOrEqual(new Date(stats.newestEntry).getTime());
        });
    });
    describe('Configuration Management', ()=>{
        it('should update configuration correctly', ()=>{
            const newConfig = {
                maxEntries: 200,
                compressImages: false
            };
            historyService.updateConfig(newConfig);
            const config = historyService.getConfig();
            expect(config.maxEntries).toBe(200);
            expect(config.compressImages).toBe(false);
        });
        it('should perform cleanup when maxEntries is exceeded', async ()=>{
            // Set low max entries limit
            historyService.updateConfig({
                maxEntries: 2
            });
            // Add more entries than the limit with small delays to ensure different timestamps
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 1'
            });
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 2'
            });
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 3'
            });
            const result = await historyService.getEntries();
            // Should only keep the most recent entries (sorted by timestamp desc)
            expect(result.entries).toHaveLength(2);
            // The most recent entries should be kept (Entry 2 and Entry 3)
            // Entry 1 should be removed as it's the oldest
            const entryNotes = result.entries.map((e)=>e.notes);
            expect(entryNotes).toContain('Entry 2');
            expect(entryNotes).toContain('Entry 3');
            expect(entryNotes).not.toContain('Entry 1');
        });
    });
    describe('Error Handling', ()=>{
        it('should handle localStorage write errors gracefully', async ()=>{
            // Mock localStorage.setItem to throw an error
            mockLocalStorage.setItem.mockImplementationOnce(()=>{
                throw new Error('localStorage full');
            });
            await expect(historyService.addEntry(sampleHistoryEntry)).rejects.toThrow('Failed to save history entries');
        });
        it('should handle corrupted localStorage data', ()=>{
            // Set corrupted data in localStorage
            mockLocalStorage.getItem.mockReturnValueOnce('invalid-json');
            // Should return empty array instead of throwing
            const entries = historyService.getStoredEntries();
            expect(entries).toEqual([]);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL3NlcnZpY2VzL3RyeW9uSGlzdG9yeVNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBqZXN0LWVudmlyb25tZW50IGpzZG9tXG4gKi9cblxuaW1wb3J0IHsgTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci9zZXJ2aWNlcy90cnlvbkhpc3RvcnlTZXJ2aWNlJztcbmltcG9ydCB0eXBlIHtcbiAgQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zLFxuICBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMsXG4gIFRyeW9uSGlzdG9yeVN0b3JhZ2VDb25maWdcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3R5cGVzL2hpc3RvcnkudHlwZXMnO1xuXG4vLyBNb2NrIGxvY2FsU3RvcmFnZSB3aXRoIGNvbXBsZXRlIGludGVyZmFjZVxuY29uc3QgbW9ja0xvY2FsU3RvcmFnZSA9ICgoKSA9PiB7XG4gIGxldCBzdG9yZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBcbiAgcmV0dXJuIHtcbiAgICBnZXRJdGVtOiBqZXN0LmZuKChrZXk6IHN0cmluZykgPT4gc3RvcmVba2V5XSB8fCBudWxsKSxcbiAgICBzZXRJdGVtOiBqZXN0LmZuKChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIH0pLFxuICAgIHJlbW92ZUl0ZW06IGplc3QuZm4oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICB9KSxcbiAgICBjbGVhcjogamVzdC5mbigoKSA9PiB7XG4gICAgICBzdG9yZSA9IHt9O1xuICAgIH0pLFxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmUpLmxlbmd0aDtcbiAgICB9LFxuICAgIGtleTogamVzdC5mbigoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0b3JlKTtcbiAgICAgIHJldHVybiBrZXlzW2luZGV4XSB8fCBudWxsO1xuICAgIH0pXG4gIH07XG59KSgpO1xuXG4vLyBFbnN1cmUgbG9jYWxTdG9yYWdlIGlzIHByb3Blcmx5IGF2YWlsYWJsZSBmb3IgdGhlIHNlcnZpY2UncyBleGlzdGVuY2UgY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XG4gIHZhbHVlOiBtb2NrTG9jYWxTdG9yYWdlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcblxuLy8gQWxzbyBzZXQgb24gZ2xvYmFsIGZvciBleHRyYSBjb21wYXRpYmlsaXR5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAnbG9jYWxTdG9yYWdlJywge1xuICB2YWx1ZTogbW9ja0xvY2FsU3RvcmFnZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5cbi8vIE1vY2sgY29tcHJlc3Npb24gdXRpbGl0aWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9pbWFnZVByb2Nlc3NpbmcnLCAoKSA9PiAoe1xuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigoYmFzZTY0OiBzdHJpbmcpID0+IFByb21pc2UucmVzb2x2ZShiYXNlNjQpKSxcbiAgZ2V0QmFzZTY0U2l6ZTogamVzdC5mbigoKSA9PiAxMDI0KSxcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJztcbiAgICB9XG4gIH1cbn0pKTtcblxuZGVzY3JpYmUoJ0xvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBoaXN0b3J5U2VydmljZTogTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZTtcblxuICBjb25zdCBzYW1wbGVIaXN0b3J5RW50cnk6IENyZWF0ZVRyeW9uSGlzdG9yeUVudHJ5T3B0aW9ucyA9IHtcbiAgICBnZW5lcmF0ZWRJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsZ2VuZXJhdGVkLWltYWdlLWRhdGEnLFxuICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vZGVsLWltYWdlLWRhdGEnLFxuICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxhcHBhcmVsLWltYWdlLWRhdGEnXSxcbiAgICBwcm9jZXNzaW5nVGltZTogNTAwMCxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbW9kZWxWZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgYXBwbGllZFF1YWxpdHk6ICdoaWdoJ1xuICAgIH0sXG4gICAgdGFnczogWyd0ZXN0JywgJ3NhbXBsZSddLFxuICAgIG5vdGVzOiAnVGVzdCBoaXN0b3J5IGVudHJ5J1xuICB9O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZVxuICAgIG1vY2tMb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgbmV3IHNlcnZpY2UgaW5zdGFuY2VcbiAgICBoaXN0b3J5U2VydmljZSA9IG5ldyBMb2NhbFN0b3JhZ2VUcnlvbkhpc3RvcnlTZXJ2aWNlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgbG9jYWxTdG9yYWdlIHdpdGggZGVmYXVsdCB2YWx1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBGb3JjZSBpbml0aWFsaXphdGlvbiBieSBjYWxsaW5nIGEgbWV0aG9kXG4gICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnc3VzZml0X3RyeW9uX2hpc3RvcnlfY29uZmlnJyxcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2xvY2FsU3RvcmFnZScpXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdzdXNmaXRfdHJ5b25faGlzdG9yeV9lbnRyaWVzJyxcbiAgICAgICAgJ1tdJ1xuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnc3VzZml0X3RyeW9uX2hpc3RvcnlfbWV0YWRhdGEnLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygndmVyc2lvbicpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgY3VzdG9tIGNvbmZpZ3VyYXRpb24gd2hlbiBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbUNvbmZpZzogUGFydGlhbDxUcnlvbkhpc3RvcnlTdG9yYWdlQ29uZmlnPiA9IHtcbiAgICAgICAgbWF4RW50cmllczogMTAwLFxuICAgICAgICBjb21wcmVzc0ltYWdlczogZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGN1c3RvbVNlcnZpY2UgPSBuZXcgTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZShjdXN0b21Db25maWcpO1xuICAgICAgZXhwZWN0KGN1c3RvbVNlcnZpY2UuZ2V0Q29uZmlnKCkubWF4RW50cmllcykudG9CZSgxMDApO1xuICAgICAgZXhwZWN0KGN1c3RvbVNlcnZpY2UuZ2V0Q29uZmlnKCkuY29tcHJlc3NJbWFnZXMpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9jYWxTdG9yYWdlIHVuYXZhaWxhYmlsaXR5IGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGxvY2FsU3RvcmFnZSBhcyB1bmRlZmluZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRlc3RTZXJ2aWNlID0gbmV3IExvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UoKTtcbiAgICAgIGF3YWl0IGV4cGVjdCh0ZXN0U2VydmljZS5nZXRFbnRyaWVzKCkpLnJlamVjdHMudG9UaHJvdygnSGlzdG9yeSBzdG9yYWdlIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuXG4gICAgICAvLyBSZXN0b3JlIGxvY2FsU3RvcmFnZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2xvY2FsU3RvcmFnZScsIHtcbiAgICAgICAgdmFsdWU6IG1vY2tMb2NhbFN0b3JhZ2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBZGRpbmcgSGlzdG9yeSBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWRkIGEgbmV3IGhpc3RvcnkgZW50cnkgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuXG4gICAgICBleHBlY3QoZW50cnkuaWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZW50cnkudGltZXN0YW1wKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVudHJ5LmdlbmVyYXRlZEltYWdlKS50b0JlKHNhbXBsZUhpc3RvcnlFbnRyeS5nZW5lcmF0ZWRJbWFnZSk7XG4gICAgICBleHBlY3QoZW50cnkubW9kZWxJbWFnZSkudG9CZShzYW1wbGVIaXN0b3J5RW50cnkubW9kZWxJbWFnZSk7XG4gICAgICBleHBlY3QoZW50cnkuYXBwYXJlbEltYWdlcykudG9FcXVhbChzYW1wbGVIaXN0b3J5RW50cnkuYXBwYXJlbEltYWdlcyk7XG4gICAgICBleHBlY3QoZW50cnkucHJvY2Vzc2luZ1RpbWUpLnRvQmUoc2FtcGxlSGlzdG9yeUVudHJ5LnByb2Nlc3NpbmdUaW1lKTtcbiAgICAgIGV4cGVjdChlbnRyeS50YWdzKS50b0VxdWFsKHNhbXBsZUhpc3RvcnlFbnRyeS50YWdzKTtcbiAgICAgIGV4cGVjdChlbnRyeS5ub3RlcykudG9CZShzYW1wbGVIaXN0b3J5RW50cnkubm90ZXMpO1xuXG4gICAgICAvLyBWZXJpZnkgbG9jYWxTdG9yYWdlIHdhcyB1cGRhdGVkXG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ3N1c2ZpdF90cnlvbl9oaXN0b3J5X2VudHJpZXMnLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhlbnRyeS5pZClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHVuaXF1ZSBJRHMgZm9yIGVudHJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeTEgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuICAgICAgY29uc3QgZW50cnkyID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoc2FtcGxlSGlzdG9yeUVudHJ5KTtcblxuICAgICAgZXhwZWN0KGVudHJ5MS5pZCkubm90LnRvQmUoZW50cnkyLmlkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1pbmltYWxFbnRyeTogQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zID0ge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZTogJ2dlbmVyYXRlZCcsXG4gICAgICAgIG1vZGVsSW1hZ2U6ICdtb2RlbCcsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnYXBwYXJlbCddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KG1pbmltYWxFbnRyeSk7XG5cbiAgICAgIGV4cGVjdChlbnRyeS50YWdzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChlbnRyeS5pc0Zhdm9yaXRlKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChlbnRyeS5ub3RlcykudG9CZSgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wcmVzc2lvbiB3aGVuIGVuYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wcmVzc0VuYWJsZWRTZXJ2aWNlID0gbmV3IExvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2Uoe1xuICAgICAgICBjb21wcmVzc0ltYWdlczogdHJ1ZSxcbiAgICAgICAgY29tcHJlc3Npb25RdWFsaXR5OiAwLjhcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGNvbXByZXNzRW5hYmxlZFNlcnZpY2UuYWRkRW50cnkoc2FtcGxlSGlzdG9yeUVudHJ5KTtcblxuICAgICAgZXhwZWN0KGVudHJ5LmlkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgLy8gQ29tcHJlc3Npb24gbW9jayBzaG91bGQgaGF2ZSBiZWVuIGNhbGxlZFxuICAgICAgY29uc3QgeyBjb21wcmVzc0Jhc2U2NCB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL3V0aWxzL2ltYWdlJyk7XG4gICAgICBleHBlY3QoY29tcHJlc3NCYXNlNjQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JldHJpZXZpbmcgSGlzdG9yeSBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIHNvbWUgdGVzdCBlbnRyaWVzXG4gICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeSh7XG4gICAgICAgIC4uLnNhbXBsZUhpc3RvcnlFbnRyeSxcbiAgICAgICAgdGFnczogWyd0YWcxJ10sXG4gICAgICAgIG5vdGVzOiAnRmlyc3QgZW50cnknXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICB0YWdzOiBbJ3RhZzInXSxcbiAgICAgICAgbm90ZXM6ICdTZWNvbmQgZW50cnknLFxuICAgICAgICBpc0Zhdm9yaXRlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICB0YWdzOiBbJ3RhZzEnLCAndGFnMiddLFxuICAgICAgICBub3RlczogJ1RoaXJkIGVudHJ5J1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHJpZXZlIGFsbCBlbnRyaWVzIHdpdGhvdXQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LnRvdGFsQ291bnQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRQYWdlKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5oYXNNb3JlKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgcGFnaW5hdGlvbiBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgIHBhZ2U6IDAsXG4gICAgICAgIHBhZ2VTaXplOiAyXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKG9wdGlvbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmVudHJpZXMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG90YWxDb3VudCkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFBhZ2UpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnBhZ2VTaXplKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5oYXNNb3JlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgZmF2b3JpdGVzIG9ubHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgIGZhdm9yaXRlc09ubHk6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMob3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLmlzRmF2b3JpdGUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBzZWFyY2ggdGVybScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFRyeW9uSGlzdG9yeVF1ZXJ5T3B0aW9ucyA9IHtcbiAgICAgICAgc2VhcmNoVGVybTogJ1NlY29uZCdcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMob3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLm5vdGVzKS50b0NvbnRhaW4oJ1NlY29uZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzb3J0IGVudHJpZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogVHJ5b25IaXN0b3J5UXVlcnlPcHRpb25zID0ge1xuICAgICAgICBzb3J0Qnk6ICd0aW1lc3RhbXAnLFxuICAgICAgICBzb3J0RGlyZWN0aW9uOiAnYXNjJ1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcyhvcHRpb25zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAvLyBTaG91bGQgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICBjb25zdCB0aW1lc3RhbXBzID0gcmVzdWx0LmVudHJpZXMubWFwKGUgPT4gbmV3IERhdGUoZS50aW1lc3RhbXApLmdldFRpbWUoKSk7XG4gICAgICBleHBlY3QodGltZXN0YW1wc1swXSkudG9CZUxlc3NUaGFuT3JFcXVhbCh0aW1lc3RhbXBzWzFdKTtcbiAgICAgIGV4cGVjdCh0aW1lc3RhbXBzWzFdKS50b0JlTGVzc1RoYW5PckVxdWFsKHRpbWVzdGFtcHNbMl0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2luZ2xlIEVudHJ5IE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgbGV0IGVudHJ5SWQ6IHN0cmluZztcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuICAgICAgZW50cnlJZCA9IGVudHJ5LmlkO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBhIHNwZWNpZmljIGVudHJ5IGJ5IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyeShlbnRyeUlkKTtcblxuICAgICAgZXhwZWN0KGVudHJ5KS5ub3QudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChlbnRyeSEuaWQpLnRvQmUoZW50cnlJZCk7XG4gICAgICBleHBlY3QoZW50cnkhLmdlbmVyYXRlZEltYWdlKS50b0JlKHNhbXBsZUhpc3RvcnlFbnRyeS5nZW5lcmF0ZWRJbWFnZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBub24tZXhpc3RlbnQgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJ5KCdub24tZXhpc3RlbnQtaWQnKTtcblxuICAgICAgZXhwZWN0KGVudHJ5KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgYW4gZXhpc3RpbmcgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgICBub3RlczogJ1VwZGF0ZWQgbm90ZXMnLFxuICAgICAgICBpc0Zhdm9yaXRlOiB0cnVlLFxuICAgICAgICB0YWdzOiBbJ3VwZGF0ZWQnLCAndGFncyddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVkRW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS51cGRhdGVFbnRyeShlbnRyeUlkLCB1cGRhdGVzKTtcblxuICAgICAgZXhwZWN0KHVwZGF0ZWRFbnRyeS5pZCkudG9CZShlbnRyeUlkKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkubm90ZXMpLnRvQmUoJ1VwZGF0ZWQgbm90ZXMnKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkuaXNGYXZvcml0ZSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkudGFncykudG9FcXVhbChbJ3VwZGF0ZWQnLCAndGFncyddKTtcbiAgICAgIC8vIE9yaWdpbmFsIGRhdGEgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgZXhwZWN0KHVwZGF0ZWRFbnRyeS5nZW5lcmF0ZWRJbWFnZSkudG9CZShzYW1wbGVIaXN0b3J5RW50cnkuZ2VuZXJhdGVkSW1hZ2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIHVwZGF0aW5nIG5vbi1leGlzdGVudCBlbnRyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgaGlzdG9yeVNlcnZpY2UudXBkYXRlRW50cnkoJ25vbi1leGlzdGVudC1pZCcsIHsgbm90ZXM6ICd0ZXN0JyB9KVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0hpc3RvcnkgZW50cnkgd2l0aCBJRCBub24tZXhpc3RlbnQtaWQgbm90IGZvdW5kJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhbiBlbnRyeSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZGVsZXRlRW50cnkoZW50cnlJZCk7XG5cbiAgICAgIGV4cGVjdChkZWxldGVkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBFbnRyeSBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJ5KGVudHJ5SWQpO1xuICAgICAgZXhwZWN0KGVudHJ5KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiBkZWxldGluZyBub24tZXhpc3RlbnQgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZGVsZXRlRW50cnkoJ25vbi1leGlzdGVudC1pZCcpO1xuXG4gICAgICBleHBlY3QoZGVsZXRlZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCdWxrIE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgbXVsdGlwbGUgdGVzdCBlbnRyaWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeSh7XG4gICAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICAgIG5vdGVzOiBgRW50cnkgJHtpfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFyIGFsbCBlbnRyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xlYXJlZCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmNsZWFyQWxsKCk7XG5cbiAgICAgIGV4cGVjdChjbGVhcmVkKS50b0JlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmVudHJpZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhwb3J0IGFsbCBoaXN0b3J5IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBvcnRlZCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmV4cG9ydEhpc3RvcnkoKTtcblxuICAgICAgZXhwZWN0KGV4cG9ydGVkKS50b0hhdmVMZW5ndGgoNSk7XG4gICAgICBleHBlY3QoZXhwb3J0ZWRbMF0ubm90ZXMpLnRvQ29udGFpbignRW50cnknKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW1wb3J0IGhpc3RvcnkgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGVudHJpZXNcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmNsZWFyQWxsKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBpbXBvcnQgZGF0YVxuICAgICAgY29uc3QgaW1wb3J0RGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnaW1wb3J0LTEnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGdlbmVyYXRlZEltYWdlOiAnaW1wb3J0ZWQtZ2VuZXJhdGVkJyxcbiAgICAgICAgICBtb2RlbEltYWdlOiAnaW1wb3J0ZWQtbW9kZWwnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnaW1wb3J0ZWQtYXBwYXJlbCddLFxuICAgICAgICAgIHRhZ3M6IFsnaW1wb3J0ZWQnXSxcbiAgICAgICAgICBub3RlczogJ0ltcG9ydGVkIGVudHJ5JyxcbiAgICAgICAgICBpc0Zhdm9yaXRlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBpbXBvcnRlZENvdW50ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuaW1wb3J0SGlzdG9yeShpbXBvcnREYXRhKTtcblxuICAgICAgZXhwZWN0KGltcG9ydGVkQ291bnQpLnRvQmUoMSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLmlkKS50b0JlKCdpbXBvcnQtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgaW1wb3J0IGR1cGxpY2F0ZSBlbnRyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdFbnRyaWVzID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZXhwb3J0SGlzdG9yeSgpO1xuICAgICAgY29uc3QgZHVwbGljYXRlSW1wb3J0ID0gZXhpc3RpbmdFbnRyaWVzLnNsaWNlKDAsIDIpOyAvLyBUcnkgdG8gaW1wb3J0IGZpcnN0IDIgZXhpc3RpbmcgZW50cmllc1xuXG4gICAgICBjb25zdCBpbXBvcnRlZENvdW50ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuaW1wb3J0SGlzdG9yeShkdXBsaWNhdGVJbXBvcnQpO1xuXG4gICAgICBleHBlY3QoaW1wb3J0ZWRDb3VudCkudG9CZSgwKTsgLy8gTm8gbmV3IGVudHJpZXMgc2hvdWxkIGJlIGltcG9ydGVkXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdG9yYWdlIFN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgdGVzdCBlbnRyaWVzIHdpdGggZGlmZmVyZW50IHRpbWVzdGFtcHNcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICBub3RlczogJ0ZpcnN0IGVudHJ5J1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBzbGlnaHQgZGVsYXkgdG8gZW5zdXJlIGRpZmZlcmVudCB0aW1lc3RhbXBzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoe1xuICAgICAgICAuLi5zYW1wbGVIaXN0b3J5RW50cnksXG4gICAgICAgIG5vdGVzOiAnTGFzdCBlbnRyeSdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYWNjdXJhdGUgc3RvcmFnZSBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRTdG9yYWdlU3RhdHMoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsRW50cmllcykudG9CZSgyKTtcbiAgICAgIGV4cGVjdChzdGF0cy50b3RhbFNpemVLQikudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHN0YXRzLm9sZGVzdEVudHJ5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHN0YXRzLm5ld2VzdEVudHJ5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG5ldyBEYXRlKHN0YXRzLm9sZGVzdEVudHJ5ISkuZ2V0VGltZSgpKS50b0JlTGVzc1RoYW5PckVxdWFsKFxuICAgICAgICBuZXcgRGF0ZShzdGF0cy5uZXdlc3RFbnRyeSEpLmdldFRpbWUoKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmZpZ3VyYXRpb24gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBjb25maWd1cmF0aW9uIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHtcbiAgICAgICAgbWF4RW50cmllczogMjAwLFxuICAgICAgICBjb21wcmVzc0ltYWdlczogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGhpc3RvcnlTZXJ2aWNlLnVwZGF0ZUNvbmZpZyhuZXdDb25maWcpO1xuXG4gICAgICBjb25zdCBjb25maWcgPSBoaXN0b3J5U2VydmljZS5nZXRDb25maWcoKTtcbiAgICAgIGV4cGVjdChjb25maWcubWF4RW50cmllcykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGNvbmZpZy5jb21wcmVzc0ltYWdlcykudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHBlcmZvcm0gY2xlYW51cCB3aGVuIG1heEVudHJpZXMgaXMgZXhjZWVkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXQgbG93IG1heCBlbnRyaWVzIGxpbWl0XG4gICAgICBoaXN0b3J5U2VydmljZS51cGRhdGVDb25maWcoeyBtYXhFbnRyaWVzOiAyIH0pO1xuXG4gICAgICAvLyBBZGQgbW9yZSBlbnRyaWVzIHRoYW4gdGhlIGxpbWl0IHdpdGggc21hbGwgZGVsYXlzIHRvIGVuc3VyZSBkaWZmZXJlbnQgdGltZXN0YW1wc1xuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMScgfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMicgfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMycgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcblxuICAgICAgLy8gU2hvdWxkIG9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllcyAoc29ydGVkIGJ5IHRpbWVzdGFtcCBkZXNjKVxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBcbiAgICAgIC8vIFRoZSBtb3N0IHJlY2VudCBlbnRyaWVzIHNob3VsZCBiZSBrZXB0IChFbnRyeSAyIGFuZCBFbnRyeSAzKVxuICAgICAgLy8gRW50cnkgMSBzaG91bGQgYmUgcmVtb3ZlZCBhcyBpdCdzIHRoZSBvbGRlc3RcbiAgICAgIGNvbnN0IGVudHJ5Tm90ZXMgPSByZXN1bHQuZW50cmllcy5tYXAoZSA9PiBlLm5vdGVzKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS50b0NvbnRhaW4oJ0VudHJ5IDInKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS50b0NvbnRhaW4oJ0VudHJ5IDMnKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS5ub3QudG9Db250YWluKCdFbnRyeSAxJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsb2NhbFN0b3JhZ2Ugd3JpdGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGxvY2FsU3RvcmFnZS5zZXRJdGVtIHRvIHRocm93IGFuIGVycm9yXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0ubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIGZ1bGwnKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHNhbXBsZUhpc3RvcnlFbnRyeSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdGYWlsZWQgdG8gc2F2ZSBoaXN0b3J5IGVudHJpZXMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvcnJ1cHRlZCBsb2NhbFN0b3JhZ2UgZGF0YScsICgpID0+IHtcbiAgICAgIC8vIFNldCBjb3JydXB0ZWQgZGF0YSBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWVPbmNlKCdpbnZhbGlkLWpzb24nKTtcblxuICAgICAgLy8gU2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICBjb25zdCBlbnRyaWVzID0gKGhpc3RvcnlTZXJ2aWNlIGFzIGFueSkuZ2V0U3RvcmVkRW50cmllcygpO1xuICAgICAgZXhwZWN0KGVudHJpZXMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNvbXByZXNzQmFzZTY0IiwiZm4iLCJiYXNlNjQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldEJhc2U2NFNpemUiLCJDb21wcmVzc2lvbkZhaWxlZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwibW9ja0xvY2FsU3RvcmFnZSIsInN0b3JlIiwiZ2V0SXRlbSIsImtleSIsInNldEl0ZW0iLCJ2YWx1ZSIsInJlbW92ZUl0ZW0iLCJjbGVhciIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJpbmRleCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2xvYmFsIiwiZGVzY3JpYmUiLCJoaXN0b3J5U2VydmljZSIsInNhbXBsZUhpc3RvcnlFbnRyeSIsImdlbmVyYXRlZEltYWdlIiwibW9kZWxJbWFnZSIsImFwcGFyZWxJbWFnZXMiLCJwcm9jZXNzaW5nVGltZSIsIm1ldGFkYXRhIiwibW9kZWxWZXJzaW9uIiwiYXBwbGllZFF1YWxpdHkiLCJ0YWdzIiwibm90ZXMiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIkxvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UiLCJpdCIsImdldEVudHJpZXMiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInN0cmluZ0NvbnRhaW5pbmciLCJjdXN0b21Db25maWciLCJtYXhFbnRyaWVzIiwiY29tcHJlc3NJbWFnZXMiLCJjdXN0b21TZXJ2aWNlIiwiZ2V0Q29uZmlnIiwidG9CZSIsInVuZGVmaW5lZCIsInRlc3RTZXJ2aWNlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJlbnRyeSIsImFkZEVudHJ5IiwiaWQiLCJ0b0JlRGVmaW5lZCIsInRpbWVzdGFtcCIsInRvRXF1YWwiLCJlbnRyeTEiLCJlbnRyeTIiLCJub3QiLCJtaW5pbWFsRW50cnkiLCJpc0Zhdm9yaXRlIiwiY29tcHJlc3NFbmFibGVkU2VydmljZSIsImNvbXByZXNzaW9uUXVhbGl0eSIsInJlcXVpcmUiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwicmVzdWx0IiwiZW50cmllcyIsInRvSGF2ZUxlbmd0aCIsInRvdGFsQ291bnQiLCJjdXJyZW50UGFnZSIsImhhc01vcmUiLCJvcHRpb25zIiwicGFnZSIsInBhZ2VTaXplIiwiZmF2b3JpdGVzT25seSIsInNlYXJjaFRlcm0iLCJ0b0NvbnRhaW4iLCJzb3J0QnkiLCJzb3J0RGlyZWN0aW9uIiwidGltZXN0YW1wcyIsIm1hcCIsImUiLCJEYXRlIiwiZ2V0VGltZSIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJlbnRyeUlkIiwiZ2V0RW50cnkiLCJ0b0JlTnVsbCIsInVwZGF0ZXMiLCJ1cGRhdGVkRW50cnkiLCJ1cGRhdGVFbnRyeSIsImRlbGV0ZWQiLCJkZWxldGVFbnRyeSIsImkiLCJjbGVhcmVkIiwiY2xlYXJBbGwiLCJleHBvcnRlZCIsImV4cG9ydEhpc3RvcnkiLCJpbXBvcnREYXRhIiwidG9JU09TdHJpbmciLCJpbXBvcnRlZENvdW50IiwiaW1wb3J0SGlzdG9yeSIsImV4aXN0aW5nRW50cmllcyIsImR1cGxpY2F0ZUltcG9ydCIsInNsaWNlIiwic2V0VGltZW91dCIsInN0YXRzIiwiZ2V0U3RvcmFnZVN0YXRzIiwidG90YWxFbnRyaWVzIiwidG90YWxTaXplS0IiLCJ0b0JlR3JlYXRlclRoYW4iLCJvbGRlc3RFbnRyeSIsIm5ld2VzdEVudHJ5IiwibmV3Q29uZmlnIiwidXBkYXRlQ29uZmlnIiwiY29uZmlnIiwiZW50cnlOb3RlcyIsIm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwiZ2V0U3RvcmVkRW50cmllcyJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7QUFrREQsNkJBQTZCO0FBQzdCQSxLQUFLQyxJQUFJLENBQUMscURBQXFELElBQU8sQ0FBQTtRQUNwRUMsZ0JBQWdCRixLQUFLRyxFQUFFLENBQUMsQ0FBQ0MsU0FBbUJDLFFBQVFDLE9BQU8sQ0FBQ0Y7UUFDNURHLGVBQWVQLEtBQUtHLEVBQUUsQ0FBQyxJQUFNO1FBQzdCSyx3QkFBd0IsY0FBY0M7WUFDcENDLFlBQVlDLE9BQWUsQ0FBRTtnQkFDM0IsS0FBSyxDQUFDQTtnQkFDTixJQUFJLENBQUNDLElBQUksR0FBRztZQUNkO1FBQ0Y7SUFDRixDQUFBOzs7O3FDQTFEZ0Q7QUFPaEQsNENBQTRDO0FBQzVDLE1BQU1DLG1CQUFtQixBQUFDLENBQUE7SUFDeEIsSUFBSUMsUUFBZ0MsQ0FBQztJQUVyQyxPQUFPO1FBQ0xDLFNBQVNmLEtBQUtHLEVBQUUsQ0FBQyxDQUFDYSxNQUFnQkYsS0FBSyxDQUFDRSxJQUFJLElBQUk7UUFDaERDLFNBQVNqQixLQUFLRyxFQUFFLENBQUMsQ0FBQ2EsS0FBYUU7WUFDN0JKLEtBQUssQ0FBQ0UsSUFBSSxHQUFHRTtRQUNmO1FBQ0FDLFlBQVluQixLQUFLRyxFQUFFLENBQUMsQ0FBQ2E7WUFDbkIsT0FBT0YsS0FBSyxDQUFDRSxJQUFJO1FBQ25CO1FBQ0FJLE9BQU9wQixLQUFLRyxFQUFFLENBQUM7WUFDYlcsUUFBUSxDQUFDO1FBQ1g7UUFDQSxJQUFJTyxVQUFTO1lBQ1gsT0FBT0MsT0FBT0MsSUFBSSxD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