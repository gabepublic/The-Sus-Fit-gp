a1b1242b5ccad592fe3150cb1072c5d0
/**
 * @jest-environment jsdom
 */ "use strict";
// Mock compression utilities
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        compressBase64: jest.fn((base64)=>Promise.resolve(base64)),
        getBase64Size: jest.fn(()=>1024),
        CompressionFailedError: class extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _tryonHistoryService = require("../../../src/business-layer/services/tryonHistoryService");
// Mock localStorage with complete interface
const mockLocalStorage = (()=>{
    let store = {};
    return {
        getItem: jest.fn((key)=>store[key] || null),
        setItem: jest.fn((key, value)=>{
            store[key] = value;
        }),
        removeItem: jest.fn((key)=>{
            delete store[key];
        }),
        clear: jest.fn(()=>{
            store = {};
        }),
        get length () {
            return Object.keys(store).length;
        },
        key: jest.fn((index)=>{
            const keys = Object.keys(store);
            return keys[index] || null;
        })
    };
})();
// Ensure localStorage is properly available for the service's existence check
Object.defineProperty(window, 'localStorage', {
    value: mockLocalStorage,
    writable: true,
    configurable: true,
    enumerable: true
});
// Also set on global for extra compatibility
Object.defineProperty(global, 'localStorage', {
    value: mockLocalStorage,
    writable: true,
    configurable: true,
    enumerable: true
});
describe('LocalStorageTryonHistoryService', ()=>{
    let historyService;
    const sampleHistoryEntry = {
        generatedImage: 'data:image/jpeg;base64,generated-image-data',
        modelImage: 'data:image/jpeg;base64,model-image-data',
        apparelImages: [
            'data:image/jpeg;base64,apparel-image-data'
        ],
        processingTime: 5000,
        metadata: {
            modelVersion: '1.0.0',
            appliedQuality: 'high'
        },
        tags: [
            'test',
            'sample'
        ],
        notes: 'Test history entry'
    };
    beforeEach(()=>{
        // Clear localStorage
        mockLocalStorage.clear();
        jest.clearAllMocks();
        // Create new service instance
        historyService = new _tryonHistoryService.LocalStorageTryonHistoryService();
    });
    describe('Initialization', ()=>{
        it('should initialize localStorage with default values', async ()=>{
            // Force initialization by calling a method
            await historyService.getEntries();
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_config', expect.stringContaining('localStorage'));
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_entries', '[]');
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_metadata', expect.stringContaining('version'));
        });
        it('should use custom configuration when provided', ()=>{
            const customConfig = {
                maxEntries: 100,
                compressImages: false
            };
            const customService = new _tryonHistoryService.LocalStorageTryonHistoryService(customConfig);
            expect(customService.getConfig().maxEntries).toBe(100);
            expect(customService.getConfig().compressImages).toBe(false);
        });
        it('should handle localStorage unavailability gracefully', async ()=>{
            // Mock localStorage as undefined
            Object.defineProperty(window, 'localStorage', {
                value: undefined,
                configurable: true
            });
            const testService = new _tryonHistoryService.LocalStorageTryonHistoryService();
            await expect(testService.getEntries()).rejects.toThrow('History storage initialization failed');
            // Restore localStorage
            Object.defineProperty(window, 'localStorage', {
                value: mockLocalStorage,
                configurable: true
            });
        });
    });
    describe('Adding History Entries', ()=>{
        it('should add a new history entry successfully', async ()=>{
            const entry = await historyService.addEntry(sampleHistoryEntry);
            expect(entry.id).toBeDefined();
            expect(entry.timestamp).toBeDefined();
            expect(entry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
            expect(entry.modelImage).toBe(sampleHistoryEntry.modelImage);
            expect(entry.apparelImages).toEqual(sampleHistoryEntry.apparelImages);
            expect(entry.processingTime).toBe(sampleHistoryEntry.processingTime);
            expect(entry.tags).toEqual(sampleHistoryEntry.tags);
            expect(entry.notes).toBe(sampleHistoryEntry.notes);
            // Verify localStorage was updated
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_entries', expect.stringContaining(entry.id));
        });
        it('should generate unique IDs for entries', async ()=>{
            const entry1 = await historyService.addEntry(sampleHistoryEntry);
            const entry2 = await historyService.addEntry(sampleHistoryEntry);
            expect(entry1.id).not.toBe(entry2.id);
        });
        it('should apply default values for optional fields', async ()=>{
            const minimalEntry = {
                generatedImage: 'generated',
                modelImage: 'model',
                apparelImages: [
                    'apparel'
                ]
            };
            const entry = await historyService.addEntry(minimalEntry);
            expect(entry.tags).toEqual([]);
            expect(entry.isFavorite).toBe(false);
            expect(entry.notes).toBe('');
        });
        it('should handle compression when enabled', async ()=>{
            const compressEnabledService = new _tryonHistoryService.LocalStorageTryonHistoryService({
                compressImages: true,
                compressionQuality: 0.8
            });
            const entry = await compressEnabledService.addEntry(sampleHistoryEntry);
            expect(entry.id).toBeDefined();
            // Compression mock should have been called - access via jest.mocked
            const imageUtils = jest.mocked(require('../../../src/business-layer/utils/imageProcessing'));
            expect(imageUtils.compressBase64).toHaveBeenCalled();
        });
    });
    describe('Retrieving History Entries', ()=>{
        beforeEach(async ()=>{
            // Add some test entries
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag1'
                ],
                notes: 'First entry'
            });
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag2'
                ],
                notes: 'Second entry',
                isFavorite: true
            });
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag1',
                    'tag2'
                ],
                notes: 'Third entry'
            });
        });
        it('should retrieve all entries without options', async ()=>{
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(3);
            expect(result.totalCount).toBe(3);
            expect(result.currentPage).toBe(0);
            expect(result.hasMore).toBe(false);
        });
        it('should apply pagination correctly', async ()=>{
            const options = {
                page: 0,
                pageSize: 2
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(2);
            expect(result.totalCount).toBe(3);
            expect(result.currentPage).toBe(0);
            expect(result.pageSize).toBe(2);
            expect(result.hasMore).toBe(true);
        });
        it('should filter by favorites only', async ()=>{
            const options = {
                favoritesOnly: true
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].isFavorite).toBe(true);
        });
        it('should filter by search term', async ()=>{
            const options = {
                searchTerm: 'Second'
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].notes).toContain('Second');
        });
        it('should sort entries correctly', async ()=>{
            const options = {
                sortBy: 'timestamp',
                sortDirection: 'asc'
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(3);
            // Should be in ascending order
            const timestamps = result.entries.map((e)=>new Date(e.timestamp).getTime());
            expect(timestamps[0]).toBeLessThanOrEqual(timestamps[1]);
            expect(timestamps[1]).toBeLessThanOrEqual(timestamps[2]);
        });
    });
    describe('Single Entry Operations', ()=>{
        let entryId;
        beforeEach(async ()=>{
            const entry = await historyService.addEntry(sampleHistoryEntry);
            entryId = entry.id;
        });
        it('should retrieve a specific entry by ID', async ()=>{
            const entry = await historyService.getEntry(entryId);
            expect(entry).not.toBeNull();
            expect(entry.id).toBe(entryId);
            expect(entry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
        });
        it('should return null for non-existent entry', async ()=>{
            const entry = await historyService.getEntry('non-existent-id');
            expect(entry).toBeNull();
        });
        it('should update an existing entry', async ()=>{
            const updates = {
                notes: 'Updated notes',
                isFavorite: true,
                tags: [
                    'updated',
                    'tags'
                ]
            };
            const updatedEntry = await historyService.updateEntry(entryId, updates);
            expect(updatedEntry.id).toBe(entryId);
            expect(updatedEntry.notes).toBe('Updated notes');
            expect(updatedEntry.isFavorite).toBe(true);
            expect(updatedEntry.tags).toEqual([
                'updated',
                'tags'
            ]);
            // Original data should be preserved
            expect(updatedEntry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
        });
        it('should throw error when updating non-existent entry', async ()=>{
            await expect(historyService.updateEntry('non-existent-id', {
                notes: 'test'
            })).rejects.toThrow('History entry with ID non-existent-id not found');
        });
        it('should delete an entry successfully', async ()=>{
            const deleted = await historyService.deleteEntry(entryId);
            expect(deleted).toBe(true);
            // Entry should no longer exist
            const entry = await historyService.getEntry(entryId);
            expect(entry).toBeNull();
        });
        it('should return false when deleting non-existent entry', async ()=>{
            const deleted = await historyService.deleteEntry('non-existent-id');
            expect(deleted).toBe(false);
        });
    });
    describe('Bulk Operations', ()=>{
        beforeEach(async ()=>{
            // Add multiple test entries
            for(let i = 0; i < 5; i++){
                await historyService.addEntry({
                    ...sampleHistoryEntry,
                    notes: `Entry ${i}`
                });
            }
        });
        it('should clear all entries', async ()=>{
            const cleared = await historyService.clearAll();
            expect(cleared).toBe(true);
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(0);
        });
        it('should export all history data', async ()=>{
            const exported = await historyService.exportHistory();
            expect(exported).toHaveLength(5);
            expect(exported[0].notes).toContain('Entry');
        });
        it('should import history data', async ()=>{
            // Clear existing entries
            await historyService.clearAll();
            // Create import data
            const importData = [
                {
                    id: 'import-1',
                    timestamp: new Date().toISOString(),
                    generatedImage: 'imported-generated',
                    modelImage: 'imported-model',
                    apparelImages: [
                        'imported-apparel'
                    ],
                    tags: [
                        'imported'
                    ],
                    notes: 'Imported entry',
                    isFavorite: false
                }
            ];
            const importedCount = await historyService.importHistory(importData);
            expect(importedCount).toBe(1);
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].id).toBe('import-1');
        });
        it('should not import duplicate entries', async ()=>{
            const existingEntries = await historyService.exportHistory();
            const duplicateImport = existingEntries.slice(0, 2); // Try to import first 2 existing entries
            const importedCount = await historyService.importHistory(duplicateImport);
            expect(importedCount).toBe(0); // No new entries should be imported
        });
    });
    describe('Storage Statistics', ()=>{
        beforeEach(async ()=>{
            // Add test entries with different timestamps
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'First entry'
            });
            // Add slight delay to ensure different timestamps
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Last entry'
            });
        });
        it('should return accurate storage statistics', async ()=>{
            const stats = await historyService.getStorageStats();
            expect(stats.totalEntries).toBe(2);
            expect(stats.totalSizeKB).toBeGreaterThan(0);
            expect(stats.oldestEntry).toBeDefined();
            expect(stats.newestEntry).toBeDefined();
            expect(new Date(stats.oldestEntry).getTime()).toBeLessThanOrEqual(new Date(stats.newestEntry).getTime());
        });
    });
    describe('Configuration Management', ()=>{
        it('should update configuration correctly', ()=>{
            const newConfig = {
                maxEntries: 200,
                compressImages: false
            };
            historyService.updateConfig(newConfig);
            const config = historyService.getConfig();
            expect(config.maxEntries).toBe(200);
            expect(config.compressImages).toBe(false);
        });
        it('should perform cleanup when maxEntries is exceeded', async ()=>{
            // Set low max entries limit
            historyService.updateConfig({
                maxEntries: 2
            });
            // Add more entries than the limit with small delays to ensure different timestamps
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 1'
            });
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 2'
            });
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 3'
            });
            const result = await historyService.getEntries();
            // Should only keep the most recent entries (sorted by timestamp desc)
            expect(result.entries).toHaveLength(2);
            // The most recent entries should be kept (Entry 2 and Entry 3)
            // Entry 1 should be removed as it's the oldest
            const entryNotes = result.entries.map((e)=>e.notes);
            expect(entryNotes).toContain('Entry 2');
            expect(entryNotes).toContain('Entry 3');
            expect(entryNotes).not.toContain('Entry 1');
        });
    });
    describe('Error Handling', ()=>{
        it('should handle localStorage write errors gracefully', async ()=>{
            // Mock localStorage.setItem to throw an error
            mockLocalStorage.setItem.mockImplementationOnce(()=>{
                throw new Error('localStorage full');
            });
            await expect(historyService.addEntry(sampleHistoryEntry)).rejects.toThrow('Failed to save history entries');
        });
        it('should handle corrupted localStorage data', ()=>{
            // Set corrupted data in localStorage
            mockLocalStorage.getItem.mockReturnValueOnce('invalid-json');
            // Should return empty array instead of throwing
            const entries = historyService.getStoredEntries();
            expect(entries).toEqual([]);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL3NlcnZpY2VzL3RyeW9uSGlzdG9yeVNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBqZXN0LWVudmlyb25tZW50IGpzZG9tXG4gKi9cblxuaW1wb3J0IHsgTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci9zZXJ2aWNlcy90cnlvbkhpc3RvcnlTZXJ2aWNlJztcbmltcG9ydCB0eXBlIHtcbiAgQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zLFxuICBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMsXG4gIFRyeW9uSGlzdG9yeVN0b3JhZ2VDb25maWdcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3R5cGVzL2hpc3RvcnkudHlwZXMnO1xuXG4vLyBNb2NrIGxvY2FsU3RvcmFnZSB3aXRoIGNvbXBsZXRlIGludGVyZmFjZVxuY29uc3QgbW9ja0xvY2FsU3RvcmFnZSA9ICgoKSA9PiB7XG4gIGxldCBzdG9yZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBcbiAgcmV0dXJuIHtcbiAgICBnZXRJdGVtOiBqZXN0LmZuKChrZXk6IHN0cmluZykgPT4gc3RvcmVba2V5XSB8fCBudWxsKSxcbiAgICBzZXRJdGVtOiBqZXN0LmZuKChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIH0pLFxuICAgIHJlbW92ZUl0ZW06IGplc3QuZm4oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICB9KSxcbiAgICBjbGVhcjogamVzdC5mbigoKSA9PiB7XG4gICAgICBzdG9yZSA9IHt9O1xuICAgIH0pLFxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmUpLmxlbmd0aDtcbiAgICB9LFxuICAgIGtleTogamVzdC5mbigoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0b3JlKTtcbiAgICAgIHJldHVybiBrZXlzW2luZGV4XSB8fCBudWxsO1xuICAgIH0pXG4gIH07XG59KSgpO1xuXG4vLyBFbnN1cmUgbG9jYWxTdG9yYWdlIGlzIHByb3Blcmx5IGF2YWlsYWJsZSBmb3IgdGhlIHNlcnZpY2UncyBleGlzdGVuY2UgY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XG4gIHZhbHVlOiBtb2NrTG9jYWxTdG9yYWdlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcblxuLy8gQWxzbyBzZXQgb24gZ2xvYmFsIGZvciBleHRyYSBjb21wYXRpYmlsaXR5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAnbG9jYWxTdG9yYWdlJywge1xuICB2YWx1ZTogbW9ja0xvY2FsU3RvcmFnZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5cbi8vIE1vY2sgY29tcHJlc3Npb24gdXRpbGl0aWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9pbWFnZVByb2Nlc3NpbmcnLCAoKSA9PiAoe1xuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigoYmFzZTY0OiBzdHJpbmcpID0+IFByb21pc2UucmVzb2x2ZShiYXNlNjQpKSxcbiAgZ2V0QmFzZTY0U2l6ZTogamVzdC5mbigoKSA9PiAxMDI0KSxcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJztcbiAgICB9XG4gIH1cbn0pKTtcblxuZGVzY3JpYmUoJ0xvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBoaXN0b3J5U2VydmljZTogTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZTtcblxuICBjb25zdCBzYW1wbGVIaXN0b3J5RW50cnk6IENyZWF0ZVRyeW9uSGlzdG9yeUVudHJ5T3B0aW9ucyA9IHtcbiAgICBnZW5lcmF0ZWRJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsZ2VuZXJhdGVkLWltYWdlLWRhdGEnLFxuICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vZGVsLWltYWdlLWRhdGEnLFxuICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxhcHBhcmVsLWltYWdlLWRhdGEnXSxcbiAgICBwcm9jZXNzaW5nVGltZTogNTAwMCxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbW9kZWxWZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgYXBwbGllZFF1YWxpdHk6ICdoaWdoJ1xuICAgIH0sXG4gICAgdGFnczogWyd0ZXN0JywgJ3NhbXBsZSddLFxuICAgIG5vdGVzOiAnVGVzdCBoaXN0b3J5IGVudHJ5J1xuICB9O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZVxuICAgIG1vY2tMb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgbmV3IHNlcnZpY2UgaW5zdGFuY2VcbiAgICBoaXN0b3J5U2VydmljZSA9IG5ldyBMb2NhbFN0b3JhZ2VUcnlvbkhpc3RvcnlTZXJ2aWNlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgbG9jYWxTdG9yYWdlIHdpdGggZGVmYXVsdCB2YWx1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBGb3JjZSBpbml0aWFsaXphdGlvbiBieSBjYWxsaW5nIGEgbWV0aG9kXG4gICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnc3VzZml0X3RyeW9uX2hpc3RvcnlfY29uZmlnJyxcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2xvY2FsU3RvcmFnZScpXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdzdXNmaXRfdHJ5b25faGlzdG9yeV9lbnRyaWVzJyxcbiAgICAgICAgJ1tdJ1xuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnc3VzZml0X3RyeW9uX2hpc3RvcnlfbWV0YWRhdGEnLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygndmVyc2lvbicpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgY3VzdG9tIGNvbmZpZ3VyYXRpb24gd2hlbiBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbUNvbmZpZzogUGFydGlhbDxUcnlvbkhpc3RvcnlTdG9yYWdlQ29uZmlnPiA9IHtcbiAgICAgICAgbWF4RW50cmllczogMTAwLFxuICAgICAgICBjb21wcmVzc0ltYWdlczogZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGN1c3RvbVNlcnZpY2UgPSBuZXcgTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZShjdXN0b21Db25maWcpO1xuICAgICAgZXhwZWN0KGN1c3RvbVNlcnZpY2UuZ2V0Q29uZmlnKCkubWF4RW50cmllcykudG9CZSgxMDApO1xuICAgICAgZXhwZWN0KGN1c3RvbVNlcnZpY2UuZ2V0Q29uZmlnKCkuY29tcHJlc3NJbWFnZXMpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9jYWxTdG9yYWdlIHVuYXZhaWxhYmlsaXR5IGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGxvY2FsU3RvcmFnZSBhcyB1bmRlZmluZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRlc3RTZXJ2aWNlID0gbmV3IExvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UoKTtcbiAgICAgIGF3YWl0IGV4cGVjdCh0ZXN0U2VydmljZS5nZXRFbnRyaWVzKCkpLnJlamVjdHMudG9UaHJvdygnSGlzdG9yeSBzdG9yYWdlIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuXG4gICAgICAvLyBSZXN0b3JlIGxvY2FsU3RvcmFnZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2xvY2FsU3RvcmFnZScsIHtcbiAgICAgICAgdmFsdWU6IG1vY2tMb2NhbFN0b3JhZ2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBZGRpbmcgSGlzdG9yeSBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWRkIGEgbmV3IGhpc3RvcnkgZW50cnkgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuXG4gICAgICBleHBlY3QoZW50cnkuaWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZW50cnkudGltZXN0YW1wKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVudHJ5LmdlbmVyYXRlZEltYWdlKS50b0JlKHNhbXBsZUhpc3RvcnlFbnRyeS5nZW5lcmF0ZWRJbWFnZSk7XG4gICAgICBleHBlY3QoZW50cnkubW9kZWxJbWFnZSkudG9CZShzYW1wbGVIaXN0b3J5RW50cnkubW9kZWxJbWFnZSk7XG4gICAgICBleHBlY3QoZW50cnkuYXBwYXJlbEltYWdlcykudG9FcXVhbChzYW1wbGVIaXN0b3J5RW50cnkuYXBwYXJlbEltYWdlcyk7XG4gICAgICBleHBlY3QoZW50cnkucHJvY2Vzc2luZ1RpbWUpLnRvQmUoc2FtcGxlSGlzdG9yeUVudHJ5LnByb2Nlc3NpbmdUaW1lKTtcbiAgICAgIGV4cGVjdChlbnRyeS50YWdzKS50b0VxdWFsKHNhbXBsZUhpc3RvcnlFbnRyeS50YWdzKTtcbiAgICAgIGV4cGVjdChlbnRyeS5ub3RlcykudG9CZShzYW1wbGVIaXN0b3J5RW50cnkubm90ZXMpO1xuXG4gICAgICAvLyBWZXJpZnkgbG9jYWxTdG9yYWdlIHdhcyB1cGRhdGVkXG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ3N1c2ZpdF90cnlvbl9oaXN0b3J5X2VudHJpZXMnLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhlbnRyeS5pZClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHVuaXF1ZSBJRHMgZm9yIGVudHJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeTEgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuICAgICAgY29uc3QgZW50cnkyID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoc2FtcGxlSGlzdG9yeUVudHJ5KTtcblxuICAgICAgZXhwZWN0KGVudHJ5MS5pZCkubm90LnRvQmUoZW50cnkyLmlkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1pbmltYWxFbnRyeTogQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zID0ge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZTogJ2dlbmVyYXRlZCcsXG4gICAgICAgIG1vZGVsSW1hZ2U6ICdtb2RlbCcsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnYXBwYXJlbCddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KG1pbmltYWxFbnRyeSk7XG5cbiAgICAgIGV4cGVjdChlbnRyeS50YWdzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChlbnRyeS5pc0Zhdm9yaXRlKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChlbnRyeS5ub3RlcykudG9CZSgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wcmVzc2lvbiB3aGVuIGVuYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wcmVzc0VuYWJsZWRTZXJ2aWNlID0gbmV3IExvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2Uoe1xuICAgICAgICBjb21wcmVzc0ltYWdlczogdHJ1ZSxcbiAgICAgICAgY29tcHJlc3Npb25RdWFsaXR5OiAwLjhcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGNvbXByZXNzRW5hYmxlZFNlcnZpY2UuYWRkRW50cnkoc2FtcGxlSGlzdG9yeUVudHJ5KTtcblxuICAgICAgZXhwZWN0KGVudHJ5LmlkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgLy8gQ29tcHJlc3Npb24gbW9jayBzaG91bGQgaGF2ZSBiZWVuIGNhbGxlZCAtIGFjY2VzcyB2aWEgamVzdC5tb2NrZWRcbiAgICAgIGNvbnN0IGltYWdlVXRpbHMgPSBqZXN0Lm1vY2tlZChyZXF1aXJlKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJykpO1xuICAgICAgZXhwZWN0KGltYWdlVXRpbHMuY29tcHJlc3NCYXNlNjQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JldHJpZXZpbmcgSGlzdG9yeSBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIHNvbWUgdGVzdCBlbnRyaWVzXG4gICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeSh7XG4gICAgICAgIC4uLnNhbXBsZUhpc3RvcnlFbnRyeSxcbiAgICAgICAgdGFnczogWyd0YWcxJ10sXG4gICAgICAgIG5vdGVzOiAnRmlyc3QgZW50cnknXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICB0YWdzOiBbJ3RhZzInXSxcbiAgICAgICAgbm90ZXM6ICdTZWNvbmQgZW50cnknLFxuICAgICAgICBpc0Zhdm9yaXRlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICB0YWdzOiBbJ3RhZzEnLCAndGFnMiddLFxuICAgICAgICBub3RlczogJ1RoaXJkIGVudHJ5J1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHJpZXZlIGFsbCBlbnRyaWVzIHdpdGhvdXQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LnRvdGFsQ291bnQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRQYWdlKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5oYXNNb3JlKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgcGFnaW5hdGlvbiBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgIHBhZ2U6IDAsXG4gICAgICAgIHBhZ2VTaXplOiAyXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKG9wdGlvbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmVudHJpZXMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG90YWxDb3VudCkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFBhZ2UpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnBhZ2VTaXplKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5oYXNNb3JlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgZmF2b3JpdGVzIG9ubHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgIGZhdm9yaXRlc09ubHk6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMob3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLmlzRmF2b3JpdGUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBzZWFyY2ggdGVybScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFRyeW9uSGlzdG9yeVF1ZXJ5T3B0aW9ucyA9IHtcbiAgICAgICAgc2VhcmNoVGVybTogJ1NlY29uZCdcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMob3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLm5vdGVzKS50b0NvbnRhaW4oJ1NlY29uZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzb3J0IGVudHJpZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogVHJ5b25IaXN0b3J5UXVlcnlPcHRpb25zID0ge1xuICAgICAgICBzb3J0Qnk6ICd0aW1lc3RhbXAnLFxuICAgICAgICBzb3J0RGlyZWN0aW9uOiAnYXNjJ1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcyhvcHRpb25zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAvLyBTaG91bGQgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICBjb25zdCB0aW1lc3RhbXBzID0gcmVzdWx0LmVudHJpZXMubWFwKGUgPT4gbmV3IERhdGUoZS50aW1lc3RhbXApLmdldFRpbWUoKSk7XG4gICAgICBleHBlY3QodGltZXN0YW1wc1swXSkudG9CZUxlc3NUaGFuT3JFcXVhbCh0aW1lc3RhbXBzWzFdKTtcbiAgICAgIGV4cGVjdCh0aW1lc3RhbXBzWzFdKS50b0JlTGVzc1RoYW5PckVxdWFsKHRpbWVzdGFtcHNbMl0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2luZ2xlIEVudHJ5IE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgbGV0IGVudHJ5SWQ6IHN0cmluZztcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuICAgICAgZW50cnlJZCA9IGVudHJ5LmlkO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBhIHNwZWNpZmljIGVudHJ5IGJ5IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyeShlbnRyeUlkKTtcblxuICAgICAgZXhwZWN0KGVudHJ5KS5ub3QudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChlbnRyeSEuaWQpLnRvQmUoZW50cnlJZCk7XG4gICAgICBleHBlY3QoZW50cnkhLmdlbmVyYXRlZEltYWdlKS50b0JlKHNhbXBsZUhpc3RvcnlFbnRyeS5nZW5lcmF0ZWRJbWFnZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBub24tZXhpc3RlbnQgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJ5KCdub24tZXhpc3RlbnQtaWQnKTtcblxuICAgICAgZXhwZWN0KGVudHJ5KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgYW4gZXhpc3RpbmcgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgICBub3RlczogJ1VwZGF0ZWQgbm90ZXMnLFxuICAgICAgICBpc0Zhdm9yaXRlOiB0cnVlLFxuICAgICAgICB0YWdzOiBbJ3VwZGF0ZWQnLCAndGFncyddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVkRW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS51cGRhdGVFbnRyeShlbnRyeUlkLCB1cGRhdGVzKTtcblxuICAgICAgZXhwZWN0KHVwZGF0ZWRFbnRyeS5pZCkudG9CZShlbnRyeUlkKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkubm90ZXMpLnRvQmUoJ1VwZGF0ZWQgbm90ZXMnKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkuaXNGYXZvcml0ZSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkudGFncykudG9FcXVhbChbJ3VwZGF0ZWQnLCAndGFncyddKTtcbiAgICAgIC8vIE9yaWdpbmFsIGRhdGEgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgZXhwZWN0KHVwZGF0ZWRFbnRyeS5nZW5lcmF0ZWRJbWFnZSkudG9CZShzYW1wbGVIaXN0b3J5RW50cnkuZ2VuZXJhdGVkSW1hZ2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIHVwZGF0aW5nIG5vbi1leGlzdGVudCBlbnRyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgaGlzdG9yeVNlcnZpY2UudXBkYXRlRW50cnkoJ25vbi1leGlzdGVudC1pZCcsIHsgbm90ZXM6ICd0ZXN0JyB9KVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0hpc3RvcnkgZW50cnkgd2l0aCBJRCBub24tZXhpc3RlbnQtaWQgbm90IGZvdW5kJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhbiBlbnRyeSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZGVsZXRlRW50cnkoZW50cnlJZCk7XG5cbiAgICAgIGV4cGVjdChkZWxldGVkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBFbnRyeSBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJ5KGVudHJ5SWQpO1xuICAgICAgZXhwZWN0KGVudHJ5KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiBkZWxldGluZyBub24tZXhpc3RlbnQgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZGVsZXRlRW50cnkoJ25vbi1leGlzdGVudC1pZCcpO1xuXG4gICAgICBleHBlY3QoZGVsZXRlZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCdWxrIE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgbXVsdGlwbGUgdGVzdCBlbnRyaWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeSh7XG4gICAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICAgIG5vdGVzOiBgRW50cnkgJHtpfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFyIGFsbCBlbnRyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xlYXJlZCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmNsZWFyQWxsKCk7XG5cbiAgICAgIGV4cGVjdChjbGVhcmVkKS50b0JlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmVudHJpZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhwb3J0IGFsbCBoaXN0b3J5IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBvcnRlZCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmV4cG9ydEhpc3RvcnkoKTtcblxuICAgICAgZXhwZWN0KGV4cG9ydGVkKS50b0hhdmVMZW5ndGgoNSk7XG4gICAgICBleHBlY3QoZXhwb3J0ZWRbMF0ubm90ZXMpLnRvQ29udGFpbignRW50cnknKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW1wb3J0IGhpc3RvcnkgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGVudHJpZXNcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmNsZWFyQWxsKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBpbXBvcnQgZGF0YVxuICAgICAgY29uc3QgaW1wb3J0RGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnaW1wb3J0LTEnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGdlbmVyYXRlZEltYWdlOiAnaW1wb3J0ZWQtZ2VuZXJhdGVkJyxcbiAgICAgICAgICBtb2RlbEltYWdlOiAnaW1wb3J0ZWQtbW9kZWwnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnaW1wb3J0ZWQtYXBwYXJlbCddLFxuICAgICAgICAgIHRhZ3M6IFsnaW1wb3J0ZWQnXSxcbiAgICAgICAgICBub3RlczogJ0ltcG9ydGVkIGVudHJ5JyxcbiAgICAgICAgICBpc0Zhdm9yaXRlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBpbXBvcnRlZENvdW50ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuaW1wb3J0SGlzdG9yeShpbXBvcnREYXRhKTtcblxuICAgICAgZXhwZWN0KGltcG9ydGVkQ291bnQpLnRvQmUoMSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLmlkKS50b0JlKCdpbXBvcnQtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgaW1wb3J0IGR1cGxpY2F0ZSBlbnRyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdFbnRyaWVzID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZXhwb3J0SGlzdG9yeSgpO1xuICAgICAgY29uc3QgZHVwbGljYXRlSW1wb3J0ID0gZXhpc3RpbmdFbnRyaWVzLnNsaWNlKDAsIDIpOyAvLyBUcnkgdG8gaW1wb3J0IGZpcnN0IDIgZXhpc3RpbmcgZW50cmllc1xuXG4gICAgICBjb25zdCBpbXBvcnRlZENvdW50ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuaW1wb3J0SGlzdG9yeShkdXBsaWNhdGVJbXBvcnQpO1xuXG4gICAgICBleHBlY3QoaW1wb3J0ZWRDb3VudCkudG9CZSgwKTsgLy8gTm8gbmV3IGVudHJpZXMgc2hvdWxkIGJlIGltcG9ydGVkXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdG9yYWdlIFN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgdGVzdCBlbnRyaWVzIHdpdGggZGlmZmVyZW50IHRpbWVzdGFtcHNcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICBub3RlczogJ0ZpcnN0IGVudHJ5J1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBzbGlnaHQgZGVsYXkgdG8gZW5zdXJlIGRpZmZlcmVudCB0aW1lc3RhbXBzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoe1xuICAgICAgICAuLi5zYW1wbGVIaXN0b3J5RW50cnksXG4gICAgICAgIG5vdGVzOiAnTGFzdCBlbnRyeSdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYWNjdXJhdGUgc3RvcmFnZSBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRTdG9yYWdlU3RhdHMoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsRW50cmllcykudG9CZSgyKTtcbiAgICAgIGV4cGVjdChzdGF0cy50b3RhbFNpemVLQikudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHN0YXRzLm9sZGVzdEVudHJ5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHN0YXRzLm5ld2VzdEVudHJ5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG5ldyBEYXRlKHN0YXRzLm9sZGVzdEVudHJ5ISkuZ2V0VGltZSgpKS50b0JlTGVzc1RoYW5PckVxdWFsKFxuICAgICAgICBuZXcgRGF0ZShzdGF0cy5uZXdlc3RFbnRyeSEpLmdldFRpbWUoKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmZpZ3VyYXRpb24gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBjb25maWd1cmF0aW9uIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHtcbiAgICAgICAgbWF4RW50cmllczogMjAwLFxuICAgICAgICBjb21wcmVzc0ltYWdlczogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGhpc3RvcnlTZXJ2aWNlLnVwZGF0ZUNvbmZpZyhuZXdDb25maWcpO1xuXG4gICAgICBjb25zdCBjb25maWcgPSBoaXN0b3J5U2VydmljZS5nZXRDb25maWcoKTtcbiAgICAgIGV4cGVjdChjb25maWcubWF4RW50cmllcykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGNvbmZpZy5jb21wcmVzc0ltYWdlcykudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHBlcmZvcm0gY2xlYW51cCB3aGVuIG1heEVudHJpZXMgaXMgZXhjZWVkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXQgbG93IG1heCBlbnRyaWVzIGxpbWl0XG4gICAgICBoaXN0b3J5U2VydmljZS51cGRhdGVDb25maWcoeyBtYXhFbnRyaWVzOiAyIH0pO1xuXG4gICAgICAvLyBBZGQgbW9yZSBlbnRyaWVzIHRoYW4gdGhlIGxpbWl0IHdpdGggc21hbGwgZGVsYXlzIHRvIGVuc3VyZSBkaWZmZXJlbnQgdGltZXN0YW1wc1xuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMScgfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMicgfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMycgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcblxuICAgICAgLy8gU2hvdWxkIG9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllcyAoc29ydGVkIGJ5IHRpbWVzdGFtcCBkZXNjKVxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBcbiAgICAgIC8vIFRoZSBtb3N0IHJlY2VudCBlbnRyaWVzIHNob3VsZCBiZSBrZXB0IChFbnRyeSAyIGFuZCBFbnRyeSAzKVxuICAgICAgLy8gRW50cnkgMSBzaG91bGQgYmUgcmVtb3ZlZCBhcyBpdCdzIHRoZSBvbGRlc3RcbiAgICAgIGNvbnN0IGVudHJ5Tm90ZXMgPSByZXN1bHQuZW50cmllcy5tYXAoZSA9PiBlLm5vdGVzKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS50b0NvbnRhaW4oJ0VudHJ5IDInKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS50b0NvbnRhaW4oJ0VudHJ5IDMnKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS5ub3QudG9Db250YWluKCdFbnRyeSAxJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsb2NhbFN0b3JhZ2Ugd3JpdGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGxvY2FsU3RvcmFnZS5zZXRJdGVtIHRvIHRocm93IGFuIGVycm9yXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0ubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIGZ1bGwnKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHNhbXBsZUhpc3RvcnlFbnRyeSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdGYWlsZWQgdG8gc2F2ZSBoaXN0b3J5IGVudHJpZXMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvcnJ1cHRlZCBsb2NhbFN0b3JhZ2UgZGF0YScsICgpID0+IHtcbiAgICAgIC8vIFNldCBjb3JydXB0ZWQgZGF0YSBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWVPbmNlKCdpbnZhbGlkLWpzb24nKTtcblxuICAgICAgLy8gU2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICBjb25zdCBlbnRyaWVzID0gKGhpc3RvcnlTZXJ2aWNlIGFzIGFueSkuZ2V0U3RvcmVkRW50cmllcygpO1xuICAgICAgZXhwZWN0KGVudHJpZXMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNvbXByZXNzQmFzZTY0IiwiZm4iLCJiYXNlNjQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldEJhc2U2NFNpemUiLCJDb21wcmVzc2lvbkZhaWxlZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwibW9ja0xvY2FsU3RvcmFnZSIsInN0b3JlIiwiZ2V0SXRlbSIsImtleSIsInNldEl0ZW0iLCJ2YWx1ZSIsInJlbW92ZUl0ZW0iLCJjbGVhciIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJpbmRleCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2xvYmFsIiwiZGVzY3JpYmUiLCJoaXN0b3J5U2VydmljZSIsInNhbXBsZUhpc3RvcnlFbnRyeSIsImdlbmVyYXRlZEltYWdlIiwibW9kZWxJbWFnZSIsImFwcGFyZWxJbWFnZXMiLCJwcm9jZXNzaW5nVGltZSIsIm1ldGFkYXRhIiwibW9kZWxWZXJzaW9uIiwiYXBwbGllZFF1YWxpdHkiLCJ0YWdzIiwibm90ZXMiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIkxvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UiLCJpdCIsImdldEVudHJpZXMiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInN0cmluZ0NvbnRhaW5pbmciLCJjdXN0b21Db25maWciLCJtYXhFbnRyaWVzIiwiY29tcHJlc3NJbWFnZXMiLCJjdXN0b21TZXJ2aWNlIiwiZ2V0Q29uZmlnIiwidG9CZSIsInVuZGVmaW5lZCIsInRlc3RTZXJ2aWNlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJlbnRyeSIsImFkZEVudHJ5IiwiaWQiLCJ0b0JlRGVmaW5lZCIsInRpbWVzdGFtcCIsInRvRXF1YWwiLCJlbnRyeTEiLCJlbnRyeTIiLCJub3QiLCJtaW5pbWFsRW50cnkiLCJpc0Zhdm9yaXRlIiwiY29tcHJlc3NFbmFibGVkU2VydmljZSIsImNvbXByZXNzaW9uUXVhbGl0eSIsImltYWdlVXRpbHMiLCJtb2NrZWQiLCJyZXF1aXJlIiwidG9IYXZlQmVlbkNhbGxlZCIsInJlc3VsdCIsImVudHJpZXMiLCJ0b0hhdmVMZW5ndGgiLCJ0b3RhbENvdW50IiwiY3VycmVudFBhZ2UiLCJoYXNNb3JlIiwib3B0aW9ucyIsInBhZ2UiLCJwYWdlU2l6ZSIsImZhdm9yaXRlc09ubHkiLCJzZWFyY2hUZXJtIiwidG9Db250YWluIiwic29ydEJ5Iiwic29ydERpcmVjdGlvbiIsInRpbWVzdGFtcHMiLCJtYXAiLCJlIiwiRGF0ZSIsImdldFRpbWUiLCJ0b0JlTGVzc1RoYW5PckVxdWFsIiwiZW50cnlJZCIsImdldEVudHJ5IiwidG9CZU51bGwiLCJ1cGRhdGVzIiwidXBkYXRlZEVudHJ5IiwidXBkYXRlRW50cnkiLCJkZWxldGVkIiwiZGVsZXRlRW50cnkiLCJpIiwiY2xlYXJlZCIsImNsZWFyQWxsIiwiZXhwb3J0ZWQiLCJleHBvcnRIaXN0b3J5IiwiaW1wb3J0RGF0YSIsInRvSVNPU3RyaW5nIiwiaW1wb3J0ZWRDb3VudCIsImltcG9ydEhpc3RvcnkiLCJleGlzdGluZ0VudHJpZXMiLCJkdXBsaWNhdGVJbXBvcnQiLCJzbGljZSIsInNldFRpbWVvdXQiLCJzdGF0cyIsImdldFN0b3JhZ2VTdGF0cyIsInRvdGFsRW50cmllcyIsInRvdGFsU2l6ZUtCIiwidG9CZUdyZWF0ZXJUaGFuIiwib2xkZXN0RW50cnkiLCJuZXdlc3RFbnRyeSIsIm5ld0NvbmZpZyIsInVwZGF0ZUNvbmZpZyIsImNvbmZpZyIsImVudHJ5Tm90ZXMiLCJtb2NrSW1wbGVtZW50YXRpb25PbmNlIiwibW9ja1JldHVyblZhbHVlT25jZSIsImdldFN0b3JlZEVudHJpZXMiXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDO0FBa0RELDZCQUE2QjtBQUM3QkEsS0FBS0MsSUFBSSxDQUFDLHFEQUFxRCxJQUFPLENBQUE7UUFDcEVDLGdCQUFnQkYsS0FBS0csRUFBRSxDQUFDLENBQUNDLFNBQW1CQyxRQUFRQyxPQUFPLENBQUNGO1FBQzVERyxlQUFlUCxLQUFLRyxFQUFFLENBQUMsSUFBTTtRQUM3Qkssd0JBQXdCLGNBQWNDO1lBQ3BDQyxZQUFZQyxPQUFlLENBQUU7Z0JBQzNCLEtBQUssQ0FBQ0E7Z0JBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUc7WUFDZDtRQUNGO0lBQ0YsQ0FBQTs7OztxQ0ExRGdEO0FBT2hELDRDQUE0QztBQUM1QyxNQUFNQyxtQkFBbUIsQUFBQyxDQUFBO0lBQ3hCLElBQUlDLFFBQWdDLENBQUM7SUFFckMsT0FBTztRQUNMQyxTQUFTZixLQUFLRyxFQUFFLENBQUMsQ0FBQ2EsTUFBZ0JGLEtBQUssQ0FBQ0UsSUFBSSxJQUFJO1FBQ2hEQyxTQUFTakIsS0FBS0csRUFBRSxDQUFDLENBQUNhLEtBQWFFO1lBQzdCSixLQUFLLENBQUNFLElBQUksR0FBR0U7UUFDZjtRQUNBQyxZQUFZbkIsS0FBS0csRUFBRSxDQUFDLENBQUNhO1lBQ25CLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSTtRQUNuQjtR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