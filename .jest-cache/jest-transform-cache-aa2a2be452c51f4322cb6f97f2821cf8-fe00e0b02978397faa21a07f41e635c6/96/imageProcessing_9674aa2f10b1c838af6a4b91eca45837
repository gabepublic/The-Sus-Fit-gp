417db1bd96c24c2147ba6549c9a62d28
// Image Processing Utilities for Try-On Mutations
// Comprehensive image processing functions for the business layer
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_PROCESSING_OPTIONS: function() {
        return DEFAULT_PROCESSING_OPTIONS;
    },
    ImageDimensionError: function() {
        return ImageDimensionError;
    },
    ImageFormat: function() {
        return ImageFormat;
    },
    ImageProcessingError: function() {
        return ImageProcessingError;
    },
    applyAutoColorCorrection: function() {
        return applyAutoColorCorrection;
    },
    applyNoiseReduction: function() {
        return applyNoiseReduction;
    },
    applySharpeningFilter: function() {
        return applySharpeningFilter;
    },
    convertImageFormat: function() {
        return convertImageFormat;
    },
    createImageThumbnail: function() {
        return createImageThumbnail;
    },
    extractImageMetadata: function() {
        return extractImageMetadata;
    },
    getBase64Size: function() {
        return getBase64Size;
    },
    getImageDimensions: function() {
        return getImageDimensions;
    },
    processImageAdvanced: function() {
        return processImageAdvanced;
    },
    processImageForTryon: function() {
        return processImageForTryon;
    },
    processImagesInBatch: function() {
        return processImagesInBatch;
    },
    processTryonImages: function() {
        return processTryonImages;
    },
    resizeImageTo1024x1536: function() {
        return resizeImageTo1024x1536;
    },
    validateImageDimensions: function() {
        return validateImageDimensions;
    }
});
const _image = require("../../utils/image");
class ImageProcessingError extends Error {
    constructor(message, originalError){
        super(message), this.originalError = originalError;
        this.name = 'ImageProcessingError';
    }
}
class ImageDimensionError extends Error {
    constructor(message, width, height){
        super(message), this.width = width, this.height = height;
        this.name = 'ImageDimensionError';
    }
}
const DEFAULT_PROCESSING_OPTIONS = {
    targetWidth: 1024,
    targetHeight: 1536,
    maxSizeKB: 1024,
    quality: 0.9,
    preserveAspectRatio: false
};
var ImageFormat = /*#__PURE__*/ function(ImageFormat) {
    ImageFormat["JPEG"] = "image/jpeg";
    ImageFormat["PNG"] = "image/png";
    ImageFormat["WEBP"] = "image/webp";
    ImageFormat["GIF"] = "image/gif";
    return ImageFormat;
}({});
function getImageDimensions(imageUrl) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            resolve({
                width: img.width,
                height: img.height
            });
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for dimension analysis'));
        };
        img.src = imageUrl;
    });
}
function resizeImageTo1024x1536(imageUrl, options = {}) {
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                let { targetWidth, targetHeight } = config;
                // Calculate dimensions preserving aspect ratio if requested
                if (config.preserveAspectRatio) {
                    const aspectRatio = img.width / img.height;
                    const targetAspectRatio = targetWidth / targetHeight;
                    if (aspectRatio > targetAspectRatio) {
                        // Image is wider, fit to width
                        targetHeight = Math.round(targetWidth / aspectRatio);
                    } else {
                        // Image is taller, fit to height
                        targetWidth = Math.round(targetHeight * aspectRatio);
                    }
                }
                // Set canvas dimensions
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                // Apply high-quality scaling
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                // Draw the image resized to fit the canvas
                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                // Convert to data URL with specified quality
                const resizedImageUrl = canvas.toDataURL('image/jpeg', config.quality);
                resolve(resizedImageUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to resize image', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for resizing'));
        };
        img.src = imageUrl;
    });
}
async function validateImageDimensions(imageUrl, minWidth = 512, minHeight = 512, maxWidth = 4096, maxHeight = 4096) {
    const dimensions = await getImageDimensions(imageUrl);
    if (dimensions.width < minWidth || dimensions.height < minHeight) {
        throw new ImageDimensionError(`Image dimensions too small. Minimum: ${minWidth}x${minHeight}, got: ${dimensions.width}x${dimensions.height}`, dimensions.width, dimensions.height);
    }
    if (dimensions.width > maxWidth || dimensions.height > maxHeight) {
        throw new ImageDimensionError(`Image dimensions too large. Maximum: ${maxWidth}x${maxHeight}, got: ${dimensions.width}x${dimensions.height}`, dimensions.width, dimensions.height);
    }
}
function getBase64Size(base64) {
    const base64Data = base64.split(',')[1];
    return atob(base64Data).length;
}
async function processImageForTryon(file, options = {}) {
    const startTime = Date.now();
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    try {
        // Step 1: Validate file type and convert to base64
        if (!(0, _image.isImageFile)(file)) {
            throw new _image.FileTypeNotSupportedError('Only image files are allowed');
        }
        const originalBase64 = await (0, _image.fileToBase64)(file);
        const originalSize = file.size;
        const originalDimensions = await getImageDimensions(originalBase64);
        // Step 2: Validate dimensions
        await validateImageDimensions(originalBase64);
        // Step 3: Resize image to target dimensions
        const resizedImage = await resizeImageTo1024x1536(originalBase64, config);
        const finalDimensions = await getImageDimensions(resizedImage);
        // Step 4: Compress if needed
        let processedImage = resizedImage;
        let wasCompressed = false;
        const resizedSize = getBase64Size(resizedImage);
        const targetSizeBytes = config.maxSizeKB * 1024;
        if (resizedSize > targetSizeBytes) {
            processedImage = await (0, _image.compressBase64)(resizedImage, config.maxSizeKB);
            wasCompressed = true;
        }
        const finalSize = getBase64Size(processedImage);
        const processingTime = Date.now() - startTime;
        return {
            processedImage,
            originalDimensions,
            finalDimensions,
            originalSize,
            finalSize,
            metadata: {
                wasResized: originalDimensions.width !== finalDimensions.width || originalDimensions.height !== finalDimensions.height,
                wasCompressed,
                compressionRatio: originalSize / finalSize,
                processingTime
            }
        };
    } catch (error) {
        if (error instanceof _image.FileTypeNotSupportedError || error instanceof _image.FileTooLargeError || error instanceof _image.CompressionFailedError || error instanceof ImageDimensionError || error instanceof ImageProcessingError) {
            throw error;
        }
        throw new ImageProcessingError('Unexpected error during image processing', error instanceof Error ? error : new Error(String(error)));
    }
}
async function processTryonImages(modelImage, apparelImages, options = {}) {
    // Process model image
    const modelImageResult = await processImageForTryon(modelImage, options);
    // Process all apparel images in parallel
    const apparelImageResults = await Promise.all(apparelImages.map((file)=>processImageForTryon(file, options)));
    return {
        modelImageResult,
        apparelImageResults
    };
}
async function extractImageMetadata(file) {
    const imageUrl = await (0, _image.fileToBase64)(file);
    const dimensions = await getImageDimensions(imageUrl);
    return {
        format: file.type,
        dimensions,
        size: file.size,
        dateCreated: file.lastModified ? new Date(file.lastModified) : undefined
    };
}
async function convertImageFormat(imageUrl, targetFormat, quality = 0.9) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                canvas.width = img.width;
                canvas.height = img.height;
                // For PNG with transparency, fill with white background for JPEG
                if (targetFormat === "image/jpeg") {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                ctx.drawImage(img, 0, 0);
                const convertedImageUrl = canvas.toDataURL(targetFormat, quality);
                resolve(convertedImageUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to convert image format', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for format conversion'));
        };
        img.src = imageUrl;
    });
}
function applySharpeningFilter(canvas, strength = 0.5) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    // Simple unsharp mask implementation
    const sharpenKernel = [
        0,
        -strength,
        0,
        -strength,
        1 + 4 * strength,
        -strength,
        0,
        -strength,
        0
    ];
    const newData = new Uint8ClampedArray(data);
    for(let y = 1; y < height - 1; y++){
        for(let x = 1; x < width - 1; x++){
            for(let c = 0; c < 3; c++){
                let sum = 0;
                for(let ky = -1; ky <= 1; ky++){
                    for(let kx = -1; kx <= 1; kx++){
                        const pixelIndex = ((y + ky) * width + (x + kx)) * 4 + c;
                        const kernelIndex = (ky + 1) * 3 + (kx + 1);
                        sum += data[pixelIndex] * sharpenKernel[kernelIndex];
                    }
                }
                newData[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));
            }
        }
    }
    // Copy the new data back
    for(let i = 0; i < data.length; i++){
        data[i] = newData[i];
    }
    ctx.putImageData(imageData, 0, 0);
}
function applyNoiseReduction(canvas, strength = 0.3) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    // Simple blur for noise reduction
    const radius = Math.ceil(strength * 3);
    const newData = new Uint8ClampedArray(data);
    for(let y = 0; y < height; y++){
        for(let x = 0; x < width; x++){
            for(let c = 0; c < 3; c++){
                let sum = 0;
                let count = 0;
                for(let dy = -radius; dy <= radius; dy++){
                    for(let dx = -radius; dx <= radius; dx++){
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            sum += data[(ny * width + nx) * 4 + c];
                            count++;
                        }
                    }
                }
                newData[(y * width + x) * 4 + c] = sum / count;
            }
        }
    }
    // Copy the new data back
    for(let i = 0; i < data.length; i += 4){
        data[i] = newData[i]; // R
        data[i + 1] = newData[i + 1]; // G
        data[i + 2] = newData[i + 2]; // B
    // Keep original alpha
    }
    ctx.putImageData(imageData, 0, 0);
}
function applyAutoColorCorrection(canvas) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    // Calculate histogram
    const histogram = {
        r: new Array(256).fill(0),
        g: new Array(256).fill(0),
        b: new Array(256).fill(0)
    };
    for(let i = 0; i < data.length; i += 4){
        histogram.r[data[i]]++;
        histogram.g[data[i + 1]]++;
        histogram.b[data[i + 2]]++;
    }
    // Find min/max values for each channel
    const getMinMax = (hist)=>{
        let min = 0, max = 255;
        for(let i = 0; i < 256; i++){
            if (hist[i] > 0) {
                min = i;
                break;
            }
        }
        for(let i = 255; i >= 0; i--){
            if (hist[i] > 0) {
                max = i;
                break;
            }
        }
        return {
            min,
            max
        };
    };
    const rMinMax = getMinMax(histogram.r);
    const gMinMax = getMinMax(histogram.g);
    const bMinMax = getMinMax(histogram.b);
    // Apply histogram stretching
    for(let i = 0; i < data.length; i += 4){
        data[i] = Math.max(0, Math.min(255, (data[i] - rMinMax.min) / (rMinMax.max - rMinMax.min) * 255));
        data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - gMinMax.min) / (gMinMax.max - gMinMax.min) * 255));
        data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - bMinMax.min) / (bMinMax.max - bMinMax.min) * 255));
    }
    ctx.putImageData(imageData, 0, 0);
}
async function processImageAdvanced(file, options = {}) {
    const startTime = Date.now();
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    const operationsApplied = [];
    try {
        // Step 1: Extract original metadata
        const originalMetadata = await extractImageMetadata(file);
        operationsApplied.push('metadata-extraction');
        // Step 2: Validate file type and convert to base64
        if (!(0, _image.isImageFile)(file)) {
            throw new _image.FileTypeNotSupportedError('Only image files are allowed');
        }
        let currentImage = await (0, _image.fileToBase64)(file);
        operationsApplied.push('base64-conversion');
        // Step 3: Validate dimensions
        await validateImageDimensions(currentImage);
        operationsApplied.push('dimension-validation');
        // Step 4: Format conversion (if needed)
        let wasFormatConverted = false;
        if (options.outputFormat && options.outputFormat !== file.type) {
            currentImage = await convertImageFormat(currentImage, options.outputFormat, config.quality);
            wasFormatConverted = true;
            operationsApplied.push('format-conversion');
        }
        // Step 5: Create canvas for advanced processing
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new ImageProcessingError('Could not get canvas context');
        // Load image onto canvas
        const img = new Image();
        img.crossOrigin = "anonymous";
        await new Promise((resolve, reject)=>{
            img.onload = ()=>resolve();
            img.onerror = ()=>reject(new ImageProcessingError('Failed to load image'));
            img.src = currentImage;
        });
        // Set canvas dimensions based on resize requirements
        const finalWidth = config.targetWidth || img.width;
        const finalHeight = config.targetHeight || img.height;
        canvas.width = finalWidth;
        canvas.height = finalHeight;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        // Draw resized image
        ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
        const wasResized = img.width !== finalWidth || img.height !== finalHeight;
        if (wasResized) {
            operationsApplied.push('resize');
        }
        // Step 6: Apply advanced processing
        let wasSharpened = false;
        if (options.enableSharpening && wasResized) {
            applySharpeningFilter(canvas, 0.3);
            wasSharpened = true;
            operationsApplied.push('sharpening');
        }
        let hadNoiseReduction = false;
        if (options.noiseReduction && options.noiseReduction > 0) {
            applyNoiseReduction(canvas, options.noiseReduction);
            hadNoiseReduction = true;
            operationsApplied.push('noise-reduction');
        }
        if (options.autoColorCorrection) {
            applyAutoColorCorrection(canvas);
            operationsApplied.push('color-correction');
        }
        // Step 7: Convert back to data URL
        const outputFormat = options.outputFormat || "image/jpeg";
        let processedImage = canvas.toDataURL(outputFormat, config.quality);
        // Step 8: Compress if needed
        let wasCompressed = false;
        const processedSize = getBase64Size(processedImage);
        const targetSizeBytes = config.maxSizeKB * 1024;
        if (processedSize > targetSizeBytes) {
            processedImage = await (0, _image.compressBase64)(processedImage, config.maxSizeKB);
            wasCompressed = true;
            operationsApplied.push('compression');
        }
        // Step 9: Generate final metadata
        const finalDimensions = await getImageDimensions(processedImage);
        const finalSize = getBase64Size(processedImage);
        const processingTime = Date.now() - startTime;
        const finalMetadata = {
            format: outputFormat,
            dimensions: finalDimensions,
            size: finalSize
        };
        return {
            processedImage,
            originalMetadata,
            finalMetadata,
            processingMetadata: {
                wasResized,
                wasCompressed,
                wasFormatConverted,
                wasSharpened,
                hadNoiseReduction,
                compressionRatio: originalMetadata.size / finalSize,
                processingTime,
                operationsApplied
            }
        };
    } catch (error) {
        if (error instanceof _image.FileTypeNotSupportedError || error instanceof _image.FileTooLargeError || error instanceof _image.CompressionFailedError || error instanceof ImageDimensionError || error instanceof ImageProcessingError) {
            throw error;
        }
        throw new ImageProcessingError('Unexpected error during advanced image processing', error instanceof Error ? error : new Error(String(error)));
    }
}
async function processImagesInBatch(files, options = {}, onProgress) {
    const results = [];
    for(let i = 0; i < files.length; i++){
        const file = files[i];
        onProgress?.(i, files.length, file.name);
        try {
            const result = await processImageAdvanced(file, options);
            results.push(result);
        } catch (error) {
            // For batch processing, we might want to continue with other files
            console.error(`Failed to process ${file.name}:`, error);
        // You could push a failed result or skip, depending on requirements
        }
    }
    onProgress?.(files.length, files.length, 'Complete');
    return results;
}
async function createImageThumbnail(file, size = 150, quality = 0.8) {
    const imageUrl = await (0, _image.fileToBase64)(file);
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                // Calculate dimensions to maintain aspect ratio
                const aspectRatio = img.width / img.height;
                let width = size;
                let height = size;
                if (aspectRatio > 1) {
                    height = size / aspectRatio;
                } else {
                    width = size * aspectRatio;
                }
                canvas.width = width;
                canvas.height = height;
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, width, height);
                const thumbnailUrl = canvas.toDataURL('image/jpeg', quality);
                resolve(thumbnailUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to create thumbnail', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for thumbnail creation'));
        };
        img.src = imageUrl;
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbWFnZSBQcm9jZXNzaW5nIFV0aWxpdGllcyBmb3IgVHJ5LU9uIE11dGF0aW9uc1xuLy8gQ29tcHJlaGVuc2l2ZSBpbWFnZSBwcm9jZXNzaW5nIGZ1bmN0aW9ucyBmb3IgdGhlIGJ1c2luZXNzIGxheWVyXG5cbmltcG9ydCB7IFxuICBmaWxlVG9CYXNlNjQsIFxuICBjb21wcmVzc0Jhc2U2NCwgXG4gIGlzSW1hZ2VGaWxlLFxuICBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yLFxuICBGaWxlVG9vTGFyZ2VFcnJvcixcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcixcbiAgdHlwZSBJbWFnZUJhc2U2NFxufSBmcm9tICdAL3V0aWxzL2ltYWdlJztcbmltcG9ydCB7IFxuICBBZHZhbmNlZENhbnZhc09wZXJhdGlvbnMsIFxuICBjcmVhdGVBZHZhbmNlZENhbnZhc09wZXJhdGlvbnMsXG4gIHR5cGUgTWFuYWdlZENhbnZhcyBcbn0gZnJvbSAnLi4vcHJvdmlkZXJzL0NhbnZhc1Byb3ZpZGVyJztcblxuLyoqXG4gKiBDdXN0b20gZXJyb3IgZm9yIGltYWdlIHByb2Nlc3NpbmcgZmFpbHVyZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlUHJvY2Vzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbEVycm9yPzogRXJyb3IpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnSW1hZ2VQcm9jZXNzaW5nRXJyb3InO1xuICB9XG59XG5cbi8qKlxuICogQ3VzdG9tIGVycm9yIGZvciBpbWFnZSBkaW1lbnNpb24gdmFsaWRhdGlvbiBmYWlsdXJlc1xuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VEaW1lbnNpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgd2lkdGg/OiBudW1iZXIsIHB1YmxpYyByZWFkb25seSBoZWlnaHQ/OiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnSW1hZ2VEaW1lbnNpb25FcnJvcic7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGltYWdlIHByb2Nlc3NpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZVByb2Nlc3NpbmdPcHRpb25zIHtcbiAgLyoqIFRhcmdldCB3aWR0aCBmb3IgcmVzaXppbmcgKGRlZmF1bHQ6IDEwMjQpICovXG4gIHRhcmdldFdpZHRoPzogbnVtYmVyO1xuICAvKiogVGFyZ2V0IGhlaWdodCBmb3IgcmVzaXppbmcgKGRlZmF1bHQ6IDE1MzYpICovXG4gIHRhcmdldEhlaWdodD86IG51bWJlcjtcbiAgLyoqIE1heGltdW0gZmlsZSBzaXplIGluIEtCIGFmdGVyIGNvbXByZXNzaW9uIChkZWZhdWx0OiAxMDI0KSAqL1xuICBtYXhTaXplS0I/OiBudW1iZXI7XG4gIC8qKiBKUEVHIHF1YWxpdHkgZm9yIGNvbXByZXNzaW9uICgwLjEtMS4wLCBkZWZhdWx0OiAwLjkpICovXG4gIHF1YWxpdHk/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIHByZXNlcnZlIGFzcGVjdCByYXRpbyBkdXJpbmcgcmVzaXplIChkZWZhdWx0OiBmYWxzZSkgKi9cbiAgcHJlc2VydmVBc3BlY3RSYXRpbz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCBwcm9jZXNzaW5nIG9wdGlvbnMgZm9yIHRyeS1vbiBpbWFnZXNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJPQ0VTU0lOR19PUFRJT05TOiBSZXF1aXJlZDxJbWFnZVByb2Nlc3NpbmdPcHRpb25zPiA9IHtcbiAgdGFyZ2V0V2lkdGg6IDEwMjQsXG4gIHRhcmdldEhlaWdodDogMTUzNixcbiAgbWF4U2l6ZUtCOiAxMDI0LFxuICBxdWFsaXR5OiAwLjksXG4gIHByZXNlcnZlQXNwZWN0UmF0aW86IGZhbHNlXG59O1xuXG4vKipcbiAqIFN1cHBvcnRlZCBpbWFnZSBmb3JtYXRzIGZvciBjb252ZXJzaW9uXG4gKi9cbmV4cG9ydCBlbnVtIEltYWdlRm9ybWF0IHtcbiAgSlBFRyA9ICdpbWFnZS9qcGVnJyxcbiAgUE5HID0gJ2ltYWdlL3BuZycsXG4gIFdFQlAgPSAnaW1hZ2Uvd2VicCcsXG4gIEdJRiA9ICdpbWFnZS9naWYnXG59XG5cbi8qKlxuICogSW1hZ2UgbWV0YWRhdGEgZXh0cmFjdGVkIGZyb20gZmlsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlTWV0YWRhdGEge1xuICAvKiogSW1hZ2UgZm9ybWF0L01JTUUgdHlwZSAqL1xuICBmb3JtYXQ6IHN0cmluZztcbiAgLyoqIEltYWdlIGRpbWVuc2lvbnMgKi9cbiAgZGltZW5zaW9uczogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAvKiogRmlsZSBzaXplIGluIGJ5dGVzICovXG4gIHNpemU6IG51bWJlcjtcbiAgLyoqIENvbG9yIGRlcHRoIGluZm9ybWF0aW9uICovXG4gIGNvbG9yRGVwdGg/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIGltYWdlIGhhcyB0cmFuc3BhcmVuY3kgKi9cbiAgaGFzQWxwaGE/OiBib29sZWFuO1xuICAvKiogRXN0aW1hdGVkIHF1YWxpdHkgKGZvciBKUEVHKSAqL1xuICBlc3RpbWF0ZWRRdWFsaXR5PzogbnVtYmVyO1xuICAvKiogQ3JlYXRpb24gdGltZXN0YW1wIGlmIGF2YWlsYWJsZSAqL1xuICBkYXRlQ3JlYXRlZD86IERhdGU7XG4gIC8qKiBEZXZpY2Ugb3JpZW50YXRpb24gKEVYSUYpICovXG4gIG9yaWVudGF0aW9uPzogbnVtYmVyO1xuICAvKiogRFBJL3Jlc29sdXRpb24gaW5mb3JtYXRpb24gKi9cbiAgcmVzb2x1dGlvbj86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbn1cblxuLyoqXG4gKiBBZHZhbmNlZCBpbWFnZSBwcm9jZXNzaW5nIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ09wdGlvbnMgZXh0ZW5kcyBJbWFnZVByb2Nlc3NpbmdPcHRpb25zIHtcbiAgLyoqIE91dHB1dCBmb3JtYXQgKi9cbiAgb3V0cHV0Rm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG4gIC8qKiBFbmFibGUgc2hhcnBlbmluZyBhZnRlciByZXNpemUgKi9cbiAgZW5hYmxlU2hhcnBlbmluZz86IGJvb2xlYW47XG4gIC8qKiBOb2lzZSByZWR1Y3Rpb24gc3RyZW5ndGggKDAtMSkgKi9cbiAgbm9pc2VSZWR1Y3Rpb24/OiBudW1iZXI7XG4gIC8qKiBFbmFibGUgYXV0b21hdGljIGNvbG9yIGNvcnJlY3Rpb24gKi9cbiAgYXV0b0NvbG9yQ29ycmVjdGlvbj86IGJvb2xlYW47XG4gIC8qKiBQcmVzZXJ2ZSBFWElGIGRhdGEgKi9cbiAgcHJlc2VydmVFeGlmPzogYm9vbGVhbjtcbiAgLyoqIEN1c3RvbSBjYW52YXMgZm9yIHByb2Nlc3NpbmcgKi9cbiAgY2FudmFzPzogTWFuYWdlZENhbnZhcztcbn1cblxuLyoqXG4gKiBFbmhhbmNlZCByZXN1bHQgb2YgaW1hZ2UgcHJvY2Vzc2luZyBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdSZXN1bHQge1xuICAvKiogUHJvY2Vzc2VkIGltYWdlIGFzIGJhc2U2NCBkYXRhIFVSTCAqL1xuICBwcm9jZXNzZWRJbWFnZTogSW1hZ2VCYXNlNjQ7XG4gIC8qKiBPcmlnaW5hbCBpbWFnZSBtZXRhZGF0YSAqL1xuICBvcmlnaW5hbE1ldGFkYXRhOiBJbWFnZU1ldGFkYXRhO1xuICAvKiogRmluYWwgaW1hZ2UgbWV0YWRhdGEgKi9cbiAgZmluYWxNZXRhZGF0YTogSW1hZ2VNZXRhZGF0YTtcbiAgLyoqIFByb2Nlc3NpbmcgbWV0YWRhdGEgKi9cbiAgcHJvY2Vzc2luZ01ldGFkYXRhOiB7XG4gICAgd2FzUmVzaXplZDogYm9vbGVhbjtcbiAgICB3YXNDb21wcmVzc2VkOiBib29sZWFuO1xuICAgIHdhc0Zvcm1hdENvbnZlcnRlZDogYm9vbGVhbjtcbiAgICB3YXNTaGFycGVuZWQ6IGJvb2xlYW47XG4gICAgaGFkTm9pc2VSZWR1Y3Rpb246IGJvb2xlYW47XG4gICAgY29tcHJlc3Npb25SYXRpbzogbnVtYmVyO1xuICAgIHByb2Nlc3NpbmdUaW1lOiBudW1iZXI7XG4gICAgb3BlcmF0aW9uc0FwcGxpZWQ6IHN0cmluZ1tdO1xuICB9O1xufVxuXG4vKipcbiAqIFJlc3VsdCBvZiBpbWFnZSBwcm9jZXNzaW5nIG9wZXJhdGlvbnMgKGxlZ2FjeSBjb21wYXRpYmlsaXR5KVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gIC8qKiBQcm9jZXNzZWQgaW1hZ2UgYXMgYmFzZTY0IGRhdGEgVVJMICovXG4gIHByb2Nlc3NlZEltYWdlOiBJbWFnZUJhc2U2NDtcbiAgLyoqIE9yaWdpbmFsIGltYWdlIGRpbWVuc2lvbnMgKi9cbiAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG4gIC8qKiBGaW5hbCBpbWFnZSBkaW1lbnNpb25zICovXG4gIGZpbmFsRGltZW5zaW9uczogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAvKiogT3JpZ2luYWwgZmlsZSBzaXplIGluIGJ5dGVzICovXG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyO1xuICAvKiogRmluYWwgZmlsZSBzaXplIGluIGJ5dGVzICovXG4gIGZpbmFsU2l6ZTogbnVtYmVyO1xuICAvKiogUHJvY2Vzc2luZyBtZXRhZGF0YSAqL1xuICBtZXRhZGF0YToge1xuICAgIHdhc1Jlc2l6ZWQ6IGJvb2xlYW47XG4gICAgd2FzQ29tcHJlc3NlZDogYm9vbGVhbjtcbiAgICBjb21wcmVzc2lvblJhdGlvOiBudW1iZXI7XG4gICAgcHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgaW1hZ2UgZGltZW5zaW9ucyBmcm9tIGEgZGF0YSBVUkwgb3IgaW1hZ2UgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VEaW1lbnNpb25zKGltYWdlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoeyB3aWR0aDogaW1nLndpZHRoLCBoZWlnaHQ6IGltZy5oZWlnaHQgfSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlIGZvciBkaW1lbnNpb24gYW5hbHlzaXMnKSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlc2l6ZSBpbWFnZSB0byBzcGVjaWZpYyBkaW1lbnNpb25zXG4gKiBcbiAqIEBwYXJhbSBpbWFnZVVybCAtIFNvdXJjZSBpbWFnZSBkYXRhIFVSTFxuICogQHBhcmFtIG9wdGlvbnMgLSBSZXNpemUgb3B0aW9uc1xuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gcmVzaXplZCBpbWFnZSBkYXRhIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplSW1hZ2VUbzEwMjR4MTUzNihcbiAgaW1hZ2VVcmw6IHN0cmluZywgXG4gIG9wdGlvbnM6IFBhcnRpYWw8SW1hZ2VQcm9jZXNzaW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgY29uZmlnID0geyAuLi5ERUZBVUxUX1BST0NFU1NJTkdfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICBcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgeyB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0IH0gPSBjb25maWc7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZGltZW5zaW9ucyBwcmVzZXJ2aW5nIGFzcGVjdCByYXRpbyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKGNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHRhcmdldEFzcGVjdFJhdGlvID0gdGFyZ2V0V2lkdGggLyB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvID4gdGFyZ2V0QXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIC8vIEltYWdlIGlzIHdpZGVyLCBmaXQgdG8gd2lkdGhcbiAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IE1hdGgucm91bmQodGFyZ2V0V2lkdGggLyBhc3BlY3RSYXRpbyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEltYWdlIGlzIHRhbGxlciwgZml0IHRvIGhlaWdodFxuICAgICAgICAgICAgdGFyZ2V0V2lkdGggPSBNYXRoLnJvdW5kKHRhcmdldEhlaWdodCAqIGFzcGVjdFJhdGlvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IGhpZ2gtcXVhbGl0eSBzY2FsaW5nXG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gJ2hpZ2gnO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgaW1hZ2UgcmVzaXplZCB0byBmaXQgdGhlIGNhbnZhc1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHRvIGRhdGEgVVJMIHdpdGggc3BlY2lmaWVkIHF1YWxpdHlcbiAgICAgICAgY29uc3QgcmVzaXplZEltYWdlVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIGNvbmZpZy5xdWFsaXR5KTtcbiAgICAgICAgcmVzb2x2ZShyZXNpemVkSW1hZ2VVcmwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIHJlc2l6ZSBpbWFnZScsXG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSBmb3IgcmVzaXppbmcnKSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gIH0pO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGltYWdlIGRpbWVuc2lvbnMgYWdhaW5zdCByZXF1aXJlbWVudHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSW1hZ2VEaW1lbnNpb25zKFxuICBpbWFnZVVybDogc3RyaW5nLFxuICBtaW5XaWR0aCA9IDUxMixcbiAgbWluSGVpZ2h0ID0gNTEyLFxuICBtYXhXaWR0aCA9IDQwOTYsXG4gIG1heEhlaWdodCA9IDQwOTZcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkaW1lbnNpb25zID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKGltYWdlVXJsKTtcbiAgXG4gIGlmIChkaW1lbnNpb25zLndpZHRoIDwgbWluV2lkdGggfHwgZGltZW5zaW9ucy5oZWlnaHQgPCBtaW5IZWlnaHQpIHtcbiAgICB0aHJvdyBuZXcgSW1hZ2VEaW1lbnNpb25FcnJvcihcbiAgICAgIGBJbWFnZSBkaW1lbnNpb25zIHRvbyBzbWFsbC4gTWluaW11bTogJHttaW5XaWR0aH14JHttaW5IZWlnaHR9LCBnb3Q6ICR7ZGltZW5zaW9ucy53aWR0aH14JHtkaW1lbnNpb25zLmhlaWdodH1gLFxuICAgICAgZGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0XG4gICAgKTtcbiAgfVxuICBcbiAgaWYgKGRpbWVuc2lvbnMud2lkdGggPiBtYXhXaWR0aCB8fCBkaW1lbnNpb25zLmhlaWdodCA+IG1heEhlaWdodCkge1xuICAgIHRocm93IG5ldyBJbWFnZURpbWVuc2lvbkVycm9yKFxuICAgICAgYEltYWdlIGRpbWVuc2lvbnMgdG9vIGxhcmdlLiBNYXhpbXVtOiAke21heFdpZHRofXgke21heEhlaWdodH0sIGdvdDogJHtkaW1lbnNpb25zLndpZHRofXgke2RpbWVuc2lvbnMuaGVpZ2h0fWAsXG4gICAgICBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgZGltZW5zaW9ucy5oZWlnaHRcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGZpbGUgc2l6ZSBmcm9tIGJhc2U2NCBkYXRhIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZTY0U2l6ZShiYXNlNjQ6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGJhc2U2NERhdGEgPSBiYXNlNjQuc3BsaXQoJywnKVsxXTtcbiAgcmV0dXJuIGF0b2IoYmFzZTY0RGF0YSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBmaWxlIHRocm91Z2ggdGhlIGNvbXBsZXRlIHRyeS1vbiBpbWFnZSBwaXBlbGluZVxuICogXG4gKiBAcGFyYW0gZmlsZSAtIElucHV0IGltYWdlIGZpbGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gUHJvY2Vzc2luZyBvcHRpb25zXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBwcm9jZXNzaW5nIHJlc3VsdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ltYWdlRm9yVHJ5b24oXG4gIGZpbGU6IEZpbGUsXG4gIG9wdGlvbnM6IFBhcnRpYWw8SW1hZ2VQcm9jZXNzaW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTxJbWFnZVByb2Nlc3NpbmdSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgY29uZmlnID0geyAuLi5ERUZBVUxUX1BST0NFU1NJTkdfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICBcbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IFZhbGlkYXRlIGZpbGUgdHlwZSBhbmQgY29udmVydCB0byBiYXNlNjRcbiAgICBpZiAoIWlzSW1hZ2VGaWxlKGZpbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZVR5cGVOb3RTdXBwb3J0ZWRFcnJvcignT25seSBpbWFnZSBmaWxlcyBhcmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBvcmlnaW5hbEJhc2U2NCA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgICBjb25zdCBvcmlnaW5hbFNpemUgPSBmaWxlLnNpemU7XG4gICAgY29uc3Qgb3JpZ2luYWxEaW1lbnNpb25zID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKG9yaWdpbmFsQmFzZTY0KTtcbiAgICBcbiAgICAvLyBTdGVwIDI6IFZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBhd2FpdCB2YWxpZGF0ZUltYWdlRGltZW5zaW9ucyhvcmlnaW5hbEJhc2U2NCk7XG4gICAgXG4gICAgLy8gU3RlcCAzOiBSZXNpemUgaW1hZ2UgdG8gdGFyZ2V0IGRpbWVuc2lvbnNcbiAgICBjb25zdCByZXNpemVkSW1hZ2UgPSBhd2FpdCByZXNpemVJbWFnZVRvMTAyNHgxNTM2KG9yaWdpbmFsQmFzZTY0LCBjb25maWcpO1xuICAgIGNvbnN0IGZpbmFsRGltZW5zaW9ucyA9IGF3YWl0IGdldEltYWdlRGltZW5zaW9ucyhyZXNpemVkSW1hZ2UpO1xuICAgIFxuICAgIC8vIFN0ZXAgNDogQ29tcHJlc3MgaWYgbmVlZGVkXG4gICAgbGV0IHByb2Nlc3NlZEltYWdlID0gcmVzaXplZEltYWdlO1xuICAgIGxldCB3YXNDb21wcmVzc2VkID0gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgcmVzaXplZFNpemUgPSBnZXRCYXNlNjRTaXplKHJlc2l6ZWRJbWFnZSk7XG4gICAgY29uc3QgdGFyZ2V0U2l6ZUJ5dGVzID0gY29uZmlnLm1heFNpemVLQiAqIDEwMjQ7XG4gICAgXG4gICAgaWYgKHJlc2l6ZWRTaXplID4gdGFyZ2V0U2l6ZUJ5dGVzKSB7XG4gICAgICBwcm9jZXNzZWRJbWFnZSA9IGF3YWl0IGNvbXByZXNzQmFzZTY0KHJlc2l6ZWRJbWFnZSwgY29uZmlnLm1heFNpemVLQik7XG4gICAgICB3YXNDb21wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmluYWxTaXplID0gZ2V0QmFzZTY0U2l6ZShwcm9jZXNzZWRJbWFnZSk7XG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBwcm9jZXNzZWRJbWFnZSxcbiAgICAgIG9yaWdpbmFsRGltZW5zaW9ucyxcbiAgICAgIGZpbmFsRGltZW5zaW9ucyxcbiAgICAgIG9yaWdpbmFsU2l6ZSxcbiAgICAgIGZpbmFsU2l6ZSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHdhc1Jlc2l6ZWQ6IG9yaWdpbmFsRGltZW5zaW9ucy53aWR0aCAhPT0gZmluYWxEaW1lbnNpb25zLndpZHRoIHx8IFxuICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGltZW5zaW9ucy5oZWlnaHQgIT09IGZpbmFsRGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgIHdhc0NvbXByZXNzZWQsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IG9yaWdpbmFsU2l6ZSAvIGZpbmFsU2l6ZSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWVcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpbGVUeXBlTm90U3VwcG9ydGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBGaWxlVG9vTGFyZ2VFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENvbXByZXNzaW9uRmFpbGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBJbWFnZURpbWVuc2lvbkVycm9yIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgSW1hZ2VQcm9jZXNzaW5nRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoXG4gICAgICAnVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgaW1hZ2UgcHJvY2Vzc2luZycsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogUHJvY2VzcyBtdWx0aXBsZSBpbWFnZXMgZm9yIHRyeS1vbiAobW9kZWwgKyBhcHBhcmVsIGltYWdlcylcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUcnlvbkltYWdlcyhcbiAgbW9kZWxJbWFnZTogRmlsZSxcbiAgYXBwYXJlbEltYWdlczogRmlsZVtdLFxuICBvcHRpb25zOiBQYXJ0aWFsPEltYWdlUHJvY2Vzc2luZ09wdGlvbnM+ID0ge31cbik6IFByb21pc2U8e1xuICBtb2RlbEltYWdlUmVzdWx0OiBJbWFnZVByb2Nlc3NpbmdSZXN1bHQ7XG4gIGFwcGFyZWxJbWFnZVJlc3VsdHM6IEltYWdlUHJvY2Vzc2luZ1Jlc3VsdFtdO1xufT4ge1xuICAvLyBQcm9jZXNzIG1vZGVsIGltYWdlXG4gIGNvbnN0IG1vZGVsSW1hZ2VSZXN1bHQgPSBhd2FpdCBwcm9jZXNzSW1hZ2VGb3JUcnlvbihtb2RlbEltYWdlLCBvcHRpb25zKTtcbiAgXG4gIC8vIFByb2Nlc3MgYWxsIGFwcGFyZWwgaW1hZ2VzIGluIHBhcmFsbGVsXG4gIGNvbnN0IGFwcGFyZWxJbWFnZVJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBhcHBhcmVsSW1hZ2VzLm1hcChmaWxlID0+IHByb2Nlc3NJbWFnZUZvclRyeW9uKGZpbGUsIG9wdGlvbnMpKVxuICApO1xuICBcbiAgcmV0dXJuIHtcbiAgICBtb2RlbEltYWdlUmVzdWx0LFxuICAgIGFwcGFyZWxJbWFnZVJlc3VsdHNcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGNvbXByZWhlbnNpdmUgbWV0YWRhdGEgZnJvbSBpbWFnZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEltYWdlTWV0YWRhdGEoZmlsZTogRmlsZSk6IFByb21pc2U8SW1hZ2VNZXRhZGF0YT4ge1xuICBjb25zdCBpbWFnZVVybCA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IGdldEltYWdlRGltZW5zaW9ucyhpbWFnZVVybCk7XG4gIFxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogZmlsZS50eXBlLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgc2l6ZTogZmlsZS5zaXplLFxuICAgIGRhdGVDcmVhdGVkOiBmaWxlLmxhc3RNb2RpZmllZCA/IG5ldyBEYXRlKGZpbGUubGFzdE1vZGlmaWVkKSA6IHVuZGVmaW5lZCxcbiAgICAvLyBBZGRpdGlvbmFsIG1ldGFkYXRhIHdvdWxkIHJlcXVpcmUgRVhJRiBwYXJzaW5nIGxpYnJhcnlcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBwcm92aWRlIGJhc2ljIG1ldGFkYXRhXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBpbWFnZSB0byBkaWZmZXJlbnQgZm9ybWF0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0SW1hZ2VGb3JtYXQoXG4gIGltYWdlVXJsOiBzdHJpbmcsXG4gIHRhcmdldEZvcm1hdDogSW1hZ2VGb3JtYXQsXG4gIHF1YWxpdHk6IG51bWJlciA9IDAuOVxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yIFBORyB3aXRoIHRyYW5zcGFyZW5jeSwgZmlsbCB3aXRoIHdoaXRlIGJhY2tncm91bmQgZm9yIEpQRUdcbiAgICAgICAgaWYgKHRhcmdldEZvcm1hdCA9PT0gSW1hZ2VGb3JtYXQuSlBFRykge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRJbWFnZVVybCA9IGNhbnZhcy50b0RhdGFVUkwodGFyZ2V0Rm9ybWF0LCBxdWFsaXR5KTtcbiAgICAgICAgcmVzb2x2ZShjb252ZXJ0ZWRJbWFnZVVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gY29udmVydCBpbWFnZSBmb3JtYXQnLFxuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UgZm9yIGZvcm1hdCBjb252ZXJzaW9uJykpO1xuICAgIH07XG4gICAgXG4gICAgaW1nLnNyYyA9IGltYWdlVXJsO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSBzaGFycGVuaW5nIGZpbHRlciB0byBpbWFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTaGFycGVuaW5nRmlsdGVyKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHN0cmVuZ3RoOiBudW1iZXIgPSAwLjUpOiB2b2lkIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGlmICghY3R4KSB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgXG4gIC8vIFNpbXBsZSB1bnNoYXJwIG1hc2sgaW1wbGVtZW50YXRpb25cbiAgY29uc3Qgc2hhcnBlbktlcm5lbCA9IFtcbiAgICAwLCAtc3RyZW5ndGgsIDAsXG4gICAgLXN0cmVuZ3RoLCAxICsgNCAqIHN0cmVuZ3RoLCAtc3RyZW5ndGgsXG4gICAgMCwgLXN0cmVuZ3RoLCAwXG4gIF07XG4gIFxuICBjb25zdCBuZXdEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEpO1xuICBcbiAgZm9yIChsZXQgeSA9IDE7IHkgPCBoZWlnaHQgLSAxOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMTsgeCA8IHdpZHRoIC0gMTsgeCsrKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDM7IGMrKykgeyAvLyBSR0IgY2hhbm5lbHMgb25seVxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQga3kgPSAtMTsga3kgPD0gMTsga3krKykge1xuICAgICAgICAgIGZvciAobGV0IGt4ID0gLTE7IGt4IDw9IDE7IGt4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsSW5kZXggPSAoKHkgKyBreSkgKiB3aWR0aCArICh4ICsga3gpKSAqIDQgKyBjO1xuICAgICAgICAgICAgY29uc3Qga2VybmVsSW5kZXggPSAoa3kgKyAxKSAqIDMgKyAoa3ggKyAxKTtcbiAgICAgICAgICAgIHN1bSArPSBkYXRhW3BpeGVsSW5kZXhdICogc2hhcnBlbktlcm5lbFtrZXJuZWxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld0RhdGFbKHkgKiB3aWR0aCArIHgpICogNCArIGNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBzdW0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIENvcHkgdGhlIG5ldyBkYXRhIGJhY2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YVtpXSA9IG5ld0RhdGFbaV07XG4gIH1cbiAgXG4gIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbn1cblxuLyoqXG4gKiBBcHBseSBub2lzZSByZWR1Y3Rpb24gZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseU5vaXNlUmVkdWN0aW9uKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHN0cmVuZ3RoOiBudW1iZXIgPSAwLjMpOiB2b2lkIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGlmICghY3R4KSB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgXG4gIC8vIFNpbXBsZSBibHVyIGZvciBub2lzZSByZWR1Y3Rpb25cbiAgY29uc3QgcmFkaXVzID0gTWF0aC5jZWlsKHN0cmVuZ3RoICogMyk7XG4gIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YSk7XG4gIFxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDM7IGMrKykgeyAvLyBSR0IgY2hhbm5lbHMgb25seVxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGR5ID0gLXJhZGl1czsgZHkgPD0gcmFkaXVzOyBkeSsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgZHggPSAtcmFkaXVzOyBkeCA8PSByYWRpdXM7IGR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG54ID0geCArIGR4O1xuICAgICAgICAgICAgY29uc3QgbnkgPSB5ICsgZHk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChueCA+PSAwICYmIG54IDwgd2lkdGggJiYgbnkgPj0gMCAmJiBueSA8IGhlaWdodCkge1xuICAgICAgICAgICAgICBzdW0gKz0gZGF0YVsobnkgKiB3aWR0aCArIG54KSAqIDQgKyBjXTtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG5ld0RhdGFbKHkgKiB3aWR0aCArIHgpICogNCArIGNdID0gc3VtIC8gY291bnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBDb3B5IHRoZSBuZXcgZGF0YSBiYWNrXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGRhdGFbaV0gPSBuZXdEYXRhW2ldOyAgICAgLy8gUlxuICAgIGRhdGFbaSArIDFdID0gbmV3RGF0YVtpICsgMV07IC8vIEdcbiAgICBkYXRhW2kgKyAyXSA9IG5ld0RhdGFbaSArIDJdOyAvLyBCXG4gICAgLy8gS2VlcCBvcmlnaW5hbCBhbHBoYVxuICB9XG4gIFxuICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG59XG5cbi8qKlxuICogQXBwbHkgYXV0b21hdGljIGNvbG9yIGNvcnJlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QXV0b0NvbG9yQ29ycmVjdGlvbihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBpZiAoIWN0eCkgdGhyb3cgbmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gIFxuICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBoaXN0b2dyYW1cbiAgY29uc3QgaGlzdG9ncmFtID0ge1xuICAgIHI6IG5ldyBBcnJheSgyNTYpLmZpbGwoMCksXG4gICAgZzogbmV3IEFycmF5KDI1NikuZmlsbCgwKSxcbiAgICBiOiBuZXcgQXJyYXkoMjU2KS5maWxsKDApXG4gIH07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBoaXN0b2dyYW0ucltkYXRhW2ldXSsrO1xuICAgIGhpc3RvZ3JhbS5nW2RhdGFbaSArIDFdXSsrO1xuICAgIGhpc3RvZ3JhbS5iW2RhdGFbaSArIDJdXSsrO1xuICB9XG4gIFxuICAvLyBGaW5kIG1pbi9tYXggdmFsdWVzIGZvciBlYWNoIGNoYW5uZWxcbiAgY29uc3QgZ2V0TWluTWF4ID0gKGhpc3Q6IG51bWJlcltdKSA9PiB7XG4gICAgbGV0IG1pbiA9IDAsIG1heCA9IDI1NTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaGlzdFtpXSA+IDApIHsgbWluID0gaTsgYnJlYWs7IH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDI1NTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChoaXN0W2ldID4gMCkgeyBtYXggPSBpOyBicmVhazsgfVxuICAgIH1cbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICB9O1xuICBcbiAgY29uc3Qgck1pbk1heCA9IGdldE1pbk1heChoaXN0b2dyYW0ucik7XG4gIGNvbnN0IGdNaW5NYXggPSBnZXRNaW5NYXgoaGlzdG9ncmFtLmcpO1xuICBjb25zdCBiTWluTWF4ID0gZ2V0TWluTWF4KGhpc3RvZ3JhbS5iKTtcbiAgXG4gIC8vIEFwcGx5IGhpc3RvZ3JhbSBzdHJldGNoaW5nXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGRhdGFbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIFxuICAgICAgKChkYXRhW2ldIC0gck1pbk1heC5taW4pIC8gKHJNaW5NYXgubWF4IC0gck1pbk1heC5taW4pKSAqIDI1NSkpO1xuICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBcbiAgICAgICgoZGF0YVtpICsgMV0gLSBnTWluTWF4Lm1pbikgLyAoZ01pbk1heC5tYXggLSBnTWluTWF4Lm1pbikpICogMjU1KSk7XG4gICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIFxuICAgICAgKChkYXRhW2kgKyAyXSAtIGJNaW5NYXgubWluKSAvIChiTWluTWF4Lm1heCAtIGJNaW5NYXgubWluKSkgKiAyNTUpKTtcbiAgfVxuICBcbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xufVxuXG4vKipcbiAqIEFkdmFuY2VkIGltYWdlIHByb2Nlc3Npbmcgd2l0aCBjb21wcmVoZW5zaXZlIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJbWFnZUFkdmFuY2VkKFxuICBmaWxlOiBGaWxlLFxuICBvcHRpb25zOiBQYXJ0aWFsPEFkdmFuY2VkSW1hZ2VQcm9jZXNzaW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTxBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ1Jlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBjb25zdCBjb25maWcgPSB7IC4uLkRFRkFVTFRfUFJPQ0VTU0lOR19PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gIGNvbnN0IG9wZXJhdGlvbnNBcHBsaWVkOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IEV4dHJhY3Qgb3JpZ2luYWwgbWV0YWRhdGFcbiAgICBjb25zdCBvcmlnaW5hbE1ldGFkYXRhID0gYXdhaXQgZXh0cmFjdEltYWdlTWV0YWRhdGEoZmlsZSk7XG4gICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnbWV0YWRhdGEtZXh0cmFjdGlvbicpO1xuICAgIFxuICAgIC8vIFN0ZXAgMjogVmFsaWRhdGUgZmlsZSB0eXBlIGFuZCBjb252ZXJ0IHRvIGJhc2U2NFxuICAgIGlmICghaXNJbWFnZUZpbGUoZmlsZSkpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yKCdPbmx5IGltYWdlIGZpbGVzIGFyZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIFxuICAgIGxldCBjdXJyZW50SW1hZ2UgPSBhd2FpdCBmaWxlVG9CYXNlNjQoZmlsZSk7XG4gICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnYmFzZTY0LWNvbnZlcnNpb24nKTtcbiAgICBcbiAgICAvLyBTdGVwIDM6IFZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBhd2FpdCB2YWxpZGF0ZUltYWdlRGltZW5zaW9ucyhjdXJyZW50SW1hZ2UpO1xuICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ2RpbWVuc2lvbi12YWxpZGF0aW9uJyk7XG4gICAgXG4gICAgLy8gU3RlcCA0OiBGb3JtYXQgY29udmVyc2lvbiAoaWYgbmVlZGVkKVxuICAgIGxldCB3YXNGb3JtYXRDb252ZXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5vdXRwdXRGb3JtYXQgJiYgb3B0aW9ucy5vdXRwdXRGb3JtYXQgIT09IGZpbGUudHlwZSkge1xuICAgICAgY3VycmVudEltYWdlID0gYXdhaXQgY29udmVydEltYWdlRm9ybWF0KGN1cnJlbnRJbWFnZSwgb3B0aW9ucy5vdXRwdXRGb3JtYXQsIGNvbmZpZy5xdWFsaXR5KTtcbiAgICAgIHdhc0Zvcm1hdENvbnZlcnRlZCA9IHRydWU7XG4gICAgICBvcGVyYXRpb25zQXBwbGllZC5wdXNoKCdmb3JtYXQtY29udmVyc2lvbicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGVwIDU6IENyZWF0ZSBjYW52YXMgZm9yIGFkdmFuY2VkIHByb2Nlc3NpbmdcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIWN0eCkgdGhyb3cgbmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgXG4gICAgLy8gTG9hZCBpbWFnZSBvbnRvIGNhbnZhc1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UnKSk7XG4gICAgICBpbWcuc3JjID0gY3VycmVudEltYWdlO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyBiYXNlZCBvbiByZXNpemUgcmVxdWlyZW1lbnRzXG4gICAgY29uc3QgZmluYWxXaWR0aCA9IGNvbmZpZy50YXJnZXRXaWR0aCB8fCBpbWcud2lkdGg7XG4gICAgY29uc3QgZmluYWxIZWlnaHQgPSBjb25maWcudGFyZ2V0SGVpZ2h0IHx8IGltZy5oZWlnaHQ7XG4gICAgXG4gICAgY2FudmFzLndpZHRoID0gZmluYWxXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZmluYWxIZWlnaHQ7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9ICdoaWdoJztcbiAgICBcbiAgICAvLyBEcmF3IHJlc2l6ZWQgaW1hZ2VcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgZmluYWxXaWR0aCwgZmluYWxIZWlnaHQpO1xuICAgIFxuICAgIGNvbnN0IHdhc1Jlc2l6ZWQgPSBpbWcud2lkdGggIT09IGZpbmFsV2lkdGggfHwgaW1nLmhlaWdodCAhPT0gZmluYWxIZWlnaHQ7XG4gICAgaWYgKHdhc1Jlc2l6ZWQpIHtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ3Jlc2l6ZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGVwIDY6IEFwcGx5IGFkdmFuY2VkIHByb2Nlc3NpbmdcbiAgICBsZXQgd2FzU2hhcnBlbmVkID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlU2hhcnBlbmluZyAmJiB3YXNSZXNpemVkKSB7XG4gICAgICBhcHBseVNoYXJwZW5pbmdGaWx0ZXIoY2FudmFzLCAwLjMpO1xuICAgICAgd2FzU2hhcnBlbmVkID0gdHJ1ZTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ3NoYXJwZW5pbmcnKTtcbiAgICB9XG4gICAgXG4gICAgbGV0IGhhZE5vaXNlUmVkdWN0aW9uID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMubm9pc2VSZWR1Y3Rpb24gJiYgb3B0aW9ucy5ub2lzZVJlZHVjdGlvbiA+IDApIHtcbiAgICAgIGFwcGx5Tm9pc2VSZWR1Y3Rpb24oY2FudmFzLCBvcHRpb25zLm5vaXNlUmVkdWN0aW9uKTtcbiAgICAgIGhhZE5vaXNlUmVkdWN0aW9uID0gdHJ1ZTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ25vaXNlLXJlZHVjdGlvbicpO1xuICAgIH1cbiAgICBcbiAgICBpZiAob3B0aW9ucy5hdXRvQ29sb3JDb3JyZWN0aW9uKSB7XG4gICAgICBhcHBseUF1dG9Db2xvckNvcnJlY3Rpb24oY2FudmFzKTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ2NvbG9yLWNvcnJlY3Rpb24nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RlcCA3OiBDb252ZXJ0IGJhY2sgdG8gZGF0YSBVUkxcbiAgICBjb25zdCBvdXRwdXRGb3JtYXQgPSBvcHRpb25zLm91dHB1dEZvcm1hdCB8fCBJbWFnZUZvcm1hdC5KUEVHO1xuICAgIGxldCBwcm9jZXNzZWRJbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwob3V0cHV0Rm9ybWF0LCBjb25maWcucXVhbGl0eSk7XG4gICAgXG4gICAgLy8gU3RlcCA4OiBDb21wcmVzcyBpZiBuZWVkZWRcbiAgICBsZXQgd2FzQ29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByb2Nlc3NlZFNpemUgPSBnZXRCYXNlNjRTaXplKHByb2Nlc3NlZEltYWdlKTtcbiAgICBjb25zdCB0YXJnZXRTaXplQnl0ZXMgPSBjb25maWcubWF4U2l6ZUtCICogMTAyNDtcbiAgICBcbiAgICBpZiAocHJvY2Vzc2VkU2l6ZSA+IHRhcmdldFNpemVCeXRlcykge1xuICAgICAgcHJvY2Vzc2VkSW1hZ2UgPSBhd2FpdCBjb21wcmVzc0Jhc2U2NChwcm9jZXNzZWRJbWFnZSwgY29uZmlnLm1heFNpemVLQik7XG4gICAgICB3YXNDb21wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ2NvbXByZXNzaW9uJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0ZXAgOTogR2VuZXJhdGUgZmluYWwgbWV0YWRhdGFcbiAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSBhd2FpdCBnZXRJbWFnZURpbWVuc2lvbnMocHJvY2Vzc2VkSW1hZ2UpO1xuICAgIGNvbnN0IGZpbmFsU2l6ZSA9IGdldEJhc2U2NFNpemUocHJvY2Vzc2VkSW1hZ2UpO1xuICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBcbiAgICBjb25zdCBmaW5hbE1ldGFkYXRhOiBJbWFnZU1ldGFkYXRhID0ge1xuICAgICAgZm9ybWF0OiBvdXRwdXRGb3JtYXQsXG4gICAgICBkaW1lbnNpb25zOiBmaW5hbERpbWVuc2lvbnMsXG4gICAgICBzaXplOiBmaW5hbFNpemVcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBwcm9jZXNzZWRJbWFnZSxcbiAgICAgIG9yaWdpbmFsTWV0YWRhdGEsXG4gICAgICBmaW5hbE1ldGFkYXRhLFxuICAgICAgcHJvY2Vzc2luZ01ldGFkYXRhOiB7XG4gICAgICAgIHdhc1Jlc2l6ZWQsXG4gICAgICAgIHdhc0NvbXByZXNzZWQsXG4gICAgICAgIHdhc0Zvcm1hdENvbnZlcnRlZCxcbiAgICAgICAgd2FzU2hhcnBlbmVkLFxuICAgICAgICBoYWROb2lzZVJlZHVjdGlvbixcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogb3JpZ2luYWxNZXRhZGF0YS5zaXplIC8gZmluYWxTaXplLFxuICAgICAgICBwcm9jZXNzaW5nVGltZSxcbiAgICAgICAgb3BlcmF0aW9uc0FwcGxpZWRcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpbGVUeXBlTm90U3VwcG9ydGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBGaWxlVG9vTGFyZ2VFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENvbXByZXNzaW9uRmFpbGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBJbWFnZURpbWVuc2lvbkVycm9yIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgSW1hZ2VQcm9jZXNzaW5nRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoXG4gICAgICAnVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgYWR2YW5jZWQgaW1hZ2UgcHJvY2Vzc2luZycsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQmF0Y2ggcHJvY2VzcyBtdWx0aXBsZSBpbWFnZXMgd2l0aCBwcm9ncmVzcyB0cmFja2luZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ltYWdlc0luQmF0Y2goXG4gIGZpbGVzOiBGaWxlW10sXG4gIG9wdGlvbnM6IFBhcnRpYWw8QWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdPcHRpb25zPiA9IHt9LFxuICBvblByb2dyZXNzPzogKGNvbXBsZXRlZDogbnVtYmVyLCB0b3RhbDogbnVtYmVyLCBjdXJyZW50RmlsZTogc3RyaW5nKSA9PiB2b2lkXG4pOiBQcm9taXNlPEFkdmFuY2VkSW1hZ2VQcm9jZXNzaW5nUmVzdWx0W10+IHtcbiAgY29uc3QgcmVzdWx0czogQWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdSZXN1bHRbXSA9IFtdO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tpXTtcbiAgICBvblByb2dyZXNzPy4oaSwgZmlsZXMubGVuZ3RoLCBmaWxlLm5hbWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzSW1hZ2VBZHZhbmNlZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGb3IgYmF0Y2ggcHJvY2Vzc2luZywgd2UgbWlnaHQgd2FudCB0byBjb250aW51ZSB3aXRoIG90aGVyIGZpbGVzXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyAke2ZpbGUubmFtZX06YCwgZXJyb3IpO1xuICAgICAgLy8gWW91IGNvdWxkIHB1c2ggYSBmYWlsZWQgcmVzdWx0IG9yIHNraXAsIGRlcGVuZGluZyBvbiByZXF1aXJlbWVudHNcbiAgICB9XG4gIH1cbiAgXG4gIG9uUHJvZ3Jlc3M/LihmaWxlcy5sZW5ndGgsIGZpbGVzLmxlbmd0aCwgJ0NvbXBsZXRlJyk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBpbWFnZSB0aHVtYm5haWwgd2l0aCBjb25zaXN0ZW50IGRpbWVuc2lvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUltYWdlVGh1bWJuYWlsKFxuICBmaWxlOiBGaWxlLFxuICBzaXplOiBudW1iZXIgPSAxNTAsXG4gIHF1YWxpdHk6IG51bWJlciA9IDAuOFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgaW1hZ2VVcmwgPSBhd2FpdCBmaWxlVG9CYXNlNjQoZmlsZSk7XG4gIFxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkaW1lbnNpb25zIHRvIG1haW50YWluIGFzcGVjdCByYXRpb1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGltZy53aWR0aCAvIGltZy5oZWlnaHQ7XG4gICAgICAgIGxldCB3aWR0aCA9IHNpemU7XG4gICAgICAgIGxldCBoZWlnaHQgPSBzaXplO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvID4gMSkge1xuICAgICAgICAgIGhlaWdodCA9IHNpemUgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aCA9IHNpemUgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9ICdoaWdoJztcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGh1bWJuYWlsVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkpO1xuICAgICAgICByZXNvbHZlKHRodW1ibmFpbFVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIHRodW1ibmFpbCcsXG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSBmb3IgdGh1bWJuYWlsIGNyZWF0aW9uJykpO1xuICAgIH07XG4gICAgXG4gICAgaW1nLnNyYyA9IGltYWdlVXJsO1xuICB9KTtcbn0iXSwibmFtZXMiOlsiREVGQVVMVF9QUk9DRVNTSU5HX09QVElPTlMiLCJJbWFnZURpbWVuc2lvbkVycm9yIiwiSW1hZ2VGb3JtYXQiLCJJbWFnZVByb2Nlc3NpbmdFcnJvciIsImFwcGx5QXV0b0NvbG9yQ29ycmVjdGlvbiIsImFwcGx5Tm9pc2VSZWR1Y3Rpb24iLCJhcHBseVNoYXJwZW5pbmdGaWx0ZXIiLCJjb252ZXJ0SW1hZ2VGb3JtYXQiLCJjcmVhdGVJbWFnZVRodW1ibmFpbCIsImV4dHJhY3RJbWFnZU1ldGFkYXRhIiwiZ2V0QmFzZTY0U2l6ZSIsImdldEltYWdlRGltZW5zaW9ucyIsInByb2Nlc3NJbWFnZUFkdmFuY2VkIiwicHJvY2Vzc0ltYWdlRm9yVHJ5b24iLCJwcm9jZXNzSW1hZ2VzSW5CYXRjaCIsInByb2Nlc3NUcnlvbkltYWdlcyIsInJlc2l6ZUltYWdlVG8xMDI0eDE1MzYiLCJ2YWxpZGF0ZUltYWdlRGltZW5zaW9ucyIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwib3JpZ2luYWxFcnJvciIsIm5hbWUiLCJ3aWR0aCIsImhlaWdodCIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwibWF4U2l6ZUtCIiwicXVhbGl0eSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJpbWFnZVVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJvcHRpb25zIiwiY29uZmlnIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImFzcGVjdFJhdGlvIiwidGFyZ2V0QXNwZWN0UmF0aW8iLCJNYXRoIiwicm91bmQiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbWFnZVNtb290aGluZ1F1YWxpdHkiLCJkcmF3SW1hZ2UiLCJyZXNpemVkSW1hZ2VVcmwiLCJ0b0RhdGFVUkwiLCJlcnJvciIsIlN0cmluZyIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJkaW1lbnNpb25zIiwiYmFzZTY0IiwiYmFzZTY0RGF0YSIsInNwbGl0IiwiYXRvYiIsImxlbmd0aCIsImZpbGUiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiaXNJbWFnZUZpbGUiLCJGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yIiwib3JpZ2luYWxCYXNlNjQiLCJmaWxlVG9CYXNlNjQiLCJvcmlnaW5hbFNpemUiLCJzaXplIiwib3JpZ2luYWxEaW1lbnNpb25zIiwicmVzaXplZEltYWdlIiwiZmluYWxEaW1lbnNpb25zIiwicHJvY2Vzc2VkSW1hZ2UiLCJ3YXNDb21wcmVzc2VkIiwicmVzaXplZFNpemUiLCJ0YXJnZXRTaXplQnl0ZXMiLCJjb21wcmVzc0Jhc2U2NCIsImZpbmFsU2l6ZSIsInByb2Nlc3NpbmdUaW1lIiwibWV0YWRhdGEiLCJ3YXNSZXNpemVkIiwiY29tcHJlc3Npb25SYXRpbyIsIkZpbGVUb29MYXJnZUVycm9yIiwiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwibW9kZWxJbWFnZVJlc3VsdCIsImFwcGFyZWxJbWFnZVJlc3VsdHMiLCJhbGwiLCJtYXAiLCJmb3JtYXQiLCJ0eXBlIiwiZGF0ZUNyZWF0ZWQiLCJsYXN0TW9kaWZpZWQiLCJ1bmRlZmluZWQiLCJ0YXJnZXRGb3JtYXQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNvbnZlcnRlZEltYWdlVXJsIiwic3RyZW5ndGgiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwic2hhcnBlbktlcm5lbCIsIm5ld0RhdGEiLCJVaW50OENsYW1wZWRBcnJheSIsInkiLCJ4IiwiYyIsInN1bSIsImt5Iiwia3giLCJwaXhlbEluZGV4Iiwia2VybmVsSW5kZXgiLCJtYXgiLCJtaW4iLCJpIiwicHV0SW1hZ2VEYXRhIiwicmFkaXVzIiwiY2VpbCIsImNvdW50IiwiZHkiLCJkeCIsIm54IiwibnkiLCJoaXN0b2dyYW0iLCJyIiwiQXJyYXkiLCJmaWxsIiwiZyIsImIiLCJnZXRNaW5NYXgiLCJoaXN0Iiwick1pbk1heCIsImdNaW5NYXgiLCJiTWluTWF4Iiwib3BlcmF0aW9uc0FwcGxpZWQiLCJvcmlnaW5hbE1ldGFkYXRhIiwicHVzaCIsImN1cnJlbnRJbWFnZSIsIndhc0Zvcm1hdENvbnZlcnRlZCIsIm91dHB1dEZvcm1hdCIsImZpbmFsV2lkdGgiLCJmaW5hbEhlaWdodCIsIndhc1NoYXJwZW5lZCIsImVuYWJsZVNoYXJwZW5pbmciLCJoYWROb2lzZVJlZHVjdGlvbiIsIm5vaXNlUmVkdWN0aW9uIiwiYXV0b0NvbG9yQ29ycmVjdGlvbiIsInByb2Nlc3NlZFNpemUiLCJmaW5hbE1ldGFkYXRhIiwicHJvY2Vzc2luZ01ldGFkYXRhIiwiZmlsZXMiLCJvblByb2dyZXNzIiwicmVzdWx0cyIsInJlc3VsdCIsImNvbnNvbGUiLCJ0aHVtYm5haWxVcmwiXSwibWFwcGluZ3MiOiJBQUFBLGtEQUFrRDtBQUNsRCxrRUFBa0U7Ozs7Ozs7Ozs7OztJQXdEckRBLDBCQUEwQjtlQUExQkE7O0lBMUJBQyxtQkFBbUI7ZUFBbkJBOztJQXFDREMsV0FBVztlQUFYQTs7SUEvQ0NDLG9CQUFvQjtlQUFwQkE7O0lBMmhCR0Msd0JBQXdCO2VBQXhCQTs7SUFsREFDLG1CQUFtQjtlQUFuQkE7O0lBN0NBQyxxQkFBcUI7ZUFBckJBOztJQW5ETUMsa0JBQWtCO2VBQWxCQTs7SUFtWEFDLG9CQUFvQjtlQUFwQkE7O0lBcFlBQyxvQkFBb0I7ZUFBcEJBOztJQTdHTkMsYUFBYTtlQUFiQTs7SUExSEFDLGtCQUFrQjtlQUFsQkE7O0lBOGJNQyxvQkFBb0I7ZUFBcEJBOztJQXhUQUMsb0JBQW9CO2VBQXBCQTs7SUF5Y0FDLG9CQUFvQjtlQUFwQkE7O0lBallBQyxrQkFBa0I7ZUFBbEJBOztJQXRMTkMsc0JBQXNCO2VBQXRCQTs7SUFxRU1DLHVCQUF1QjtlQUF2QkE7Ozt1QkF4UGY7QUFVQSxNQUFNZCw2QkFBNkJlO0lBQ3hDQyxZQUFZQyxPQUFlLEVBQUUsQUFBZ0JDLGFBQXFCLENBQUU7UUFDbEUsS0FBSyxDQUFDRCxlQURxQ0MsZ0JBQUFBO1FBRTNDLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUtPLE1BQU1yQiw0QkFBNEJpQjtJQUN2Q0MsWUFBWUMsT0FBZSxFQUFFLEFBQWdCRyxLQUFjLEVBQUUsQUFBZ0JDLE1BQWUsQ0FBRTtRQUM1RixLQUFLLENBQUNKLGVBRHFDRyxRQUFBQSxZQUFnQ0MsU0FBQUE7UUFFM0UsSUFBSSxDQUFDRixJQUFJLEdBQUc7SUFDZDtBQUNGO0FBcUJPLE1BQU10Qiw2QkFBK0Q7SUFDMUV5QixhQUFhO0lBQ2JD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