a52c08871840362ccfa4fca4a93b2fa4
/**
 * Unit tests for OpenAI Client Wrapper
 * 
 * Tests the generateTryOn function with mocked OpenAI SDK to ensure:
 * - Happy path scenarios work correctly
 * - Error scenarios are properly handled
 * - Correct parameters are passed to the SDK
 * - Full branch and line coverage is achieved
 */ "use strict";
// Mock getEnv first
jest.mock('../../src/lib/getEnv', ()=>({
        getEnv: jest.fn(()=>({
                key: 'test-api-key',
                model: 'dall-e-2'
            }))
    }));
// Mock OpenAI SDK
jest.mock('openai', ()=>{
    const mockImagesEdit = jest.fn();
    return jest.fn().mockImplementation(()=>({
            images: {
                edit: mockImagesEdit
            }
        }));
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _openaiClient = require("../../src/lib/openaiClient");
describe('openaiClient', ()=>{
    const validBase64Image = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    const validDataUrlImage = `data:image/png;base64,${validBase64Image}`;
    // Get the mock function from the mocked module
    const getMockImagesEdit = ()=>{
        const OpenAI = require('openai');
        const mockInstance = new OpenAI();
        return mockInstance.images.edit;
    };
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('generateTryOn', ()=>{
        describe('Happy Path Scenarios', ()=>{
            it('should resolve base64 URL when SDK returns b64_json data', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: 'ZmFrZUJhc2U2NA=='
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act
                const result = await (0, _openaiClient.generateTryOn)(params);
                // Assert
                expect(result).toBe('ZmFrZUJhc2U2NA==');
                expect(mockImagesEdit).toHaveBeenCalledTimes(1);
            });
            it('should handle data URL format for model image', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: 'ZmFrZUJhc2U2NA=='
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validDataUrlImage,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act
                const result = await (0, _openaiClient.generateTryOn)(params);
                // Assert
                expect(result).toBe('ZmFrZUJhc2U2NA==');
                expect(mockImagesEdit).toHaveBeenCalledWith(expect.objectContaining({
                    model: 'dall-e-2',
                    image: expect.arrayContaining([
                        expect.any(File),
                        expect.any(File)
                    ]),
                    prompt: 'Change the garment of the model in the first image with the garment from the second image.',
                    n: 1,
                    size: '1024x1024',
                    quality: 'low'
                }));
            });
            it('should handle data URL format for apparel images', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: 'ZmFrZUJhc2U2NA=='
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validDataUrlImage
                    ]
                };
                // Act
                const result = await (0, _openaiClient.generateTryOn)(params);
                // Assert
                expect(result).toBe('ZmFrZUJhc2U2NA==');
                expect(mockImagesEdit).toHaveBeenCalledWith(expect.objectContaining({
                    image: expect.arrayContaining([
                        expect.any(File),
                        expect.any(File)
                    ])
                }));
            });
            it('should use only the first apparel image when multiple are provided', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: 'ZmFrZUJhc2U2NA=='
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image,
                        validBase64Image,
                        validBase64Image
                    ]
                };
                // Act
                const result = await (0, _openaiClient.generateTryOn)(params);
                // Assert
                expect(result).toBe('ZmFrZUJhc2U2NA==');
                expect(mockImagesEdit).toHaveBeenCalledWith(expect.objectContaining({
                    image: expect.arrayContaining([
                        expect.any(File),
                        expect.any(File) // apparel.png (only first one)
                    ])
                }));
                // Verify only 2 files are passed (model + first apparel)
                const callArgs = mockImagesEdit.mock.calls[0][0];
                expect(callArgs.image).toHaveLength(2);
                expect(callArgs.image[0].name).toBe('model.png');
                expect(callArgs.image[1].name).toBe('apparel.png');
            });
            it('should pass correct parameters to OpenAI SDK', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: 'ZmFrZUJhc2U2NA=='
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act
                await (0, _openaiClient.generateTryOn)(params);
                // Assert
                expect(mockImagesEdit).toHaveBeenCalledWith({
                    model: 'dall-e-2',
                    image: expect.arrayContaining([
                        expect.any(File),
                        expect.any(File)
                    ]),
                    prompt: 'Change the garment of the model in the first image with the garment from the second image.',
                    n: 1,
                    size: '1024x1024',
                    quality: 'low'
                });
            });
        });
        describe('Error Scenarios', ()=>{
            it('should propagate SDK rejection with custom error context', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const sdkError = new Error('OpenAI API error');
                mockImagesEdit.mockRejectedValueOnce(sdkError);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow('generateTryOn failed: OpenAI API error');
                // Verify the original error is preserved as cause
                try {
                    await (0, _openaiClient.generateTryOn)(params);
                } catch (error) {
                    expect(error.cause).toBe(sdkError);
                }
            });
            it('should handle SDK returning empty data array', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: []
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow('generateTryOn failed: No response data received from OpenAI API');
            });
            it('should handle SDK returning data without b64_json', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            url: 'https://example.com/image.png'
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow('generateTryOn failed: No image data received from OpenAI API');
            });
            it('should handle SDK returning null/undefined data', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: null
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow('generateTryOn failed: No response data received from OpenAI API');
            });
            it('should handle SDK returning data with null b64_json', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: null
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow('generateTryOn failed: No image data received from OpenAI API');
            });
            it('should handle non-Error objects thrown by SDK', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const nonError = 'String error';
                mockImagesEdit.mockRejectedValueOnce(nonError);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow('generateTryOn failed: Unknown error occurred');
            });
        });
        describe('Input Validation', ()=>{
            it('should reject invalid model image format', async ()=>{
                // Arrange
                const params = {
                    modelImage: 'invalid-base64!@#',
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow();
            });
            it('should reject empty apparel images array', async ()=>{
                // Arrange
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: []
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow();
            });
            it('should reject invalid apparel image format', async ()=>{
                // Arrange
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        'invalid-base64!@#'
                    ]
                };
                // Act & Assert
                await expect((0, _openaiClient.generateTryOn)(params)).rejects.toThrow();
            });
        });
        describe('File Object Creation', ()=>{
            it('should create File objects with correct names and types', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: 'ZmFrZUJhc2U2NA=='
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validBase64Image,
                    apparelImages: [
                        validBase64Image
                    ]
                };
                // Act
                await (0, _openaiClient.generateTryOn)(params);
                // Assert
                const callArgs = mockImagesEdit.mock.calls[0][0];
                const [modelFile, apparelFile] = callArgs.image;
                expect(modelFile).toBeInstanceOf(File);
                expect(apparelFile).toBeInstanceOf(File);
                expect(modelFile.name).toBe('model.png');
                expect(apparelFile.name).toBe('apparel.png');
                expect(modelFile.type).toBe('image/png');
                expect(apparelFile.type).toBe('image/png');
            });
            it('should handle base64 strings with and without data URL prefix', async ()=>{
                // Arrange
                const mockImagesEdit = getMockImagesEdit();
                const mockResponse = {
                    data: [
                        {
                            b64_json: 'ZmFrZUJhc2U2NA=='
                        }
                    ]
                };
                mockImagesEdit.mockResolvedValue(mockResponse);
                const params = {
                    modelImage: validDataUrlImage,
                    apparelImages: [
                        validBase64Image
                    ] // without data URL prefix
                };
                // Act
                await (0, _openaiClient.generateTryOn)(params);
                // Assert - should work with both formats
                expect(mockImagesEdit).toHaveBeenCalledTimes(1);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2xpYi9vcGVuYWlDbGllbnQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaXQgdGVzdHMgZm9yIE9wZW5BSSBDbGllbnQgV3JhcHBlclxuICogXG4gKiBUZXN0cyB0aGUgZ2VuZXJhdGVUcnlPbiBmdW5jdGlvbiB3aXRoIG1vY2tlZCBPcGVuQUkgU0RLIHRvIGVuc3VyZTpcbiAqIC0gSGFwcHkgcGF0aCBzY2VuYXJpb3Mgd29yayBjb3JyZWN0bHlcbiAqIC0gRXJyb3Igc2NlbmFyaW9zIGFyZSBwcm9wZXJseSBoYW5kbGVkXG4gKiAtIENvcnJlY3QgcGFyYW1ldGVycyBhcmUgcGFzc2VkIHRvIHRoZSBTREtcbiAqIC0gRnVsbCBicmFuY2ggYW5kIGxpbmUgY292ZXJhZ2UgaXMgYWNoaWV2ZWRcbiAqL1xuXG5pbXBvcnQgeyBab2RFcnJvciB9IGZyb20gJ3pvZCc7XG5cbi8vIE1vY2sgZ2V0RW52IGZpcnN0XG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9saWIvZ2V0RW52JywgKCkgPT4gKHtcbiAgZ2V0RW52OiBqZXN0LmZuKCgpID0+ICh7XG4gICAga2V5OiAndGVzdC1hcGkta2V5JyxcbiAgICBtb2RlbDogJ2RhbGwtZS0yJ1xuICB9KSlcbn0pKTtcblxuLy8gTW9jayBPcGVuQUkgU0RLXG5qZXN0Lm1vY2soJ29wZW5haScsICgpID0+IHtcbiAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBqZXN0LmZuKCk7XG4gIHJldHVybiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgaW1hZ2VzOiB7XG4gICAgICBlZGl0OiBtb2NrSW1hZ2VzRWRpdFxuICAgIH1cbiAgfSkpO1xufSk7XG5cbi8vIEltcG9ydCBhZnRlciBtb2NrcyBhcmUgc2V0IHVwXG5pbXBvcnQgeyBnZW5lcmF0ZVRyeU9uIH0gZnJvbSAnLi4vLi4vc3JjL2xpYi9vcGVuYWlDbGllbnQnO1xuXG5kZXNjcmliZSgnb3BlbmFpQ2xpZW50JywgKCkgPT4ge1xuICBjb25zdCB2YWxpZEJhc2U2NEltYWdlID0gJ2lWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlI0Mm1Oa1lQaGZEd0FDaHdHQTYwZTZrZ0FBQUFCSlJVNUVya0pnZ2c9PSc7XG4gIGNvbnN0IHZhbGlkRGF0YVVybEltYWdlID0gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwke3ZhbGlkQmFzZTY0SW1hZ2V9YDtcbiAgXG4gIC8vIEdldCB0aGUgbW9jayBmdW5jdGlvbiBmcm9tIHRoZSBtb2NrZWQgbW9kdWxlXG4gIGNvbnN0IGdldE1vY2tJbWFnZXNFZGl0ID0gKCkgPT4ge1xuICAgIGNvbnN0IE9wZW5BSSA9IHJlcXVpcmUoJ29wZW5haScpO1xuICAgIGNvbnN0IG1vY2tJbnN0YW5jZSA9IG5ldyBPcGVuQUkoKTtcbiAgICByZXR1cm4gbW9ja0luc3RhbmNlLmltYWdlcy5lZGl0O1xuICB9O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2VuZXJhdGVUcnlPbicsICgpID0+IHtcbiAgICBkZXNjcmliZSgnSGFwcHkgUGF0aCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHJlc29sdmUgYmFzZTY0IFVSTCB3aGVuIFNESyByZXR1cm5zIGI2NF9qc29uIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgICAgZGF0YTogW3sgYjY0X2pzb246ICdabUZyWlVKaGMyVTJOQT09JyB9XVxuICAgICAgICB9O1xuICAgICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVzcG9uc2UpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWN0XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcblxuICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnWm1GclpVSmhjMlUyTkE9PScpO1xuICAgICAgICBleHBlY3QobW9ja0ltYWdlc0VkaXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhIFVSTCBmb3JtYXQgZm9yIG1vZGVsIGltYWdlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICAgIGRhdGE6IFt7IGI2NF9qc29uOiAnWm1GclpVSmhjMlUyTkE9PScgfV1cbiAgICAgICAgfTtcbiAgICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Jlc3BvbnNlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBtb2RlbEltYWdlOiB2YWxpZERhdGFVcmxJbWFnZSxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZV1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3RcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2VuZXJhdGVUcnlPbihwYXJhbXMpO1xuXG4gICAgICAgIC8vIEFzc2VydFxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdabUZyWlVKaGMyVTJOQT09Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgbW9kZWw6ICdkYWxsLWUtMicsXG4gICAgICAgICAgICBpbWFnZTogZXhwZWN0LmFycmF5Q29udGFpbmluZyhbXG4gICAgICAgICAgICAgIGV4cGVjdC5hbnkoRmlsZSksXG4gICAgICAgICAgICAgIGV4cGVjdC5hbnkoRmlsZSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgcHJvbXB0OiAnQ2hhbmdlIHRoZSBnYXJtZW50IG9mIHRoZSBtb2RlbCBpbiB0aGUgZmlyc3QgaW1hZ2Ugd2l0aCB0aGUgZ2FybWVudCBmcm9tIHRoZSBzZWNvbmQgaW1hZ2UuJyxcbiAgICAgICAgICAgIG46IDEsXG4gICAgICAgICAgICBzaXplOiAnMTAyNHgxMDI0JyxcbiAgICAgICAgICAgIHF1YWxpdHk6ICdsb3cnXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhIFVSTCBmb3JtYXQgZm9yIGFwcGFyZWwgaW1hZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICAgIGRhdGE6IFt7IGI2NF9qc29uOiAnWm1GclpVSmhjMlUyTkE9PScgfV1cbiAgICAgICAgfTtcbiAgICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Jlc3BvbnNlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFt2YWxpZERhdGFVcmxJbWFnZV1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3RcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2VuZXJhdGVUcnlPbihwYXJhbXMpO1xuXG4gICAgICAgIC8vIEFzc2VydFxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdabUZyWlVKaGMyVTJOQT09Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgaW1hZ2U6IGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICAgICAgICAgICBleHBlY3QuYW55KEZpbGUpLFxuICAgICAgICAgICAgICBleHBlY3QuYW55KEZpbGUpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB1c2Ugb25seSB0aGUgZmlyc3QgYXBwYXJlbCBpbWFnZSB3aGVuIG11bHRpcGxlIGFyZSBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICAgICAgICBkYXRhOiBbeyBiNjRfanNvbjogJ1ptRnJaVUpoYzJVMk5BPT0nIH1dXG4gICAgICAgIH07XG4gICAgICAgIG1vY2tJbWFnZXNFZGl0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tSZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZSwgdmFsaWRCYXNlNjRJbWFnZSwgdmFsaWRCYXNlNjRJbWFnZV1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3RcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2VuZXJhdGVUcnlPbihwYXJhbXMpO1xuXG4gICAgICAgIC8vIEFzc2VydFxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdabUZyWlVKaGMyVTJOQT09Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgaW1hZ2U6IGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICAgICAgICAgICBleHBlY3QuYW55KEZpbGUpLCAvLyBtb2RlbC5wbmdcbiAgICAgICAgICAgICAgZXhwZWN0LmFueShGaWxlKSAgLy8gYXBwYXJlbC5wbmcgKG9ubHkgZmlyc3Qgb25lKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IG9ubHkgMiBmaWxlcyBhcmUgcGFzc2VkIChtb2RlbCArIGZpcnN0IGFwcGFyZWwpXG4gICAgICAgIGNvbnN0IGNhbGxBcmdzID0gbW9ja0ltYWdlc0VkaXQubW9jay5jYWxsc1swXVswXTtcbiAgICAgICAgZXhwZWN0KGNhbGxBcmdzLmltYWdlKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICAgIGV4cGVjdChjYWxsQXJncy5pbWFnZVswXS5uYW1lKS50b0JlKCdtb2RlbC5wbmcnKTtcbiAgICAgICAgZXhwZWN0KGNhbGxBcmdzLmltYWdlWzFdLm5hbWUpLnRvQmUoJ2FwcGFyZWwucG5nJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBwYXNzIGNvcnJlY3QgcGFyYW1ldGVycyB0byBPcGVuQUkgU0RLJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICAgIGRhdGE6IFt7IGI2NF9qc29uOiAnWm1GclpVSmhjMlUyTkE9PScgfV1cbiAgICAgICAgfTtcbiAgICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Jlc3BvbnNlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFt2YWxpZEJhc2U2NEltYWdlXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjdFxuICAgICAgICBhd2FpdCBnZW5lcmF0ZVRyeU9uKHBhcmFtcyk7XG5cbiAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIG1vZGVsOiAnZGFsbC1lLTInLFxuICAgICAgICAgIGltYWdlOiBleHBlY3QuYXJyYXlDb250YWluaW5nKFtcbiAgICAgICAgICAgIGV4cGVjdC5hbnkoRmlsZSksXG4gICAgICAgICAgICBleHBlY3QuYW55KEZpbGUpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcHJvbXB0OiAnQ2hhbmdlIHRoZSBnYXJtZW50IG9mIHRoZSBtb2RlbCBpbiB0aGUgZmlyc3QgaW1hZ2Ugd2l0aCB0aGUgZ2FybWVudCBmcm9tIHRoZSBzZWNvbmQgaW1hZ2UuJyxcbiAgICAgICAgICBuOiAxLFxuICAgICAgICAgIHNpemU6ICcxMDI0eDEwMjQnLFxuICAgICAgICAgIHF1YWxpdHk6ICdsb3cnXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnRXJyb3IgU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBwcm9wYWdhdGUgU0RLIHJlamVjdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBjb250ZXh0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3Qgc2RrRXJyb3IgPSBuZXcgRXJyb3IoJ09wZW5BSSBBUEkgZXJyb3InKTtcbiAgICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1JlamVjdGVkVmFsdWVPbmNlKHNka0Vycm9yKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFt2YWxpZEJhc2U2NEltYWdlXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgICBhd2FpdCBleHBlY3QoZ2VuZXJhdGVUcnlPbihwYXJhbXMpKS5yZWplY3RzLnRvVGhyb3coJ2dlbmVyYXRlVHJ5T24gZmFpbGVkOiBPcGVuQUkgQVBJIGVycm9yJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgdGhlIG9yaWdpbmFsIGVycm9yIGlzIHByZXNlcnZlZCBhcyBjYXVzZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBleHBlY3QoKGVycm9yIGFzIEVycm9yICYgeyBjYXVzZT86IHVua25vd24gfSkuY2F1c2UpLnRvQmUoc2RrRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgU0RLIHJldHVybmluZyBlbXB0eSBkYXRhIGFycmF5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0geyBkYXRhOiBbXSB9O1xuICAgICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVzcG9uc2UpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICAgIGF3YWl0IGV4cGVjdChnZW5lcmF0ZVRyeU9uKHBhcmFtcykpLnJlamVjdHMudG9UaHJvdygnZ2VuZXJhdGVUcnlPbiBmYWlsZWQ6IE5vIHJlc3BvbnNlIGRhdGEgcmVjZWl2ZWQgZnJvbSBPcGVuQUkgQVBJJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgU0RLIHJldHVybmluZyBkYXRhIHdpdGhvdXQgYjY0X2pzb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7IGRhdGE6IFt7IHVybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vaW1hZ2UucG5nJyB9XSB9O1xuICAgICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVzcG9uc2UpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICAgIGF3YWl0IGV4cGVjdChnZW5lcmF0ZVRyeU9uKHBhcmFtcykpLnJlamVjdHMudG9UaHJvdygnZ2VuZXJhdGVUcnlPbiBmYWlsZWQ6IE5vIGltYWdlIGRhdGEgcmVjZWl2ZWQgZnJvbSBPcGVuQUkgQVBJJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgU0RLIHJldHVybmluZyBudWxsL3VuZGVmaW5lZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0geyBkYXRhOiBudWxsIH07XG4gICAgICAgIG1vY2tJbWFnZXNFZGl0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tSZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZV1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgICAgYXdhaXQgZXhwZWN0KGdlbmVyYXRlVHJ5T24ocGFyYW1zKSkucmVqZWN0cy50b1Rocm93KCdnZW5lcmF0ZVRyeU9uIGZhaWxlZDogTm8gcmVzcG9uc2UgZGF0YSByZWNlaXZlZCBmcm9tIE9wZW5BSSBBUEknKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBTREsgcmV0dXJuaW5nIGRhdGEgd2l0aCBudWxsIGI2NF9qc29uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0geyBkYXRhOiBbeyBiNjRfanNvbjogbnVsbCB9XSB9O1xuICAgICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVzcG9uc2UpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICAgIGF3YWl0IGV4cGVjdChnZW5lcmF0ZVRyeU9uKHBhcmFtcykpLnJlamVjdHMudG9UaHJvdygnZ2VuZXJhdGVUcnlPbiBmYWlsZWQ6IE5vIGltYWdlIGRhdGEgcmVjZWl2ZWQgZnJvbSBPcGVuQUkgQVBJJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm9uLUVycm9yIG9iamVjdHMgdGhyb3duIGJ5IFNESycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICAgIGNvbnN0IG5vbkVycm9yID0gJ1N0cmluZyBlcnJvcic7XG4gICAgICAgIG1vY2tJbWFnZXNFZGl0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShub25FcnJvcik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZV1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgICAgYXdhaXQgZXhwZWN0KGdlbmVyYXRlVHJ5T24ocGFyYW1zKSkucmVqZWN0cy50b1Rocm93KCdnZW5lcmF0ZVRyeU9uIGZhaWxlZDogVW5rbm93biBlcnJvciBvY2N1cnJlZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnSW5wdXQgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgbW9kZWwgaW1hZ2UgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBtb2RlbEltYWdlOiAnaW52YWxpZC1iYXNlNjQhQCMnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFt2YWxpZEJhc2U2NEltYWdlXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgICBhd2FpdCBleHBlY3QoZ2VuZXJhdGVUcnlPbihwYXJhbXMpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBlbXB0eSBhcHBhcmVsIGltYWdlcyBhcnJheScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgICBhd2FpdCBleHBlY3QoZ2VuZXJhdGVUcnlPbihwYXJhbXMpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGFwcGFyZWwgaW1hZ2UgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnaW52YWxpZC1iYXNlNjQhQCMnXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgICBhd2FpdCBleHBlY3QoZ2VuZXJhdGVUcnlPbihwYXJhbXMpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0ZpbGUgT2JqZWN0IENyZWF0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgRmlsZSBvYmplY3RzIHdpdGggY29ycmVjdCBuYW1lcyBhbmQgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgICAgZGF0YTogW3sgYjY0X2pzb246ICdabUZyWlVKaGMyVTJOQT09JyB9XVxuICAgICAgICB9O1xuICAgICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVzcG9uc2UpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWN0XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcblxuICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgY29uc3QgY2FsbEFyZ3MgPSBtb2NrSW1hZ2VzRWRpdC5tb2NrLmNhbGxzWzBdWzBdO1xuICAgICAgICBjb25zdCBbbW9kZWxGaWxlLCBhcHBhcmVsRmlsZV0gPSBjYWxsQXJncy5pbWFnZTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChtb2RlbEZpbGUpLnRvQmVJbnN0YW5jZU9mKEZpbGUpO1xuICAgICAgICBleHBlY3QoYXBwYXJlbEZpbGUpLnRvQmVJbnN0YW5jZU9mKEZpbGUpO1xuICAgICAgICBleHBlY3QobW9kZWxGaWxlLm5hbWUpLnRvQmUoJ21vZGVsLnBuZycpO1xuICAgICAgICBleHBlY3QoYXBwYXJlbEZpbGUubmFtZSkudG9CZSgnYXBwYXJlbC5wbmcnKTtcbiAgICAgICAgZXhwZWN0KG1vZGVsRmlsZS50eXBlKS50b0JlKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgZXhwZWN0KGFwcGFyZWxGaWxlLnR5cGUpLnRvQmUoJ2ltYWdlL3BuZycpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGJhc2U2NCBzdHJpbmdzIHdpdGggYW5kIHdpdGhvdXQgZGF0YSBVUkwgcHJlZml4JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICAgIGRhdGE6IFt7IGI2NF9qc29uOiAnWm1GclpVSmhjMlUyTkE9PScgfV1cbiAgICAgICAgfTtcbiAgICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Jlc3BvbnNlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBtb2RlbEltYWdlOiB2YWxpZERhdGFVcmxJbWFnZSwgLy8gd2l0aCBkYXRhIFVSTCBwcmVmaXhcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZV0gLy8gd2l0aG91dCBkYXRhIFVSTCBwcmVmaXhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3RcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVUcnlPbihwYXJhbXMpO1xuXG4gICAgICAgIC8vIEFzc2VydCAtIHNob3VsZCB3b3JrIHdpdGggYm90aCBmb3JtYXRzXG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJnZXRFbnYiLCJmbiIsImtleSIsIm1vZGVsIiwibW9ja0ltYWdlc0VkaXQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJpbWFnZXMiLCJlZGl0IiwiZGVzY3JpYmUiLCJ2YWxpZEJhc2U2NEltYWdlIiwidmFsaWREYXRhVXJsSW1hZ2UiLCJnZXRNb2NrSW1hZ2VzRWRpdCIsIk9wZW5BSSIsInJlcXVpcmUiLCJtb2NrSW5zdGFuY2UiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwibW9ja1Jlc3BvbnNlIiwiZGF0YSIsImI2NF9qc29uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJwYXJhbXMiLCJtb2RlbEltYWdlIiwiYXBwYXJlbEltYWdlcyIsInJlc3VsdCIsImdlbmVyYXRlVHJ5T24iLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwiaW1hZ2UiLCJhcnJheUNvbnRhaW5pbmciLCJhbnkiLCJGaWxlIiwicHJvbXB0IiwibiIsInNpemUiLCJxdWFsaXR5IiwiY2FsbEFyZ3MiLCJjYWxscyIsInRvSGF2ZUxlbmd0aCIsIm5hbWUiLCJzZGtFcnJvciIsIkVycm9yIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJlcnJvciIsImNhdXNlIiwidXJsIiwibm9uRXJyb3IiLCJtb2RlbEZpbGUiLCJhcHBhcmVsRmlsZSIsInRvQmVJbnN0YW5jZU9mIiwidHlwZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUM7QUFJRCxvQkFBb0I7QUFDcEJBLEtBQUtDLElBQUksQ0FBQyx3QkFBd0IsSUFBTyxDQUFBO1FBQ3ZDQyxRQUFRRixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO2dCQUNyQkMsS0FBSztnQkFDTEMsT0FBTztZQUNULENBQUE7SUFDRixDQUFBO0FBRUEsa0JBQWtCO0FBQ2xC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