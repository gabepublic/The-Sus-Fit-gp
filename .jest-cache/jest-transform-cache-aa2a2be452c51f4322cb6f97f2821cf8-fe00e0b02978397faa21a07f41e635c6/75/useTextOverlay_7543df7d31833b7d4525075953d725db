044ef9b6e50b110dbf14fde66c758059
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useInteractiveTextEditor: function() {
        return useInteractiveTextEditor;
    },
    useTextOverlay: function() {
        return useTextOverlay;
    },
    useTextPresets: function() {
        return useTextPresets;
    }
});
const _react = require("react");
const _CanvasProvider = require("../providers/CanvasProvider");
const _textOverlay = require("../utils/textOverlay");
function useTextOverlay(canvasWidth, canvasHeight, canvasId) {
    const canvas = (0, _CanvasProvider.useManagedCanvas)(canvasWidth, canvasHeight, canvasId);
    const [state, setState] = (0, _react.useState)({
        overlays: [],
        activeOverlayId: null,
        isEditing: false
    });
    const rendererRef = (0, _react.useRef)((0, _textOverlay.createTextOverlayRenderer)(canvas));
    const generateId = (0, _react.useCallback)(()=>{
        return `text-overlay-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }, []);
    const addTextOverlay = (0, _react.useCallback)((config)=>{
        const id = generateId();
        const now = new Date();
        const newOverlay = {
            id,
            config: config,
            visible: true,
            locked: false,
            createdAt: now,
            updatedAt: now
        };
        setState((prev)=>({
                ...prev,
                overlays: [
                    ...prev.overlays,
                    newOverlay
                ],
                activeOverlayId: id
            }));
        return id;
    }, [
        generateId
    ]);
    const updateTextOverlay = (0, _react.useCallback)((id, configUpdate)=>{
        setState((prev)=>({
                ...prev,
                overlays: prev.overlays.map((overlay)=>overlay.id === id ? {
                        ...overlay,
                        config: {
                            ...overlay.config,
                            ...configUpdate
                        },
                        updatedAt: new Date()
                    } : overlay)
            }));
    }, []);
    const removeTextOverlay = (0, _react.useCallback)((id)=>{
        setState((prev)=>({
                ...prev,
                overlays: prev.overlays.filter((overlay)=>overlay.id !== id),
                activeOverlayId: prev.activeOverlayId === id ? null : prev.activeOverlayId
            }));
    }, []);
    const setActiveOverlay = (0, _react.useCallback)((id)=>{
        setState((prev)=>({
                ...prev,
                activeOverlayId: id
            }));
    }, []);
    const setOverlayVisibility = (0, _react.useCallback)((id, visible)=>{
        setState((prev)=>({
                ...prev,
                overlays: prev.overlays.map((overlay)=>overlay.id === id ? {
                        ...overlay,
                        visible,
                        updatedAt: new Date()
                    } : overlay)
            }));
    }, []);
    const setOverlayLocked = (0, _react.useCallback)((id, locked)=>{
        setState((prev)=>({
                ...prev,
                overlays: prev.overlays.map((overlay)=>overlay.id === id ? {
                        ...overlay,
                        locked,
                        updatedAt: new Date()
                    } : overlay)
            }));
    }, []);
    const renderAllOverlays = (0, _react.useCallback)(()=>{
        // Clear previous overlays
        canvas.context.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);
        // Render visible overlays in order
        const visibleOverlays = state.overlays.filter((overlay)=>overlay.visible).sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());
        visibleOverlays.forEach((overlay)=>{
            const measurement = rendererRef.current.renderText(overlay.config);
            // Update overlay with measurement
            setState((prev)=>({
                    ...prev,
                    overlays: prev.overlays.map((o)=>o.id === overlay.id ? {
                            ...o,
                            measurement
                        } : o)
                }));
        });
    }, [
        canvas,
        state.overlays
    ]);
    const clearAllOverlays = (0, _react.useCallback)(()=>{
        canvas.context.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);
        setState((prev)=>({
                ...prev,
                overlays: [],
                activeOverlayId: null
            }));
    }, [
        canvas
    ]);
    const getOverlayById = (0, _react.useCallback)((id)=>{
        return state.overlays.find((overlay)=>overlay.id === id);
    }, [
        state.overlays
    ]);
    const duplicateOverlay = (0, _react.useCallback)((id)=>{
        const overlay = getOverlayById(id);
        if (!overlay) return null;
        const newId = generateId();
        const now = new Date();
        // Offset position slightly
        const newConfig = {
            ...overlay.config,
            position: {
                ...overlay.config.position,
                x: overlay.config.position.x + 20,
                y: overlay.config.position.y + 20
            }
        };
        const duplicatedOverlay = {
            id: newId,
            config: newConfig,
            visible: true,
            locked: false,
            createdAt: now,
            updatedAt: now
        };
        setState((prev)=>({
                ...prev,
                overlays: [
                    ...prev.overlays,
                    duplicatedOverlay
                ],
                activeOverlayId: newId
            }));
        return newId;
    }, [
        getOverlayById,
        generateId
    ]);
    const moveOverlay = (0, _react.useCallback)((id, newPosition)=>{
        setState((prev)=>({
                ...prev,
                overlays: prev.overlays.map((overlay)=>overlay.id === id ? {
                        ...overlay,
                        config: {
                            ...overlay.config,
                            position: {
                                ...overlay.config.position,
                                ...newPosition
                            }
                        },
                        updatedAt: new Date()
                    } : overlay)
            }));
    }, []);
    const exportOverlays = (0, _react.useCallback)(()=>{
        return JSON.parse(JSON.stringify(state.overlays));
    }, [
        state.overlays
    ]);
    const importOverlays = (0, _react.useCallback)((overlays)=>{
        setState((prev)=>({
                ...prev,
                overlays: overlays.map((overlay)=>({
                        ...overlay,
                        id: generateId(),
                        createdAt: new Date(overlay.createdAt),
                        updatedAt: new Date(overlay.updatedAt)
                    })),
                activeOverlayId: null
            }));
    }, [
        generateId
    ]);
    const startEditing = (0, _react.useCallback)(()=>{
        setState((prev)=>({
                ...prev,
                isEditing: true
            }));
    }, []);
    const stopEditing = (0, _react.useCallback)(()=>{
        setState((prev)=>({
                ...prev,
                isEditing: false
            }));
    }, []);
    return {
        canvas,
        renderer: rendererRef.current,
        overlays: state.overlays,
        activeOverlayId: state.activeOverlayId,
        isEditing: state.isEditing,
        addTextOverlay,
        updateTextOverlay,
        removeTextOverlay,
        setActiveOverlay,
        setOverlayVisibility,
        setOverlayLocked,
        renderAllOverlays,
        clearAllOverlays,
        getOverlayById,
        duplicateOverlay,
        moveOverlay,
        exportOverlays,
        importOverlays,
        startEditing,
        stopEditing
    };
}
function useTextPresets() {
    const [customPresets, setCustomPresets] = (0, _react.useState)({});
    const presets = _textOverlay.TextOverlayUtils.createPresets();
    const calculateOptimalFontSize = (0, _react.useCallback)((text, maxWidth, maxHeight, style, canvas)=>{
        return _textOverlay.TextOverlayUtils.calculateOptimalFontSize(text, maxWidth, maxHeight, style, canvas);
    }, []);
    const createCustomPreset = (0, _react.useCallback)((name, style)=>{
        setCustomPresets((prev)=>({
                ...prev,
                [name]: {
                    style
                }
            }));
    }, []);
    const getCustomPresets = (0, _react.useCallback)(()=>{
        return customPresets;
    }, [
        customPresets
    ]);
    const removeCustomPreset = (0, _react.useCallback)((name)=>{
        setCustomPresets((prev)=>{
            const { [name]: removed, ...rest } = prev;
            return rest;
        });
    }, []);
    return {
        presets,
        calculateOptimalFontSize,
        createCustomPreset,
        getCustomPresets,
        removeCustomPreset
    };
}
function useInteractiveTextEditor(canvas, overlayId, onUpdate) {
    const [isEditing, setIsEditing] = (0, _react.useState)(false);
    const startEditing = (0, _react.useCallback)(()=>{
        setIsEditing(true);
    }, []);
    const stopEditing = (0, _react.useCallback)(()=>{
        setIsEditing(false);
    }, []);
    const updateText = (0, _react.useCallback)((text)=>{
        onUpdate({
            text
        });
    }, [
        onUpdate
    ]);
    const updateStyle = (0, _react.useCallback)((style)=>{
        onUpdate({
            style
        });
    }, [
        onUpdate
    ]);
    const updatePosition = (0, _react.useCallback)((position)=>{
        onUpdate({
            position: {
                x: 0,
                y: 0,
                ...position
            }
        });
    }, [
        onUpdate
    ]);
    return {
        isEditing,
        startEditing,
        stopEditing,
        updateText,
        updateStyle,
        updatePosition
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL2hvb2tzL3VzZVRleHRPdmVybGF5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuLy8gVGV4dCBPdmVybGF5IFJlYWN0IEhvb2tzXG4vLyBSZWFjdCBob29rcyBmb3IgbWFuYWdpbmcgdGV4dCBvdmVybGF5cyBvbiBjYW52YXNcblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VNYW5hZ2VkQ2FudmFzLCB0eXBlIE1hbmFnZWRDYW52YXMgfSBmcm9tICcuLi9wcm92aWRlcnMvQ2FudmFzUHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgVGV4dE92ZXJsYXlSZW5kZXJlcixcbiAgVGV4dE92ZXJsYXlVdGlscyxcbiAgY3JlYXRlVGV4dE92ZXJsYXlSZW5kZXJlcixcbiAgdHlwZSBUZXh0T3ZlcmxheUNvbmZpZyxcbiAgdHlwZSBUZXh0TWVhc3VyZW1lbnQsXG4gIHR5cGUgVGV4dFN0eWxlLFxuICB0eXBlIFRleHRQb3NpdGlvblxufSBmcm9tICcuLi91dGlscy90ZXh0T3ZlcmxheSc7XG5cbi8qKlxuICogVGV4dCBvdmVybGF5IGl0ZW0gd2l0aCB1bmlxdWUgSURcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0T3ZlcmxheUl0ZW0ge1xuICBpZDogc3RyaW5nO1xuICBjb25maWc6IFRleHRPdmVybGF5Q29uZmlnO1xuICBtZWFzdXJlbWVudD86IFRleHRNZWFzdXJlbWVudDtcbiAgdmlzaWJsZTogYm9vbGVhbjtcbiAgbG9ja2VkOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuLyoqXG4gKiBUZXh0IG92ZXJsYXkgbWFuYWdlciBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRleHRPdmVybGF5U3RhdGUge1xuICBvdmVybGF5czogVGV4dE92ZXJsYXlJdGVtW107XG4gIGFjdGl2ZU92ZXJsYXlJZDogc3RyaW5nIHwgbnVsbDtcbiAgaXNFZGl0aW5nOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIG1hbmFnaW5nIHRleHQgb3ZlcmxheXMgb24gYSBjYW52YXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVRleHRPdmVybGF5KFxuICBjYW52YXNXaWR0aDogbnVtYmVyLFxuICBjYW52YXNIZWlnaHQ6IG51bWJlcixcbiAgY2FudmFzSWQ/OiBzdHJpbmdcbik6IHtcbiAgY2FudmFzOiBNYW5hZ2VkQ2FudmFzO1xuICByZW5kZXJlcjogVGV4dE92ZXJsYXlSZW5kZXJlcjtcbiAgb3ZlcmxheXM6IFRleHRPdmVybGF5SXRlbVtdO1xuICBhY3RpdmVPdmVybGF5SWQ6IHN0cmluZyB8IG51bGw7XG4gIGlzRWRpdGluZzogYm9vbGVhbjtcbiAgYWRkVGV4dE92ZXJsYXk6IChjb25maWc6IE9taXQ8VGV4dE92ZXJsYXlDb25maWcsICd0ZXh0Jz4gJiB7IHRleHQ6IHN0cmluZyB9KSA9PiBzdHJpbmc7XG4gIHVwZGF0ZVRleHRPdmVybGF5OiAoaWQ6IHN0cmluZywgY29uZmlnOiBQYXJ0aWFsPFRleHRPdmVybGF5Q29uZmlnPikgPT4gdm9pZDtcbiAgcmVtb3ZlVGV4dE92ZXJsYXk6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRBY3RpdmVPdmVybGF5OiAoaWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldE92ZXJsYXlWaXNpYmlsaXR5OiAoaWQ6IHN0cmluZywgdmlzaWJsZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0T3ZlcmxheUxvY2tlZDogKGlkOiBzdHJpbmcsIGxvY2tlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgcmVuZGVyQWxsT3ZlcmxheXM6ICgpID0+IHZvaWQ7XG4gIGNsZWFyQWxsT3ZlcmxheXM6ICgpID0+IHZvaWQ7XG4gIGdldE92ZXJsYXlCeUlkOiAoaWQ6IHN0cmluZykgPT4gVGV4dE92ZXJsYXlJdGVtIHwgdW5kZWZpbmVkO1xuICBkdXBsaWNhdGVPdmVybGF5OiAoaWQ6IHN0cmluZykgPT4gc3RyaW5nIHwgbnVsbDtcbiAgbW92ZU92ZXJsYXk6IChpZDogc3RyaW5nLCBuZXdQb3NpdGlvbjogUGFydGlhbDxUZXh0UG9zaXRpb24+KSA9PiB2b2lkO1xuICBleHBvcnRPdmVybGF5czogKCkgPT4gVGV4dE92ZXJsYXlJdGVtW107XG4gIGltcG9ydE92ZXJsYXlzOiAob3ZlcmxheXM6IFRleHRPdmVybGF5SXRlbVtdKSA9PiB2b2lkO1xuICBzdGFydEVkaXRpbmc6ICgpID0+IHZvaWQ7XG4gIHN0b3BFZGl0aW5nOiAoKSA9PiB2b2lkO1xufSB7XG4gIGNvbnN0IGNhbnZhcyA9IHVzZU1hbmFnZWRDYW52YXMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgY2FudmFzSWQpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFRleHRPdmVybGF5U3RhdGU+KHtcbiAgICBvdmVybGF5czogW10sXG4gICAgYWN0aXZlT3ZlcmxheUlkOiBudWxsLFxuICAgIGlzRWRpdGluZzogZmFsc2VcbiAgfSk7XG5cbiAgY29uc3QgcmVuZGVyZXJSZWYgPSB1c2VSZWY8VGV4dE92ZXJsYXlSZW5kZXJlcj4oY3JlYXRlVGV4dE92ZXJsYXlSZW5kZXJlcihjYW52YXMpKTtcblxuICBjb25zdCBnZW5lcmF0ZUlkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBgdGV4dC1vdmVybGF5LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGFkZFRleHRPdmVybGF5ID0gdXNlQ2FsbGJhY2soKGNvbmZpZzogT21pdDxUZXh0T3ZlcmxheUNvbmZpZywgJ3RleHQnPiAmIHsgdGV4dDogc3RyaW5nIH0pOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgXG4gICAgY29uc3QgbmV3T3ZlcmxheTogVGV4dE92ZXJsYXlJdGVtID0ge1xuICAgICAgaWQsXG4gICAgICBjb25maWc6IGNvbmZpZyBhcyBUZXh0T3ZlcmxheUNvbmZpZyxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBsb2NrZWQ6IGZhbHNlLFxuICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICB1cGRhdGVkQXQ6IG5vd1xuICAgIH07XG5cbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgb3ZlcmxheXM6IFsuLi5wcmV2Lm92ZXJsYXlzLCBuZXdPdmVybGF5XSxcbiAgICAgIGFjdGl2ZU92ZXJsYXlJZDogaWRcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH0sIFtnZW5lcmF0ZUlkXSk7XG5cbiAgY29uc3QgdXBkYXRlVGV4dE92ZXJsYXkgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZywgY29uZmlnVXBkYXRlOiBQYXJ0aWFsPFRleHRPdmVybGF5Q29uZmlnPikgPT4ge1xuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBvdmVybGF5czogcHJldi5vdmVybGF5cy5tYXAob3ZlcmxheSA9PiBcbiAgICAgICAgb3ZlcmxheS5pZCA9PT0gaWQgXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLm92ZXJsYXksXG4gICAgICAgICAgICAgIGNvbmZpZzogeyAuLi5vdmVybGF5LmNvbmZpZywgLi4uY29uZmlnVXBkYXRlIH0sXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogb3ZlcmxheVxuICAgICAgKVxuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlbW92ZVRleHRPdmVybGF5ID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgb3ZlcmxheXM6IHByZXYub3ZlcmxheXMuZmlsdGVyKG92ZXJsYXkgPT4gb3ZlcmxheS5pZCAhPT0gaWQpLFxuICAgICAgYWN0aXZlT3ZlcmxheUlkOiBwcmV2LmFjdGl2ZU92ZXJsYXlJZCA9PT0gaWQgPyBudWxsIDogcHJldi5hY3RpdmVPdmVybGF5SWRcbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzZXRBY3RpdmVPdmVybGF5ID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBhY3RpdmVPdmVybGF5SWQ6IGlkIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE92ZXJsYXlWaXNpYmlsaXR5ID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcsIHZpc2libGU6IGJvb2xlYW4pID0+IHtcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgb3ZlcmxheXM6IHByZXYub3ZlcmxheXMubWFwKG92ZXJsYXkgPT5cbiAgICAgICAgb3ZlcmxheS5pZCA9PT0gaWQgPyB7IC4uLm92ZXJsYXksIHZpc2libGUsIHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9IDogb3ZlcmxheVxuICAgICAgKVxuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE92ZXJsYXlMb2NrZWQgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZywgbG9ja2VkOiBib29sZWFuKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIG92ZXJsYXlzOiBwcmV2Lm92ZXJsYXlzLm1hcChvdmVybGF5ID0+XG4gICAgICAgIG92ZXJsYXkuaWQgPT09IGlkID8geyAuLi5vdmVybGF5LCBsb2NrZWQsIHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9IDogb3ZlcmxheVxuICAgICAgKVxuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlbmRlckFsbE92ZXJsYXlzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIENsZWFyIHByZXZpb3VzIG92ZXJsYXlzXG4gICAgY2FudmFzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy5jYW52YXMud2lkdGgsIGNhbnZhcy5jYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vIFJlbmRlciB2aXNpYmxlIG92ZXJsYXlzIGluIG9yZGVyXG4gICAgY29uc3QgdmlzaWJsZU92ZXJsYXlzID0gc3RhdGUub3ZlcmxheXNcbiAgICAgIC5maWx0ZXIob3ZlcmxheSA9PiBvdmVybGF5LnZpc2libGUpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYi5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcblxuICAgIHZpc2libGVPdmVybGF5cy5mb3JFYWNoKG92ZXJsYXkgPT4ge1xuICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSByZW5kZXJlclJlZi5jdXJyZW50LnJlbmRlclRleHQob3ZlcmxheS5jb25maWcpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgb3ZlcmxheSB3aXRoIG1lYXN1cmVtZW50XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIG92ZXJsYXlzOiBwcmV2Lm92ZXJsYXlzLm1hcChvID0+IFxuICAgICAgICAgIG8uaWQgPT09IG92ZXJsYXkuaWQgPyB7IC4uLm8sIG1lYXN1cmVtZW50IH0gOiBvXG4gICAgICAgIClcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSwgW2NhbnZhcywgc3RhdGUub3ZlcmxheXNdKTtcblxuICBjb25zdCBjbGVhckFsbE92ZXJsYXlzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNhbnZhcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMuY2FudmFzLndpZHRoLCBjYW52YXMuY2FudmFzLmhlaWdodCk7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBvdmVybGF5czogW10sIGFjdGl2ZU92ZXJsYXlJZDogbnVsbCB9KSk7XG4gIH0sIFtjYW52YXNdKTtcblxuICBjb25zdCBnZXRPdmVybGF5QnlJZCA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKTogVGV4dE92ZXJsYXlJdGVtIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gc3RhdGUub3ZlcmxheXMuZmluZChvdmVybGF5ID0+IG92ZXJsYXkuaWQgPT09IGlkKTtcbiAgfSwgW3N0YXRlLm92ZXJsYXlzXSk7XG5cbiAgY29uc3QgZHVwbGljYXRlT3ZlcmxheSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCA9PiB7XG4gICAgY29uc3Qgb3ZlcmxheSA9IGdldE92ZXJsYXlCeUlkKGlkKTtcbiAgICBpZiAoIW92ZXJsYXkpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbmV3SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBcbiAgICAvLyBPZmZzZXQgcG9zaXRpb24gc2xpZ2h0bHlcbiAgICBjb25zdCBuZXdDb25maWcgPSB7XG4gICAgICAuLi5vdmVybGF5LmNvbmZpZyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIC4uLm92ZXJsYXkuY29uZmlnLnBvc2l0aW9uLFxuICAgICAgICB4OiBvdmVybGF5LmNvbmZpZy5wb3NpdGlvbi54ICsgMjAsXG4gICAgICAgIHk6IG92ZXJsYXkuY29uZmlnLnBvc2l0aW9uLnkgKyAyMFxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBkdXBsaWNhdGVkT3ZlcmxheTogVGV4dE92ZXJsYXlJdGVtID0ge1xuICAgICAgaWQ6IG5ld0lkLFxuICAgICAgY29uZmlnOiBuZXdDb25maWcsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgbG9ja2VkOiBmYWxzZSxcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgdXBkYXRlZEF0OiBub3dcbiAgICB9O1xuXG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIG92ZXJsYXlzOiBbLi4ucHJldi5vdmVybGF5cywgZHVwbGljYXRlZE92ZXJsYXldLFxuICAgICAgYWN0aXZlT3ZlcmxheUlkOiBuZXdJZFxuICAgIH0pKTtcblxuICAgIHJldHVybiBuZXdJZDtcbiAgfSwgW2dldE92ZXJsYXlCeUlkLCBnZW5lcmF0ZUlkXSk7XG5cbiAgY29uc3QgbW92ZU92ZXJsYXkgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZywgbmV3UG9zaXRpb246IFBhcnRpYWw8VGV4dFBvc2l0aW9uPikgPT4ge1xuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBvdmVybGF5czogcHJldi5vdmVybGF5cy5tYXAob3ZlcmxheSA9PlxuICAgICAgICBvdmVybGF5LmlkID09PSBpZFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5vdmVybGF5LFxuICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICAuLi5vdmVybGF5LmNvbmZpZyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5vdmVybGF5LmNvbmZpZy5wb3NpdGlvbiwgLi4ubmV3UG9zaXRpb24gfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IG92ZXJsYXlcbiAgICAgIClcbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBleHBvcnRPdmVybGF5cyA9IHVzZUNhbGxiYWNrKCgpOiBUZXh0T3ZlcmxheUl0ZW1bXSA9PiB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUub3ZlcmxheXMpKTtcbiAgfSwgW3N0YXRlLm92ZXJsYXlzXSk7XG5cbiAgY29uc3QgaW1wb3J0T3ZlcmxheXMgPSB1c2VDYWxsYmFjaygob3ZlcmxheXM6IFRleHRPdmVybGF5SXRlbVtdKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIG92ZXJsYXlzOiBvdmVybGF5cy5tYXAob3ZlcmxheSA9PiAoe1xuICAgICAgICAuLi5vdmVybGF5LFxuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLCAvLyBHZW5lcmF0ZSBuZXcgSURzIHRvIGF2b2lkIGNvbmZsaWN0c1xuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKG92ZXJsYXkuY3JlYXRlZEF0KSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShvdmVybGF5LnVwZGF0ZWRBdClcbiAgICAgIH0pKSxcbiAgICAgIGFjdGl2ZU92ZXJsYXlJZDogbnVsbFxuICAgIH0pKTtcbiAgfSwgW2dlbmVyYXRlSWRdKTtcblxuICBjb25zdCBzdGFydEVkaXRpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0VkaXRpbmc6IHRydWUgfSkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc3RvcEVkaXRpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0VkaXRpbmc6IGZhbHNlIH0pKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgY2FudmFzLFxuICAgIHJlbmRlcmVyOiByZW5kZXJlclJlZi5jdXJyZW50LFxuICAgIG92ZXJsYXlzOiBzdGF0ZS5vdmVybGF5cyxcbiAgICBhY3RpdmVPdmVybGF5SWQ6IHN0YXRlLmFjdGl2ZU92ZXJsYXlJZCxcbiAgICBpc0VkaXRpbmc6IHN0YXRlLmlzRWRpdGluZyxcbiAgICBhZGRUZXh0T3ZlcmxheSxcbiAgICB1cGRhdGVUZXh0T3ZlcmxheSxcbiAgICByZW1vdmVUZXh0T3ZlcmxheSxcbiAgICBzZXRBY3RpdmVPdmVybGF5LFxuICAgIHNldE92ZXJsYXlWaXNpYmlsaXR5LFxuICAgIHNldE92ZXJsYXlMb2NrZWQsXG4gICAgcmVuZGVyQWxsT3ZlcmxheXMsXG4gICAgY2xlYXJBbGxPdmVybGF5cyxcbiAgICBnZXRPdmVybGF5QnlJZCxcbiAgICBkdXBsaWNhdGVPdmVybGF5LFxuICAgIG1vdmVPdmVybGF5LFxuICAgIGV4cG9ydE92ZXJsYXlzLFxuICAgIGltcG9ydE92ZXJsYXlzLFxuICAgIHN0YXJ0RWRpdGluZyxcbiAgICBzdG9wRWRpdGluZ1xuICB9O1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIHRleHQgc3R5bGUgcHJlc2V0cyBhbmQgdXRpbGl0aWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUZXh0UHJlc2V0cygpOiB7XG4gIHByZXNldHM6IFJldHVyblR5cGU8dHlwZW9mIFRleHRPdmVybGF5VXRpbHMuY3JlYXRlUHJlc2V0cz47XG4gIGNhbGN1bGF0ZU9wdGltYWxGb250U2l6ZTogKFxuICAgIHRleHQ6IHN0cmluZyxcbiAgICBtYXhXaWR0aDogbnVtYmVyLFxuICAgIG1heEhlaWdodDogbnVtYmVyLFxuICAgIHN0eWxlOiBUZXh0U3R5bGUsXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuICApID0+IG51bWJlcjtcbiAgY3JlYXRlQ3VzdG9tUHJlc2V0OiAobmFtZTogc3RyaW5nLCBzdHlsZTogVGV4dFN0eWxlKSA9PiB2b2lkO1xuICBnZXRDdXN0b21QcmVzZXRzOiAoKSA9PiBSZWNvcmQ8c3RyaW5nLCB7IHN0eWxlOiBUZXh0U3R5bGUgfT47XG4gIHJlbW92ZUN1c3RvbVByZXNldDogKG5hbWU6IHN0cmluZykgPT4gdm9pZDtcbn0ge1xuICBjb25zdCBbY3VzdG9tUHJlc2V0cywgc2V0Q3VzdG9tUHJlc2V0c10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCB7IHN0eWxlOiBUZXh0U3R5bGUgfT4+KHt9KTtcblxuICBjb25zdCBwcmVzZXRzID0gVGV4dE92ZXJsYXlVdGlscy5jcmVhdGVQcmVzZXRzKCk7XG5cbiAgY29uc3QgY2FsY3VsYXRlT3B0aW1hbEZvbnRTaXplID0gdXNlQ2FsbGJhY2soKFxuICAgIHRleHQ6IHN0cmluZyxcbiAgICBtYXhXaWR0aDogbnVtYmVyLFxuICAgIG1heEhlaWdodDogbnVtYmVyLFxuICAgIHN0eWxlOiBUZXh0U3R5bGUsXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuICApID0+IHtcbiAgICByZXR1cm4gVGV4dE92ZXJsYXlVdGlscy5jYWxjdWxhdGVPcHRpbWFsRm9udFNpemUodGV4dCwgbWF4V2lkdGgsIG1heEhlaWdodCwgc3R5bGUsIGNhbnZhcyk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjcmVhdGVDdXN0b21QcmVzZXQgPSB1c2VDYWxsYmFjaygobmFtZTogc3RyaW5nLCBzdHlsZTogVGV4dFN0eWxlKSA9PiB7XG4gICAgc2V0Q3VzdG9tUHJlc2V0cyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgW25hbWVdOiB7IHN0eWxlIH1cbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBnZXRDdXN0b21QcmVzZXRzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjdXN0b21QcmVzZXRzO1xuICB9LCBbY3VzdG9tUHJlc2V0c10pO1xuXG4gIGNvbnN0IHJlbW92ZUN1c3RvbVByZXNldCA9IHVzZUNhbGxiYWNrKChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBzZXRDdXN0b21QcmVzZXRzKHByZXYgPT4ge1xuICAgICAgY29uc3QgeyBbbmFtZV06IHJlbW92ZWQsIC4uLnJlc3QgfSA9IHByZXY7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgcHJlc2V0cyxcbiAgICBjYWxjdWxhdGVPcHRpbWFsRm9udFNpemUsXG4gICAgY3JlYXRlQ3VzdG9tUHJlc2V0LFxuICAgIGdldEN1c3RvbVByZXNldHMsXG4gICAgcmVtb3ZlQ3VzdG9tUHJlc2V0XG4gIH07XG59XG5cbi8qKlxuICogSG9vayBmb3IgaW50ZXJhY3RpdmUgdGV4dCBlZGl0aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcmFjdGl2ZVRleHRFZGl0b3IoXG4gIGNhbnZhczogTWFuYWdlZENhbnZhcyxcbiAgb3ZlcmxheUlkOiBzdHJpbmcsXG4gIG9uVXBkYXRlOiAoY29uZmlnOiBQYXJ0aWFsPFRleHRPdmVybGF5Q29uZmlnPikgPT4gdm9pZFxuKToge1xuICBpc0VkaXRpbmc6IGJvb2xlYW47XG4gIHN0YXJ0RWRpdGluZzogKCkgPT4gdm9pZDtcbiAgc3RvcEVkaXRpbmc6ICgpID0+IHZvaWQ7XG4gIHVwZGF0ZVRleHQ6ICh0ZXh0OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHVwZGF0ZVN0eWxlOiAoc3R5bGU6IFBhcnRpYWw8VGV4dFN0eWxlPikgPT4gdm9pZDtcbiAgdXBkYXRlUG9zaXRpb246IChwb3NpdGlvbjogUGFydGlhbDxUZXh0UG9zaXRpb24+KSA9PiB2b2lkO1xufSB7XG4gIGNvbnN0IFtpc0VkaXRpbmcsIHNldElzRWRpdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3Qgc3RhcnRFZGl0aW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzRWRpdGluZyh0cnVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHN0b3BFZGl0aW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzRWRpdGluZyhmYWxzZSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCB1cGRhdGVUZXh0ID0gdXNlQ2FsbGJhY2soKHRleHQ6IHN0cmluZykgPT4ge1xuICAgIG9uVXBkYXRlKHsgdGV4dCB9KTtcbiAgfSwgW29uVXBkYXRlXSk7XG5cbiAgY29uc3QgdXBkYXRlU3R5bGUgPSB1c2VDYWxsYmFjaygoc3R5bGU6IFBhcnRpYWw8VGV4dFN0eWxlPikgPT4ge1xuICAgIG9uVXBkYXRlKHsgc3R5bGUgfSk7XG4gIH0sIFtvblVwZGF0ZV0pO1xuXG4gIGNvbnN0IHVwZGF0ZVBvc2l0aW9uID0gdXNlQ2FsbGJhY2soKHBvc2l0aW9uOiBQYXJ0aWFsPFRleHRQb3NpdGlvbj4pID0+IHtcbiAgICBvblVwZGF0ZSh7IHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAsIC4uLnBvc2l0aW9uIH0gfSk7XG4gIH0sIFtvblVwZGF0ZV0pO1xuXG4gIHJldHVybiB7XG4gICAgaXNFZGl0aW5nLFxuICAgIHN0YXJ0RWRpdGluZyxcbiAgICBzdG9wRWRpdGluZyxcbiAgICB1cGRhdGVUZXh0LFxuICAgIHVwZGF0ZVN0eWxlLFxuICAgIHVwZGF0ZVBvc2l0aW9uXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZUludGVyYWN0aXZlVGV4dEVkaXRvciIsInVzZVRleHRPdmVybGF5IiwidXNlVGV4dFByZXNldHMiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImNhbnZhc0lkIiwiY2FudmFzIiwidXNlTWFuYWdlZENhbnZhcyIsInN0YXRlIiwic2V0U3RhdGUiLCJ1c2VTdGF0ZSIsIm92ZXJsYXlzIiwiYWN0aXZlT3ZlcmxheUlkIiwiaXNFZGl0aW5nIiwicmVuZGVyZXJSZWYiLCJ1c2VSZWYiLCJjcmVhdGVUZXh0T3ZlcmxheVJlbmRlcmVyIiwiZ2VuZXJhdGVJZCIsInVzZUNhbGxiYWNrIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImFkZFRleHRPdmVybGF5IiwiY29uZmlnIiwiaWQiLCJuZXdPdmVybGF5IiwidmlzaWJsZSIsImxvY2tlZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInByZXYiLCJ1cGRhdGVUZXh0T3ZlcmxheSIsImNvbmZpZ1VwZGF0ZSIsIm1hcCIsIm92ZXJsYXkiLCJyZW1vdmVUZXh0T3ZlcmxheSIsImZpbHRlciIsInNldEFjdGl2ZU92ZXJsYXkiLCJzZXRPdmVybGF5VmlzaWJpbGl0eSIsInNldE92ZXJsYXlMb2NrZWQiLCJyZW5kZXJBbGxPdmVybGF5cyIsImNvbnRleHQiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInZpc2libGVPdmVybGF5cyIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJmb3JFYWNoIiwibWVhc3VyZW1lbnQiLCJjdXJyZW50IiwicmVuZGVyVGV4dCIsIm8iLCJjbGVhckFsbE92ZXJsYXlzIiwiZ2V0T3ZlcmxheUJ5SWQiLCJmaW5kIiwiZHVwbGljYXRlT3ZlcmxheSIsIm5ld0lkIiwibmV3Q29uZmlnIiwicG9zaXRpb24iLCJ4IiwieSIsImR1cGxpY2F0ZWRPdmVybGF5IiwibW92ZU92ZXJsYXkiLCJuZXdQb3NpdGlvbiIsImV4cG9ydE92ZXJsYXlzIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiaW1wb3J0T3ZlcmxheXMiLCJzdGFydEVkaXRpbmciLCJzdG9wRWRpdGluZyIsInJlbmRlcmVyIiwiY3VzdG9tUHJlc2V0cyIsInNldEN1c3RvbVByZXNldHMiLCJwcmVzZXRzIiwiVGV4dE92ZXJsYXlVdGlscyIsImNyZWF0ZVByZXNldHMiLCJjYWxjdWxhdGVPcHRpbWFsRm9udFNpemUiLCJ0ZXh0IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJzdHlsZSIsImNyZWF0ZUN1c3RvbVByZXNldCIsIm5hbWUiLCJnZXRDdXN0b21QcmVzZXRzIiwicmVtb3ZlQ3VzdG9tUHJlc2V0IiwicmVtb3ZlZCIsInJlc3QiLCJvdmVybGF5SWQiLCJvblVwZGF0ZSIsInNldElzRWRpdGluZyIsInVwZGF0ZVRleHQiLCJ1cGRhdGVTdHlsZSIsInVwZGF0ZVBvc2l0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0lBcVZnQkEsd0JBQXdCO2VBQXhCQTs7SUEzU0FDLGNBQWM7ZUFBZEE7O0lBa1BBQyxjQUFjO2VBQWRBOzs7dUJBdlI4QjtnQ0FDTzs2QkFTOUM7QUEyQkEsU0FBU0QsZUFDZEUsV0FBbUIsRUFDbkJDLFlBQW9CLEVBQ3BCQyxRQUFpQjtJQXVCakIsTUFBTUMsU0FBU0MsSUFBQUEsZ0NBQWdCLEVBQUNKLGFBQWFDLGNBQWNDO0lBQzNELE1BQU0sQ0FBQ0csT0FBT0MsU0FBUyxHQUFHQyxJQUFBQSxl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