32aedb42d3bd78aeb7ca97c806fe1f1a
// Image Processing Utilities for Try-On Mutations
// Comprehensive image processing functions for the business layer
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    CompressionFailedError: function() {
        return _image.CompressionFailedError;
    },
    DEFAULT_PROCESSING_OPTIONS: function() {
        return DEFAULT_PROCESSING_OPTIONS;
    },
    FileTooLargeError: function() {
        return _image.FileTooLargeError;
    },
    FileTypeNotSupportedError: function() {
        return _image.FileTypeNotSupportedError;
    },
    ImageDimensionError: function() {
        return ImageDimensionError;
    },
    ImageFormat: function() {
        return ImageFormat;
    },
    ImageProcessingError: function() {
        return ImageProcessingError;
    },
    applyAutoColorCorrection: function() {
        return applyAutoColorCorrection;
    },
    applyNoiseReduction: function() {
        return applyNoiseReduction;
    },
    applySharpeningFilter: function() {
        return applySharpeningFilter;
    },
    compressBase64: function() {
        return _image.compressBase64;
    },
    convertImageFormat: function() {
        return convertImageFormat;
    },
    createImageThumbnail: function() {
        return createImageThumbnail;
    },
    extractImageMetadata: function() {
        return extractImageMetadata;
    },
    fileToBase64: function() {
        return _image.fileToBase64;
    },
    getBase64Size: function() {
        return getBase64Size;
    },
    getImageDimensions: function() {
        return getImageDimensions;
    },
    isImageFile: function() {
        return _image.isImageFile;
    },
    processImageAdvanced: function() {
        return processImageAdvanced;
    },
    processImageForTryon: function() {
        return processImageForTryon;
    },
    processImagesInBatch: function() {
        return processImagesInBatch;
    },
    processTryonImages: function() {
        return processTryonImages;
    },
    resizeImageTo1024x1536: function() {
        return resizeImageTo1024x1536;
    },
    validateImageDimensions: function() {
        return validateImageDimensions;
    }
});
const _image = require("../../utils/image");
class ImageProcessingError extends Error {
    constructor(message, originalError){
        super(message), this.originalError = originalError;
        this.name = 'ImageProcessingError';
    }
}
class ImageDimensionError extends Error {
    constructor(message, width, height){
        super(message), this.width = width, this.height = height;
        this.name = 'ImageDimensionError';
    }
}
const DEFAULT_PROCESSING_OPTIONS = {
    targetWidth: 1024,
    targetHeight: 1536,
    maxSizeKB: 1024,
    quality: 0.9,
    preserveAspectRatio: false
};
var ImageFormat = /*#__PURE__*/ function(ImageFormat) {
    ImageFormat["JPEG"] = "image/jpeg";
    ImageFormat["PNG"] = "image/png";
    ImageFormat["WEBP"] = "image/webp";
    ImageFormat["GIF"] = "image/gif";
    return ImageFormat;
}({});
function getImageDimensions(imageUrl) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            resolve({
                width: img.width,
                height: img.height
            });
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for dimension analysis'));
        };
        img.src = imageUrl;
    });
}
function resizeImageTo1024x1536(imageUrl, options = {}) {
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                let { targetWidth, targetHeight } = config;
                // Calculate dimensions preserving aspect ratio if requested
                if (config.preserveAspectRatio) {
                    const aspectRatio = img.width / img.height;
                    const targetAspectRatio = targetWidth / targetHeight;
                    if (aspectRatio > targetAspectRatio) {
                        // Image is wider, fit to width
                        targetHeight = Math.round(targetWidth / aspectRatio);
                    } else {
                        // Image is taller, fit to height
                        targetWidth = Math.round(targetHeight * aspectRatio);
                    }
                }
                // Set canvas dimensions
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                // Apply high-quality scaling
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                // Draw the image resized to fit the canvas
                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                // Convert to data URL with specified quality
                const resizedImageUrl = canvas.toDataURL('image/jpeg', config.quality);
                resolve(resizedImageUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to resize image', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for resizing'));
        };
        img.src = imageUrl;
    });
}
async function validateImageDimensions(imageUrl, minWidth = 512, minHeight = 512, maxWidth = 4096, maxHeight = 4096) {
    const dimensions = await getImageDimensions(imageUrl);
    if (dimensions.width < minWidth || dimensions.height < minHeight) {
        throw new ImageDimensionError(`Image dimensions too small. Minimum: ${minWidth}x${minHeight}, got: ${dimensions.width}x${dimensions.height}`, dimensions.width, dimensions.height);
    }
    if (dimensions.width > maxWidth || dimensions.height > maxHeight) {
        throw new ImageDimensionError(`Image dimensions too large. Maximum: ${maxWidth}x${maxHeight}, got: ${dimensions.width}x${dimensions.height}`, dimensions.width, dimensions.height);
    }
}
function getBase64Size(base64) {
    const base64Data = base64.split(',')[1];
    return atob(base64Data).length;
}
async function processImageForTryon(file, options = {}) {
    const startTime = Date.now();
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    try {
        // Step 1: Validate file type and convert to base64
        if (!(0, _image.isImageFile)(file)) {
            throw new _image.FileTypeNotSupportedError('Only image files are allowed');
        }
        const originalBase64 = await (0, _image.fileToBase64)(file);
        const originalSize = file.size;
        const originalDimensions = await getImageDimensions(originalBase64);
        // Step 2: Validate dimensions
        await validateImageDimensions(originalBase64);
        // Step 3: Resize image to target dimensions
        const resizedImage = await resizeImageTo1024x1536(originalBase64, config);
        const finalDimensions = await getImageDimensions(resizedImage);
        // Step 4: Compress if needed
        let processedImage = resizedImage;
        let wasCompressed = false;
        const resizedSize = getBase64Size(resizedImage);
        const targetSizeBytes = config.maxSizeKB * 1024;
        if (resizedSize > targetSizeBytes) {
            processedImage = await (0, _image.compressBase64)(resizedImage, config.maxSizeKB);
            wasCompressed = true;
        }
        const finalSize = getBase64Size(processedImage);
        const processingTime = Date.now() - startTime;
        return {
            processedImage,
            originalDimensions,
            finalDimensions,
            originalSize,
            finalSize,
            metadata: {
                wasResized: originalDimensions.width !== finalDimensions.width || originalDimensions.height !== finalDimensions.height,
                wasCompressed,
                compressionRatio: originalSize / finalSize,
                processingTime
            }
        };
    } catch (error) {
        if (error instanceof _image.FileTypeNotSupportedError || error instanceof _image.FileTooLargeError || error instanceof _image.CompressionFailedError || error instanceof ImageDimensionError || error instanceof ImageProcessingError) {
            throw error;
        }
        throw new ImageProcessingError('Unexpected error during image processing', error instanceof Error ? error : new Error(String(error)));
    }
}
async function processTryonImages(modelImage, apparelImages, options = {}) {
    // Process model image
    const modelImageResult = await processImageForTryon(modelImage, options);
    // Process all apparel images in parallel
    const apparelImageResults = await Promise.all(apparelImages.map((file)=>processImageForTryon(file, options)));
    return {
        modelImageResult,
        apparelImageResults
    };
}
async function extractImageMetadata(file) {
    const imageUrl = await (0, _image.fileToBase64)(file);
    const dimensions = await getImageDimensions(imageUrl);
    return {
        format: file.type,
        dimensions,
        size: file.size,
        dateCreated: file.lastModified ? new Date(file.lastModified) : undefined
    };
}
async function convertImageFormat(imageUrl, targetFormat, quality = 0.9) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                canvas.width = img.width;
                canvas.height = img.height;
                // For PNG with transparency, fill with white background for JPEG
                if (targetFormat === "image/jpeg") {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                ctx.drawImage(img, 0, 0);
                const convertedImageUrl = canvas.toDataURL(targetFormat, quality);
                resolve(convertedImageUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to convert image format', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for format conversion'));
        };
        img.src = imageUrl;
    });
}
function applySharpeningFilter(canvas, strength = 0.5) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    // Simple unsharp mask implementation
    const sharpenKernel = [
        0,
        -strength,
        0,
        -strength,
        1 + 4 * strength,
        -strength,
        0,
        -strength,
        0
    ];
    const newData = new Uint8ClampedArray(data);
    for(let y = 1; y < height - 1; y++){
        for(let x = 1; x < width - 1; x++){
            for(let c = 0; c < 3; c++){
                let sum = 0;
                for(let ky = -1; ky <= 1; ky++){
                    for(let kx = -1; kx <= 1; kx++){
                        const pixelIndex = ((y + ky) * width + (x + kx)) * 4 + c;
                        const kernelIndex = (ky + 1) * 3 + (kx + 1);
                        sum += data[pixelIndex] * sharpenKernel[kernelIndex];
                    }
                }
                newData[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));
            }
        }
    }
    // Copy the new data back
    for(let i = 0; i < data.length; i++){
        data[i] = newData[i];
    }
    ctx.putImageData(imageData, 0, 0);
}
function applyNoiseReduction(canvas, strength = 0.3) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    // Simple blur for noise reduction
    const radius = Math.ceil(strength * 3);
    const newData = new Uint8ClampedArray(data);
    for(let y = 0; y < height; y++){
        for(let x = 0; x < width; x++){
            for(let c = 0; c < 3; c++){
                let sum = 0;
                let count = 0;
                for(let dy = -radius; dy <= radius; dy++){
                    for(let dx = -radius; dx <= radius; dx++){
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            sum += data[(ny * width + nx) * 4 + c];
                            count++;
                        }
                    }
                }
                newData[(y * width + x) * 4 + c] = sum / count;
            }
        }
    }
    // Copy the new data back
    for(let i = 0; i < data.length; i += 4){
        data[i] = newData[i]; // R
        data[i + 1] = newData[i + 1]; // G
        data[i + 2] = newData[i + 2]; // B
    // Keep original alpha
    }
    ctx.putImageData(imageData, 0, 0);
}
function applyAutoColorCorrection(canvas) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    // Calculate histogram
    const histogram = {
        r: new Array(256).fill(0),
        g: new Array(256).fill(0),
        b: new Array(256).fill(0)
    };
    for(let i = 0; i < data.length; i += 4){
        histogram.r[data[i]]++;
        histogram.g[data[i + 1]]++;
        histogram.b[data[i + 2]]++;
    }
    // Find min/max values for each channel
    const getMinMax = (hist)=>{
        let min = 0, max = 255;
        for(let i = 0; i < 256; i++){
            if (hist[i] > 0) {
                min = i;
                break;
            }
        }
        for(let i = 255; i >= 0; i--){
            if (hist[i] > 0) {
                max = i;
                break;
            }
        }
        return {
            min,
            max
        };
    };
    const rMinMax = getMinMax(histogram.r);
    const gMinMax = getMinMax(histogram.g);
    const bMinMax = getMinMax(histogram.b);
    // Apply histogram stretching
    for(let i = 0; i < data.length; i += 4){
        data[i] = Math.max(0, Math.min(255, (data[i] - rMinMax.min) / (rMinMax.max - rMinMax.min) * 255));
        data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - gMinMax.min) / (gMinMax.max - gMinMax.min) * 255));
        data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - bMinMax.min) / (bMinMax.max - bMinMax.min) * 255));
    }
    ctx.putImageData(imageData, 0, 0);
}
async function processImageAdvanced(file, options = {}) {
    const startTime = Date.now();
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    const operationsApplied = [];
    try {
        // Step 1: Extract original metadata
        const originalMetadata = await extractImageMetadata(file);
        operationsApplied.push('metadata-extraction');
        // Step 2: Validate file type and convert to base64
        if (!(0, _image.isImageFile)(file)) {
            throw new _image.FileTypeNotSupportedError('Only image files are allowed');
        }
        let currentImage = await (0, _image.fileToBase64)(file);
        operationsApplied.push('base64-conversion');
        // Step 3: Validate dimensions
        await validateImageDimensions(currentImage);
        operationsApplied.push('dimension-validation');
        // Step 4: Format conversion (if needed)
        let wasFormatConverted = false;
        if (options.outputFormat && options.outputFormat !== file.type) {
            currentImage = await convertImageFormat(currentImage, options.outputFormat, config.quality);
            wasFormatConverted = true;
            operationsApplied.push('format-conversion');
        }
        // Step 5: Create canvas for advanced processing
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new ImageProcessingError('Could not get canvas context');
        // Load image onto canvas
        const img = new Image();
        img.crossOrigin = "anonymous";
        await new Promise((resolve, reject)=>{
            img.onload = ()=>resolve();
            img.onerror = ()=>reject(new ImageProcessingError('Failed to load image'));
            img.src = currentImage;
        });
        // Set canvas dimensions based on resize requirements
        const finalWidth = config.targetWidth || img.width;
        const finalHeight = config.targetHeight || img.height;
        canvas.width = finalWidth;
        canvas.height = finalHeight;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        // Draw resized image
        ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
        const wasResized = img.width !== finalWidth || img.height !== finalHeight;
        if (wasResized) {
            operationsApplied.push('resize');
        }
        // Step 6: Apply advanced processing
        let wasSharpened = false;
        if (options.enableSharpening && wasResized) {
            applySharpeningFilter(canvas, 0.3);
            wasSharpened = true;
            operationsApplied.push('sharpening');
        }
        let hadNoiseReduction = false;
        if (options.noiseReduction && options.noiseReduction > 0) {
            applyNoiseReduction(canvas, options.noiseReduction);
            hadNoiseReduction = true;
            operationsApplied.push('noise-reduction');
        }
        if (options.autoColorCorrection) {
            applyAutoColorCorrection(canvas);
            operationsApplied.push('color-correction');
        }
        // Step 7: Convert back to data URL
        const outputFormat = options.outputFormat || "image/jpeg";
        let processedImage = canvas.toDataURL(outputFormat, config.quality);
        // Step 8: Compress if needed
        let wasCompressed = false;
        const processedSize = getBase64Size(processedImage);
        const targetSizeBytes = config.maxSizeKB * 1024;
        if (processedSize > targetSizeBytes) {
            processedImage = await (0, _image.compressBase64)(processedImage, config.maxSizeKB);
            wasCompressed = true;
            operationsApplied.push('compression');
        }
        // Step 9: Generate final metadata
        const finalDimensions = await getImageDimensions(processedImage);
        const finalSize = getBase64Size(processedImage);
        const processingTime = Date.now() - startTime;
        const finalMetadata = {
            format: outputFormat,
            dimensions: finalDimensions,
            size: finalSize
        };
        return {
            processedImage,
            originalMetadata,
            finalMetadata,
            processingMetadata: {
                wasResized,
                wasCompressed,
                wasFormatConverted,
                wasSharpened,
                hadNoiseReduction,
                compressionRatio: originalMetadata.size / finalSize,
                processingTime,
                operationsApplied
            }
        };
    } catch (error) {
        if (error instanceof _image.FileTypeNotSupportedError || error instanceof _image.FileTooLargeError || error instanceof _image.CompressionFailedError || error instanceof ImageDimensionError || error instanceof ImageProcessingError) {
            throw error;
        }
        throw new ImageProcessingError('Unexpected error during advanced image processing', error instanceof Error ? error : new Error(String(error)));
    }
}
async function processImagesInBatch(files, options = {}, onProgress) {
    const results = [];
    for(let i = 0; i < files.length; i++){
        const file = files[i];
        onProgress?.(i, files.length, file.name);
        try {
            const result = await processImageAdvanced(file, options);
            results.push(result);
        } catch (error) {
            // For batch processing, we might want to continue with other files
            console.error(`Failed to process ${file.name}:`, error);
        // You could push a failed result or skip, depending on requirements
        }
    }
    onProgress?.(files.length, files.length, 'Complete');
    return results;
}
async function createImageThumbnail(file, size = 150, quality = 0.8) {
    const imageUrl = await (0, _image.fileToBase64)(file);
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                // Calculate dimensions to maintain aspect ratio
                const aspectRatio = img.width / img.height;
                let width = size;
                let height = size;
                if (aspectRatio > 1) {
                    height = size / aspectRatio;
                } else {
                    width = size * aspectRatio;
                }
                canvas.width = width;
                canvas.height = height;
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, width, height);
                const thumbnailUrl = canvas.toDataURL('image/jpeg', quality);
                resolve(thumbnailUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to create thumbnail', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for thumbnail creation'));
        };
        img.src = imageUrl;
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbWFnZSBQcm9jZXNzaW5nIFV0aWxpdGllcyBmb3IgVHJ5LU9uIE11dGF0aW9uc1xuLy8gQ29tcHJlaGVuc2l2ZSBpbWFnZSBwcm9jZXNzaW5nIGZ1bmN0aW9ucyBmb3IgdGhlIGJ1c2luZXNzIGxheWVyXG5cbmltcG9ydCB7IFxuICBmaWxlVG9CYXNlNjQsIFxuICBjb21wcmVzc0Jhc2U2NCwgXG4gIGlzSW1hZ2VGaWxlLFxuICBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yLFxuICBGaWxlVG9vTGFyZ2VFcnJvcixcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcixcbiAgdHlwZSBJbWFnZUJhc2U2NFxufSBmcm9tICdAL3V0aWxzL2ltYWdlJztcblxuLy8gUmUtZXhwb3J0IHV0aWxpdGllcyBuZWVkZWQgYnkgb3RoZXIgYnVzaW5lc3MgbGF5ZXIgbW9kdWxlc1xuZXhwb3J0IHsgXG4gIGNvbXByZXNzQmFzZTY0LCBcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcixcbiAgRmlsZVR5cGVOb3RTdXBwb3J0ZWRFcnJvcixcbiAgRmlsZVRvb0xhcmdlRXJyb3IsXG4gIGZpbGVUb0Jhc2U2NCxcbiAgaXNJbWFnZUZpbGUsXG4gIHR5cGUgSW1hZ2VCYXNlNjQgXG59O1xuXG4vLyBFeHBvcnQgZ2V0QmFzZTY0U2l6ZSBmdW5jdGlvbiB0aGF0J3MgZGVmaW5lZCBpbiB0aGlzIGZpbGVcbmV4cG9ydCB7IGdldEJhc2U2NFNpemUgfTtcbmltcG9ydCB7IFxuICBBZHZhbmNlZENhbnZhc09wZXJhdGlvbnMsIFxuICBjcmVhdGVBZHZhbmNlZENhbnZhc09wZXJhdGlvbnMsXG4gIHR5cGUgTWFuYWdlZENhbnZhcyBcbn0gZnJvbSAnLi4vcHJvdmlkZXJzL0NhbnZhc1Byb3ZpZGVyJztcblxuLyoqXG4gKiBDdXN0b20gZXJyb3IgZm9yIGltYWdlIHByb2Nlc3NpbmcgZmFpbHVyZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlUHJvY2Vzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbEVycm9yPzogRXJyb3IpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnSW1hZ2VQcm9jZXNzaW5nRXJyb3InO1xuICB9XG59XG5cbi8qKlxuICogQ3VzdG9tIGVycm9yIGZvciBpbWFnZSBkaW1lbnNpb24gdmFsaWRhdGlvbiBmYWlsdXJlc1xuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VEaW1lbnNpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgd2lkdGg/OiBudW1iZXIsIHB1YmxpYyByZWFkb25seSBoZWlnaHQ/OiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnSW1hZ2VEaW1lbnNpb25FcnJvcic7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGltYWdlIHByb2Nlc3NpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZVByb2Nlc3NpbmdPcHRpb25zIHtcbiAgLyoqIFRhcmdldCB3aWR0aCBmb3IgcmVzaXppbmcgKGRlZmF1bHQ6IDEwMjQpICovXG4gIHRhcmdldFdpZHRoPzogbnVtYmVyO1xuICAvKiogVGFyZ2V0IGhlaWdodCBmb3IgcmVzaXppbmcgKGRlZmF1bHQ6IDE1MzYpICovXG4gIHRhcmdldEhlaWdodD86IG51bWJlcjtcbiAgLyoqIE1heGltdW0gZmlsZSBzaXplIGluIEtCIGFmdGVyIGNvbXByZXNzaW9uIChkZWZhdWx0OiAxMDI0KSAqL1xuICBtYXhTaXplS0I/OiBudW1iZXI7XG4gIC8qKiBKUEVHIHF1YWxpdHkgZm9yIGNvbXByZXNzaW9uICgwLjEtMS4wLCBkZWZhdWx0OiAwLjkpICovXG4gIHF1YWxpdHk/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIHByZXNlcnZlIGFzcGVjdCByYXRpbyBkdXJpbmcgcmVzaXplIChkZWZhdWx0OiBmYWxzZSkgKi9cbiAgcHJlc2VydmVBc3BlY3RSYXRpbz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCBwcm9jZXNzaW5nIG9wdGlvbnMgZm9yIHRyeS1vbiBpbWFnZXNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJPQ0VTU0lOR19PUFRJT05TOiBSZXF1aXJlZDxJbWFnZVByb2Nlc3NpbmdPcHRpb25zPiA9IHtcbiAgdGFyZ2V0V2lkdGg6IDEwMjQsXG4gIHRhcmdldEhlaWdodDogMTUzNixcbiAgbWF4U2l6ZUtCOiAxMDI0LFxuICBxdWFsaXR5OiAwLjksXG4gIHByZXNlcnZlQXNwZWN0UmF0aW86IGZhbHNlXG59O1xuXG4vKipcbiAqIFN1cHBvcnRlZCBpbWFnZSBmb3JtYXRzIGZvciBjb252ZXJzaW9uXG4gKi9cbmV4cG9ydCBlbnVtIEltYWdlRm9ybWF0IHtcbiAgSlBFRyA9ICdpbWFnZS9qcGVnJyxcbiAgUE5HID0gJ2ltYWdlL3BuZycsXG4gIFdFQlAgPSAnaW1hZ2Uvd2VicCcsXG4gIEdJRiA9ICdpbWFnZS9naWYnXG59XG5cbi8qKlxuICogSW1hZ2UgbWV0YWRhdGEgZXh0cmFjdGVkIGZyb20gZmlsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlTWV0YWRhdGEge1xuICAvKiogSW1hZ2UgZm9ybWF0L01JTUUgdHlwZSAqL1xuICBmb3JtYXQ6IHN0cmluZztcbiAgLyoqIEltYWdlIGRpbWVuc2lvbnMgKi9cbiAgZGltZW5zaW9uczogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAvKiogRmlsZSBzaXplIGluIGJ5dGVzICovXG4gIHNpemU6IG51bWJlcjtcbiAgLyoqIENvbG9yIGRlcHRoIGluZm9ybWF0aW9uICovXG4gIGNvbG9yRGVwdGg/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIGltYWdlIGhhcyB0cmFuc3BhcmVuY3kgKi9cbiAgaGFzQWxwaGE/OiBib29sZWFuO1xuICAvKiogRXN0aW1hdGVkIHF1YWxpdHkgKGZvciBKUEVHKSAqL1xuICBlc3RpbWF0ZWRRdWFsaXR5PzogbnVtYmVyO1xuICAvKiogQ3JlYXRpb24gdGltZXN0YW1wIGlmIGF2YWlsYWJsZSAqL1xuICBkYXRlQ3JlYXRlZD86IERhdGU7XG4gIC8qKiBEZXZpY2Ugb3JpZW50YXRpb24gKEVYSUYpICovXG4gIG9yaWVudGF0aW9uPzogbnVtYmVyO1xuICAvKiogRFBJL3Jlc29sdXRpb24gaW5mb3JtYXRpb24gKi9cbiAgcmVzb2x1dGlvbj86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbn1cblxuLyoqXG4gKiBBZHZhbmNlZCBpbWFnZSBwcm9jZXNzaW5nIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ09wdGlvbnMgZXh0ZW5kcyBJbWFnZVByb2Nlc3NpbmdPcHRpb25zIHtcbiAgLyoqIE91dHB1dCBmb3JtYXQgKi9cbiAgb3V0cHV0Rm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG4gIC8qKiBFbmFibGUgc2hhcnBlbmluZyBhZnRlciByZXNpemUgKi9cbiAgZW5hYmxlU2hhcnBlbmluZz86IGJvb2xlYW47XG4gIC8qKiBOb2lzZSByZWR1Y3Rpb24gc3RyZW5ndGggKDAtMSkgKi9cbiAgbm9pc2VSZWR1Y3Rpb24/OiBudW1iZXI7XG4gIC8qKiBFbmFibGUgYXV0b21hdGljIGNvbG9yIGNvcnJlY3Rpb24gKi9cbiAgYXV0b0NvbG9yQ29ycmVjdGlvbj86IGJvb2xlYW47XG4gIC8qKiBQcmVzZXJ2ZSBFWElGIGRhdGEgKi9cbiAgcHJlc2VydmVFeGlmPzogYm9vbGVhbjtcbiAgLyoqIEN1c3RvbSBjYW52YXMgZm9yIHByb2Nlc3NpbmcgKi9cbiAgY2FudmFzPzogTWFuYWdlZENhbnZhcztcbn1cblxuLyoqXG4gKiBFbmhhbmNlZCByZXN1bHQgb2YgaW1hZ2UgcHJvY2Vzc2luZyBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdSZXN1bHQge1xuICAvKiogUHJvY2Vzc2VkIGltYWdlIGFzIGJhc2U2NCBkYXRhIFVSTCAqL1xuICBwcm9jZXNzZWRJbWFnZTogSW1hZ2VCYXNlNjQ7XG4gIC8qKiBPcmlnaW5hbCBpbWFnZSBtZXRhZGF0YSAqL1xuICBvcmlnaW5hbE1ldGFkYXRhOiBJbWFnZU1ldGFkYXRhO1xuICAvKiogRmluYWwgaW1hZ2UgbWV0YWRhdGEgKi9cbiAgZmluYWxNZXRhZGF0YTogSW1hZ2VNZXRhZGF0YTtcbiAgLyoqIFByb2Nlc3NpbmcgbWV0YWRhdGEgKi9cbiAgcHJvY2Vzc2luZ01ldGFkYXRhOiB7XG4gICAgd2FzUmVzaXplZDogYm9vbGVhbjtcbiAgICB3YXNDb21wcmVzc2VkOiBib29sZWFuO1xuICAgIHdhc0Zvcm1hdENvbnZlcnRlZDogYm9vbGVhbjtcbiAgICB3YXNTaGFycGVuZWQ6IGJvb2xlYW47XG4gICAgaGFkTm9pc2VSZWR1Y3Rpb246IGJvb2xlYW47XG4gICAgY29tcHJlc3Npb25SYXRpbzogbnVtYmVyO1xuICAgIHByb2Nlc3NpbmdUaW1lOiBudW1iZXI7XG4gICAgb3BlcmF0aW9uc0FwcGxpZWQ6IHN0cmluZ1tdO1xuICB9O1xufVxuXG4vKipcbiAqIFJlc3VsdCBvZiBpbWFnZSBwcm9jZXNzaW5nIG9wZXJhdGlvbnMgKGxlZ2FjeSBjb21wYXRpYmlsaXR5KVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gIC8qKiBQcm9jZXNzZWQgaW1hZ2UgYXMgYmFzZTY0IGRhdGEgVVJMICovXG4gIHByb2Nlc3NlZEltYWdlOiBJbWFnZUJhc2U2NDtcbiAgLyoqIE9yaWdpbmFsIGltYWdlIGRpbWVuc2lvbnMgKi9cbiAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG4gIC8qKiBGaW5hbCBpbWFnZSBkaW1lbnNpb25zICovXG4gIGZpbmFsRGltZW5zaW9uczogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAvKiogT3JpZ2luYWwgZmlsZSBzaXplIGluIGJ5dGVzICovXG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyO1xuICAvKiogRmluYWwgZmlsZSBzaXplIGluIGJ5dGVzICovXG4gIGZpbmFsU2l6ZTogbnVtYmVyO1xuICAvKiogUHJvY2Vzc2luZyBtZXRhZGF0YSAqL1xuICBtZXRhZGF0YToge1xuICAgIHdhc1Jlc2l6ZWQ6IGJvb2xlYW47XG4gICAgd2FzQ29tcHJlc3NlZDogYm9vbGVhbjtcbiAgICBjb21wcmVzc2lvblJhdGlvOiBudW1iZXI7XG4gICAgcHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgaW1hZ2UgZGltZW5zaW9ucyBmcm9tIGEgZGF0YSBVUkwgb3IgaW1hZ2UgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VEaW1lbnNpb25zKGltYWdlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoeyB3aWR0aDogaW1nLndpZHRoLCBoZWlnaHQ6IGltZy5oZWlnaHQgfSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlIGZvciBkaW1lbnNpb24gYW5hbHlzaXMnKSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlc2l6ZSBpbWFnZSB0byBzcGVjaWZpYyBkaW1lbnNpb25zXG4gKiBcbiAqIEBwYXJhbSBpbWFnZVVybCAtIFNvdXJjZSBpbWFnZSBkYXRhIFVSTFxuICogQHBhcmFtIG9wdGlvbnMgLSBSZXNpemUgb3B0aW9uc1xuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gcmVzaXplZCBpbWFnZSBkYXRhIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplSW1hZ2VUbzEwMjR4MTUzNihcbiAgaW1hZ2VVcmw6IHN0cmluZywgXG4gIG9wdGlvbnM6IFBhcnRpYWw8SW1hZ2VQcm9jZXNzaW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgY29uZmlnID0geyAuLi5ERUZBVUxUX1BST0NFU1NJTkdfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICBcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgeyB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0IH0gPSBjb25maWc7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZGltZW5zaW9ucyBwcmVzZXJ2aW5nIGFzcGVjdCByYXRpbyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKGNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHRhcmdldEFzcGVjdFJhdGlvID0gdGFyZ2V0V2lkdGggLyB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvID4gdGFyZ2V0QXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIC8vIEltYWdlIGlzIHdpZGVyLCBmaXQgdG8gd2lkdGhcbiAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IE1hdGgucm91bmQodGFyZ2V0V2lkdGggLyBhc3BlY3RSYXRpbyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEltYWdlIGlzIHRhbGxlciwgZml0IHRvIGhlaWdodFxuICAgICAgICAgICAgdGFyZ2V0V2lkdGggPSBNYXRoLnJvdW5kKHRhcmdldEhlaWdodCAqIGFzcGVjdFJhdGlvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IGhpZ2gtcXVhbGl0eSBzY2FsaW5nXG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gJ2hpZ2gnO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgaW1hZ2UgcmVzaXplZCB0byBmaXQgdGhlIGNhbnZhc1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHRvIGRhdGEgVVJMIHdpdGggc3BlY2lmaWVkIHF1YWxpdHlcbiAgICAgICAgY29uc3QgcmVzaXplZEltYWdlVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIGNvbmZpZy5xdWFsaXR5KTtcbiAgICAgICAgcmVzb2x2ZShyZXNpemVkSW1hZ2VVcmwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIHJlc2l6ZSBpbWFnZScsXG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSBmb3IgcmVzaXppbmcnKSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gIH0pO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGltYWdlIGRpbWVuc2lvbnMgYWdhaW5zdCByZXF1aXJlbWVudHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSW1hZ2VEaW1lbnNpb25zKFxuICBpbWFnZVVybDogc3RyaW5nLFxuICBtaW5XaWR0aCA9IDUxMixcbiAgbWluSGVpZ2h0ID0gNTEyLFxuICBtYXhXaWR0aCA9IDQwOTYsXG4gIG1heEhlaWdodCA9IDQwOTZcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkaW1lbnNpb25zID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKGltYWdlVXJsKTtcbiAgXG4gIGlmIChkaW1lbnNpb25zLndpZHRoIDwgbWluV2lkdGggfHwgZGltZW5zaW9ucy5oZWlnaHQgPCBtaW5IZWlnaHQpIHtcbiAgICB0aHJvdyBuZXcgSW1hZ2VEaW1lbnNpb25FcnJvcihcbiAgICAgIGBJbWFnZSBkaW1lbnNpb25zIHRvbyBzbWFsbC4gTWluaW11bTogJHttaW5XaWR0aH14JHttaW5IZWlnaHR9LCBnb3Q6ICR7ZGltZW5zaW9ucy53aWR0aH14JHtkaW1lbnNpb25zLmhlaWdodH1gLFxuICAgICAgZGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0XG4gICAgKTtcbiAgfVxuICBcbiAgaWYgKGRpbWVuc2lvbnMud2lkdGggPiBtYXhXaWR0aCB8fCBkaW1lbnNpb25zLmhlaWdodCA+IG1heEhlaWdodCkge1xuICAgIHRocm93IG5ldyBJbWFnZURpbWVuc2lvbkVycm9yKFxuICAgICAgYEltYWdlIGRpbWVuc2lvbnMgdG9vIGxhcmdlLiBNYXhpbXVtOiAke21heFdpZHRofXgke21heEhlaWdodH0sIGdvdDogJHtkaW1lbnNpb25zLndpZHRofXgke2RpbWVuc2lvbnMuaGVpZ2h0fWAsXG4gICAgICBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgZGltZW5zaW9ucy5oZWlnaHRcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGZpbGUgc2l6ZSBmcm9tIGJhc2U2NCBkYXRhIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZTY0U2l6ZShiYXNlNjQ6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGJhc2U2NERhdGEgPSBiYXNlNjQuc3BsaXQoJywnKVsxXTtcbiAgcmV0dXJuIGF0b2IoYmFzZTY0RGF0YSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBmaWxlIHRocm91Z2ggdGhlIGNvbXBsZXRlIHRyeS1vbiBpbWFnZSBwaXBlbGluZVxuICogXG4gKiBAcGFyYW0gZmlsZSAtIElucHV0IGltYWdlIGZpbGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gUHJvY2Vzc2luZyBvcHRpb25zXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBwcm9jZXNzaW5nIHJlc3VsdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ltYWdlRm9yVHJ5b24oXG4gIGZpbGU6IEZpbGUsXG4gIG9wdGlvbnM6IFBhcnRpYWw8SW1hZ2VQcm9jZXNzaW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTxJbWFnZVByb2Nlc3NpbmdSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgY29uZmlnID0geyAuLi5ERUZBVUxUX1BST0NFU1NJTkdfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICBcbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IFZhbGlkYXRlIGZpbGUgdHlwZSBhbmQgY29udmVydCB0byBiYXNlNjRcbiAgICBpZiAoIWlzSW1hZ2VGaWxlKGZpbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlsZVR5cGVOb3RTdXBwb3J0ZWRFcnJvcignT25seSBpbWFnZSBmaWxlcyBhcmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBvcmlnaW5hbEJhc2U2NCA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgICBjb25zdCBvcmlnaW5hbFNpemUgPSBmaWxlLnNpemU7XG4gICAgY29uc3Qgb3JpZ2luYWxEaW1lbnNpb25zID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKG9yaWdpbmFsQmFzZTY0KTtcbiAgICBcbiAgICAvLyBTdGVwIDI6IFZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBhd2FpdCB2YWxpZGF0ZUltYWdlRGltZW5zaW9ucyhvcmlnaW5hbEJhc2U2NCk7XG4gICAgXG4gICAgLy8gU3RlcCAzOiBSZXNpemUgaW1hZ2UgdG8gdGFyZ2V0IGRpbWVuc2lvbnNcbiAgICBjb25zdCByZXNpemVkSW1hZ2UgPSBhd2FpdCByZXNpemVJbWFnZVRvMTAyNHgxNTM2KG9yaWdpbmFsQmFzZTY0LCBjb25maWcpO1xuICAgIGNvbnN0IGZpbmFsRGltZW5zaW9ucyA9IGF3YWl0IGdldEltYWdlRGltZW5zaW9ucyhyZXNpemVkSW1hZ2UpO1xuICAgIFxuICAgIC8vIFN0ZXAgNDogQ29tcHJlc3MgaWYgbmVlZGVkXG4gICAgbGV0IHByb2Nlc3NlZEltYWdlID0gcmVzaXplZEltYWdlO1xuICAgIGxldCB3YXNDb21wcmVzc2VkID0gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgcmVzaXplZFNpemUgPSBnZXRCYXNlNjRTaXplKHJlc2l6ZWRJbWFnZSk7XG4gICAgY29uc3QgdGFyZ2V0U2l6ZUJ5dGVzID0gY29uZmlnLm1heFNpemVLQiAqIDEwMjQ7XG4gICAgXG4gICAgaWYgKHJlc2l6ZWRTaXplID4gdGFyZ2V0U2l6ZUJ5dGVzKSB7XG4gICAgICBwcm9jZXNzZWRJbWFnZSA9IGF3YWl0IGNvbXByZXNzQmFzZTY0KHJlc2l6ZWRJbWFnZSwgY29uZmlnLm1heFNpemVLQik7XG4gICAgICB3YXNDb21wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmluYWxTaXplID0gZ2V0QmFzZTY0U2l6ZShwcm9jZXNzZWRJbWFnZSk7XG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBwcm9jZXNzZWRJbWFnZSxcbiAgICAgIG9yaWdpbmFsRGltZW5zaW9ucyxcbiAgICAgIGZpbmFsRGltZW5zaW9ucyxcbiAgICAgIG9yaWdpbmFsU2l6ZSxcbiAgICAgIGZpbmFsU2l6ZSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHdhc1Jlc2l6ZWQ6IG9yaWdpbmFsRGltZW5zaW9ucy53aWR0aCAhPT0gZmluYWxEaW1lbnNpb25zLndpZHRoIHx8IFxuICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGltZW5zaW9ucy5oZWlnaHQgIT09IGZpbmFsRGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgIHdhc0NvbXByZXNzZWQsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IG9yaWdpbmFsU2l6ZSAvIGZpbmFsU2l6ZSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWVcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpbGVUeXBlTm90U3VwcG9ydGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBGaWxlVG9vTGFyZ2VFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENvbXByZXNzaW9uRmFpbGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBJbWFnZURpbWVuc2lvbkVycm9yIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgSW1hZ2VQcm9jZXNzaW5nRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoXG4gICAgICAnVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgaW1hZ2UgcHJvY2Vzc2luZycsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogUHJvY2VzcyBtdWx0aXBsZSBpbWFnZXMgZm9yIHRyeS1vbiAobW9kZWwgKyBhcHBhcmVsIGltYWdlcylcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUcnlvbkltYWdlcyhcbiAgbW9kZWxJbWFnZTogRmlsZSxcbiAgYXBwYXJlbEltYWdlczogRmlsZVtdLFxuICBvcHRpb25zOiBQYXJ0aWFsPEltYWdlUHJvY2Vzc2luZ09wdGlvbnM+ID0ge31cbik6IFByb21pc2U8e1xuICBtb2RlbEltYWdlUmVzdWx0OiBJbWFnZVByb2Nlc3NpbmdSZXN1bHQ7XG4gIGFwcGFyZWxJbWFnZVJlc3VsdHM6IEltYWdlUHJvY2Vzc2luZ1Jlc3VsdFtdO1xufT4ge1xuICAvLyBQcm9jZXNzIG1vZGVsIGltYWdlXG4gIGNvbnN0IG1vZGVsSW1hZ2VSZXN1bHQgPSBhd2FpdCBwcm9jZXNzSW1hZ2VGb3JUcnlvbihtb2RlbEltYWdlLCBvcHRpb25zKTtcbiAgXG4gIC8vIFByb2Nlc3MgYWxsIGFwcGFyZWwgaW1hZ2VzIGluIHBhcmFsbGVsXG4gIGNvbnN0IGFwcGFyZWxJbWFnZVJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBhcHBhcmVsSW1hZ2VzLm1hcChmaWxlID0+IHByb2Nlc3NJbWFnZUZvclRyeW9uKGZpbGUsIG9wdGlvbnMpKVxuICApO1xuICBcbiAgcmV0dXJuIHtcbiAgICBtb2RlbEltYWdlUmVzdWx0LFxuICAgIGFwcGFyZWxJbWFnZVJlc3VsdHNcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGNvbXByZWhlbnNpdmUgbWV0YWRhdGEgZnJvbSBpbWFnZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEltYWdlTWV0YWRhdGEoZmlsZTogRmlsZSk6IFByb21pc2U8SW1hZ2VNZXRhZGF0YT4ge1xuICBjb25zdCBpbWFnZVVybCA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IGdldEltYWdlRGltZW5zaW9ucyhpbWFnZVVybCk7XG4gIFxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogZmlsZS50eXBlLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgc2l6ZTogZmlsZS5zaXplLFxuICAgIGRhdGVDcmVhdGVkOiBmaWxlLmxhc3RNb2RpZmllZCA/IG5ldyBEYXRlKGZpbGUubGFzdE1vZGlmaWVkKSA6IHVuZGVmaW5lZCxcbiAgICAvLyBBZGRpdGlvbmFsIG1ldGFkYXRhIHdvdWxkIHJlcXVpcmUgRVhJRiBwYXJzaW5nIGxpYnJhcnlcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBwcm92aWRlIGJhc2ljIG1ldGFkYXRhXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBpbWFnZSB0byBkaWZmZXJlbnQgZm9ybWF0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0SW1hZ2VGb3JtYXQoXG4gIGltYWdlVXJsOiBzdHJpbmcsXG4gIHRhcmdldEZvcm1hdDogSW1hZ2VGb3JtYXQsXG4gIHF1YWxpdHk6IG51bWJlciA9IDAuOVxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yIFBORyB3aXRoIHRyYW5zcGFyZW5jeSwgZmlsbCB3aXRoIHdoaXRlIGJhY2tncm91bmQgZm9yIEpQRUdcbiAgICAgICAgaWYgKHRhcmdldEZvcm1hdCA9PT0gSW1hZ2VGb3JtYXQuSlBFRykge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRJbWFnZVVybCA9IGNhbnZhcy50b0RhdGFVUkwodGFyZ2V0Rm9ybWF0LCBxdWFsaXR5KTtcbiAgICAgICAgcmVzb2x2ZShjb252ZXJ0ZWRJbWFnZVVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gY29udmVydCBpbWFnZSBmb3JtYXQnLFxuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UgZm9yIGZvcm1hdCBjb252ZXJzaW9uJykpO1xuICAgIH07XG4gICAgXG4gICAgaW1nLnNyYyA9IGltYWdlVXJsO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSBzaGFycGVuaW5nIGZpbHRlciB0byBpbWFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTaGFycGVuaW5nRmlsdGVyKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHN0cmVuZ3RoOiBudW1iZXIgPSAwLjUpOiB2b2lkIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGlmICghY3R4KSB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgXG4gIC8vIFNpbXBsZSB1bnNoYXJwIG1hc2sgaW1wbGVtZW50YXRpb25cbiAgY29uc3Qgc2hhcnBlbktlcm5lbCA9IFtcbiAgICAwLCAtc3RyZW5ndGgsIDAsXG4gICAgLXN0cmVuZ3RoLCAxICsgNCAqIHN0cmVuZ3RoLCAtc3RyZW5ndGgsXG4gICAgMCwgLXN0cmVuZ3RoLCAwXG4gIF07XG4gIFxuICBjb25zdCBuZXdEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEpO1xuICBcbiAgZm9yIChsZXQgeSA9IDE7IHkgPCBoZWlnaHQgLSAxOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMTsgeCA8IHdpZHRoIC0gMTsgeCsrKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDM7IGMrKykgeyAvLyBSR0IgY2hhbm5lbHMgb25seVxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQga3kgPSAtMTsga3kgPD0gMTsga3krKykge1xuICAgICAgICAgIGZvciAobGV0IGt4ID0gLTE7IGt4IDw9IDE7IGt4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsSW5kZXggPSAoKHkgKyBreSkgKiB3aWR0aCArICh4ICsga3gpKSAqIDQgKyBjO1xuICAgICAgICAgICAgY29uc3Qga2VybmVsSW5kZXggPSAoa3kgKyAxKSAqIDMgKyAoa3ggKyAxKTtcbiAgICAgICAgICAgIHN1bSArPSBkYXRhW3BpeGVsSW5kZXhdICogc2hhcnBlbktlcm5lbFtrZXJuZWxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld0RhdGFbKHkgKiB3aWR0aCArIHgpICogNCArIGNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBzdW0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIENvcHkgdGhlIG5ldyBkYXRhIGJhY2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YVtpXSA9IG5ld0RhdGFbaV07XG4gIH1cbiAgXG4gIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbn1cblxuLyoqXG4gKiBBcHBseSBub2lzZSByZWR1Y3Rpb24gZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseU5vaXNlUmVkdWN0aW9uKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHN0cmVuZ3RoOiBudW1iZXIgPSAwLjMpOiB2b2lkIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGlmICghY3R4KSB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgXG4gIC8vIFNpbXBsZSBibHVyIGZvciBub2lzZSByZWR1Y3Rpb25cbiAgY29uc3QgcmFkaXVzID0gTWF0aC5jZWlsKHN0cmVuZ3RoICogMyk7XG4gIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YSk7XG4gIFxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDM7IGMrKykgeyAvLyBSR0IgY2hhbm5lbHMgb25seVxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGR5ID0gLXJhZGl1czsgZHkgPD0gcmFkaXVzOyBkeSsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgZHggPSAtcmFkaXVzOyBkeCA8PSByYWRpdXM7IGR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG54ID0geCArIGR4O1xuICAgICAgICAgICAgY29uc3QgbnkgPSB5ICsgZHk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChueCA+PSAwICYmIG54IDwgd2lkdGggJiYgbnkgPj0gMCAmJiBueSA8IGhlaWdodCkge1xuICAgICAgICAgICAgICBzdW0gKz0gZGF0YVsobnkgKiB3aWR0aCArIG54KSAqIDQgKyBjXTtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG5ld0RhdGFbKHkgKiB3aWR0aCArIHgpICogNCArIGNdID0gc3VtIC8gY291bnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBDb3B5IHRoZSBuZXcgZGF0YSBiYWNrXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGRhdGFbaV0gPSBuZXdEYXRhW2ldOyAgICAgLy8gUlxuICAgIGRhdGFbaSArIDFdID0gbmV3RGF0YVtpICsgMV07IC8vIEdcbiAgICBkYXRhW2kgKyAyXSA9IG5ld0RhdGFbaSArIDJdOyAvLyBCXG4gICAgLy8gS2VlcCBvcmlnaW5hbCBhbHBoYVxuICB9XG4gIFxuICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG59XG5cbi8qKlxuICogQXBwbHkgYXV0b21hdGljIGNvbG9yIGNvcnJlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QXV0b0NvbG9yQ29ycmVjdGlvbihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBpZiAoIWN0eCkgdGhyb3cgbmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gIFxuICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBoaXN0b2dyYW1cbiAgY29uc3QgaGlzdG9ncmFtID0ge1xuICAgIHI6IG5ldyBBcnJheSgyNTYpLmZpbGwoMCksXG4gICAgZzogbmV3IEFycmF5KDI1NikuZmlsbCgwKSxcbiAgICBiOiBuZXcgQXJyYXkoMjU2KS5maWxsKDApXG4gIH07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBoaXN0b2dyYW0ucltkYXRhW2ldXSsrO1xuICAgIGhpc3RvZ3JhbS5nW2RhdGFbaSArIDFdXSsrO1xuICAgIGhpc3RvZ3JhbS5iW2RhdGFbaSArIDJdXSsrO1xuICB9XG4gIFxuICAvLyBGaW5kIG1pbi9tYXggdmFsdWVzIGZvciBlYWNoIGNoYW5uZWxcbiAgY29uc3QgZ2V0TWluTWF4ID0gKGhpc3Q6IG51bWJlcltdKSA9PiB7XG4gICAgbGV0IG1pbiA9IDAsIG1heCA9IDI1NTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaGlzdFtpXSA+IDApIHsgbWluID0gaTsgYnJlYWs7IH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDI1NTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChoaXN0W2ldID4gMCkgeyBtYXggPSBpOyBicmVhazsgfVxuICAgIH1cbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICB9O1xuICBcbiAgY29uc3Qgck1pbk1heCA9IGdldE1pbk1heChoaXN0b2dyYW0ucik7XG4gIGNvbnN0IGdNaW5NYXggPSBnZXRNaW5NYXgoaGlzdG9ncmFtLmcpO1xuICBjb25zdCBiTWluTWF4ID0gZ2V0TWluTWF4KGhpc3RvZ3JhbS5iKTtcbiAgXG4gIC8vIEFwcGx5IGhpc3RvZ3JhbSBzdHJldGNoaW5nXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGRhdGFbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIFxuICAgICAgKChkYXRhW2ldIC0gck1pbk1heC5taW4pIC8gKHJNaW5NYXgubWF4IC0gck1pbk1heC5taW4pKSAqIDI1NSkpO1xuICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBcbiAgICAgICgoZGF0YVtpICsgMV0gLSBnTWluTWF4Lm1pbikgLyAoZ01pbk1heC5tYXggLSBnTWluTWF4Lm1pbikpICogMjU1KSk7XG4gICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIFxuICAgICAgKChkYXRhW2kgKyAyXSAtIGJNaW5NYXgubWluKSAvIChiTWluTWF4Lm1heCAtIGJNaW5NYXgubWluKSkgKiAyNTUpKTtcbiAgfVxuICBcbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xufVxuXG4vKipcbiAqIEFkdmFuY2VkIGltYWdlIHByb2Nlc3Npbmcgd2l0aCBjb21wcmVoZW5zaXZlIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJbWFnZUFkdmFuY2VkKFxuICBmaWxlOiBGaWxlLFxuICBvcHRpb25zOiBQYXJ0aWFsPEFkdmFuY2VkSW1hZ2VQcm9jZXNzaW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTxBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ1Jlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBjb25zdCBjb25maWcgPSB7IC4uLkRFRkFVTFRfUFJPQ0VTU0lOR19PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gIGNvbnN0IG9wZXJhdGlvbnNBcHBsaWVkOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IEV4dHJhY3Qgb3JpZ2luYWwgbWV0YWRhdGFcbiAgICBjb25zdCBvcmlnaW5hbE1ldGFkYXRhID0gYXdhaXQgZXh0cmFjdEltYWdlTWV0YWRhdGEoZmlsZSk7XG4gICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnbWV0YWRhdGEtZXh0cmFjdGlvbicpO1xuICAgIFxuICAgIC8vIFN0ZXAgMjogVmFsaWRhdGUgZmlsZSB0eXBlIGFuZCBjb252ZXJ0IHRvIGJhc2U2NFxuICAgIGlmICghaXNJbWFnZUZpbGUoZmlsZSkpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yKCdPbmx5IGltYWdlIGZpbGVzIGFyZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIFxuICAgIGxldCBjdXJyZW50SW1hZ2UgPSBhd2FpdCBmaWxlVG9CYXNlNjQoZmlsZSk7XG4gICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnYmFzZTY0LWNvbnZlcnNpb24nKTtcbiAgICBcbiAgICAvLyBTdGVwIDM6IFZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBhd2FpdCB2YWxpZGF0ZUltYWdlRGltZW5zaW9ucyhjdXJyZW50SW1hZ2UpO1xuICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ2RpbWVuc2lvbi12YWxpZGF0aW9uJyk7XG4gICAgXG4gICAgLy8gU3RlcCA0OiBGb3JtYXQgY29udmVyc2lvbiAoaWYgbmVlZGVkKVxuICAgIGxldCB3YXNGb3JtYXRDb252ZXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5vdXRwdXRGb3JtYXQgJiYgb3B0aW9ucy5vdXRwdXRGb3JtYXQgIT09IGZpbGUudHlwZSkge1xuICAgICAgY3VycmVudEltYWdlID0gYXdhaXQgY29udmVydEltYWdlRm9ybWF0KGN1cnJlbnRJbWFnZSwgb3B0aW9ucy5vdXRwdXRGb3JtYXQsIGNvbmZpZy5xdWFsaXR5KTtcbiAgICAgIHdhc0Zvcm1hdENvbnZlcnRlZCA9IHRydWU7XG4gICAgICBvcGVyYXRpb25zQXBwbGllZC5wdXNoKCdmb3JtYXQtY29udmVyc2lvbicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGVwIDU6IENyZWF0ZSBjYW52YXMgZm9yIGFkdmFuY2VkIHByb2Nlc3NpbmdcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIWN0eCkgdGhyb3cgbmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgXG4gICAgLy8gTG9hZCBpbWFnZSBvbnRvIGNhbnZhc1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UnKSk7XG4gICAgICBpbWcuc3JjID0gY3VycmVudEltYWdlO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyBiYXNlZCBvbiByZXNpemUgcmVxdWlyZW1lbnRzXG4gICAgY29uc3QgZmluYWxXaWR0aCA9IGNvbmZpZy50YXJnZXRXaWR0aCB8fCBpbWcud2lkdGg7XG4gICAgY29uc3QgZmluYWxIZWlnaHQgPSBjb25maWcudGFyZ2V0SGVpZ2h0IHx8IGltZy5oZWlnaHQ7XG4gICAgXG4gICAgY2FudmFzLndpZHRoID0gZmluYWxXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZmluYWxIZWlnaHQ7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9ICdoaWdoJztcbiAgICBcbiAgICAvLyBEcmF3IHJlc2l6ZWQgaW1hZ2VcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgZmluYWxXaWR0aCwgZmluYWxIZWlnaHQpO1xuICAgIFxuICAgIGNvbnN0IHdhc1Jlc2l6ZWQgPSBpbWcud2lkdGggIT09IGZpbmFsV2lkdGggfHwgaW1nLmhlaWdodCAhPT0gZmluYWxIZWlnaHQ7XG4gICAgaWYgKHdhc1Jlc2l6ZWQpIHtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ3Jlc2l6ZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGVwIDY6IEFwcGx5IGFkdmFuY2VkIHByb2Nlc3NpbmdcbiAgICBsZXQgd2FzU2hhcnBlbmVkID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlU2hhcnBlbmluZyAmJiB3YXNSZXNpemVkKSB7XG4gICAgICBhcHBseVNoYXJwZW5pbmdGaWx0ZXIoY2FudmFzLCAwLjMpO1xuICAgICAgd2FzU2hhcnBlbmVkID0gdHJ1ZTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ3NoYXJwZW5pbmcnKTtcbiAgICB9XG4gICAgXG4gICAgbGV0IGhhZE5vaXNlUmVkdWN0aW9uID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMubm9pc2VSZWR1Y3Rpb24gJiYgb3B0aW9ucy5ub2lzZVJlZHVjdGlvbiA+IDApIHtcbiAgICAgIGFwcGx5Tm9pc2VSZWR1Y3Rpb24oY2FudmFzLCBvcHRpb25zLm5vaXNlUmVkdWN0aW9uKTtcbiAgICAgIGhhZE5vaXNlUmVkdWN0aW9uID0gdHJ1ZTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ25vaXNlLXJlZHVjdGlvbicpO1xuICAgIH1cbiAgICBcbiAgICBpZiAob3B0aW9ucy5hdXRvQ29sb3JDb3JyZWN0aW9uKSB7XG4gICAgICBhcHBseUF1dG9Db2xvckNvcnJlY3Rpb24oY2FudmFzKTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ2NvbG9yLWNvcnJlY3Rpb24nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RlcCA3OiBDb252ZXJ0IGJhY2sgdG8gZGF0YSBVUkxcbiAgICBjb25zdCBvdXRwdXRGb3JtYXQgPSBvcHRpb25zLm91dHB1dEZvcm1hdCB8fCBJbWFnZUZvcm1hdC5KUEVHO1xuICAgIGxldCBwcm9jZXNzZWRJbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwob3V0cHV0Rm9ybWF0LCBjb25maWcucXVhbGl0eSk7XG4gICAgXG4gICAgLy8gU3RlcCA4OiBDb21wcmVzcyBpZiBuZWVkZWRcbiAgICBsZXQgd2FzQ29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByb2Nlc3NlZFNpemUgPSBnZXRCYXNlNjRTaXplKHByb2Nlc3NlZEltYWdlKTtcbiAgICBjb25zdCB0YXJnZXRTaXplQnl0ZXMgPSBjb25maWcubWF4U2l6ZUtCICogMTAyNDtcbiAgICBcbiAgICBpZiAocHJvY2Vzc2VkU2l6ZSA+IHRhcmdldFNpemVCeXRlcykge1xuICAgICAgcHJvY2Vzc2VkSW1hZ2UgPSBhd2FpdCBjb21wcmVzc0Jhc2U2NChwcm9jZXNzZWRJbWFnZSwgY29uZmlnLm1heFNpemVLQik7XG4gICAgICB3YXNDb21wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ2NvbXByZXNzaW9uJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0ZXAgOTogR2VuZXJhdGUgZmluYWwgbWV0YWRhdGFcbiAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSBhd2FpdCBnZXRJbWFnZURpbWVuc2lvbnMocHJvY2Vzc2VkSW1hZ2UpO1xuICAgIGNvbnN0IGZpbmFsU2l6ZSA9IGdldEJhc2U2NFNpemUocHJvY2Vzc2VkSW1hZ2UpO1xuICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBcbiAgICBjb25zdCBmaW5hbE1ldGFkYXRhOiBJbWFnZU1ldGFkYXRhID0ge1xuICAgICAgZm9ybWF0OiBvdXRwdXRGb3JtYXQsXG4gICAgICBkaW1lbnNpb25zOiBmaW5hbERpbWVuc2lvbnMsXG4gICAgICBzaXplOiBmaW5hbFNpemVcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBwcm9jZXNzZWRJbWFnZSxcbiAgICAgIG9yaWdpbmFsTWV0YWRhdGEsXG4gICAgICBmaW5hbE1ldGFkYXRhLFxuICAgICAgcHJvY2Vzc2luZ01ldGFkYXRhOiB7XG4gICAgICAgIHdhc1Jlc2l6ZWQsXG4gICAgICAgIHdhc0NvbXByZXNzZWQsXG4gICAgICAgIHdhc0Zvcm1hdENvbnZlcnRlZCxcbiAgICAgICAgd2FzU2hhcnBlbmVkLFxuICAgICAgICBoYWROb2lzZVJlZHVjdGlvbixcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogb3JpZ2luYWxNZXRhZGF0YS5zaXplIC8gZmluYWxTaXplLFxuICAgICAgICBwcm9jZXNzaW5nVGltZSxcbiAgICAgICAgb3BlcmF0aW9uc0FwcGxpZWRcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpbGVUeXBlTm90U3VwcG9ydGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBGaWxlVG9vTGFyZ2VFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENvbXByZXNzaW9uRmFpbGVkRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBJbWFnZURpbWVuc2lvbkVycm9yIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgSW1hZ2VQcm9jZXNzaW5nRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoXG4gICAgICAnVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgYWR2YW5jZWQgaW1hZ2UgcHJvY2Vzc2luZycsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQmF0Y2ggcHJvY2VzcyBtdWx0aXBsZSBpbWFnZXMgd2l0aCBwcm9ncmVzcyB0cmFja2luZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ltYWdlc0luQmF0Y2goXG4gIGZpbGVzOiBGaWxlW10sXG4gIG9wdGlvbnM6IFBhcnRpYWw8QWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdPcHRpb25zPiA9IHt9LFxuICBvblByb2dyZXNzPzogKGNvbXBsZXRlZDogbnVtYmVyLCB0b3RhbDogbnVtYmVyLCBjdXJyZW50RmlsZTogc3RyaW5nKSA9PiB2b2lkXG4pOiBQcm9taXNlPEFkdmFuY2VkSW1hZ2VQcm9jZXNzaW5nUmVzdWx0W10+IHtcbiAgY29uc3QgcmVzdWx0czogQWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdSZXN1bHRbXSA9IFtdO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tpXTtcbiAgICBvblByb2dyZXNzPy4oaSwgZmlsZXMubGVuZ3RoLCBmaWxlLm5hbWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzSW1hZ2VBZHZhbmNlZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGb3IgYmF0Y2ggcHJvY2Vzc2luZywgd2UgbWlnaHQgd2FudCB0byBjb250aW51ZSB3aXRoIG90aGVyIGZpbGVzXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyAke2ZpbGUubmFtZX06YCwgZXJyb3IpO1xuICAgICAgLy8gWW91IGNvdWxkIHB1c2ggYSBmYWlsZWQgcmVzdWx0IG9yIHNraXAsIGRlcGVuZGluZyBvbiByZXF1aXJlbWVudHNcbiAgICB9XG4gIH1cbiAgXG4gIG9uUHJvZ3Jlc3M/LihmaWxlcy5sZW5ndGgsIGZpbGVzLmxlbmd0aCwgJ0NvbXBsZXRlJyk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBpbWFnZSB0aHVtYm5haWwgd2l0aCBjb25zaXN0ZW50IGRpbWVuc2lvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUltYWdlVGh1bWJuYWlsKFxuICBmaWxlOiBGaWxlLFxuICBzaXplOiBudW1iZXIgPSAxNTAsXG4gIHF1YWxpdHk6IG51bWJlciA9IDAuOFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgaW1hZ2VVcmwgPSBhd2FpdCBmaWxlVG9CYXNlNjQoZmlsZSk7XG4gIFxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkaW1lbnNpb25zIHRvIG1haW50YWluIGFzcGVjdCByYXRpb1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGltZy53aWR0aCAvIGltZy5oZWlnaHQ7XG4gICAgICAgIGxldCB3aWR0aCA9IHNpemU7XG4gICAgICAgIGxldCBoZWlnaHQgPSBzaXplO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvID4gMSkge1xuICAgICAgICAgIGhlaWdodCA9IHNpemUgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aCA9IHNpemUgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9ICdoaWdoJztcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGh1bWJuYWlsVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkpO1xuICAgICAgICByZXNvbHZlKHRodW1ibmFpbFVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIHRodW1ibmFpbCcsXG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSBmb3IgdGh1bWJuYWlsIGNyZWF0aW9uJykpO1xuICAgIH07XG4gICAgXG4gICAgaW1nLnNyYyA9IGltYWdlVXJsO1xuICB9KTtcbn0iXSwibmFtZXMiOlsiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsIkRFRkFVTFRfUFJPQ0VTU0lOR19PUFRJT05TIiwiRmlsZVRvb0xhcmdlRXJyb3IiLCJGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yIiwiSW1hZ2VEaW1lbnNpb25FcnJvciIsIkltYWdlRm9ybWF0IiwiSW1hZ2VQcm9jZXNzaW5nRXJyb3IiLCJhcHBseUF1dG9Db2xvckNvcnJlY3Rpb24iLCJhcHBseU5vaXNlUmVkdWN0aW9uIiwiYXBwbHlTaGFycGVuaW5nRmlsdGVyIiwiY29tcHJlc3NCYXNlNjQiLCJjb252ZXJ0SW1hZ2VGb3JtYXQiLCJjcmVhdGVJbWFnZVRodW1ibmFpbCIsImV4dHJhY3RJbWFnZU1ldGFkYXRhIiwiZmlsZVRvQmFzZTY0IiwiZ2V0QmFzZTY0U2l6ZSIsImdldEltYWdlRGltZW5zaW9ucyIsImlzSW1hZ2VGaWxlIiwicHJvY2Vzc0ltYWdlQWR2YW5jZWQiLCJwcm9jZXNzSW1hZ2VGb3JUcnlvbiIsInByb2Nlc3NJbWFnZXNJbkJhdGNoIiwicHJvY2Vzc1RyeW9uSW1hZ2VzIiwicmVzaXplSW1hZ2VUbzEwMjR4MTUzNiIsInZhbGlkYXRlSW1hZ2VEaW1lbnNpb25zIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcmlnaW5hbEVycm9yIiwibmFtZSIsIndpZHRoIiwiaGVpZ2h0IiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJtYXhTaXplS0IiLCJxdWFsaXR5IiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImltYWdlVXJsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbWciLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwib25sb2FkIiwib25lcnJvciIsInNyYyIsIm9wdGlvbnMiLCJjb25maWciLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiYXNwZWN0UmF0aW8iLCJ0YXJnZXRBc3BlY3RSYXRpbyIsIk1hdGgiLCJyb3VuZCIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsImltYWdlU21vb3RoaW5nUXVhbGl0eSIsImRyYXdJbWFnZSIsInJlc2l6ZWRJbWFnZVVybCIsInRvRGF0YVVSTCIsImVycm9yIiwiU3RyaW5nIiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsImRpbWVuc2lvbnMiLCJiYXNlNjQiLCJiYXNlNjREYXRhIiwic3BsaXQiLCJhdG9iIiwibGVuZ3RoIiwiZmlsZSIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJvcmlnaW5hbEJhc2U2NCIsIm9yaWdpbmFsU2l6ZSIsInNpemUiLCJvcmlnaW5hbERpbWVuc2lvbnMiLCJyZXNpemVkSW1hZ2UiLCJmaW5hbERpbWVuc2lvbnMiLCJwcm9jZXNzZWRJbWFnZSIsIndhc0NvbXByZXNzZWQiLCJyZXNpemVkU2l6ZSIsInRhcmdldFNpemVCeXRlcyIsImZpbmFsU2l6ZSIsInByb2Nlc3NpbmdUaW1lIiwibWV0YWRhdGEiLCJ3YXNSZXNpemVkIiwiY29tcHJlc3Npb25SYXRpbyIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwibW9kZWxJbWFnZVJlc3VsdCIsImFwcGFyZWxJbWFnZVJlc3VsdHMiLCJhbGwiLCJtYXAiLCJmb3JtYXQiLCJ0eXBlIiwiZGF0ZUNyZWF0ZWQiLCJsYXN0TW9kaWZpZWQiLCJ1bmRlZmluZWQiLCJ0YXJnZXRGb3JtYXQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNvbnZlcnRlZEltYWdlVXJsIiwic3RyZW5ndGgiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwic2hhcnBlbktlcm5lbCIsIm5ld0RhdGEiLCJVaW50OENsYW1wZWRBcnJheSIsInkiLCJ4IiwiYyIsInN1bSIsImt5Iiwia3giLCJwaXhlbEluZGV4Iiwia2VybmVsSW5kZXgiLCJtYXgiLCJtaW4iLCJpIiwicHV0SW1hZ2VEYXRhIiwicmFkaXVzIiwiY2VpbCIsImNvdW50IiwiZHkiLCJkeCIsIm54IiwibnkiLCJoaXN0b2dyYW0iLCJyIiwiQXJyYXkiLCJmaWxsIiwiZyIsImIiLCJnZXRNaW5NYXgiLCJoaXN0Iiwick1pbk1heCIsImdNaW5NYXgiLCJiTWluTWF4Iiwib3BlcmF0aW9uc0FwcGxpZWQiLCJvcmlnaW5hbE1ldGFkYXRhIiwicHVzaCIsImN1cnJlbnRJbWFnZSIsIndhc0Zvcm1hdENvbnZlcnRlZCIsIm91dHB1dEZvcm1hdCIsImZpbmFsV2lkdGgiLCJmaW5hbEhlaWdodCIsIndhc1NoYXJwZW5lZCIsImVuYWJsZVNoYXJwZW5pbmciLCJoYWROb2lzZVJlZHVjdGlvbiIsIm5vaXNlUmVkdWN0aW9uIiwiYXV0b0NvbG9yQ29ycmVjdGlvbiIsInByb2Nlc3NlZFNpemUiLCJmaW5hbE1ldGFkYXRhIiwicHJvY2Vzc2luZ01ldGFkYXRhIiwiZmlsZXMiLCJvblByb2dyZXNzIiwicmVzdWx0cyIsInJlc3VsdCIsImNvbnNvbGUiLCJ0aHVtYm5haWxVcmwiXSwibWFwcGluZ3MiOiJBQUFBLGtEQUFrRDtBQUNsRCxrRUFBa0U7Ozs7Ozs7Ozs7OztJQWVoRUEsc0JBQXNCO2VBQXRCQSw2QkFBc0I7O0lBdURYQywwQkFBMEI7ZUFBMUJBOztJQXJEWEMsaUJBQWlCO2VBQWpCQSx3QkFBaUI7O0lBRGpCQyx5QkFBeUI7ZUFBekJBLGdDQUF5Qjs7SUE0QmRDLG1CQUFtQjtlQUFuQkE7O0lBcUNEQyxXQUFXO2VBQVhBOztJQS9DQ0Msb0JBQW9CO2VBQXBCQTs7SUEyaEJHQyx3QkFBd0I7ZUFBeEJBOztJQWxEQUMsbUJBQW1CO2VBQW5CQTs7SUE3Q0FDLHFCQUFxQjtlQUFyQkE7O0lBaGRkQyxjQUFjO2VBQWRBLHFCQUFjOztJQTZaTUMsa0JBQWtCO2VBQWxCQTs7SUFtWEFDLG9CQUFvQjtlQUFwQkE7O0lBcFlBQyxvQkFBb0I7ZUFBcEJBOztJQXhZcEJDLFlBQVk7ZUFBWkEsbUJBQVk7O0lBMlJFQyxhQUFhO2VBQWJBOztJQTFIQUMsa0JBQWtCO2VBQWxCQTs7SUFo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