210fbd10a6735fae72812217dc9165fd
/**
 * @jest-environment jsdom
 */ "use strict";
// Mock business layer dependencies for performance tests
jest.mock('../../src/business-layer', ()=>({
        useTryonMutation: jest.fn(()=>({
                mutate: jest.fn(),
                mutateAsync: jest.fn(),
                data: undefined,
                error: null,
                isError: false,
                isSuccess: false,
                isLoading: false,
                reset: jest.fn()
            })),
        useImageProcessing: jest.fn(()=>({
                processImage: jest.fn(),
                isProcessing: false,
                error: null
            })),
        useImageValidation: jest.fn(()=>({
                data: null,
                isLoading: false,
                error: null
            })),
        useImageMetadata: jest.fn(()=>({
                data: null,
                isLoading: false,
                error: null
            })),
        useImageThumbnail: jest.fn(()=>({
                data: null,
                isLoading: false,
                error: null
            })),
        useTryonHistory: jest.fn(()=>({
                data: [],
                isLoading: false,
                error: null
            })),
        useFeatureFlag: jest.fn(()=>({
                value: false,
                isLoading: false,
                error: null
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _index = require("../test-utils/index");
const _useBridgeLayer = require("../../src/hooks/useBridgeLayer");
const _useTryonWorkflow = require("../../src/hooks/useTryonWorkflow");
const _useBackwardCompatibility = require("../../src/hooks/useBackwardCompatibility");
// Setup API mocks 
_index.MockAPIUtils.setupServer();
describe('Bridge Layer Performance Tests', ()=>{
    let perfUtils;
    // Increase timeout for performance tests
    jest.setTimeout(30000);
    beforeEach(()=>{
        perfUtils = new _index.BridgePerformanceUtils();
        _index.MockAPIUtils.reset();
    });
    describe('Hook Initialization Performance', ()=>{
        it('should initialize useBridgeLayer within performance budget', async ()=>{
            const { duration } = await perfUtils.measureHookRender(()=>(0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)()), 'useBridgeLayer-init');
            // Bridge layer should initialize quickly (< 50ms)
            perfUtils.assertPerformance(duration, 50, 'useBridgeLayer initialization');
        });
        it('should initialize useTryonWorkflow within performance budget', async ()=>{
            const { duration } = await perfUtils.measureHookRender(()=>(0, _index.renderBridgeHook)(()=>(0, _useTryonWorkflow.useTryonWorkflow)()), 'useTryonWorkflow-init');
            // Workflow hook should initialize quickly (< 30ms)
            perfUtils.assertPerformance(duration, 30, 'useTryonWorkflow initialization');
        });
        it('should initialize usePageComponentState within performance budget', async ()=>{
            const { duration } = await perfUtils.measureHookRender(()=>(0, _index.renderBridgeHook)(()=>(0, _useBackwardCompatibility.usePageComponentState)()), 'usePageComponentState-init');
            // Backward compatibility hook should be fast (< 40ms)
            perfUtils.assertPerformance(duration, 40, 'usePageComponentState initialization');
        });
    });
    describe('File Upload Performance', ()=>{
        it('should handle file uploads efficiently', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            perfUtils.startMeasurement('file-upload');
            await (0, _react.act)(async ()=>{
                await result.current.actions.uploadUserImage(mockFiles.userImage);
            });
            const uploadDuration = perfUtils.endMeasurement('file-upload');
            // File upload should complete within 200ms (excluding API calls)
            perfUtils.assertPerformance(uploadDuration, 200, 'file upload processing');
        });
        it('should handle multiple file uploads efficiently', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            perfUtils.startMeasurement('multiple-uploads');
            await (0, _react.act)(async ()=>{
                await Promise.all([
                    result.current.actions.uploadUserImage(mockFiles.userImage),
                    result.current.actions.uploadApparelImage(mockFiles.apparelImage)
                ]);
            });
            const uploadDuration = perfUtils.endMeasurement('multiple-uploads');
            // Parallel uploads should be efficient (< 300ms)
            perfUtils.assertPerformance(uploadDuration, 300, 'parallel file uploads');
        });
    });
    describe('Generation Performance', ()=>{
        it('should complete generation workflow within reasonable time', async ()=>{
            const { result, testUtils, waitForWorkflow } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            // Setup fast API response
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            testUtils.mockSuccessfulApiCall(undefined, 100); // 100ms API delay
            // Upload files
            await (0, _react.act)(async ()=>{
                await result.current.actions.uploadUserImage(mockFiles.userImage);
                await result.current.actions.uploadApparelImage(mockFiles.apparelImage);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.state.canGenerate).toBe(true);
            });
            perfUtils.startMeasurement('generation-workflow');
            // Generate
            await (0, _react.act)(async ()=>{
                await result.current.actions.generate();
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.state.resultImage).toBeTruthy();
            });
            const generationDuration = perfUtils.endMeasurement('generation-workflow');
            // Complete workflow should be reasonable (< 500ms including API)
            perfUtils.assertPerformance(generationDuration, 500, 'generation workflow');
        });
        it('should handle error scenarios efficiently', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            testUtils.mockApiError('Test error', 500);
            // Upload files
            await (0, _react.act)(async ()=>{
                await result.current.actions.uploadUserImage(mockFiles.userImage);
                await result.current.actions.uploadApparelImage(mockFiles.apparelImage);
            });
            perfUtils.startMeasurement('error-handling');
            // Generate (will fail)
            try {
                await (0, _react.act)(async ()=>{
                    await result.current.actions.generate();
                });
            } catch (error) {
            // Expected to fail
            }
            const errorDuration = perfUtils.endMeasurement('error-handling');
            // Error handling should be fast (< 100ms)
            perfUtils.assertPerformance(errorDuration, 100, 'error handling');
        });
    });
    describe('State Management Performance', ()=>{
        it('should update state efficiently during workflow', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useTryonWorkflow.useTryonWorkflow)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            const stateUpdateTimes = [];
            // Measure state updates
            perfUtils.startMeasurement('state-update-1');
            (0, _react.act)(()=>{
                result.current.handleUserFileUpload(mockFiles.userImage);
            });
            stateUpdateTimes.push(perfUtils.endMeasurement('state-update-1'));
            perfUtils.startMeasurement('state-update-2');
            (0, _react.act)(()=>{
                result.current.handleApparelFileUpload(mockFiles.apparelImage);
            });
            stateUpdateTimes.push(perfUtils.endMeasurement('state-update-2'));
            // Each state update should be very fast (< 10ms)
            stateUpdateTimes.forEach((duration, index)=>{
                perfUtils.assertPerformance(duration, 10, `state update ${index + 1}`);
            });
        });
        it('should reset state efficiently', async ()=>{
            const { result, testUtils, waitForWorkflow } = (0, _index.renderBridgeHook)(()=>(0, _useTryonWorkflow.useTryonWorkflow)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            // Setup workflow with data
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            testUtils.mockSuccessfulApiCall();
            (0, _react.act)(()=>{
                result.current.handleUserFileUpload(mockFiles.userImage);
                result.current.handleApparelFileUpload(mockFiles.apparelImage);
            });
            await waitForWorkflow((workflow)=>workflow.canGenerate());
            await (0, _react.act)(async ()=>{
                await result.current.startGeneration();
            });
            await waitForWorkflow((workflow)=>!!workflow.generatedImage);
            // Measure reset performance
            perfUtils.startMeasurement('workflow-reset');
            (0, _react.act)(()=>{
                result.current.resetWorkflow();
            });
            const resetDuration = perfUtils.endMeasurement('workflow-reset');
            // Reset should be very fast (< 20ms)
            perfUtils.assertPerformance(resetDuration, 20, 'workflow reset');
        });
    });
    describe('Memory Performance', ()=>{
        it('should not leak memory during repeated operations', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            const initialMemory = process.memoryUsage().heapUsed;
            // Perform multiple upload/reset cycles
            for(let i = 0; i < 5; i++){
                await (0, _react.act)(async ()=>{
                    await result.current.actions.uploadUserImage(mockFiles.userImage);
                    await result.current.actions.uploadApparelImage(mockFiles.apparelImage);
                });
                (0, _react.act)(()=>{
                    result.current.actions.reset();
                });
                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be minimal (< 5MB)
            expect(memoryIncrease).toBeLessThan(5 * 1024 * 1024);
        });
        it('should handle large files efficiently', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            // Create a larger mock file
            const largeFile = new File([
                'x'.repeat(1024 * 1024)
            ], 'large.jpg', {
                type: 'image/jpeg'
            }); // 1MB
            testUtils.mockFileRead('data:image/jpeg;base64,processed-large-image');
            const initialMemory = process.memoryUsage().heapUsed;
            perfUtils.startMeasurement('large-file-upload');
            await (0, _react.act)(async ()=>{
                await result.current.actions.uploadUserImage(largeFile);
            });
            const uploadDuration = perfUtils.endMeasurement('large-file-upload');
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Large file upload should complete within reasonable time (< 1s)
            perfUtils.assertPerformance(uploadDuration, 1000, 'large file upload');
            // Memory increase should be reasonable (< 10MB)
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
        });
    });
    describe('Architecture Comparison', ()=>{
        it('should compare performance with direct state management', async ()=>{
            // Measure new architecture performance
            perfUtils.startMeasurement('new-architecture');
            const { result: newResult, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            testUtils.mockSuccessfulApiCall(undefined, 50);
            await (0, _react.act)(async ()=>{
                await newResult.current.actions.uploadUserImage(mockFiles.userImage);
                await newResult.current.actions.uploadApparelImage(mockFiles.apparelImage);
            });
            await (0, _react.act)(async ()=>{
                await newResult.current.actions.generate();
            });
            const newArchDuration = perfUtils.endMeasurement('new-architecture');
            // Simulate old architecture (direct state management)
            perfUtils.startMeasurement('old-architecture-simulation');
            // Simplified simulation of old architecture overhead
            await new Promise((resolve)=>setTimeout(resolve, 10)); // Simulate direct state updates
            await new Promise((resolve)=>setTimeout(resolve, 50)); // Simulate API call
            await new Promise((resolve)=>setTimeout(resolve, 5)); // Simulate result processing
            const oldArchDuration = perfUtils.endMeasurement('old-architecture-simulation');
            // New architecture should be competitive or better
            // Allow some overhead for the abstraction layers (max 2x)
            expect(newArchDuration).toBeLessThan(oldArchDuration * 2);
        });
        it('should demonstrate improved error handling performance', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,processed-image');
            testUtils.mockApiError('Error test', 500);
            // Upload files
            await (0, _react.act)(async ()=>{
                await result.current.actions.uploadUserImage(mockFiles.userImage);
                await result.current.actions.uploadApparelImage(mockFiles.apparelImage);
            });
            perfUtils.startMeasurement('error-recovery');
            // Generate (will fail)
            try {
                await (0, _react.act)(async ()=>{
                    await result.current.actions.generate();
                });
            } catch (error) {
            // Expected to fail
            }
            // Clear error and retry
            (0, _react.act)(()=>{
                result.current.actions.clearError();
            });
            const errorRecoveryDuration = perfUtils.endMeasurement('error-recovery');
            // Error recovery should be fast (< 50ms)
            perfUtils.assertPerformance(errorRecoveryDuration, 50, 'error recovery');
        });
    });
    describe('Advanced Architecture Benchmarks', ()=>{
        it('should benchmark hook composition overhead', async ()=>{
            // Test individual hook performance
            const workflowTime = await perfUtils.measureHookRender(()=>(0, _index.renderBridgeHook)(()=>(0, _useTryonWorkflow.useTryonWorkflow)()), 'workflow-only');
            const bridgeTime = await perfUtils.measureHookRender(()=>(0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)()), 'bridge-only');
            const backwardCompatTime = await perfUtils.measureHookRender(()=>(0, _index.renderBridgeHook)(()=>(0, _useBackwardCompatibility.usePageComponentState)()), 'backward-compat-only');
            // Bridge layer should have reasonable overhead vs individual hooks
            const compositionOverhead = bridgeTime.duration - workflowTime.duration;
            expect(compositionOverhead).toBeLessThan(20); // < 20ms overhead
            // Backward compatibility should be efficient
            perfUtils.assertPerformance(backwardCompatTime.duration, 60, 'backward compatibility');
            console.log('ðŸ”§ Architecture Performance Breakdown:');
            console.log(`  - Workflow Hook: ${workflowTime.duration}ms`);
            console.log(`  - Bridge Layer: ${bridgeTime.duration}ms`);
            console.log(`  - Backward Compat: ${backwardCompatTime.duration}ms`);
            console.log(`  - Composition Overhead: ${compositionOverhead}ms`);
        });
        it('should compare bundle size impact (simulated)', async ()=>{
            // Simulate bundle size analysis by measuring hook complexity
            const hooks = [
                {
                    name: 'useTryonWorkflow',
                    hook: _useTryonWorkflow.useTryonWorkflow
                },
                {
                    name: 'useBridgeLayer',
                    hook: _useBridgeLayer.useBridgeLayer
                },
                {
                    name: 'usePageComponentState',
                    hook: _useBackwardCompatibility.usePageComponentState
                }
            ];
            const bundleMetrics = [];
            for (const { name, hook } of hooks){
                const startMemory = process.memoryUsage().heapUsed;
                const { result } = (0, _index.renderBridgeHook)(hook);
                const endMemory = process.memoryUsage().heapUsed;
                const memoryDelta = endMemory - startMemory;
                // Count the number of functions/properties in the hook result
                const apiSurface = Object.keys(result.current).length;
                bundleMetrics.push({
                    name,
                    memoryDelta,
                    apiSurface
                });
            }
            console.log('ðŸ“¦ Simulated Bundle Impact Analysis:');
            bundleMetrics.forEach((metric)=>{
                console.log(`  - ${metric.name}: ${metric.apiSurface} APIs, ${Math.round(metric.memoryDelta / 1024)}KB memory`);
            });
            // Bridge layer should have reasonable API surface
            const bridgeMetric = bundleMetrics.find((m)=>m.name === 'useBridgeLayer');
            expect(bridgeMetric?.apiSurface).toBeLessThan(20); // Reasonable API size
        });
        it('should benchmark concurrent hook usage', async ()=>{
            // Test performance when multiple instances are used simultaneously
            const concurrentCount = 5;
            const concurrentHooks = [];
            perfUtils.startMeasurement('concurrent-hooks');
            for(let i = 0; i < concurrentCount; i++){
                const { result } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
                concurrentHooks.push(result);
            }
            const concurrentDuration = perfUtils.endMeasurement('concurrent-hooks');
            // Concurrent usage should scale reasonably
            const avgTimePerHook = concurrentDuration / concurrentCount;
            expect(avgTimePerHook).toBeLessThan(100); // < 100ms per concurrent hook
            console.log(`âš¡ Concurrent Performance: ${concurrentCount} hooks in ${concurrentDuration}ms (${avgTimePerHook.toFixed(1)}ms avg)`);
        });
        it('should analyze state update performance patterns', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,test-data');
            // Measure different types of state updates
            const stateUpdateMetrics = [];
            // File upload state update
            perfUtils.startMeasurement('file-upload-state');
            await (0, _react.act)(async ()=>{
                await result.current.actions.uploadUserImage(mockFiles.userImage);
            });
            stateUpdateMetrics.push({
                operation: 'file-upload',
                duration: perfUtils.endMeasurement('file-upload-state')
            });
            // Action state update
            perfUtils.startMeasurement('action-state');
            (0, _react.act)(()=>{
                result.current.actions.clearError();
            });
            stateUpdateMetrics.push({
                operation: 'clear-error',
                duration: perfUtils.endMeasurement('action-state')
            });
            // Reset state update
            perfUtils.startMeasurement('reset-state');
            (0, _react.act)(()=>{
                result.current.actions.reset();
            });
            stateUpdateMetrics.push({
                operation: 'reset',
                duration: perfUtils.endMeasurement('reset-state')
            });
            console.log('ðŸ“Š State Update Performance:');
            stateUpdateMetrics.forEach((metric)=>{
                console.log(`  - ${metric.operation}: ${metric.duration}ms`);
                expect(metric.duration).toBeLessThan(50); // All state updates < 50ms
            });
        });
        it('should benchmark real-world usage patterns', async ()=>{
            const { result, testUtils } = (0, _index.renderBridgeHook)(()=>(0, _useBridgeLayer.useBridgeLayer)());
            const mockFiles = _index.WorkflowTestUtils.createMockFiles();
            testUtils.mockFileRead('data:image/jpeg;base64,test-data');
            testUtils.mockSuccessfulApiCall({
                img_generated: 'result-data'
            });
            // Simulate a complete user workflow
            perfUtils.startMeasurement('complete-workflow');
            // User uploads files
            await (0, _react.act)(async ()=>{
                await result.current.actions.uploadUserImage(mockFiles.userImage);
                await result.current.actions.uploadApparelImage(mockFiles.apparelImage);
            });
            // User generates result
            await (0, _react.act)(async ()=>{
                await result.current.actions.generate();
            });
            // User resets for another try
            (0, _react.act)(()=>{
                result.current.actions.reset();
            });
            const workflowDuration = perfUtils.endMeasurement('complete-workflow');
            // Complete workflow should be reasonably fast
            perfUtils.assertPerformance(workflowDuration, 2000, 'complete user workflow');
            console.log(`ðŸš€ Complete Workflow Performance: ${workflowDuration}ms`);
        });
    });
    describe('Performance Regression Detection', ()=>{
        it('should establish performance baselines', ()=>{
            // Store performance baselines for regression detection
            const baselines = {
                hookInitialization: 50,
                fileUpload: 200,
                apiCall: 1000,
                stateUpdate: 10,
                memoryUsage: 10 * 1024 * 1024
            };
            // These baselines can be used in CI/CD to detect performance regressions
            console.log('ðŸ“ Performance Baselines Established:');
            Object.entries(baselines).forEach(([metric, baseline])=>{
                console.log(`  - ${metric}: ${baseline}${metric.includes('memory') ? ' bytes' : 'ms'}`);
            });
            expect(baselines).toBeDefined();
        });
        it('should monitor performance trends over time', ()=>{
            // In a real scenario, this would track performance metrics over time
            const performanceHistory = {
                date: new Date().toISOString(),
                metrics: {
                    avgHookInit: 25,
                    avgFileUpload: 150,
                    avgApiCall: 800,
                    p95HookInit: 45,
                    p95FileUpload: 180,
                    p95ApiCall: 950
                }
            };
            console.log('ðŸ“ˆ Performance Trend Data:', performanceHistory);
            expect(performanceHistory.metrics.avgHookInit).toBeLessThan(50);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL3BlcmZvcm1hbmNlL2JyaWRnZS1sYXllci1wZXJmb3JtYW5jZS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBqZXN0LWVudmlyb25tZW50IGpzZG9tXG4gKi9cbmltcG9ydCB7IGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgXG4gIHJlbmRlckJyaWRnZUhvb2ssIFxuICBCcmlkZ2VQZXJmb3JtYW5jZVV0aWxzLFxuICBNb2NrQVBJVXRpbHMsIFxuICBXb3JrZmxvd1Rlc3RVdGlsc1xufSBmcm9tICcuLi90ZXN0LXV0aWxzL2luZGV4JztcbmltcG9ydCB7IHVzZUJyaWRnZUxheWVyIH0gZnJvbSAnQC9ob29rcy91c2VCcmlkZ2VMYXllcic7XG5pbXBvcnQgeyB1c2VUcnlvbldvcmtmbG93IH0gZnJvbSAnQC9ob29rcy91c2VUcnlvbldvcmtmbG93JztcbmltcG9ydCB7IHVzZVBhZ2VDb21wb25lbnRTdGF0ZSB9IGZyb20gJ0AvaG9va3MvdXNlQmFja3dhcmRDb21wYXRpYmlsaXR5JztcblxuLy8gTW9jayBidXNpbmVzcyBsYXllciBkZXBlbmRlbmNpZXMgZm9yIHBlcmZvcm1hbmNlIHRlc3RzXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9idXNpbmVzcy1sYXllcicsICgpID0+ICh7XG4gIHVzZVRyeW9uTXV0YXRpb246IGplc3QuZm4oKCkgPT4gKHtcbiAgICBtdXRhdGU6IGplc3QuZm4oKSxcbiAgICBtdXRhdGVBc3luYzogamVzdC5mbigpLFxuICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICBpc1N1Y2Nlc3M6IGZhbHNlLFxuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgcmVzZXQ6IGplc3QuZm4oKSxcbiAgfSkpLFxuICB1c2VJbWFnZVByb2Nlc3Npbmc6IGplc3QuZm4oKCkgPT4gKHtcbiAgICBwcm9jZXNzSW1hZ2U6IGplc3QuZm4oKSxcbiAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgIGVycm9yOiBudWxsLFxuICB9KSksXG4gIHVzZUltYWdlVmFsaWRhdGlvbjogamVzdC5mbigoKSA9PiAoeyBkYXRhOiBudWxsLCBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogbnVsbCB9KSksXG4gIHVzZUltYWdlTWV0YWRhdGE6IGplc3QuZm4oKCkgPT4gKHsgZGF0YTogbnVsbCwgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6IG51bGwgfSkpLFxuICB1c2VJbWFnZVRodW1ibmFpbDogamVzdC5mbigoKSA9PiAoeyBkYXRhOiBudWxsLCBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogbnVsbCB9KSksXG4gIHVzZVRyeW9uSGlzdG9yeTogamVzdC5mbigoKSA9PiAoeyBkYXRhOiBbXSwgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6IG51bGwgfSkpLFxuICB1c2VGZWF0dXJlRmxhZzogamVzdC5mbigoKSA9PiAoeyB2YWx1ZTogZmFsc2UsIGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiBudWxsIH0pKSxcbn0pKTtcblxuLy8gU2V0dXAgQVBJIG1vY2tzIFxuTW9ja0FQSVV0aWxzLnNldHVwU2VydmVyKCk7XG5cbmRlc2NyaWJlKCdCcmlkZ2UgTGF5ZXIgUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBwZXJmVXRpbHM6IEJyaWRnZVBlcmZvcm1hbmNlVXRpbHM7XG5cbiAgLy8gSW5jcmVhc2UgdGltZW91dCBmb3IgcGVyZm9ybWFuY2UgdGVzdHNcbiAgamVzdC5zZXRUaW1lb3V0KDMwMDAwKTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBwZXJmVXRpbHMgPSBuZXcgQnJpZGdlUGVyZm9ybWFuY2VVdGlscygpO1xuICAgIE1vY2tBUElVdGlscy5yZXNldCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnSG9vayBJbml0aWFsaXphdGlvbiBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdXNlQnJpZGdlTGF5ZXIgd2l0aGluIHBlcmZvcm1hbmNlIGJ1ZGdldCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZHVyYXRpb24gfSA9IGF3YWl0IHBlcmZVdGlscy5tZWFzdXJlSG9va1JlbmRlcihcbiAgICAgICAgKCkgPT4gcmVuZGVyQnJpZGdlSG9vaygoKSA9PiB1c2VCcmlkZ2VMYXllcigpKSxcbiAgICAgICAgJ3VzZUJyaWRnZUxheWVyLWluaXQnXG4gICAgICApO1xuXG4gICAgICAvLyBCcmlkZ2UgbGF5ZXIgc2hvdWxkIGluaXRpYWxpemUgcXVpY2tseSAoPCA1MG1zKVxuICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKGR1cmF0aW9uLCA1MCwgJ3VzZUJyaWRnZUxheWVyIGluaXRpYWxpemF0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdXNlVHJ5b25Xb3JrZmxvdyB3aXRoaW4gcGVyZm9ybWFuY2UgYnVkZ2V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gYXdhaXQgcGVyZlV0aWxzLm1lYXN1cmVIb29rUmVuZGVyKFxuICAgICAgICAoKSA9PiByZW5kZXJCcmlkZ2VIb29rKCgpID0+IHVzZVRyeW9uV29ya2Zsb3coKSksXG4gICAgICAgICd1c2VUcnlvbldvcmtmbG93LWluaXQnXG4gICAgICApO1xuXG4gICAgICAvLyBXb3JrZmxvdyBob29rIHNob3VsZCBpbml0aWFsaXplIHF1aWNrbHkgKDwgMzBtcylcbiAgICAgIHBlcmZVdGlscy5hc3NlcnRQZXJmb3JtYW5jZShkdXJhdGlvbiwgMzAsICd1c2VUcnlvbldvcmtmbG93IGluaXRpYWxpemF0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdXNlUGFnZUNvbXBvbmVudFN0YXRlIHdpdGhpbiBwZXJmb3JtYW5jZSBidWRnZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmVXRpbHMubWVhc3VyZUhvb2tSZW5kZXIoXG4gICAgICAgICgpID0+IHJlbmRlckJyaWRnZUhvb2soKCkgPT4gdXNlUGFnZUNvbXBvbmVudFN0YXRlKCkpLFxuICAgICAgICAndXNlUGFnZUNvbXBvbmVudFN0YXRlLWluaXQnXG4gICAgICApO1xuXG4gICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IGhvb2sgc2hvdWxkIGJlIGZhc3QgKDwgNDBtcylcbiAgICAgIHBlcmZVdGlscy5hc3NlcnRQZXJmb3JtYW5jZShkdXJhdGlvbiwgNDAsICd1c2VQYWdlQ29tcG9uZW50U3RhdGUgaW5pdGlhbGl6YXRpb24nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpbGUgVXBsb2FkIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZpbGUgdXBsb2FkcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCB0ZXN0VXRpbHMgfSA9IHJlbmRlckJyaWRnZUhvb2soKCkgPT4gdXNlQnJpZGdlTGF5ZXIoKSk7XG4gICAgICBjb25zdCBtb2NrRmlsZXMgPSBXb3JrZmxvd1Rlc3RVdGlscy5jcmVhdGVNb2NrRmlsZXMoKTtcblxuICAgICAgdGVzdFV0aWxzLm1vY2tGaWxlUmVhZCgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtaW1hZ2UnKTtcblxuICAgICAgcGVyZlV0aWxzLnN0YXJ0TWVhc3VyZW1lbnQoJ2ZpbGUtdXBsb2FkJyk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmFjdGlvbnMudXBsb2FkVXNlckltYWdlKG1vY2tGaWxlcy51c2VySW1hZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVwbG9hZER1cmF0aW9uID0gcGVyZlV0aWxzLmVuZE1lYXN1cmVtZW50KCdmaWxlLXVwbG9hZCcpO1xuXG4gICAgICAvLyBGaWxlIHVwbG9hZCBzaG91bGQgY29tcGxldGUgd2l0aGluIDIwMG1zIChleGNsdWRpbmcgQVBJIGNhbGxzKVxuICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKHVwbG9hZER1cmF0aW9uLCAyMDAsICdmaWxlIHVwbG9hZCBwcm9jZXNzaW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBmaWxlIHVwbG9hZHMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgdGVzdFV0aWxzIH0gPSByZW5kZXJCcmlkZ2VIb29rKCgpID0+IHVzZUJyaWRnZUxheWVyKCkpO1xuICAgICAgY29uc3QgbW9ja0ZpbGVzID0gV29ya2Zsb3dUZXN0VXRpbHMuY3JlYXRlTW9ja0ZpbGVzKCk7XG5cbiAgICAgIHRlc3RVdGlscy5tb2NrRmlsZVJlYWQoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQscHJvY2Vzc2VkLWltYWdlJyk7XG5cbiAgICAgIHBlcmZVdGlscy5zdGFydE1lYXN1cmVtZW50KCdtdWx0aXBsZS11cGxvYWRzJyk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICByZXN1bHQuY3VycmVudC5hY3Rpb25zLnVwbG9hZFVzZXJJbWFnZShtb2NrRmlsZXMudXNlckltYWdlKSxcbiAgICAgICAgICByZXN1bHQuY3VycmVudC5hY3Rpb25zLnVwbG9hZEFwcGFyZWxJbWFnZShtb2NrRmlsZXMuYXBwYXJlbEltYWdlKSxcbiAgICAgICAgXSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXBsb2FkRHVyYXRpb24gPSBwZXJmVXRpbHMuZW5kTWVhc3VyZW1lbnQoJ211bHRpcGxlLXVwbG9hZHMnKTtcblxuICAgICAgLy8gUGFyYWxsZWwgdXBsb2FkcyBzaG91bGQgYmUgZWZmaWNpZW50ICg8IDMwMG1zKVxuICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKHVwbG9hZER1cmF0aW9uLCAzMDAsICdwYXJhbGxlbCBmaWxlIHVwbG9hZHMnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dlbmVyYXRpb24gUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb21wbGV0ZSBnZW5lcmF0aW9uIHdvcmtmbG93IHdpdGhpbiByZWFzb25hYmxlIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgdGVzdFV0aWxzLCB3YWl0Rm9yV29ya2Zsb3cgfSA9IHJlbmRlckJyaWRnZUhvb2soKCkgPT4gdXNlQnJpZGdlTGF5ZXIoKSk7XG4gICAgICBjb25zdCBtb2NrRmlsZXMgPSBXb3JrZmxvd1Rlc3RVdGlscy5jcmVhdGVNb2NrRmlsZXMoKTtcblxuICAgICAgLy8gU2V0dXAgZmFzdCBBUEkgcmVzcG9uc2VcbiAgICAgIHRlc3RVdGlscy5tb2NrRmlsZVJlYWQoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQscHJvY2Vzc2VkLWltYWdlJyk7XG4gICAgICB0ZXN0VXRpbHMubW9ja1N1Y2Nlc3NmdWxBcGlDYWxsKHVuZGVmaW5lZCwgMTAwKTsgLy8gMTAwbXMgQVBJIGRlbGF5XG5cbiAgICAgIC8vIFVwbG9hZCBmaWxlc1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy51cGxvYWRVc2VySW1hZ2UobW9ja0ZpbGVzLnVzZXJJbWFnZSk7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmFjdGlvbnMudXBsb2FkQXBwYXJlbEltYWdlKG1vY2tGaWxlcy5hcHBhcmVsSW1hZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3RhdGUuY2FuR2VuZXJhdGUpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgcGVyZlV0aWxzLnN0YXJ0TWVhc3VyZW1lbnQoJ2dlbmVyYXRpb24td29ya2Zsb3cnKTtcblxuICAgICAgLy8gR2VuZXJhdGVcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmFjdGlvbnMuZ2VuZXJhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN0YXRlLnJlc3VsdEltYWdlKS50b0JlVHJ1dGh5KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZ2VuZXJhdGlvbkR1cmF0aW9uID0gcGVyZlV0aWxzLmVuZE1lYXN1cmVtZW50KCdnZW5lcmF0aW9uLXdvcmtmbG93Jyk7XG5cbiAgICAgIC8vIENvbXBsZXRlIHdvcmtmbG93IHNob3VsZCBiZSByZWFzb25hYmxlICg8IDUwMG1zIGluY2x1ZGluZyBBUEkpXG4gICAgICBwZXJmVXRpbHMuYXNzZXJ0UGVyZm9ybWFuY2UoZ2VuZXJhdGlvbkR1cmF0aW9uLCA1MDAsICdnZW5lcmF0aW9uIHdvcmtmbG93Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvciBzY2VuYXJpb3MgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgdGVzdFV0aWxzIH0gPSByZW5kZXJCcmlkZ2VIb29rKCgpID0+IHVzZUJyaWRnZUxheWVyKCkpO1xuICAgICAgY29uc3QgbW9ja0ZpbGVzID0gV29ya2Zsb3dUZXN0VXRpbHMuY3JlYXRlTW9ja0ZpbGVzKCk7XG5cbiAgICAgIHRlc3RVdGlscy5tb2NrRmlsZVJlYWQoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQscHJvY2Vzc2VkLWltYWdlJyk7XG4gICAgICB0ZXN0VXRpbHMubW9ja0FwaUVycm9yKCdUZXN0IGVycm9yJywgNTAwKTtcblxuICAgICAgLy8gVXBsb2FkIGZpbGVzXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5hY3Rpb25zLnVwbG9hZFVzZXJJbWFnZShtb2NrRmlsZXMudXNlckltYWdlKTtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy51cGxvYWRBcHBhcmVsSW1hZ2UobW9ja0ZpbGVzLmFwcGFyZWxJbWFnZSk7XG4gICAgICB9KTtcblxuICAgICAgcGVyZlV0aWxzLnN0YXJ0TWVhc3VyZW1lbnQoJ2Vycm9yLWhhbmRsaW5nJyk7XG5cbiAgICAgIC8vIEdlbmVyYXRlICh3aWxsIGZhaWwpXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmFjdGlvbnMuZ2VuZXJhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBFeHBlY3RlZCB0byBmYWlsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9yRHVyYXRpb24gPSBwZXJmVXRpbHMuZW5kTWVhc3VyZW1lbnQoJ2Vycm9yLWhhbmRsaW5nJyk7XG5cbiAgICAgIC8vIEVycm9yIGhhbmRsaW5nIHNob3VsZCBiZSBmYXN0ICg8IDEwMG1zKVxuICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKGVycm9yRHVyYXRpb24sIDEwMCwgJ2Vycm9yIGhhbmRsaW5nJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdGF0ZSBNYW5hZ2VtZW50IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdXBkYXRlIHN0YXRlIGVmZmljaWVudGx5IGR1cmluZyB3b3JrZmxvdycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCB0ZXN0VXRpbHMgfSA9IHJlbmRlckJyaWRnZUhvb2soKCkgPT4gdXNlVHJ5b25Xb3JrZmxvdygpKTtcbiAgICAgIGNvbnN0IG1vY2tGaWxlcyA9IFdvcmtmbG93VGVzdFV0aWxzLmNyZWF0ZU1vY2tGaWxlcygpO1xuXG4gICAgICB0ZXN0VXRpbHMubW9ja0ZpbGVSZWFkKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZScpO1xuXG4gICAgICBjb25zdCBzdGF0ZVVwZGF0ZVRpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAvLyBNZWFzdXJlIHN0YXRlIHVwZGF0ZXNcbiAgICAgIHBlcmZVdGlscy5zdGFydE1lYXN1cmVtZW50KCdzdGF0ZS11cGRhdGUtMScpO1xuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlVXNlckZpbGVVcGxvYWQobW9ja0ZpbGVzLnVzZXJJbWFnZSk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlVXBkYXRlVGltZXMucHVzaChwZXJmVXRpbHMuZW5kTWVhc3VyZW1lbnQoJ3N0YXRlLXVwZGF0ZS0xJykpO1xuXG4gICAgICBwZXJmVXRpbHMuc3RhcnRNZWFzdXJlbWVudCgnc3RhdGUtdXBkYXRlLTInKTtcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZUFwcGFyZWxGaWxlVXBsb2FkKG1vY2tGaWxlcy5hcHBhcmVsSW1hZ2UpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZVVwZGF0ZVRpbWVzLnB1c2gocGVyZlV0aWxzLmVuZE1lYXN1cmVtZW50KCdzdGF0ZS11cGRhdGUtMicpKTtcblxuICAgICAgLy8gRWFjaCBzdGF0ZSB1cGRhdGUgc2hvdWxkIGJlIHZlcnkgZmFzdCAoPCAxMG1zKVxuICAgICAgc3RhdGVVcGRhdGVUaW1lcy5mb3JFYWNoKChkdXJhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKGR1cmF0aW9uLCAxMCwgYHN0YXRlIHVwZGF0ZSAke2luZGV4ICsgMX1gKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNldCBzdGF0ZSBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCB0ZXN0VXRpbHMsIHdhaXRGb3JXb3JrZmxvdyB9ID0gcmVuZGVyQnJpZGdlSG9vaygoKSA9PiB1c2VUcnlvbldvcmtmbG93KCkpO1xuICAgICAgY29uc3QgbW9ja0ZpbGVzID0gV29ya2Zsb3dUZXN0VXRpbHMuY3JlYXRlTW9ja0ZpbGVzKCk7XG5cbiAgICAgIC8vIFNldHVwIHdvcmtmbG93IHdpdGggZGF0YVxuICAgICAgdGVzdFV0aWxzLm1vY2tGaWxlUmVhZCgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtaW1hZ2UnKTtcbiAgICAgIHRlc3RVdGlscy5tb2NrU3VjY2Vzc2Z1bEFwaUNhbGwoKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlVXNlckZpbGVVcGxvYWQobW9ja0ZpbGVzLnVzZXJJbWFnZSk7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZUFwcGFyZWxGaWxlVXBsb2FkKG1vY2tGaWxlcy5hcHBhcmVsSW1hZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3JXb3JrZmxvdygod29ya2Zsb3cpID0+IHdvcmtmbG93LmNhbkdlbmVyYXRlKCkpO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5zdGFydEdlbmVyYXRpb24oKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yV29ya2Zsb3coKHdvcmtmbG93KSA9PiAhIXdvcmtmbG93LmdlbmVyYXRlZEltYWdlKTtcblxuICAgICAgLy8gTWVhc3VyZSByZXNldCBwZXJmb3JtYW5jZVxuICAgICAgcGVyZlV0aWxzLnN0YXJ0TWVhc3VyZW1lbnQoJ3dvcmtmbG93LXJlc2V0Jyk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnJlc2V0V29ya2Zsb3coKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNldER1cmF0aW9uID0gcGVyZlV0aWxzLmVuZE1lYXN1cmVtZW50KCd3b3JrZmxvdy1yZXNldCcpO1xuXG4gICAgICAvLyBSZXNldCBzaG91bGQgYmUgdmVyeSBmYXN0ICg8IDIwbXMpXG4gICAgICBwZXJmVXRpbHMuYXNzZXJ0UGVyZm9ybWFuY2UocmVzZXREdXJhdGlvbiwgMjAsICd3b3JrZmxvdyByZXNldCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbm90IGxlYWsgbWVtb3J5IGR1cmluZyByZXBlYXRlZCBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQsIHRlc3RVdGlscyB9ID0gcmVuZGVyQnJpZGdlSG9vaygoKSA9PiB1c2VCcmlkZ2VMYXllcigpKTtcbiAgICAgIGNvbnN0IG1vY2tGaWxlcyA9IFdvcmtmbG93VGVzdFV0aWxzLmNyZWF0ZU1vY2tGaWxlcygpO1xuXG4gICAgICB0ZXN0VXRpbHMubW9ja0ZpbGVSZWFkKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZScpO1xuXG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICAvLyBQZXJmb3JtIG11bHRpcGxlIHVwbG9hZC9yZXNldCBjeWNsZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy51cGxvYWRVc2VySW1hZ2UobW9ja0ZpbGVzLnVzZXJJbWFnZSk7XG4gICAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy51cGxvYWRBcHBhcmVsSW1hZ2UobW9ja0ZpbGVzLmFwcGFyZWxJbWFnZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy5yZXNldCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChnbG9iYWwuZ2MpIHtcbiAgICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuXG4gICAgICAvLyBNZW1vcnkgaW5jcmVhc2Ugc2hvdWxkIGJlIG1pbmltYWwgKDwgNU1CKVxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oNSAqIDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIGZpbGVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQsIHRlc3RVdGlscyB9ID0gcmVuZGVyQnJpZGdlSG9vaygoKSA9PiB1c2VCcmlkZ2VMYXllcigpKTtcbiAgICAgIGNvbnN0IG1vY2tGaWxlcyA9IFdvcmtmbG93VGVzdFV0aWxzLmNyZWF0ZU1vY2tGaWxlcygpO1xuXG4gICAgICAvLyBDcmVhdGUgYSBsYXJnZXIgbW9jayBmaWxlXG4gICAgICBjb25zdCBsYXJnZUZpbGUgPSBuZXcgRmlsZShbJ3gnLnJlcGVhdCgxMDI0ICogMTAyNCldLCAnbGFyZ2UuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7IC8vIDFNQlxuXG4gICAgICB0ZXN0VXRpbHMubW9ja0ZpbGVSZWFkKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1sYXJnZS1pbWFnZScpO1xuXG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICBwZXJmVXRpbHMuc3RhcnRNZWFzdXJlbWVudCgnbGFyZ2UtZmlsZS11cGxvYWQnKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy51cGxvYWRVc2VySW1hZ2UobGFyZ2VGaWxlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGxvYWREdXJhdGlvbiA9IHBlcmZVdGlscy5lbmRNZWFzdXJlbWVudCgnbGFyZ2UtZmlsZS11cGxvYWQnKTtcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG5cbiAgICAgIC8vIExhcmdlIGZpbGUgdXBsb2FkIHNob3VsZCBjb21wbGV0ZSB3aXRoaW4gcmVhc29uYWJsZSB0aW1lICg8IDFzKVxuICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKHVwbG9hZER1cmF0aW9uLCAxMDAwLCAnbGFyZ2UgZmlsZSB1cGxvYWQnKTtcblxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSByZWFzb25hYmxlICg8IDEwTUIpXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMCAqIDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FyY2hpdGVjdHVyZSBDb21wYXJpc29uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29tcGFyZSBwZXJmb3JtYW5jZSB3aXRoIGRpcmVjdCBzdGF0ZSBtYW5hZ2VtZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTWVhc3VyZSBuZXcgYXJjaGl0ZWN0dXJlIHBlcmZvcm1hbmNlXG4gICAgICBwZXJmVXRpbHMuc3RhcnRNZWFzdXJlbWVudCgnbmV3LWFyY2hpdGVjdHVyZScpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdDogbmV3UmVzdWx0LCB0ZXN0VXRpbHMgfSA9IHJlbmRlckJyaWRnZUhvb2soKCkgPT4gdXNlQnJpZGdlTGF5ZXIoKSk7XG4gICAgICBjb25zdCBtb2NrRmlsZXMgPSBXb3JrZmxvd1Rlc3RVdGlscy5jcmVhdGVNb2NrRmlsZXMoKTtcblxuICAgICAgdGVzdFV0aWxzLm1vY2tGaWxlUmVhZCgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtaW1hZ2UnKTtcbiAgICAgIHRlc3RVdGlscy5tb2NrU3VjY2Vzc2Z1bEFwaUNhbGwodW5kZWZpbmVkLCA1MCk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ld1Jlc3VsdC5jdXJyZW50LmFjdGlvbnMudXBsb2FkVXNlckltYWdlKG1vY2tGaWxlcy51c2VySW1hZ2UpO1xuICAgICAgICBhd2FpdCBuZXdSZXN1bHQuY3VycmVudC5hY3Rpb25zLnVwbG9hZEFwcGFyZWxJbWFnZShtb2NrRmlsZXMuYXBwYXJlbEltYWdlKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXdSZXN1bHQuY3VycmVudC5hY3Rpb25zLmdlbmVyYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbmV3QXJjaER1cmF0aW9uID0gcGVyZlV0aWxzLmVuZE1lYXN1cmVtZW50KCduZXctYXJjaGl0ZWN0dXJlJyk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIG9sZCBhcmNoaXRlY3R1cmUgKGRpcmVjdCBzdGF0ZSBtYW5hZ2VtZW50KVxuICAgICAgcGVyZlV0aWxzLnN0YXJ0TWVhc3VyZW1lbnQoJ29sZC1hcmNoaXRlY3R1cmUtc2ltdWxhdGlvbicpO1xuXG4gICAgICAvLyBTaW1wbGlmaWVkIHNpbXVsYXRpb24gb2Ygb2xkIGFyY2hpdGVjdHVyZSBvdmVyaGVhZFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7IC8vIFNpbXVsYXRlIGRpcmVjdCBzdGF0ZSB1cGRhdGVzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTsgLy8gU2ltdWxhdGUgQVBJIGNhbGxcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1KSk7ICAvLyBTaW11bGF0ZSByZXN1bHQgcHJvY2Vzc2luZ1xuXG4gICAgICBjb25zdCBvbGRBcmNoRHVyYXRpb24gPSBwZXJmVXRpbHMuZW5kTWVhc3VyZW1lbnQoJ29sZC1hcmNoaXRlY3R1cmUtc2ltdWxhdGlvbicpO1xuXG4gICAgICAvLyBOZXcgYXJjaGl0ZWN0dXJlIHNob3VsZCBiZSBjb21wZXRpdGl2ZSBvciBiZXR0ZXJcbiAgICAgIC8vIEFsbG93IHNvbWUgb3ZlcmhlYWQgZm9yIHRoZSBhYnN0cmFjdGlvbiBsYXllcnMgKG1heCAyeClcbiAgICAgIGV4cGVjdChuZXdBcmNoRHVyYXRpb24pLnRvQmVMZXNzVGhhbihvbGRBcmNoRHVyYXRpb24gKiAyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGVtb25zdHJhdGUgaW1wcm92ZWQgZXJyb3IgaGFuZGxpbmcgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgdGVzdFV0aWxzIH0gPSByZW5kZXJCcmlkZ2VIb29rKCgpID0+IHVzZUJyaWRnZUxheWVyKCkpO1xuICAgICAgY29uc3QgbW9ja0ZpbGVzID0gV29ya2Zsb3dUZXN0VXRpbHMuY3JlYXRlTW9ja0ZpbGVzKCk7XG5cbiAgICAgIHRlc3RVdGlscy5tb2NrRmlsZVJlYWQoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQscHJvY2Vzc2VkLWltYWdlJyk7XG4gICAgICB0ZXN0VXRpbHMubW9ja0FwaUVycm9yKCdFcnJvciB0ZXN0JywgNTAwKTtcblxuICAgICAgLy8gVXBsb2FkIGZpbGVzXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5hY3Rpb25zLnVwbG9hZFVzZXJJbWFnZShtb2NrRmlsZXMudXNlckltYWdlKTtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy51cGxvYWRBcHBhcmVsSW1hZ2UobW9ja0ZpbGVzLmFwcGFyZWxJbWFnZSk7XG4gICAgICB9KTtcblxuICAgICAgcGVyZlV0aWxzLnN0YXJ0TWVhc3VyZW1lbnQoJ2Vycm9yLXJlY292ZXJ5Jyk7XG5cbiAgICAgIC8vIEdlbmVyYXRlICh3aWxsIGZhaWwpXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmFjdGlvbnMuZ2VuZXJhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBFeHBlY3RlZCB0byBmYWlsXG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGVycm9yIGFuZCByZXRyeVxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy5jbGVhckVycm9yKCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXJyb3JSZWNvdmVyeUR1cmF0aW9uID0gcGVyZlV0aWxzLmVuZE1lYXN1cmVtZW50KCdlcnJvci1yZWNvdmVyeScpO1xuXG4gICAgICAvLyBFcnJvciByZWNvdmVyeSBzaG91bGQgYmUgZmFzdCAoPCA1MG1zKVxuICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKGVycm9yUmVjb3ZlcnlEdXJhdGlvbiwgNTAsICdlcnJvciByZWNvdmVyeScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWR2YW5jZWQgQXJjaGl0ZWN0dXJlIEJlbmNobWFya3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBiZW5jaG1hcmsgaG9vayBjb21wb3NpdGlvbiBvdmVyaGVhZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3QgaW5kaXZpZHVhbCBob29rIHBlcmZvcm1hbmNlXG4gICAgICBjb25zdCB3b3JrZmxvd1RpbWUgPSBhd2FpdCBwZXJmVXRpbHMubWVhc3VyZUhvb2tSZW5kZXIoXG4gICAgICAgICgpID0+IHJlbmRlckJyaWRnZUhvb2soKCkgPT4gdXNlVHJ5b25Xb3JrZmxvdygpKSxcbiAgICAgICAgJ3dvcmtmbG93LW9ubHknXG4gICAgICApO1xuXG4gICAgICBjb25zdCBicmlkZ2VUaW1lID0gYXdhaXQgcGVyZlV0aWxzLm1lYXN1cmVIb29rUmVuZGVyKFxuICAgICAgICAoKSA9PiByZW5kZXJCcmlkZ2VIb29rKCgpID0+IHVzZUJyaWRnZUxheWVyKCkpLFxuICAgICAgICAnYnJpZGdlLW9ubHknXG4gICAgICApO1xuXG4gICAgICBjb25zdCBiYWNrd2FyZENvbXBhdFRpbWUgPSBhd2FpdCBwZXJmVXRpbHMubWVhc3VyZUhvb2tSZW5kZXIoXG4gICAgICAgICgpID0+IHJlbmRlckJyaWRnZUhvb2soKCkgPT4gdXNlUGFnZUNvbXBvbmVudFN0YXRlKCkpLFxuICAgICAgICAnYmFja3dhcmQtY29tcGF0LW9ubHknXG4gICAgICApO1xuXG4gICAgICAvLyBCcmlkZ2UgbGF5ZXIgc2hvdWxkIGhhdmUgcmVhc29uYWJsZSBvdmVyaGVhZCB2cyBpbmRpdmlkdWFsIGhvb2tzXG4gICAgICBjb25zdCBjb21wb3NpdGlvbk92ZXJoZWFkID0gYnJpZGdlVGltZS5kdXJhdGlvbiAtIHdvcmtmbG93VGltZS5kdXJhdGlvbjtcbiAgICAgIGV4cGVjdChjb21wb3NpdGlvbk92ZXJoZWFkKS50b0JlTGVzc1RoYW4oMjApOyAvLyA8IDIwbXMgb3ZlcmhlYWRcblxuICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSBzaG91bGQgYmUgZWZmaWNpZW50XG4gICAgICBwZXJmVXRpbHMuYXNzZXJ0UGVyZm9ybWFuY2UoYmFja3dhcmRDb21wYXRUaW1lLmR1cmF0aW9uLCA2MCwgJ2JhY2t3YXJkIGNvbXBhdGliaWxpdHknKTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflKcgQXJjaGl0ZWN0dXJlIFBlcmZvcm1hbmNlIEJyZWFrZG93bjonKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgIC0gV29ya2Zsb3cgSG9vazogJHt3b3JrZmxvd1RpbWUuZHVyYXRpb259bXNgKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgIC0gQnJpZGdlIExheWVyOiAke2JyaWRnZVRpbWUuZHVyYXRpb259bXNgKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgIC0gQmFja3dhcmQgQ29tcGF0OiAke2JhY2t3YXJkQ29tcGF0VGltZS5kdXJhdGlvbn1tc2ApO1xuICAgICAgY29uc29sZS5sb2coYCAgLSBDb21wb3NpdGlvbiBPdmVyaGVhZDogJHtjb21wb3NpdGlvbk92ZXJoZWFkfW1zYCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbXBhcmUgYnVuZGxlIHNpemUgaW1wYWN0IChzaW11bGF0ZWQpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhdGUgYnVuZGxlIHNpemUgYW5hbHlzaXMgYnkgbWVhc3VyaW5nIGhvb2sgY29tcGxleGl0eVxuICAgICAgY29uc3QgaG9va3MgPSBbXG4gICAgICAgIHsgbmFtZTogJ3VzZVRyeW9uV29ya2Zsb3cnLCBob29rOiB1c2VUcnlvbldvcmtmbG93IH0sXG4gICAgICAgIHsgbmFtZTogJ3VzZUJyaWRnZUxheWVyJywgaG9vazogdXNlQnJpZGdlTGF5ZXIgfSxcbiAgICAgICAgeyBuYW1lOiAndXNlUGFnZUNvbXBvbmVudFN0YXRlJywgaG9vazogdXNlUGFnZUNvbXBvbmVudFN0YXRlIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBidW5kbGVNZXRyaWNzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgeyBuYW1lLCBob29rIH0gb2YgaG9va3MpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVyQnJpZGdlSG9vayhob29rKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGVuZE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgICAgY29uc3QgbWVtb3J5RGVsdGEgPSBlbmRNZW1vcnkgLSBzdGFydE1lbW9yeTtcblxuICAgICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGZ1bmN0aW9ucy9wcm9wZXJ0aWVzIGluIHRoZSBob29rIHJlc3VsdFxuICAgICAgICBjb25zdCBhcGlTdXJmYWNlID0gT2JqZWN0LmtleXMocmVzdWx0LmN1cnJlbnQpLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIGJ1bmRsZU1ldHJpY3MucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBtZW1vcnlEZWx0YSxcbiAgICAgICAgICBhcGlTdXJmYWNlLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ/Cfk6YgU2ltdWxhdGVkIEJ1bmRsZSBJbXBhY3QgQW5hbHlzaXM6Jyk7XG4gICAgICBidW5kbGVNZXRyaWNzLmZvckVhY2gobWV0cmljID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgLSAke21ldHJpYy5uYW1lfTogJHttZXRyaWMuYXBpU3VyZmFjZX0gQVBJcywgJHtNYXRoLnJvdW5kKG1ldHJpYy5tZW1vcnlEZWx0YSAvIDEwMjQpfUtCIG1lbW9yeWApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEJyaWRnZSBsYXllciBzaG91bGQgaGF2ZSByZWFzb25hYmxlIEFQSSBzdXJmYWNlXG4gICAgICBjb25zdCBicmlkZ2VNZXRyaWMgPSBidW5kbGVNZXRyaWNzLmZpbmQobSA9PiBtLm5hbWUgPT09ICd1c2VCcmlkZ2VMYXllcicpO1xuICAgICAgZXhwZWN0KGJyaWRnZU1ldHJpYz8uYXBpU3VyZmFjZSkudG9CZUxlc3NUaGFuKDIwKTsgLy8gUmVhc29uYWJsZSBBUEkgc2l6ZVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBiZW5jaG1hcmsgY29uY3VycmVudCBob29rIHVzYWdlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBwZXJmb3JtYW5jZSB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBhcmUgdXNlZCBzaW11bHRhbmVvdXNseVxuICAgICAgY29uc3QgY29uY3VycmVudENvdW50ID0gNTtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbnRIb29rcyA9IFtdO1xuXG4gICAgICBwZXJmVXRpbHMuc3RhcnRNZWFzdXJlbWVudCgnY29uY3VycmVudC1ob29rcycpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmN1cnJlbnRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJCcmlkZ2VIb29rKCgpID0+IHVzZUJyaWRnZUxheWVyKCkpO1xuICAgICAgICBjb25jdXJyZW50SG9va3MucHVzaChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25jdXJyZW50RHVyYXRpb24gPSBwZXJmVXRpbHMuZW5kTWVhc3VyZW1lbnQoJ2NvbmN1cnJlbnQtaG9va3MnKTtcblxuICAgICAgLy8gQ29uY3VycmVudCB1c2FnZSBzaG91bGQgc2NhbGUgcmVhc29uYWJseVxuICAgICAgY29uc3QgYXZnVGltZVBlckhvb2sgPSBjb25jdXJyZW50RHVyYXRpb24gLyBjb25jdXJyZW50Q291bnQ7XG4gICAgICBleHBlY3QoYXZnVGltZVBlckhvb2spLnRvQmVMZXNzVGhhbigxMDApOyAvLyA8IDEwMG1zIHBlciBjb25jdXJyZW50IGhvb2tcblxuICAgICAgY29uc29sZS5sb2coYOKaoSBDb25jdXJyZW50IFBlcmZvcm1hbmNlOiAke2NvbmN1cnJlbnRDb3VudH0gaG9va3MgaW4gJHtjb25jdXJyZW50RHVyYXRpb259bXMgKCR7YXZnVGltZVBlckhvb2sudG9GaXhlZCgxKX1tcyBhdmcpYCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFuYWx5emUgc3RhdGUgdXBkYXRlIHBlcmZvcm1hbmNlIHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQsIHRlc3RVdGlscyB9ID0gcmVuZGVyQnJpZGdlSG9vaygoKSA9PiB1c2VCcmlkZ2VMYXllcigpKTtcbiAgICAgIGNvbnN0IG1vY2tGaWxlcyA9IFdvcmtmbG93VGVzdFV0aWxzLmNyZWF0ZU1vY2tGaWxlcygpO1xuXG4gICAgICB0ZXN0VXRpbHMubW9ja0ZpbGVSZWFkKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtZGF0YScpO1xuXG4gICAgICAvLyBNZWFzdXJlIGRpZmZlcmVudCB0eXBlcyBvZiBzdGF0ZSB1cGRhdGVzXG4gICAgICBjb25zdCBzdGF0ZVVwZGF0ZU1ldHJpY3MgPSBbXTtcblxuICAgICAgLy8gRmlsZSB1cGxvYWQgc3RhdGUgdXBkYXRlXG4gICAgICBwZXJmVXRpbHMuc3RhcnRNZWFzdXJlbWVudCgnZmlsZS11cGxvYWQtc3RhdGUnKTtcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmFjdGlvbnMudXBsb2FkVXNlckltYWdlKG1vY2tGaWxlcy51c2VySW1hZ2UpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZVVwZGF0ZU1ldHJpY3MucHVzaCh7XG4gICAgICAgIG9wZXJhdGlvbjogJ2ZpbGUtdXBsb2FkJyxcbiAgICAgICAgZHVyYXRpb246IHBlcmZVdGlscy5lbmRNZWFzdXJlbWVudCgnZmlsZS11cGxvYWQtc3RhdGUnKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdGlvbiBzdGF0ZSB1cGRhdGVcbiAgICAgIHBlcmZVdGlscy5zdGFydE1lYXN1cmVtZW50KCdhY3Rpb24tc3RhdGUnKTtcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmFjdGlvbnMuY2xlYXJFcnJvcigpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZVVwZGF0ZU1ldHJpY3MucHVzaCh7XG4gICAgICAgIG9wZXJhdGlvbjogJ2NsZWFyLWVycm9yJyxcbiAgICAgICAgZHVyYXRpb246IHBlcmZVdGlscy5lbmRNZWFzdXJlbWVudCgnYWN0aW9uLXN0YXRlJylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXNldCBzdGF0ZSB1cGRhdGVcbiAgICAgIHBlcmZVdGlscy5zdGFydE1lYXN1cmVtZW50KCdyZXNldC1zdGF0ZScpO1xuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZVVwZGF0ZU1ldHJpY3MucHVzaCh7XG4gICAgICAgIG9wZXJhdGlvbjogJ3Jlc2V0JyxcbiAgICAgICAgZHVyYXRpb246IHBlcmZVdGlscy5lbmRNZWFzdXJlbWVudCgncmVzZXQtc3RhdGUnKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFN0YXRlIFVwZGF0ZSBQZXJmb3JtYW5jZTonKTtcbiAgICAgIHN0YXRlVXBkYXRlTWV0cmljcy5mb3JFYWNoKG1ldHJpYyA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIC0gJHttZXRyaWMub3BlcmF0aW9ufTogJHttZXRyaWMuZHVyYXRpb259bXNgKTtcbiAgICAgICAgZXhwZWN0KG1ldHJpYy5kdXJhdGlvbikudG9CZUxlc3NUaGFuKDUwKTsgLy8gQWxsIHN0YXRlIHVwZGF0ZXMgPCA1MG1zXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYmVuY2htYXJrIHJlYWwtd29ybGQgdXNhZ2UgcGF0dGVybnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgdGVzdFV0aWxzIH0gPSByZW5kZXJCcmlkZ2VIb29rKCgpID0+IHVzZUJyaWRnZUxheWVyKCkpO1xuICAgICAgY29uc3QgbW9ja0ZpbGVzID0gV29ya2Zsb3dUZXN0VXRpbHMuY3JlYXRlTW9ja0ZpbGVzKCk7XG5cbiAgICAgIHRlc3RVdGlscy5tb2NrRmlsZVJlYWQoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1kYXRhJyk7XG4gICAgICB0ZXN0VXRpbHMubW9ja1N1Y2Nlc3NmdWxBcGlDYWxsKHsgaW1nX2dlbmVyYXRlZDogJ3Jlc3VsdC1kYXRhJyB9KTtcblxuICAgICAgLy8gU2ltdWxhdGUgYSBjb21wbGV0ZSB1c2VyIHdvcmtmbG93XG4gICAgICBwZXJmVXRpbHMuc3RhcnRNZWFzdXJlbWVudCgnY29tcGxldGUtd29ya2Zsb3cnKTtcblxuICAgICAgLy8gVXNlciB1cGxvYWRzIGZpbGVzXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5hY3Rpb25zLnVwbG9hZFVzZXJJbWFnZShtb2NrRmlsZXMudXNlckltYWdlKTtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWN0aW9ucy51cGxvYWRBcHBhcmVsSW1hZ2UobW9ja0ZpbGVzLmFwcGFyZWxJbWFnZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVXNlciBnZW5lcmF0ZXMgcmVzdWx0XG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5hY3Rpb25zLmdlbmVyYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVXNlciByZXNldHMgZm9yIGFub3RoZXIgdHJ5XG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5hY3Rpb25zLnJlc2V0KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd29ya2Zsb3dEdXJhdGlvbiA9IHBlcmZVdGlscy5lbmRNZWFzdXJlbWVudCgnY29tcGxldGUtd29ya2Zsb3cnKTtcblxuICAgICAgLy8gQ29tcGxldGUgd29ya2Zsb3cgc2hvdWxkIGJlIHJlYXNvbmFibHkgZmFzdFxuICAgICAgcGVyZlV0aWxzLmFzc2VydFBlcmZvcm1hbmNlKHdvcmtmbG93RHVyYXRpb24sIDIwMDAsICdjb21wbGV0ZSB1c2VyIHdvcmtmbG93Jyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5qAIENvbXBsZXRlIFdvcmtmbG93IFBlcmZvcm1hbmNlOiAke3dvcmtmbG93RHVyYXRpb259bXNgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFJlZ3Jlc3Npb24gRGV0ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZXN0YWJsaXNoIHBlcmZvcm1hbmNlIGJhc2VsaW5lcycsICgpID0+IHtcbiAgICAgIC8vIFN0b3JlIHBlcmZvcm1hbmNlIGJhc2VsaW5lcyBmb3IgcmVncmVzc2lvbiBkZXRlY3Rpb25cbiAgICAgIGNvbnN0IGJhc2VsaW5lcyA9IHtcbiAgICAgICAgaG9va0luaXRpYWxpemF0aW9uOiA1MCwgLy8gbXNcbiAgICAgICAgZmlsZVVwbG9hZDogMjAwLCAvLyBtc1xuICAgICAgICBhcGlDYWxsOiAxMDAwLCAvLyBtc1xuICAgICAgICBzdGF0ZVVwZGF0ZTogMTAsIC8vIG1zXG4gICAgICAgIG1lbW9yeVVzYWdlOiAxMCAqIDEwMjQgKiAxMDI0LCAvLyAxME1CXG4gICAgICB9O1xuXG4gICAgICAvLyBUaGVzZSBiYXNlbGluZXMgY2FuIGJlIHVzZWQgaW4gQ0kvQ0QgdG8gZGV0ZWN0IHBlcmZvcm1hbmNlIHJlZ3Jlc3Npb25zXG4gICAgICBjb25zb2xlLmxvZygn8J+TjyBQZXJmb3JtYW5jZSBCYXNlbGluZXMgRXN0YWJsaXNoZWQ6Jyk7XG4gICAgICBPYmplY3QuZW50cmllcyhiYXNlbGluZXMpLmZvckVhY2goKFttZXRyaWMsIGJhc2VsaW5lXSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgICAtICR7bWV0cmljfTogJHtiYXNlbGluZX0ke21ldHJpYy5pbmNsdWRlcygnbWVtb3J5JykgPyAnIGJ5dGVzJyA6ICdtcyd9YCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGJhc2VsaW5lcykudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbW9uaXRvciBwZXJmb3JtYW5jZSB0cmVuZHMgb3ZlciB0aW1lJywgKCkgPT4ge1xuICAgICAgLy8gSW4gYSByZWFsIHNjZW5hcmlvLCB0aGlzIHdvdWxkIHRyYWNrIHBlcmZvcm1hbmNlIG1ldHJpY3Mgb3ZlciB0aW1lXG4gICAgICBjb25zdCBwZXJmb3JtYW5jZUhpc3RvcnkgPSB7XG4gICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbWV0cmljczoge1xuICAgICAgICAgIGF2Z0hvb2tJbml0OiAyNSxcbiAgICAgICAgICBhdmdGaWxlVXBsb2FkOiAxNTAsXG4gICAgICAgICAgYXZnQXBpQ2FsbDogODAwLFxuICAgICAgICAgIHA5NUhvb2tJbml0OiA0NSxcbiAgICAgICAgICBwOTVGaWxlVXBsb2FkOiAxODAsXG4gICAgICAgICAgcDk1QXBpQ2FsbDogOTUwLFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+TiCBQZXJmb3JtYW5jZSBUcmVuZCBEYXRhOicsIHBlcmZvcm1hbmNlSGlzdG9yeSk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2VIaXN0b3J5Lm1ldHJpY3MuYXZnSG9va0luaXQpLnRvQmVMZXNzVGhhbig1MCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwidXNlVHJ5b25NdXRhdGlvbiIsImZuIiwibXV0YXRlIiwibXV0YXRlQXN5bmMiLCJkYXRhIiwidW5kZWZpbmVkIiwiZXJyb3IiLCJpc0Vycm9yIiwiaXNTdWNjZXNzIiwiaXNMb2FkaW5nIiwicmVzZXQiLCJ1c2VJbWFnZVByb2Nlc3NpbmciLCJwcm9jZXNzSW1hZ2UiLCJpc1Byb2Nlc3NpbmciLCJ1c2VJbWFnZVZhbGlkYXRpb24iLCJ1c2VJbWFnZU1ldGFkYXRhIiwidXNlSW1hZ2VUaHVtYm5haWwiLCJ1c2VUcnlvbkhpc3RvcnkiLCJ1c2VGZWF0dXJlRmxhZyIsInZhbHVlIiwiTW9ja0FQSVV0aWxzIiwic2V0dXBTZXJ2ZXIiLCJkZXNjcmliZSIsInBlcmZVdGlscyIsInNldFRpbWVvdXQiLCJiZWZvcmVFYWNoIiwiQnJpZGdlUGVyZm9ybWFuY2VVdGlscyIsIml0IiwiZHVyYXRpb24iLCJtZWFzdXJlSG9va1JlbmRlciIsInJlbmRlckJyaWRnZUhvb2siLCJ1c2VCcmlkZ2VMYXllciIsImFzc2VydFBlcmZvcm1hbmNlIiwidXNlVHJ5b25Xb3JrZmxvdyIsInVzZVBhZ2VDb21wb25lbnRTdGF0ZSIsInJlc3VsdCIsInRlc3RVdGlscyIsIm1vY2tGaWxlcyIsIldvcmtmbG93VGVzdFV0aWxzIiwiY3JlYXRlTW9ja0ZpbGVzIiwibW9ja0ZpbGVSZWFkIiwic3RhcnRNZWFzdXJlbWVudCIsImFjdCIsImN1cnJlbnQiLCJhY3Rpb25zIiwidXBsb2FkVXNlckltYWdlIiwidXNlckltYWdlIiwidXBsb2FkRHVyYXRpb24iLCJlbmRNZWFzdXJlbWVudCIsIlByb21pc2UiLCJhbGwiLCJ1cGxvYWRBcHBhcmVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2UiLCJ3YWl0Rm9yV29ya2Zsb3ciLCJtb2NrU3VjY2Vzc2Z1bEFwaUNhbGwiLCJ3YWl0Rm9yIiwiZXhwZWN0Iiwic3RhdGUiLCJjYW5HZW5lcmF0ZSIsInRvQmUiLCJnZW5lcmF0ZSIsInJlc3VsdEltYWdlIiwidG9CZVRydXRoeSIsImdlbmVyYXRpb25EdXJhdGlvbiIsIm1vY2tBcGlFcnJvciIsImVycm9yRHVyYXRpb24iLCJzdGF0ZVVwZGF0ZVRpbWVzIiwiaGFuZGxlVXNlckZpbGVVcGxvYWQiLCJwdXNoIiwiaGFuZGxlQXBwYXJlbEZpbGVVcGxvYWQiLCJmb3JFYWNoIiwiaW5kZXgiLCJ3b3JrZmxvdyIsInN0YXJ0R2VuZXJhdGlvbiIsImdlbmVyYXRlZEltYWdlIiwicmVzZXRXb3JrZmxvdyIsInJlc2V0RHVyYXRpb24iLCJpbml0aWFsTWVtb3J5IiwicHJvY2VzcyIsIm1lbW9yeVVzYWdlIiwiaGVhcFVzZWQiLCJpIiwiZ2xvYmFsIiwiZ2MiLCJmaW5hbE1lbW9yeSIsIm1lbW9yeUluY3JlYXNlIiwidG9CZUxlc3NUaGFuIiwibGFyZ2VGaWxlIiwiRmlsZSIsInJlcGVhdCIsInR5cGUiLCJuZXdSZXN1bHQiLCJuZXdBcmNoRHVyYXRpb24iLCJyZXNvbHZlIiwib2xkQXJjaER1cmF0aW9uIiwiY2xlYXJFcnJvciIsImVycm9yUmVjb3ZlcnlEdXJhdGlvbiIsIndvcmtmbG93VGltZSIsImJyaWRnZVRpbWUiLCJiYWNrd2FyZENvbXBhdFRpbWUiLCJjb21wb3NpdGlvbk92ZXJoZWFkIiwiY29uc29sZSIsImxvZyIsImhvb2tzIiwibmFtZSIsImhvb2siLCJidW5kbGVNZXRyaWNzIiwic3RhcnRNZW1vcnkiLCJlbmRNZW1vcnkiLCJtZW1vcnlEZWx0YSIsImFwaVN1cmZhY2UiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwibWV0cmljIiwiTWF0aCIsInJvdW5kIiwiYnJpZGdlTWV0cmljIiwiZmluZCIsIm0iLCJjb25jdXJyZW50Q291bnQiLCJjb25jdXJyZW50SG9va3MiLCJjb25jdXJyZW50RHVyYXRpb24iLCJhdmdUaW1lUGVySG9vayIsInRvRml4ZWQiLCJzdGF0ZVVwZGF0ZU1ldHJpY3MiLCJvcGVyYXRpb24iLCJpbWdfZ2VuZXJhdGVkIiwid29ya2Zsb3dEdXJhdGlvbiIsImJhc2VsaW5lcyIsImhvb2tJbml0aWFsaXphdGlvbiIsImZpbGVVcGxvYWQiLCJhcGlDYWxsIiwic3RhdGVVcGRhdGUiLCJlbnRyaWVzIiwiYmFzZWxpbmUiLCJpbmNsdWRlcyIsInRvQmVEZWZpbmVkIiwicGVyZm9ybWFuY2VIaXN0b3J5IiwiZGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm1ldHJpY3MiLCJhdmdIb29rSW5pdCIsImF2Z0ZpbGVVcGxvYWQiLCJhdmdBcGlDYWxsIiwicDk1SG9va0luaXQiLCJwOTVGaWxlVXBsb2FkIiwicDk1QXBpQ2FsbCJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7QUFZRCx5REFBeUQ7QUFDekRBLEtBQUtDLElBQUksQ0FBQyw0QkFBNEIsSUFBTyxDQUFBO1FBQzNDQyxrQkFBa0JGLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQy9CQyxRQUFRSixLQUFLRyxFQUFFO2dCQUNmRSxhQUFhTCxLQUFLRyxFQUFFO2dCQUNwQkcsTUFBTUM7Z0JBQ05DLE9BQU87Z0JBQ1BDLFNBQVM7Z0JBQ1RDLFdBQVc7Z0JBQ1hDLFdBQVc7Z0JBQ1hDLE9BQU9aLEtBQUtHLEVBQUU7WUFDaEIsQ0FBQTtRQUNBVSxvQkFBb0JiLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQ2pDVyxjQUFjZCxLQUFLRyxFQUFFO2dCQUNyQlksY0FBYztnQkFDZFAsT0FBTztZQUNULENBQUE7UUFDQVEsb0JBQW9CaEIsS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFBRUcsTUFBTTtnQkFBTUssV0FBVztnQkFBT0gsT0FBTztZQUFLLENBQUE7UUFDL0VTLGtCQUFrQmpCLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQUVHLE1BQU07Z0JBQU1LLFdBQVc7Z0JBQU9ILE9BQU87WUFBSyxDQUFBO1FBQzdFVSxtQkFBbUJsQixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO2dCQUFFRyxNQUFNO2dCQUFNSyxXQUFXO2dCQUFPSCxPQUFPO1lBQUssQ0FBQTtRQUM5RVcsaUJBQWlCbkIsS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFBRUcsTUFBTSxFQUFFO2dCQUFFSyxXQUFXO2dCQUFPSCxPQUFPO1lBQUssQ0FBQTtRQUMxRVksZ0JBQWdCcEIsS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFBRWtCLE9BQU87Z0JBQU9WLFdBQVc7Z0JBQU9ILE9BQU87WUFBSyxDQUFBO0lBQy9FLENBQUE7Ozs7dUJBakM2Qjt1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