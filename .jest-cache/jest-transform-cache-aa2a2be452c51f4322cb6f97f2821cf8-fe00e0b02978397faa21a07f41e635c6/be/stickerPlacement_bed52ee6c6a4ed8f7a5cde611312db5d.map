{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/utils/stickerPlacement.ts"],"sourcesContent":["// Sticker Placement System for Canvas\n// Comprehensive sticker management with positioning, scaling, rotation, and layering\n\nimport type { ManagedCanvas } from '../providers/CanvasProvider';\nimport { BlendMode } from './canvasUtils';\n\n/**\n * Sticker anchor points for positioning\n */\nexport enum StickerAnchor {\n  TopLeft = 'top-left',\n  TopCenter = 'top-center',\n  TopRight = 'top-right',\n  MiddleLeft = 'middle-left',\n  MiddleCenter = 'middle-center',\n  MiddleRight = 'middle-right',\n  BottomLeft = 'bottom-left',\n  BottomCenter = 'bottom-center',\n  BottomRight = 'bottom-right'\n}\n\n/**\n * Sticker transformation properties\n */\nexport interface StickerTransform {\n  /** X position */\n  x: number;\n  /** Y position */\n  y: number;\n  /** Scale factor (1.0 = original size) */\n  scale: number;\n  /** Rotation in radians */\n  rotation: number;\n  /** Horizontal flip */\n  flipX: boolean;\n  /** Vertical flip */\n  flipY: boolean;\n  /** Skew X in radians */\n  skewX?: number;\n  /** Skew Y in radians */\n  skewY?: number;\n}\n\n/**\n * Sticker visual properties\n */\nexport interface StickerVisualProps {\n  /** Opacity (0-1) */\n  opacity: number;\n  /** Blend mode */\n  blendMode: BlendMode;\n  /** Color tint overlay */\n  tint?: string;\n  /** Shadow configuration */\n  shadow?: {\n    color: string;\n    offsetX: number;\n    offsetY: number;\n    blur: number;\n  };\n  /** Border configuration */\n  border?: {\n    color: string;\n    width: number;\n    style: 'solid' | 'dashed' | 'dotted';\n  };\n}\n\n/**\n * Sticker bounds and collision detection\n */\nexport interface StickerBounds {\n  /** Bounding rectangle */\n  rect: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  /** Rotated corner points */\n  corners: Array<{ x: number; y: number }>;\n  /** Center point */\n  center: { x: number; y: number };\n}\n\n/**\n * Sticker configuration\n */\nexport interface StickerConfig {\n  /** Unique identifier */\n  id: string;\n  /** Sticker image source */\n  imageSource: string | HTMLImageElement | HTMLCanvasElement;\n  /** Original dimensions */\n  originalSize: { width: number; height: number };\n  /** Transform properties */\n  transform: StickerTransform;\n  /** Visual properties */\n  visual: StickerVisualProps;\n  /** Anchor point for positioning */\n  anchor: StickerAnchor;\n  /** Z-index for layering */\n  zIndex: number;\n  /** Whether sticker is locked from editing */\n  locked: boolean;\n  /** Whether sticker is visible */\n  visible: boolean;\n  /** Whether sticker maintains aspect ratio when scaling */\n  maintainAspectRatio: boolean;\n  /** Minimum and maximum scale limits */\n  scaleConstraints?: {\n    min: number;\n    max: number;\n  };\n  /** Snap to grid configuration */\n  snapToGrid?: {\n    enabled: boolean;\n    gridSize: number;\n  };\n  /** Metadata */\n  metadata?: {\n    name?: string;\n    category?: string;\n    tags?: string[];\n    createdAt: Date;\n    updatedAt: Date;\n  };\n}\n\n/**\n * Sticker interaction state\n */\nexport interface StickerInteractionState {\n  /** Whether sticker is selected */\n  selected: boolean;\n  /** Whether sticker is being dragged */\n  dragging: boolean;\n  /** Whether sticker is being scaled */\n  scaling: boolean;\n  /** Whether sticker is being rotated */\n  rotating: boolean;\n  /** Interaction handles visibility */\n  showHandles: boolean;\n  /** Mouse/touch interaction data */\n  interaction?: {\n    startX: number;\n    startY: number;\n    initialTransform: StickerTransform;\n    handle?: 'move' | 'scale' | 'rotate' | 'corner-tl' | 'corner-tr' | 'corner-bl' | 'corner-br';\n  };\n}\n\n/**\n * Sticker item with interaction state\n */\nexport interface Sticker extends StickerConfig {\n  /** Cached image element */\n  image?: HTMLImageElement;\n  /** Current bounds */\n  bounds?: StickerBounds;\n  /** Interaction state */\n  interactionState: StickerInteractionState;\n}\n\n/**\n * Grid snap configuration\n */\nexport interface GridSnapConfig {\n  enabled: boolean;\n  size: number;\n  showGrid: boolean;\n  gridColor: string;\n  snapThreshold: number;\n}\n\n/**\n * Collision detection result\n */\nexport interface CollisionResult {\n  hasCollision: boolean;\n  collidingStickers: string[];\n  suggestedPosition?: { x: number; y: number };\n}\n\n/**\n * Default sticker configuration\n */\nexport const DEFAULT_STICKER_CONFIG: Omit<StickerConfig, 'id' | 'imageSource' | 'originalSize'> = {\n  transform: {\n    x: 0,\n    y: 0,\n    scale: 1,\n    rotation: 0,\n    flipX: false,\n    flipY: false\n  },\n  visual: {\n    opacity: 1,\n    blendMode: BlendMode.Normal\n  },\n  anchor: StickerAnchor.MiddleCenter,\n  zIndex: 0,\n  locked: false,\n  visible: true,\n  maintainAspectRatio: true\n};\n\n/**\n * Sticker placement and management system\n */\nexport class StickerManager {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private stickers: Map<string, Sticker> = new Map();\n  private selectedStickerId: string | null = null;\n  private gridConfig: GridSnapConfig = {\n    enabled: false,\n    size: 20,\n    showGrid: false,\n    gridColor: 'rgba(0, 0, 0, 0.1)',\n    snapThreshold: 10\n  };\n\n  constructor(managedCanvas: ManagedCanvas) {\n    this.canvas = managedCanvas.canvas;\n    this.ctx = managedCanvas.context;\n  }\n\n  /**\n   * Calculate sticker bounds\n   */\n  private calculateBounds(sticker: Sticker): StickerBounds {\n    const { transform, originalSize, anchor } = sticker;\n    const { x, y, scale, rotation } = transform;\n    \n    const width = originalSize.width * scale;\n    const height = originalSize.height * scale;\n    \n    // Calculate anchor offset\n    let anchorOffsetX = 0;\n    let anchorOffsetY = 0;\n    \n    switch (anchor) {\n      case StickerAnchor.TopLeft:\n        anchorOffsetX = 0;\n        anchorOffsetY = 0;\n        break;\n      case StickerAnchor.TopCenter:\n        anchorOffsetX = -width / 2;\n        anchorOffsetY = 0;\n        break;\n      case StickerAnchor.TopRight:\n        anchorOffsetX = -width;\n        anchorOffsetY = 0;\n        break;\n      case StickerAnchor.MiddleLeft:\n        anchorOffsetX = 0;\n        anchorOffsetY = -height / 2;\n        break;\n      case StickerAnchor.MiddleCenter:\n        anchorOffsetX = -width / 2;\n        anchorOffsetY = -height / 2;\n        break;\n      case StickerAnchor.MiddleRight:\n        anchorOffsetX = -width;\n        anchorOffsetY = -height / 2;\n        break;\n      case StickerAnchor.BottomLeft:\n        anchorOffsetX = 0;\n        anchorOffsetY = -height;\n        break;\n      case StickerAnchor.BottomCenter:\n        anchorOffsetX = -width / 2;\n        anchorOffsetY = -height;\n        break;\n      case StickerAnchor.BottomRight:\n        anchorOffsetX = -width;\n        anchorOffsetY = -height;\n        break;\n    }\n    \n    const centerX = x;\n    const centerY = y;\n    \n    // Calculate corner points (before rotation)\n    const corners = [\n      { x: anchorOffsetX, y: anchorOffsetY }, // top-left\n      { x: anchorOffsetX + width, y: anchorOffsetY }, // top-right\n      { x: anchorOffsetX + width, y: anchorOffsetY + height }, // bottom-right\n      { x: anchorOffsetX, y: anchorOffsetY + height } // bottom-left\n    ];\n    \n    // Apply rotation to corners\n    const cos = Math.cos(rotation);\n    const sin = Math.sin(rotation);\n    \n    const rotatedCorners = corners.map(corner => ({\n      x: centerX + (corner.x * cos - corner.y * sin),\n      y: centerY + (corner.x * sin + corner.y * cos)\n    }));\n    \n    // Calculate bounding rectangle\n    const minX = Math.min(...rotatedCorners.map(c => c.x));\n    const maxX = Math.max(...rotatedCorners.map(c => c.x));\n    const minY = Math.min(...rotatedCorners.map(c => c.y));\n    const maxY = Math.max(...rotatedCorners.map(c => c.y));\n    \n    return {\n      rect: {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n      },\n      corners: rotatedCorners,\n      center: { x: centerX, y: centerY }\n    };\n  }\n\n  /**\n   * Snap position to grid\n   */\n  private snapToGrid(x: number, y: number): { x: number; y: number } {\n    if (!this.gridConfig.enabled) {\n      return { x, y };\n    }\n    \n    const { size, snapThreshold } = this.gridConfig;\n    const snappedX = Math.round(x / size) * size;\n    const snappedY = Math.round(y / size) * size;\n    \n    const deltaX = Math.abs(x - snappedX);\n    const deltaY = Math.abs(y - snappedY);\n    \n    return {\n      x: deltaX <= snapThreshold ? snappedX : x,\n      y: deltaY <= snapThreshold ? snappedY : y\n    };\n  }\n\n  /**\n   * Load image from source\n   */\n  private async loadImage(source: string | HTMLImageElement | HTMLCanvasElement): Promise<HTMLImageElement> {\n    if (source instanceof HTMLImageElement) {\n      return source;\n    }\n    \n    if (source instanceof HTMLCanvasElement) {\n      const img = new Image();\n      img.src = source.toDataURL();\n      return new Promise((resolve, reject) => {\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n      });\n    }\n    \n    // String URL\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    return new Promise((resolve, reject) => {\n      img.onload = () => resolve(img);\n      img.onerror = reject;\n      img.src = source;\n    });\n  }\n\n  /**\n   * Add sticker to canvas\n   */\n  async addSticker(config: Omit<StickerConfig, 'id'> & { id?: string }): Promise<string> {\n    const id = config.id || `sticker-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    \n    try {\n      const image = await this.loadImage(config.imageSource);\n      \n      const sticker: Sticker = {\n        ...DEFAULT_STICKER_CONFIG,\n        ...config,\n        id,\n        image,\n        interactionState: {\n          selected: false,\n          dragging: false,\n          scaling: false,\n          rotating: false,\n          showHandles: false\n        }\n      };\n      \n      // Calculate initial bounds\n      sticker.bounds = this.calculateBounds(sticker);\n      \n      this.stickers.set(id, sticker);\n      return id;\n    } catch (error) {\n      throw new Error(`Failed to load sticker image: ${error}`);\n    }\n  }\n\n  /**\n   * Remove sticker\n   */\n  removeSticker(id: string): boolean {\n    const removed = this.stickers.delete(id);\n    if (this.selectedStickerId === id) {\n      this.selectedStickerId = null;\n    }\n    return removed;\n  }\n\n  /**\n   * Update sticker configuration\n   */\n  updateSticker(id: string, updates: Partial<StickerConfig>): boolean {\n    const sticker = this.stickers.get(id);\n    if (!sticker) return false;\n    \n    Object.assign(sticker, updates);\n    \n    // Update metadata timestamp\n    if (sticker.metadata) {\n      sticker.metadata.updatedAt = new Date();\n    }\n    \n    // Recalculate bounds\n    sticker.bounds = this.calculateBounds(sticker);\n    \n    return true;\n  }\n\n  /**\n   * Get sticker by ID\n   */\n  getSticker(id: string): Sticker | undefined {\n    return this.stickers.get(id);\n  }\n\n  /**\n   * Get all stickers sorted by z-index\n   */\n  getAllStickers(): Sticker[] {\n    return Array.from(this.stickers.values())\n      .sort((a, b) => a.zIndex - b.zIndex);\n  }\n\n  /**\n   * Select sticker\n   */\n  selectSticker(id: string | null): void {\n    // Deselect previous sticker\n    if (this.selectedStickerId) {\n      const prevSticker = this.stickers.get(this.selectedStickerId);\n      if (prevSticker) {\n        prevSticker.interactionState.selected = false;\n        prevSticker.interactionState.showHandles = false;\n      }\n    }\n    \n    this.selectedStickerId = id;\n    \n    // Select new sticker\n    if (id) {\n      const sticker = this.stickers.get(id);\n      if (sticker && !sticker.locked) {\n        sticker.interactionState.selected = true;\n        sticker.interactionState.showHandles = true;\n      }\n    }\n  }\n\n  /**\n   * Move sticker to position\n   */\n  moveStickerTo(id: string, x: number, y: number): boolean {\n    const sticker = this.stickers.get(id);\n    if (!sticker || sticker.locked) return false;\n    \n    const snapped = this.snapToGrid(x, y);\n    sticker.transform.x = snapped.x;\n    sticker.transform.y = snapped.y;\n    sticker.bounds = this.calculateBounds(sticker);\n    \n    return true;\n  }\n\n  /**\n   * Scale sticker\n   */\n  scaleSticker(id: string, scale: number, maintainAspectRatio?: boolean): boolean {\n    const sticker = this.stickers.get(id);\n    if (!sticker || sticker.locked) return false;\n    \n    // Apply scale constraints\n    if (sticker.scaleConstraints) {\n      scale = Math.max(sticker.scaleConstraints.min, Math.min(sticker.scaleConstraints.max, scale));\n    }\n    \n    sticker.transform.scale = scale;\n    sticker.bounds = this.calculateBounds(sticker);\n    \n    return true;\n  }\n\n  /**\n   * Rotate sticker\n   */\n  rotateSticker(id: string, rotation: number): boolean {\n    const sticker = this.stickers.get(id);\n    if (!sticker || sticker.locked) return false;\n    \n    // Normalize rotation to 0-2Ï€ range\n    sticker.transform.rotation = rotation % (2 * Math.PI);\n    sticker.bounds = this.calculateBounds(sticker);\n    \n    return true;\n  }\n\n  /**\n   * Flip sticker\n   */\n  flipSticker(id: string, flipX?: boolean, flipY?: boolean): boolean {\n    const sticker = this.stickers.get(id);\n    if (!sticker || sticker.locked) return false;\n    \n    if (flipX !== undefined) sticker.transform.flipX = flipX;\n    if (flipY !== undefined) sticker.transform.flipY = flipY;\n    sticker.bounds = this.calculateBounds(sticker);\n    \n    return true;\n  }\n\n  /**\n   * Set sticker z-index\n   */\n  setStickerZIndex(id: string, zIndex: number): boolean {\n    const sticker = this.stickers.get(id);\n    if (!sticker) return false;\n    \n    sticker.zIndex = zIndex;\n    return true;\n  }\n\n  /**\n   * Bring sticker to front\n   */\n  bringToFront(id: string): boolean {\n    const maxZ = Math.max(0, ...Array.from(this.stickers.values()).map(s => s.zIndex));\n    return this.setStickerZIndex(id, maxZ + 1);\n  }\n\n  /**\n   * Send sticker to back\n   */\n  sendToBack(id: string): boolean {\n    const minZ = Math.min(0, ...Array.from(this.stickers.values()).map(s => s.zIndex));\n    return this.setStickerZIndex(id, minZ - 1);\n  }\n\n  /**\n   * Check collision between stickers\n   */\n  checkCollisions(excludeId?: string): CollisionResult {\n    const stickers = this.getAllStickers().filter(s => s.id !== excludeId && s.visible);\n    const collidingStickers: string[] = [];\n    \n    for (let i = 0; i < stickers.length; i++) {\n      for (let j = i + 1; j < stickers.length; j++) {\n        const a = stickers[i];\n        const b = stickers[j];\n        \n        if (!a.bounds || !b.bounds) continue;\n        \n        // Simple bounding box collision detection\n        const aRect = a.bounds.rect;\n        const bRect = b.bounds.rect;\n        \n        if (aRect.x < bRect.x + bRect.width &&\n            aRect.x + aRect.width > bRect.x &&\n            aRect.y < bRect.y + bRect.height &&\n            aRect.y + aRect.height > bRect.y) {\n          \n          if (!collidingStickers.includes(a.id)) collidingStickers.push(a.id);\n          if (!collidingStickers.includes(b.id)) collidingStickers.push(b.id);\n        }\n      }\n    }\n    \n    return {\n      hasCollision: collidingStickers.length > 0,\n      collidingStickers\n    };\n  }\n\n  /**\n   * Find sticker at position\n   */\n  getStickerAtPosition(x: number, y: number): string | null {\n    const stickers = this.getAllStickers()\n      .filter(s => s.visible)\n      .reverse(); // Check from top to bottom\n    \n    for (const sticker of stickers) {\n      if (!sticker.bounds) continue;\n      \n      const { rect } = sticker.bounds;\n      if (x >= rect.x && x <= rect.x + rect.width &&\n          y >= rect.y && y <= rect.y + rect.height) {\n        return sticker.id;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Render grid\n   */\n  private renderGrid(): void {\n    if (!this.gridConfig.enabled || !this.gridConfig.showGrid) return;\n    \n    this.ctx.save();\n    this.ctx.strokeStyle = this.gridConfig.gridColor;\n    this.ctx.lineWidth = 0.5;\n    this.ctx.beginPath();\n    \n    const { size } = this.gridConfig;\n    const { width, height } = this.canvas;\n    \n    // Vertical lines\n    for (let x = 0; x <= width; x += size) {\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, height);\n    }\n    \n    // Horizontal lines\n    for (let y = 0; y <= height; y += size) {\n      this.ctx.moveTo(0, y);\n      this.ctx.lineTo(width, y);\n    }\n    \n    this.ctx.stroke();\n    this.ctx.restore();\n  }\n\n  /**\n   * Render sticker with all transforms\n   */\n  private renderSticker(sticker: Sticker): void {\n    if (!sticker.visible || !sticker.image) return;\n    \n    const { transform, visual, originalSize } = sticker;\n    const { x, y, scale, rotation, flipX, flipY } = transform;\n    \n    this.ctx.save();\n    \n    // Apply global alpha and blend mode\n    this.ctx.globalAlpha = visual.opacity;\n    this.ctx.globalCompositeOperation = visual.blendMode;\n    \n    // Apply shadow if configured\n    if (visual.shadow) {\n      this.ctx.shadowColor = visual.shadow.color;\n      this.ctx.shadowOffsetX = visual.shadow.offsetX;\n      this.ctx.shadowOffsetY = visual.shadow.offsetY;\n      this.ctx.shadowBlur = visual.shadow.blur;\n    }\n    \n    // Transform context\n    this.ctx.translate(x, y);\n    this.ctx.rotate(rotation);\n    this.ctx.scale(flipX ? -scale : scale, flipY ? -scale : scale);\n    \n    const width = originalSize.width;\n    const height = originalSize.height;\n    \n    // Apply anchor offset\n    let anchorOffsetX = 0;\n    let anchorOffsetY = 0;\n    \n    switch (sticker.anchor) {\n      case StickerAnchor.TopLeft:\n        anchorOffsetX = 0;\n        anchorOffsetY = 0;\n        break;\n      case StickerAnchor.TopCenter:\n        anchorOffsetX = -width / 2;\n        anchorOffsetY = 0;\n        break;\n      case StickerAnchor.TopRight:\n        anchorOffsetX = -width;\n        anchorOffsetY = 0;\n        break;\n      case StickerAnchor.MiddleLeft:\n        anchorOffsetX = 0;\n        anchorOffsetY = -height / 2;\n        break;\n      case StickerAnchor.MiddleCenter:\n        anchorOffsetX = -width / 2;\n        anchorOffsetY = -height / 2;\n        break;\n      case StickerAnchor.MiddleRight:\n        anchorOffsetX = -width;\n        anchorOffsetY = -height / 2;\n        break;\n      case StickerAnchor.BottomLeft:\n        anchorOffsetX = 0;\n        anchorOffsetY = -height;\n        break;\n      case StickerAnchor.BottomCenter:\n        anchorOffsetX = -width / 2;\n        anchorOffsetY = -height;\n        break;\n      case StickerAnchor.BottomRight:\n        anchorOffsetX = -width;\n        anchorOffsetY = -height;\n        break;\n    }\n    \n    // Draw the sticker\n    this.ctx.drawImage(sticker.image, anchorOffsetX, anchorOffsetY, width, height);\n    \n    // Apply tint overlay\n    if (visual.tint) {\n      this.ctx.globalCompositeOperation = 'source-atop';\n      this.ctx.fillStyle = visual.tint;\n      this.ctx.fillRect(anchorOffsetX, anchorOffsetY, width, height);\n    }\n    \n    this.ctx.restore();\n    \n    // Draw border if configured\n    if (visual.border && sticker.bounds) {\n      this.ctx.save();\n      this.ctx.strokeStyle = visual.border.color;\n      this.ctx.lineWidth = visual.border.width;\n      \n      if (visual.border.style === 'dashed') {\n        this.ctx.setLineDash([5, 5]);\n      } else if (visual.border.style === 'dotted') {\n        this.ctx.setLineDash([2, 2]);\n      }\n      \n      const { corners } = sticker.bounds;\n      this.ctx.beginPath();\n      this.ctx.moveTo(corners[0].x, corners[0].y);\n      corners.forEach(corner => this.ctx.lineTo(corner.x, corner.y));\n      this.ctx.closePath();\n      this.ctx.stroke();\n      this.ctx.restore();\n    }\n  }\n\n  /**\n   * Render selection handles\n   */\n  private renderSelectionHandles(sticker: Sticker): void {\n    if (!sticker.interactionState.showHandles || !sticker.bounds) return;\n    \n    const { corners, center } = sticker.bounds;\n    const handleSize = 8;\n    const handleColor = '#4A90E2';\n    const handleBorderColor = '#FFFFFF';\n    \n    this.ctx.save();\n    \n    // Draw corner handles\n    corners.forEach(corner => {\n      this.ctx.fillStyle = handleColor;\n      this.ctx.strokeStyle = handleBorderColor;\n      this.ctx.lineWidth = 2;\n      \n      this.ctx.fillRect(\n        corner.x - handleSize / 2,\n        corner.y - handleSize / 2,\n        handleSize,\n        handleSize\n      );\n      this.ctx.strokeRect(\n        corner.x - handleSize / 2,\n        corner.y - handleSize / 2,\n        handleSize,\n        handleSize\n      );\n    });\n    \n    // Draw rotation handle\n    const rotationHandleY = corners[0].y - 30;\n    this.ctx.beginPath();\n    this.ctx.arc(center.x, rotationHandleY, handleSize / 2, 0, 2 * Math.PI);\n    this.ctx.fillStyle = '#FF6B6B';\n    this.ctx.fill();\n    this.ctx.strokeStyle = handleBorderColor;\n    this.ctx.stroke();\n    \n    // Draw line to rotation handle\n    this.ctx.beginPath();\n    this.ctx.moveTo(center.x, corners[0].y);\n    this.ctx.lineTo(center.x, rotationHandleY);\n    this.ctx.strokeStyle = '#CCCCCC';\n    this.ctx.lineWidth = 1;\n    this.ctx.stroke();\n    \n    this.ctx.restore();\n  }\n\n  /**\n   * Render all stickers\n   */\n  renderAllStickers(): void {\n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    // Render grid\n    this.renderGrid();\n    \n    // Render stickers in z-index order\n    const sortedStickers = this.getAllStickers();\n    \n    sortedStickers.forEach(sticker => {\n      this.renderSticker(sticker);\n      \n      // Render selection handles for selected sticker\n      if (sticker.interactionState.selected) {\n        this.renderSelectionHandles(sticker);\n      }\n    });\n  }\n\n  /**\n   * Configure grid settings\n   */\n  setGridConfig(config: Partial<GridSnapConfig>): void {\n    Object.assign(this.gridConfig, config);\n  }\n\n  /**\n   * Get grid configuration\n   */\n  getGridConfig(): GridSnapConfig {\n    return { ...this.gridConfig };\n  }\n\n  /**\n   * Export stickers data\n   */\n  exportStickers(): StickerConfig[] {\n    return this.getAllStickers().map(sticker => {\n      const { image, bounds, interactionState, ...config } = sticker;\n      return config;\n    });\n  }\n\n  /**\n   * Import stickers data\n   */\n  async importStickers(stickers: StickerConfig[]): Promise<string[]> {\n    const importedIds: string[] = [];\n    \n    for (const stickerConfig of stickers) {\n      try {\n        const id = await this.addSticker(stickerConfig);\n        importedIds.push(id);\n      } catch (error) {\n        console.error(`Failed to import sticker ${stickerConfig.id}:`, error);\n      }\n    }\n    \n    return importedIds;\n  }\n\n  /**\n   * Clear all stickers\n   */\n  clearAllStickers(): void {\n    this.stickers.clear();\n    this.selectedStickerId = null;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n}\n\n/**\n * Factory function to create sticker manager\n */\nexport function createStickerManager(managedCanvas: ManagedCanvas): StickerManager {\n  return new StickerManager(managedCanvas);\n}"],"names":["DEFAULT_STICKER_CONFIG","StickerAnchor","StickerManager","createStickerManager","transform","x","y","scale","rotation","flipX","flipY","visual","opacity","blendMode","BlendMode","Normal","anchor","zIndex","locked","visible","maintainAspectRatio","constructor","managedCanvas","stickers","Map","selectedStickerId","gridConfig","enabled","size","showGrid","gridColor","snapThreshold","canvas","ctx","context","calculateBounds","sticker","originalSize","width","height","anchorOffsetX","anchorOffsetY","centerX","centerY","corners","cos","Math","sin","rotatedCorners","map","corner","minX","min","c","maxX","max","minY","maxY","rect","center","snapToGrid","snappedX","round","snappedY","deltaX","abs","deltaY","loadImage","source","HTMLImageElement","HTMLCanvasElement","img","Image","src","toDataURL","Promise","resolve","reject","onload","onerror","crossOrigin","addSticker","config","id","Date","now","random","toString","substr","image","imageSource","interactionState","selected","dragging","scaling","rotating","showHandles","bounds","set","error","Error","removeSticker","removed","delete","updateSticker","updates","get","Object","assign","metadata","updatedAt","getSticker","getAllStickers","Array","from","values","sort","a","b","selectSticker","prevSticker","moveStickerTo","snapped","scaleSticker","scaleConstraints","rotateSticker","PI","flipSticker","undefined","setStickerZIndex","bringToFront","maxZ","s","sendToBack","minZ","checkCollisions","excludeId","filter","collidingStickers","i","length","j","aRect","bRect","includes","push","hasCollision","getStickerAtPosition","reverse","renderGrid","save","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","restore","renderSticker","globalAlpha","globalCompositeOperation","shadow","shadowColor","color","shadowOffsetX","offsetX","shadowOffsetY","offsetY","shadowBlur","blur","translate","rotate","drawImage","tint","fillStyle","fillRect","border","style","setLineDash","forEach","closePath","renderSelectionHandles","handleSize","handleColor","handleBorderColor","strokeRect","rotationHandleY","arc","fill","renderAllStickers","clearRect","sortedStickers","setGridConfig","getGridConfig","exportStickers","importStickers","importedIds","stickerConfig","console","clearAllStickers","clear"],"mappings":"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"}