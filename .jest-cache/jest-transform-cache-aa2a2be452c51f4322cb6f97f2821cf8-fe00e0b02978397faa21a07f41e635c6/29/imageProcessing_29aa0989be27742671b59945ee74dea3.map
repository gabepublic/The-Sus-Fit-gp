{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/utils/imageProcessing.ts"],"sourcesContent":["// Image Processing Utilities for Try-On Mutations\n// Comprehensive image processing functions for the business layer\n\nimport { \n  fileToBase64, \n  compressBase64, \n  isImageFile,\n  FileTypeNotSupportedError,\n  FileTooLargeError,\n  CompressionFailedError,\n  type ImageBase64\n} from '@/utils/image';\n\n// Re-export utilities needed by other business layer modules\nexport { \n  compressBase64, \n  CompressionFailedError,\n  FileTypeNotSupportedError,\n  FileTooLargeError,\n  fileToBase64,\n  isImageFile,\n  type ImageBase64 \n};\n\n// getBase64Size function is exported where it's defined below\nimport { \n  type ManagedCanvas \n} from '../providers/CanvasProvider';\nimport {\n  AdvancedCanvasOperations,\n  createAdvancedCanvasOperations\n} from './canvasUtils';\n\n/**\n * Custom error for image processing failures\n */\nexport class ImageProcessingError extends Error {\n  constructor(message: string, public readonly originalError?: Error) {\n    super(message);\n    this.name = 'ImageProcessingError';\n  }\n}\n\n/**\n * Custom error for image dimension validation failures\n */\nexport class ImageDimensionError extends Error {\n  constructor(message: string, public readonly width?: number, public readonly height?: number) {\n    super(message);\n    this.name = 'ImageDimensionError';\n  }\n}\n\n/**\n * Configuration options for image processing\n */\nexport interface ImageProcessingOptions {\n  /** Target width for resizing (default: 1024) */\n  targetWidth?: number;\n  /** Target height for resizing (default: 1536) */\n  targetHeight?: number;\n  /** Maximum file size in KB after compression (default: 1024) */\n  maxSizeKB?: number;\n  /** JPEG quality for compression (0.1-1.0, default: 0.9) */\n  quality?: number;\n  /** Whether to preserve aspect ratio during resize (default: false) */\n  preserveAspectRatio?: boolean;\n}\n\n/**\n * Default processing options for try-on images\n */\nexport const DEFAULT_PROCESSING_OPTIONS: Required<ImageProcessingOptions> = {\n  targetWidth: 1024,\n  targetHeight: 1536,\n  maxSizeKB: 1024,\n  quality: 0.9,\n  preserveAspectRatio: false\n};\n\n/**\n * Supported image formats for conversion\n */\nexport enum ImageFormat {\n  JPEG = 'image/jpeg',\n  PNG = 'image/png',\n  WEBP = 'image/webp',\n  GIF = 'image/gif'\n}\n\n/**\n * Image metadata extracted from file\n */\nexport interface ImageMetadata {\n  /** Image format/MIME type */\n  format: string;\n  /** Image dimensions */\n  dimensions: { width: number; height: number };\n  /** File size in bytes */\n  size: number;\n  /** Color depth information */\n  colorDepth?: number;\n  /** Whether image has transparency */\n  hasAlpha?: boolean;\n  /** Estimated quality (for JPEG) */\n  estimatedQuality?: number;\n  /** Creation timestamp if available */\n  dateCreated?: Date;\n  /** Device orientation (EXIF) */\n  orientation?: number;\n  /** DPI/resolution information */\n  resolution?: { x: number; y: number };\n}\n\n/**\n * Advanced image processing options\n */\nexport interface AdvancedImageProcessingOptions extends ImageProcessingOptions {\n  /** Output format */\n  outputFormat?: ImageFormat;\n  /** Enable sharpening after resize */\n  enableSharpening?: boolean;\n  /** Noise reduction strength (0-1) */\n  noiseReduction?: number;\n  /** Enable automatic color correction */\n  autoColorCorrection?: boolean;\n  /** Preserve EXIF data */\n  preserveExif?: boolean;\n  /** Custom canvas for processing */\n  canvas?: ManagedCanvas;\n}\n\n/**\n * Enhanced result of image processing operations\n */\nexport interface AdvancedImageProcessingResult {\n  /** Processed image as base64 data URL */\n  processedImage: ImageBase64;\n  /** Original image metadata */\n  originalMetadata: ImageMetadata;\n  /** Final image metadata */\n  finalMetadata: ImageMetadata;\n  /** Processing metadata */\n  processingMetadata: {\n    wasResized: boolean;\n    wasCompressed: boolean;\n    wasFormatConverted: boolean;\n    wasSharpened: boolean;\n    hadNoiseReduction: boolean;\n    compressionRatio: number;\n    processingTime: number;\n    operationsApplied: string[];\n  };\n}\n\n/**\n * Result of image processing operations (legacy compatibility)\n */\nexport interface ImageProcessingResult {\n  /** Processed image as base64 data URL */\n  processedImage: ImageBase64;\n  /** Original image dimensions */\n  originalDimensions: { width: number; height: number };\n  /** Final image dimensions */\n  finalDimensions: { width: number; height: number };\n  /** Original file size in bytes */\n  originalSize: number;\n  /** Final file size in bytes */\n  finalSize: number;\n  /** Processing metadata */\n  metadata: {\n    wasResized: boolean;\n    wasCompressed: boolean;\n    compressionRatio: number;\n    processingTime: number;\n  };\n}\n\n/**\n * Get image dimensions from a data URL or image element\n */\nexport function getImageDimensions(imageUrl: string): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      resolve({ width: img.width, height: img.height });\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for dimension analysis'));\n    };\n    \n    img.src = imageUrl;\n  });\n}\n\n/**\n * Resize image to specific dimensions\n * \n * @param imageUrl - Source image data URL\n * @param options - Resize options\n * @returns Promise resolving to resized image data URL\n */\nexport function resizeImageTo1024x1536(\n  imageUrl: string, \n  options: Partial<ImageProcessingOptions> = {}\n): Promise<string> {\n  const config = { ...DEFAULT_PROCESSING_OPTIONS, ...options };\n  \n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      try {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        if (!ctx) {\n          reject(new ImageProcessingError('Could not get canvas context'));\n          return;\n        }\n        \n        let { targetWidth, targetHeight } = config;\n        \n        // Calculate dimensions preserving aspect ratio if requested\n        if (config.preserveAspectRatio) {\n          const aspectRatio = img.width / img.height;\n          const targetAspectRatio = targetWidth / targetHeight;\n          \n          if (aspectRatio > targetAspectRatio) {\n            // Image is wider, fit to width\n            targetHeight = Math.round(targetWidth / aspectRatio);\n          } else {\n            // Image is taller, fit to height\n            targetWidth = Math.round(targetHeight * aspectRatio);\n          }\n        }\n        \n        // Set canvas dimensions\n        canvas.width = targetWidth;\n        canvas.height = targetHeight;\n        \n        // Apply high-quality scaling\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n        \n        // Draw the image resized to fit the canvas\n        ctx.drawImage(img, 0, 0, targetWidth, targetHeight);\n        \n        // Convert to data URL with specified quality\n        const resizedImageUrl = canvas.toDataURL('image/jpeg', config.quality);\n        resolve(resizedImageUrl);\n      } catch (error) {\n        reject(new ImageProcessingError(\n          'Failed to resize image',\n          error instanceof Error ? error : new Error(String(error))\n        ));\n      }\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for resizing'));\n    };\n    \n    img.src = imageUrl;\n  });\n}\n\n/**\n * Validate image dimensions against requirements\n */\nexport async function validateImageDimensions(\n  imageUrl: string,\n  minWidth = 512,\n  minHeight = 512,\n  maxWidth = 4096,\n  maxHeight = 4096\n): Promise<void> {\n  const dimensions = await getImageDimensions(imageUrl);\n  \n  if (dimensions.width < minWidth || dimensions.height < minHeight) {\n    throw new ImageDimensionError(\n      `Image dimensions too small. Minimum: ${minWidth}x${minHeight}, got: ${dimensions.width}x${dimensions.height}`,\n      dimensions.width,\n      dimensions.height\n    );\n  }\n  \n  if (dimensions.width > maxWidth || dimensions.height > maxHeight) {\n    throw new ImageDimensionError(\n      `Image dimensions too large. Maximum: ${maxWidth}x${maxHeight}, got: ${dimensions.width}x${dimensions.height}`,\n      dimensions.width,\n      dimensions.height\n    );\n  }\n}\n\n/**\n * Calculate file size from base64 data URL\n */\nexport function getBase64Size(base64: string): number {\n  const base64Data = base64.split(',')[1];\n  return atob(base64Data).length;\n}\n\n/**\n * Process a file through the complete try-on image pipeline\n * \n * @param file - Input image file\n * @param options - Processing options\n * @returns Promise resolving to processing result\n */\nexport async function processImageForTryon(\n  file: File,\n  options: Partial<ImageProcessingOptions> = {}\n): Promise<ImageProcessingResult> {\n  const startTime = Date.now();\n  const config = { ...DEFAULT_PROCESSING_OPTIONS, ...options };\n  \n  try {\n    // Step 1: Validate file type and convert to base64\n    if (!isImageFile(file)) {\n      throw new FileTypeNotSupportedError('Only image files are allowed');\n    }\n    \n    const originalBase64 = await fileToBase64(file);\n    const originalSize = file.size;\n    const originalDimensions = await getImageDimensions(originalBase64);\n    \n    // Step 2: Validate dimensions\n    await validateImageDimensions(originalBase64);\n    \n    // Step 3: Resize image to target dimensions\n    const resizedImage = await resizeImageTo1024x1536(originalBase64, config);\n    const finalDimensions = await getImageDimensions(resizedImage);\n    \n    // Step 4: Compress if needed\n    let processedImage = resizedImage;\n    let wasCompressed = false;\n    \n    const resizedSize = getBase64Size(resizedImage);\n    const targetSizeBytes = config.maxSizeKB * 1024;\n    \n    if (resizedSize > targetSizeBytes) {\n      processedImage = await compressBase64(resizedImage, config.maxSizeKB);\n      wasCompressed = true;\n    }\n    \n    const finalSize = getBase64Size(processedImage);\n    const processingTime = Date.now() - startTime;\n    \n    return {\n      processedImage,\n      originalDimensions,\n      finalDimensions,\n      originalSize,\n      finalSize,\n      metadata: {\n        wasResized: originalDimensions.width !== finalDimensions.width || \n                   originalDimensions.height !== finalDimensions.height,\n        wasCompressed,\n        compressionRatio: originalSize / finalSize,\n        processingTime\n      }\n    };\n  } catch (error) {\n    if (error instanceof FileTypeNotSupportedError ||\n        error instanceof FileTooLargeError ||\n        error instanceof CompressionFailedError ||\n        error instanceof ImageDimensionError ||\n        error instanceof ImageProcessingError) {\n      throw error;\n    }\n    \n    throw new ImageProcessingError(\n      'Unexpected error during image processing',\n      error instanceof Error ? error : new Error(String(error))\n    );\n  }\n}\n\n/**\n * Process multiple images for try-on (model + apparel images)\n */\nexport async function processTryonImages(\n  modelImage: File,\n  apparelImages: File[],\n  options: Partial<ImageProcessingOptions> = {}\n): Promise<{\n  modelImageResult: ImageProcessingResult;\n  apparelImageResults: ImageProcessingResult[];\n}> {\n  // Process model image\n  const modelImageResult = await processImageForTryon(modelImage, options);\n  \n  // Process all apparel images in parallel\n  const apparelImageResults = await Promise.all(\n    apparelImages.map(file => processImageForTryon(file, options))\n  );\n  \n  return {\n    modelImageResult,\n    apparelImageResults\n  };\n}\n\n/**\n * Extract comprehensive metadata from image\n */\nexport async function extractImageMetadata(file: File): Promise<ImageMetadata> {\n  const imageUrl = await fileToBase64(file);\n  const dimensions = await getImageDimensions(imageUrl);\n  \n  return {\n    format: file.type,\n    dimensions,\n    size: file.size,\n    dateCreated: file.lastModified ? new Date(file.lastModified) : undefined,\n    // Additional metadata would require EXIF parsing library\n    // For now, we'll provide basic metadata\n  };\n}\n\n/**\n * Convert image to different format\n */\nexport async function convertImageFormat(\n  imageUrl: string,\n  targetFormat: ImageFormat,\n  quality: number = 0.9\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      try {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        if (!ctx) {\n          reject(new ImageProcessingError('Could not get canvas context'));\n          return;\n        }\n        \n        canvas.width = img.width;\n        canvas.height = img.height;\n        \n        // For PNG with transparency, fill with white background for JPEG\n        if (targetFormat === ImageFormat.JPEG) {\n          ctx.fillStyle = 'white';\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n        \n        ctx.drawImage(img, 0, 0);\n        \n        const convertedImageUrl = canvas.toDataURL(targetFormat, quality);\n        resolve(convertedImageUrl);\n      } catch (error) {\n        reject(new ImageProcessingError(\n          'Failed to convert image format',\n          error instanceof Error ? error : new Error(String(error))\n        ));\n      }\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for format conversion'));\n    };\n    \n    img.src = imageUrl;\n  });\n}\n\n/**\n * Apply sharpening filter to image\n */\nexport function applySharpeningFilter(canvas: HTMLCanvasElement, strength: number = 0.5): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  const width = canvas.width;\n  const height = canvas.height;\n  \n  // Simple unsharp mask implementation\n  const sharpenKernel = [\n    0, -strength, 0,\n    -strength, 1 + 4 * strength, -strength,\n    0, -strength, 0\n  ];\n  \n  const newData = new Uint8ClampedArray(data);\n  \n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      for (let c = 0; c < 3; c++) { // RGB channels only\n        let sum = 0;\n        for (let ky = -1; ky <= 1; ky++) {\n          for (let kx = -1; kx <= 1; kx++) {\n            const pixelIndex = ((y + ky) * width + (x + kx)) * 4 + c;\n            const kernelIndex = (ky + 1) * 3 + (kx + 1);\n            sum += data[pixelIndex] * sharpenKernel[kernelIndex];\n          }\n        }\n        newData[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));\n      }\n    }\n  }\n  \n  // Copy the new data back\n  for (let i = 0; i < data.length; i++) {\n    data[i] = newData[i];\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Apply noise reduction filter\n */\nexport function applyNoiseReduction(canvas: HTMLCanvasElement, strength: number = 0.3): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  const width = canvas.width;\n  const height = canvas.height;\n  \n  // Simple blur for noise reduction\n  const radius = Math.ceil(strength * 3);\n  const newData = new Uint8ClampedArray(data);\n  \n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      for (let c = 0; c < 3; c++) { // RGB channels only\n        let sum = 0;\n        let count = 0;\n        \n        for (let dy = -radius; dy <= radius; dy++) {\n          for (let dx = -radius; dx <= radius; dx++) {\n            const nx = x + dx;\n            const ny = y + dy;\n            \n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n              sum += data[(ny * width + nx) * 4 + c];\n              count++;\n            }\n          }\n        }\n        \n        newData[(y * width + x) * 4 + c] = sum / count;\n      }\n    }\n  }\n  \n  // Copy the new data back\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = newData[i];     // R\n    data[i + 1] = newData[i + 1]; // G\n    data[i + 2] = newData[i + 2]; // B\n    // Keep original alpha\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Apply automatic color correction\n */\nexport function applyAutoColorCorrection(canvas: HTMLCanvasElement): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  \n  // Calculate histogram\n  const histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0)\n  };\n  \n  for (let i = 0; i < data.length; i += 4) {\n    histogram.r[data[i]]++;\n    histogram.g[data[i + 1]]++;\n    histogram.b[data[i + 2]]++;\n  }\n  \n  // Find min/max values for each channel\n  const getMinMax = (hist: number[]) => {\n    let min = 0, max = 255;\n    for (let i = 0; i < 256; i++) {\n      if (hist[i] > 0) { min = i; break; }\n    }\n    for (let i = 255; i >= 0; i--) {\n      if (hist[i] > 0) { max = i; break; }\n    }\n    return { min, max };\n  };\n  \n  const rMinMax = getMinMax(histogram.r);\n  const gMinMax = getMinMax(histogram.g);\n  const bMinMax = getMinMax(histogram.b);\n  \n  // Apply histogram stretching\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = Math.max(0, Math.min(255, \n      ((data[i] - rMinMax.min) / (rMinMax.max - rMinMax.min)) * 255));\n    data[i + 1] = Math.max(0, Math.min(255, \n      ((data[i + 1] - gMinMax.min) / (gMinMax.max - gMinMax.min)) * 255));\n    data[i + 2] = Math.max(0, Math.min(255, \n      ((data[i + 2] - bMinMax.min) / (bMinMax.max - bMinMax.min)) * 255));\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Advanced image processing with comprehensive options\n */\nexport async function processImageAdvanced(\n  file: File,\n  options: Partial<AdvancedImageProcessingOptions> = {}\n): Promise<AdvancedImageProcessingResult> {\n  const startTime = Date.now();\n  const config = { ...DEFAULT_PROCESSING_OPTIONS, ...options };\n  const operationsApplied: string[] = [];\n  \n  try {\n    // Step 1: Extract original metadata\n    const originalMetadata = await extractImageMetadata(file);\n    operationsApplied.push('metadata-extraction');\n    \n    // Step 2: Validate file type and convert to base64\n    if (!isImageFile(file)) {\n      throw new FileTypeNotSupportedError('Only image files are allowed');\n    }\n    \n    let currentImage = await fileToBase64(file);\n    operationsApplied.push('base64-conversion');\n    \n    // Step 3: Validate dimensions\n    await validateImageDimensions(currentImage);\n    operationsApplied.push('dimension-validation');\n    \n    // Step 4: Format conversion (if needed)\n    let wasFormatConverted = false;\n    if (options.outputFormat && options.outputFormat !== file.type) {\n      currentImage = await convertImageFormat(currentImage, options.outputFormat, config.quality);\n      wasFormatConverted = true;\n      operationsApplied.push('format-conversion');\n    }\n    \n    // Step 5: Create canvas for advanced processing\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n    \n    // Load image onto canvas\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    await new Promise<void>((resolve, reject) => {\n      img.onload = () => resolve();\n      img.onerror = () => reject(new ImageProcessingError('Failed to load image'));\n      img.src = currentImage;\n    });\n    \n    // Set canvas dimensions based on resize requirements\n    const finalWidth = config.targetWidth || img.width;\n    const finalHeight = config.targetHeight || img.height;\n    \n    canvas.width = finalWidth;\n    canvas.height = finalHeight;\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high';\n    \n    // Draw resized image\n    ctx.drawImage(img, 0, 0, finalWidth, finalHeight);\n    \n    const wasResized = img.width !== finalWidth || img.height !== finalHeight;\n    if (wasResized) {\n      operationsApplied.push('resize');\n    }\n    \n    // Step 6: Apply advanced processing\n    let wasSharpened = false;\n    if (options.enableSharpening && wasResized) {\n      applySharpeningFilter(canvas, 0.3);\n      wasSharpened = true;\n      operationsApplied.push('sharpening');\n    }\n    \n    let hadNoiseReduction = false;\n    if (options.noiseReduction && options.noiseReduction > 0) {\n      applyNoiseReduction(canvas, options.noiseReduction);\n      hadNoiseReduction = true;\n      operationsApplied.push('noise-reduction');\n    }\n    \n    if (options.autoColorCorrection) {\n      applyAutoColorCorrection(canvas);\n      operationsApplied.push('color-correction');\n    }\n    \n    // Step 7: Convert back to data URL\n    const outputFormat = options.outputFormat || ImageFormat.JPEG;\n    let processedImage = canvas.toDataURL(outputFormat, config.quality);\n    \n    // Step 8: Compress if needed\n    let wasCompressed = false;\n    const processedSize = getBase64Size(processedImage);\n    const targetSizeBytes = config.maxSizeKB * 1024;\n    \n    if (processedSize > targetSizeBytes) {\n      processedImage = await compressBase64(processedImage, config.maxSizeKB);\n      wasCompressed = true;\n      operationsApplied.push('compression');\n    }\n    \n    // Step 9: Generate final metadata\n    const finalDimensions = await getImageDimensions(processedImage);\n    const finalSize = getBase64Size(processedImage);\n    const processingTime = Date.now() - startTime;\n    \n    const finalMetadata: ImageMetadata = {\n      format: outputFormat,\n      dimensions: finalDimensions,\n      size: finalSize\n    };\n    \n    return {\n      processedImage,\n      originalMetadata,\n      finalMetadata,\n      processingMetadata: {\n        wasResized,\n        wasCompressed,\n        wasFormatConverted,\n        wasSharpened,\n        hadNoiseReduction,\n        compressionRatio: originalMetadata.size / finalSize,\n        processingTime,\n        operationsApplied\n      }\n    };\n    \n  } catch (error) {\n    if (error instanceof FileTypeNotSupportedError ||\n        error instanceof FileTooLargeError ||\n        error instanceof CompressionFailedError ||\n        error instanceof ImageDimensionError ||\n        error instanceof ImageProcessingError) {\n      throw error;\n    }\n    \n    throw new ImageProcessingError(\n      'Unexpected error during advanced image processing',\n      error instanceof Error ? error : new Error(String(error))\n    );\n  }\n}\n\n/**\n * Batch process multiple images with progress tracking\n */\nexport async function processImagesInBatch(\n  files: File[],\n  options: Partial<AdvancedImageProcessingOptions> = {},\n  onProgress?: (completed: number, total: number, currentFile: string) => void\n): Promise<AdvancedImageProcessingResult[]> {\n  const results: AdvancedImageProcessingResult[] = [];\n  \n  for (let i = 0; i < files.length; i++) {\n    const file = files[i];\n    onProgress?.(i, files.length, file.name);\n    \n    try {\n      const result = await processImageAdvanced(file, options);\n      results.push(result);\n    } catch (error) {\n      // For batch processing, we might want to continue with other files\n      console.error(`Failed to process ${file.name}:`, error);\n      // You could push a failed result or skip, depending on requirements\n    }\n  }\n  \n  onProgress?.(files.length, files.length, 'Complete');\n  return results;\n}\n\n/**\n * Create image thumbnail with consistent dimensions\n */\nexport async function createImageThumbnail(\n  file: File,\n  size: number = 150,\n  quality: number = 0.8\n): Promise<string> {\n  const imageUrl = await fileToBase64(file);\n  \n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      try {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        if (!ctx) {\n          reject(new ImageProcessingError('Could not get canvas context'));\n          return;\n        }\n        \n        // Calculate dimensions to maintain aspect ratio\n        const aspectRatio = img.width / img.height;\n        let width = size;\n        let height = size;\n        \n        if (aspectRatio > 1) {\n          height = size / aspectRatio;\n        } else {\n          width = size * aspectRatio;\n        }\n        \n        canvas.width = width;\n        canvas.height = height;\n        \n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n        ctx.drawImage(img, 0, 0, width, height);\n        \n        const thumbnailUrl = canvas.toDataURL('image/jpeg', quality);\n        resolve(thumbnailUrl);\n      } catch (error) {\n        reject(new ImageProcessingError(\n          'Failed to create thumbnail',\n          error instanceof Error ? error : new Error(String(error))\n        ));\n      }\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for thumbnail creation'));\n    };\n    \n    img.src = imageUrl;\n  });\n}"],"names":["CompressionFailedError","DEFAULT_PROCESSING_OPTIONS","FileTooLargeError","FileTypeNotSupportedError","ImageDimensionError","ImageFormat","ImageProcessingError","applyAutoColorCorrection","applyNoiseReduction","applySharpeningFilter","compressBase64","convertImageFormat","createImageThumbnail","extractImageMetadata","fileToBase64","getBase64Size","getImageDimensions","isImageFile","processImageAdvanced","processImageForTryon","processImagesInBatch","processTryonImages","resizeImageTo1024x1536","validateImageDimensions","Error","constructor","message","originalError","name","width","height","targetWidth","targetHeight","maxSizeKB","quality","preserveAspectRatio","imageUrl","Promise","resolve","reject","img","Image","crossOrigin","onload","onerror","src","options","config","canvas","document","createElement","ctx","getContext","aspectRatio","targetAspectRatio","Math","round","imageSmoothingEnabled","imageSmoothingQuality","drawImage","resizedImageUrl","toDataURL","error","String","minWidth","minHeight","maxWidth","maxHeight","dimensions","base64","base64Data","split","atob","length","file","startTime","Date","now","originalBase64","originalSize","size","originalDimensions","resizedImage","finalDimensions","processedImage","wasCompressed","resizedSize","targetSizeBytes","finalSize","processingTime","metadata","wasResized","compressionRatio","modelImage","apparelImages","modelImageResult","apparelImageResults","all","map","format","type","dateCreated","lastModified","undefined","targetFormat","fillStyle","fillRect","convertedImageUrl","strength","imageData","getImageData","data","sharpenKernel","newData","Uint8ClampedArray","y","x","c","sum","ky","kx","pixelIndex","kernelIndex","max","min","i","putImageData","radius","ceil","count","dy","dx","nx","ny","histogram","r","Array","fill","g","b","getMinMax","hist","rMinMax","gMinMax","bMinMax","operationsApplied","originalMetadata","push","currentImage","wasFormatConverted","outputFormat","finalWidth","finalHeight","wasSharpened","enableSharpening","hadNoiseReduction","noiseReduction","autoColorCorrection","processedSize","finalMetadata","processingMetadata","files","onProgress","results","result","console","thumbnailUrl"],"mappings":"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"}