89d3d0cdf3876882a226da156ee9572e
// Polyfill Web APIs for MSW v2 in Node.js environment
"use strict";
// Mock Next.js router
jest.mock('next/router', ()=>({
        useRouter () {
            return {
                route: '/',
                pathname: '/',
                query: {},
                asPath: '/',
                push: jest.fn(),
                pop: jest.fn(),
                reload: jest.fn(),
                back: jest.fn(),
                prefetch: jest.fn(),
                beforePopState: jest.fn(),
                events: {
                    on: jest.fn(),
                    off: jest.fn(),
                    emit: jest.fn()
                }
            };
        }
    }));
// Mock Next.js navigation
jest.mock('next/navigation', ()=>({
        useRouter () {
            return {
                push: jest.fn(),
                replace: jest.fn(),
                prefetch: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn()
            };
        },
        useSearchParams () {
            return new URLSearchParams();
        },
        usePathname () {
            return '/';
        }
    }));
// Next.js response is now part of next/server, so we don't need a separate mock for next/response
// Mock Next.js server (required by subtask)
jest.mock('next/server', ()=>({
        NextRequest: class NextRequest {
            constructor(input, init = {}){
                this.url = typeof input === 'string' ? input : input.url;
                this.method = init.method || 'GET';
                this.headers = new Headers(init.headers || {});
                this.body = init.body;
            }
            json() {
                return Promise.resolve(JSON.parse(this.body || '{}'));
            }
            text() {
                return Promise.resolve(this.body || '');
            }
        },
        NextResponse: {
            json: jest.fn((data, init)=>({
                    json: ()=>Promise.resolve(data),
                    status: init?.status || 200,
                    headers: init?.headers || {}
                })),
            redirect: jest.fn((url)=>({
                    status: 302,
                    headers: {
                        location: url
                    }
                })),
            rewrite: jest.fn((url)=>({
                    status: 200,
                    headers: {
                        'x-rewrite-url': url
                    }
                }))
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("@testing-library/jest-dom");
const { TextEncoder, TextDecoder } = require('util');
const { ReadableStream, WritableStream, TransformStream } = require('stream/web');
// Set globals before requiring undici
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
global.ReadableStream = ReadableStream;
global.WritableStream = WritableStream;
global.TransformStream = TransformStream;
// Mock MessagePort for undici
global.MessagePort = class MessagePort {
    constructor(){}
    postMessage() {}
    start() {}
    close() {}
};
// Mock BroadcastChannel for MSW
global.BroadcastChannel = class BroadcastChannel {
    constructor(name){
        this.name = name;
    }
    postMessage() {}
    close() {}
    addEventListener() {}
    removeEventListener() {}
};
// Now require undici after globals are set
const { fetch, Request, Response, Headers } = require('undici');
global.fetch = fetch;
global.Request = Request;
global.Response = Response;
global.Headers = Headers;
// Mock environment variables
process.env.NEXT_PUBLIC_APP_URL = 'http://localhost:3000';
// Mock browser APIs that are not available in Node.js
global.ResizeObserver = jest.fn().mockImplementation(()=>({
        observe: jest.fn(),
        unobserve: jest.fn(),
        disconnect: jest.fn()
    }));
// Mock IntersectionObserver
global.IntersectionObserver = jest.fn().mockImplementation(()=>({
        observe: jest.fn(),
        unobserve: jest.fn(),
        disconnect: jest.fn()
    }));
// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: jest.fn().mockImplementation((query)=>({
            matches: false,
            media: query,
            onchange: null,
            addListener: jest.fn(),
            removeListener: jest.fn(),
            addEventListener: jest.fn(),
            removeEventListener: jest.fn(),
            dispatchEvent: jest.fn()
        }))
});
// Mock window.scrollTo
Object.defineProperty(window, 'scrollTo', {
    writable: true,
    value: jest.fn()
});
// Suppress console.error for expected test errors
const originalError = console.error;
console.error = (...args)=>{
    // Suppress environment validation errors in tests
    if (typeof args[0] === 'string' && args[0].includes('Environment validation failed:')) {
        return;
    }
    // Suppress expected API errors in tests
    if (typeof args[0] === 'string' && args[0].includes('Try-on API error:')) {
        return;
    }
    originalError.call(console, ...args);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvamVzdC5zZXR1cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb2x5ZmlsbCBXZWIgQVBJcyBmb3IgTVNXIHYyIGluIE5vZGUuanMgZW52aXJvbm1lbnRcbmNvbnN0IHsgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IHsgUmVhZGFibGVTdHJlYW0sIFdyaXRhYmxlU3RyZWFtLCBUcmFuc2Zvcm1TdHJlYW0gfSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKVxuXG4vLyBTZXQgZ2xvYmFscyBiZWZvcmUgcmVxdWlyaW5nIHVuZGljaVxuZ2xvYmFsLlRleHRFbmNvZGVyID0gVGV4dEVuY29kZXJcbmdsb2JhbC5UZXh0RGVjb2RlciA9IFRleHREZWNvZGVyXG5nbG9iYWwuUmVhZGFibGVTdHJlYW0gPSBSZWFkYWJsZVN0cmVhbVxuZ2xvYmFsLldyaXRhYmxlU3RyZWFtID0gV3JpdGFibGVTdHJlYW1cbmdsb2JhbC5UcmFuc2Zvcm1TdHJlYW0gPSBUcmFuc2Zvcm1TdHJlYW1cblxuLy8gTW9jayBNZXNzYWdlUG9ydCBmb3IgdW5kaWNpXG5nbG9iYWwuTWVzc2FnZVBvcnQgPSBjbGFzcyBNZXNzYWdlUG9ydCB7XG4gIGNvbnN0cnVjdG9yKCkge31cbiAgcG9zdE1lc3NhZ2UoKSB7fVxuICBzdGFydCgpIHt9XG4gIGNsb3NlKCkge31cbn1cblxuLy8gTW9jayBCcm9hZGNhc3RDaGFubmVsIGZvciBNU1dcbmdsb2JhbC5Ccm9hZGNhc3RDaGFubmVsID0gY2xhc3MgQnJvYWRjYXN0Q2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gIH1cbiAgcG9zdE1lc3NhZ2UoKSB7fVxuICBjbG9zZSgpIHt9XG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7fVxuICByZW1vdmVFdmVudExpc3RlbmVyKCkge31cbn1cblxuLy8gTm93IHJlcXVpcmUgdW5kaWNpIGFmdGVyIGdsb2JhbHMgYXJlIHNldFxuY29uc3QgeyBmZXRjaCwgUmVxdWVzdCwgUmVzcG9uc2UsIEhlYWRlcnMgfSA9IHJlcXVpcmUoJ3VuZGljaScpXG5nbG9iYWwuZmV0Y2ggPSBmZXRjaFxuZ2xvYmFsLlJlcXVlc3QgPSBSZXF1ZXN0XG5nbG9iYWwuUmVzcG9uc2UgPSBSZXNwb25zZVxuZ2xvYmFsLkhlYWRlcnMgPSBIZWFkZXJzXG5cbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9qZXN0LWRvbSdcblxuLy8gTW9jayBOZXh0LmpzIHJvdXRlclxuamVzdC5tb2NrKCduZXh0L3JvdXRlcicsICgpID0+ICh7XG4gIHVzZVJvdXRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGU6ICcvJyxcbiAgICAgIHBhdGhuYW1lOiAnLycsXG4gICAgICBxdWVyeToge30sXG4gICAgICBhc1BhdGg6ICcvJyxcbiAgICAgIHB1c2g6IGplc3QuZm4oKSxcbiAgICAgIHBvcDogamVzdC5mbigpLFxuICAgICAgcmVsb2FkOiBqZXN0LmZuKCksXG4gICAgICBiYWNrOiBqZXN0LmZuKCksXG4gICAgICBwcmVmZXRjaDogamVzdC5mbigpLFxuICAgICAgYmVmb3JlUG9wU3RhdGU6IGplc3QuZm4oKSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBvbjogamVzdC5mbigpLFxuICAgICAgICBvZmY6IGplc3QuZm4oKSxcbiAgICAgICAgZW1pdDogamVzdC5mbigpLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG59KSlcblxuLy8gTW9jayBOZXh0LmpzIG5hdmlnYXRpb25cbmplc3QubW9jaygnbmV4dC9uYXZpZ2F0aW9uJywgKCkgPT4gKHtcbiAgdXNlUm91dGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwdXNoOiBqZXN0LmZuKCksXG4gICAgICByZXBsYWNlOiBqZXN0LmZuKCksXG4gICAgICBwcmVmZXRjaDogamVzdC5mbigpLFxuICAgICAgYmFjazogamVzdC5mbigpLFxuICAgICAgZm9yd2FyZDogamVzdC5mbigpLFxuICAgICAgcmVmcmVzaDogamVzdC5mbigpLFxuICAgIH1cbiAgfSxcbiAgdXNlU2VhcmNoUGFyYW1zKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgfSxcbiAgdXNlUGF0aG5hbWUoKSB7XG4gICAgcmV0dXJuICcvJ1xuICB9LFxufSkpXG5cbi8vIE5leHQuanMgcmVzcG9uc2UgaXMgbm93IHBhcnQgb2YgbmV4dC9zZXJ2ZXIsIHNvIHdlIGRvbid0IG5lZWQgYSBzZXBhcmF0ZSBtb2NrIGZvciBuZXh0L3Jlc3BvbnNlXG5cbi8vIE1vY2sgTmV4dC5qcyBzZXJ2ZXIgKHJlcXVpcmVkIGJ5IHN1YnRhc2spXG5qZXN0Lm1vY2soJ25leHQvc2VydmVyJywgKCkgPT4gKHtcbiAgTmV4dFJlcXVlc3Q6IGNsYXNzIE5leHRSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgICB0aGlzLnVybCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IGlucHV0LnVybFxuICAgICAgdGhpcy5tZXRob2QgPSBpbml0Lm1ldGhvZCB8fCAnR0VUJ1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzIHx8IHt9KVxuICAgICAgdGhpcy5ib2R5ID0gaW5pdC5ib2R5XG4gICAgfVxuICAgIFxuICAgIGpzb24oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UodGhpcy5ib2R5IHx8ICd7fScpKVxuICAgIH1cbiAgICBcbiAgICB0ZXh0KCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmJvZHkgfHwgJycpXG4gICAgfVxuICB9LFxuICBOZXh0UmVzcG9uc2U6IHtcbiAgICBqc29uOiBqZXN0LmZuKChkYXRhLCBpbml0KSA9PiAoe1xuICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpLFxuICAgICAgc3RhdHVzOiBpbml0Py5zdGF0dXMgfHwgMjAwLFxuICAgICAgaGVhZGVyczogaW5pdD8uaGVhZGVycyB8fCB7fSxcbiAgICB9KSksXG4gICAgcmVkaXJlY3Q6IGplc3QuZm4oKHVybCkgPT4gKHtcbiAgICAgIHN0YXR1czogMzAyLFxuICAgICAgaGVhZGVyczogeyBsb2NhdGlvbjogdXJsIH0sXG4gICAgfSkpLFxuICAgIHJld3JpdGU6IGplc3QuZm4oKHVybCkgPT4gKHtcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgaGVhZGVyczogeyAneC1yZXdyaXRlLXVybCc6IHVybCB9LFxuICAgIH0pKSxcbiAgfSxcbn0pKVxuXG4vLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xucHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBQX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnXG5cbi8vIE1vY2sgYnJvd3NlciBBUElzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGUgaW4gTm9kZS5qc1xuZ2xvYmFsLlJlc2l6ZU9ic2VydmVyID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICBvYnNlcnZlOiBqZXN0LmZuKCksXG4gIHVub2JzZXJ2ZTogamVzdC5mbigpLFxuICBkaXNjb25uZWN0OiBqZXN0LmZuKCksXG59KSlcblxuLy8gTW9jayBJbnRlcnNlY3Rpb25PYnNlcnZlclxuZ2xvYmFsLkludGVyc2VjdGlvbk9ic2VydmVyID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICBvYnNlcnZlOiBqZXN0LmZuKCksXG4gIHVub2JzZXJ2ZTogamVzdC5mbigpLFxuICBkaXNjb25uZWN0OiBqZXN0LmZuKCksXG59KSlcblxuLy8gTW9jayBtYXRjaE1lZGlhXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnbWF0Y2hNZWRpYScsIHtcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKHF1ZXJ5ID0+ICh7XG4gICAgbWF0Y2hlczogZmFsc2UsXG4gICAgbWVkaWE6IHF1ZXJ5LFxuICAgIG9uY2hhbmdlOiBudWxsLFxuICAgIGFkZExpc3RlbmVyOiBqZXN0LmZuKCksIC8vIGRlcHJlY2F0ZWRcbiAgICByZW1vdmVMaXN0ZW5lcjogamVzdC5mbigpLCAvLyBkZXByZWNhdGVkXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICBkaXNwYXRjaEV2ZW50OiBqZXN0LmZuKCksXG4gIH0pKSxcbn0pXG5cbi8vIE1vY2sgd2luZG93LnNjcm9sbFRvXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnc2Nyb2xsVG8nLCB7XG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogamVzdC5mbigpLFxufSlcblxuLy8gU3VwcHJlc3MgY29uc29sZS5lcnJvciBmb3IgZXhwZWN0ZWQgdGVzdCBlcnJvcnNcbmNvbnN0IG9yaWdpbmFsRXJyb3IgPSBjb25zb2xlLmVycm9yXG5jb25zb2xlLmVycm9yID0gKC4uLmFyZ3MpID0+IHtcbiAgLy8gU3VwcHJlc3MgZW52aXJvbm1lbnQgdmFsaWRhdGlvbiBlcnJvcnMgaW4gdGVzdHNcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLmluY2x1ZGVzKCdFbnZpcm9ubWVudCB2YWxpZGF0aW9uIGZhaWxlZDonKSkge1xuICAgIHJldHVyblxuICB9XG4gIC8vIFN1cHByZXNzIGV4cGVjdGVkIEFQSSBlcnJvcnMgaW4gdGVzdHNcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLmluY2x1ZGVzKCdUcnktb24gQVBJIGVycm9yOicpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb3JpZ2luYWxFcnJvci5jYWxsKGNvbnNvbGUsIC4uLmFyZ3MpXG59Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwidXNlUm91dGVyIiwicm91dGUiLCJwYXRobmFtZSIsInF1ZXJ5IiwiYXNQYXRoIiwicHVzaCIsImZuIiwicG9wIiwicmVsb2FkIiwiYmFjayIsInByZWZldGNoIiwiYmVmb3JlUG9wU3RhdGUiLCJldmVudHMiLCJvbiIsIm9mZiIsImVtaXQiLCJyZXBsYWNlIiwiZm9yd2FyZCIsInJlZnJlc2giLCJ1c2VTZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ1c2VQYXRobmFtZSIsIk5leHRSZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJpbnB1dCIsImluaXQiLCJ1cmwiLCJtZXRob2QiLCJoZWFkZXJzIiwiSGVhZGVycyIsImJvZHkiLCJqc29uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJKU09OIiwicGFyc2UiLCJ0ZXh0IiwiTmV4dFJlc3BvbnNlIiwiZGF0YSIsInN0YXR1cyIsInJlZGlyZWN0IiwibG9jYXRpb24iLCJyZXdyaXRlIiwiVGV4dEVuY29kZXIiLCJUZXh0RGVjb2RlciIsInJlcXVpcmUiLCJSZWFkYWJsZVN0cmVhbSIsIldyaXRhYmxlU3RyZWFtIiwiVHJhbnNmb3JtU3RyZWFtIiwiZ2xvYmFsIiwiTWVzc2FnZVBvcnQiLCJwb3N0TWVzc2FnZSIsInN0YXJ0IiwiY2xvc2UiLCJCcm9hZGNhc3RDaGFubmVsIiwibmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZmV0Y2giLCJSZXF1ZXN0IiwiUmVzcG9uc2UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBQX1VSTCIsIlJlc2l6ZU9ic2VydmVyIiwibW9ja0ltcGxlbWVudGF0aW9uIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93Iiwid3JpdGFibGUiLCJ2YWx1ZSIsIm1hdGNoZXMiLCJtZWRpYSIsIm9uY2hhbmdlIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsImRpc3BhdGNoRXZlbnQiLCJvcmlnaW5hbEVycm9yIiwiY29uc29sZSIsImVycm9yIiwiYXJncyIsImluY2x1ZGVzIiwiY2FsbCJdLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEOztBQXVDdEQsc0JBQXNCO0FBQ3RCQSxLQUFLQyxJQUFJLENBQUMsZUFBZSxJQUFPLENBQUE7UUFDOUJDO1lBQ0UsT0FBTztnQkFDTEMsT0FBTztnQkFDUEMsVUFBVTtnQkFDVkMsT0FBTyxDQUFDO2dCQUNSQyxRQUFRO2dCQUNSQyxNQUFNUCxLQUFLUSxFQUFFO2dCQUNiQyxLQUFLVCxLQUFLUSxFQUFFO2dCQUNaRSxRQUFRVixLQUFLUSxFQUFFO2dCQUNmRyxNQUFNWCxLQUFLUSxFQUFFO2dCQUNiSSxVQUFVWixLQUFLUSxFQUFFO2dCQUNqQkssZ0JBQWdCYixLQUFLUSxFQUFFO2dCQUN2Qk0sUUFBUTtvQkFDTkMsSUFBSWYsS0FBS1EsRUFBRTtvQkFDWFEsS0FBS2hCLEtBQUtRLEVBQUU7b0JBQ1pTLE1BQU1qQixLQUFLUSxFQUFFO2dCQUNmO1lBQ0Y7UUFDRjtJQUNGLENBQUE7QUFFQSwwQkFBMEI7QUFDMUJSLEtBQUtDLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDQztZQUNFLE9BQU87Z0JBQ0xLLE1BQU1QLEtBQUtRLEVBQUU7Z0JBQ2JVLFNBQVNsQixLQUFLUSxFQUFFO2dCQUNoQkksVUFBVVosS0FBS1EsRUFBRTtnQkFDakJHLE1BQU1YLEtBQUtRLEVBQUU7Z0JBQ2JXLFNBQVNuQixLQUFLUSxFQUFFO2dCQUNoQlksU0FBU3BCLEtBQUtRLEVBQUU7WUFDbEI7UUFDRjtRQUNBYTtZQUNFLE9BQU8sSUFBSUM7UUFDYjtRQUNBQztZQUNFLE9BQU87UUFDVDtJQUNGLENBQUE7QUFFQSxrR0FBa0c7QUFFbEcsNENBQTRDO0FBQzVDdkIsS0FBS0MsSUFBSSxDQUFDLGVBQWUsSUFBTyxDQUFBO1FBQzlCdUIsYUFBYSxNQUFNQTtZQUNqQkMsWUFBWUMsS0FBSyxFQUFF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