{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/hooks/useUndoRedo.ts"],"sourcesContent":["'use client';\n\n// Undo/Redo React Hooks\n// React hooks for managing undo/redo operations with keyboard shortcuts\n\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { useManagedCanvas, type ManagedCanvas } from '../providers/CanvasProvider';\nimport {\n  UndoRedoManager,\n  createUndoRedoManager,\n  OperationType,\n  type UndoRedoConfig,\n  type UndoRedoState,\n  type Operation,\n  type CompositeOperation,\n  DEFAULT_UNDO_REDO_CONFIG\n} from '../utils/undoRedoStack';\n\n/**\n * Undo/Redo hook options\n */\nexport interface UseUndoRedoOptions {\n  /** Undo/Redo configuration */\n  config?: Partial<UndoRedoConfig>;\n  /** Enable keyboard shortcuts (Ctrl+Z, Ctrl+Y) */\n  enableKeyboardShortcuts?: boolean;\n  /** Custom keyboard shortcuts */\n  keyboardShortcuts?: {\n    undo?: string[];\n    redo?: string[];\n  };\n  /** Callback when operation is executed */\n  onOperationExecuted?: (operation: Operation | CompositeOperation) => void;\n  /** Callback when undo is performed */\n  onUndo?: (operation: Operation | CompositeOperation) => void;\n  /** Callback when redo is performed */\n  onRedo?: (operation: Operation | CompositeOperation) => void;\n  /** Callback when history is cleared */\n  onHistoryCleared?: () => void;\n}\n\n/**\n * Default keyboard shortcuts\n */\nconst DEFAULT_SHORTCUTS = {\n  undo: ['ctrl+z', 'cmd+z'],\n  redo: ['ctrl+y', 'cmd+y', 'ctrl+shift+z', 'cmd+shift+z']\n};\n\n/**\n * Main undo/redo hook\n */\nexport function useUndoRedo(\n  canvasWidth: number,\n  canvasHeight: number,\n  canvasId?: string,\n  options: UseUndoRedoOptions = {}\n): {\n  canvas: ManagedCanvas;\n  manager: UndoRedoManager;\n  state: UndoRedoState;\n  canUndo: boolean;\n  canRedo: boolean;\n  undo: () => boolean;\n  redo: () => boolean;\n  executeOperation: (\n    type: OperationType,\n    description: string,\n    operationFn: () => void | Promise<void>,\n    operationData?: Record<string, unknown>,\n    metadata?: Record<string, unknown>\n  ) => Promise<string>;\n  startComposite: (description: string, metadata?: Record<string, unknown>) => string;\n  endComposite: () => void;\n  jumpToOperation: (index: number) => boolean;\n  clearHistory: () => void;\n  getHistory: () => (Operation | CompositeOperation)[];\n  getOperation: (id: string) => Operation | CompositeOperation | null;\n  cleanup: (targetMemoryMB?: number) => void;\n  exportHistory: () => string;\n  importHistory: (historyData: string) => boolean;\n  updateConfig: (newConfig: Partial<UndoRedoConfig>) => void;\n} {\n  const canvas = useManagedCanvas(canvasWidth, canvasHeight, canvasId);\n  const managerRef = useRef<UndoRedoManager>();\n  const [state, setState] = useState<UndoRedoState>({\n    currentIndex: -1,\n    operations: [],\n    canUndo: false,\n    canRedo: false,\n    memoryUsage: 0,\n    stats: {\n      totalOperations: 0,\n      undoCount: 0,\n      redoCount: 0,\n      memoryPeakUsage: 0,\n      lastCleanup: Date.now()\n    }\n  });\n\n  // Initialize manager\n  if (!managerRef.current) {\n    managerRef.current = createUndoRedoManager(canvas, options.config);\n  }\n\n  const updateState = useCallback(() => {\n    if (managerRef.current) {\n      setState(managerRef.current.getState());\n    }\n  }, []);\n\n  const executeOperation = useCallback(async (\n    type: OperationType,\n    description: string,\n    operationFn: () => void | Promise<void>,\n    operationData?: Record<string, unknown>,\n    metadata?: Record<string, unknown>\n  ): Promise<string> => {\n    if (!managerRef.current) throw new Error('Manager not initialized');\n    \n    const operationId = await managerRef.current.executeOperation(\n      type,\n      description,\n      operationFn,\n      operationData,\n      metadata\n    );\n    \n    updateState();\n    \n    const operation = managerRef.current.getOperation(operationId);\n    if (operation) {\n      options.onOperationExecuted?.(operation);\n    }\n    \n    return operationId;\n  }, [updateState, options]);\n\n  const undo = useCallback((): boolean => {\n    if (!managerRef.current) return false;\n    \n    const currentOperation = state.currentIndex >= 0 \n      ? managerRef.current.getHistory()[state.currentIndex] \n      : null;\n    \n    const success = managerRef.current.undo();\n    if (success) {\n      updateState();\n      if (currentOperation) {\n        options.onUndo?.(currentOperation);\n      }\n    }\n    return success;\n  }, [state.currentIndex, updateState, options]);\n\n  const redo = useCallback((): boolean => {\n    if (!managerRef.current) return false;\n    \n    const nextOperation = state.currentIndex + 1 < state.operations.length\n      ? state.operations[state.currentIndex + 1]\n      : null;\n    \n    const success = managerRef.current.redo();\n    if (success) {\n      updateState();\n      if (nextOperation) {\n        options.onRedo?.(nextOperation);\n      }\n    }\n    return success;\n  }, [state.currentIndex, state.operations, updateState, options]);\n\n  const startComposite = useCallback((description: string, metadata?: Record<string, unknown>): string => {\n    if (!managerRef.current) throw new Error('Manager not initialized');\n    return managerRef.current.startCompositeOperation(description, metadata);\n  }, []);\n\n  const endComposite = useCallback((): void => {\n    if (!managerRef.current) return;\n    managerRef.current.endCompositeOperation();\n    updateState();\n  }, [updateState]);\n\n  const jumpToOperation = useCallback((index: number): boolean => {\n    if (!managerRef.current) return false;\n    const success = managerRef.current.jumpToOperation(index);\n    if (success) {\n      updateState();\n    }\n    return success;\n  }, [updateState]);\n\n  const clearHistory = useCallback((): void => {\n    if (!managerRef.current) return;\n    managerRef.current.clearHistory();\n    updateState();\n    options.onHistoryCleared?.();\n  }, [updateState, options]);\n\n  const getHistory = useCallback((): (Operation | CompositeOperation)[] => {\n    return managerRef.current?.getHistory() || [];\n  }, []);\n\n  const getOperation = useCallback((id: string): Operation | CompositeOperation | null => {\n    return managerRef.current?.getOperation(id) || null;\n  }, []);\n\n  const cleanup = useCallback((targetMemoryMB?: number): void => {\n    if (!managerRef.current) return;\n    managerRef.current.cleanup(targetMemoryMB);\n    updateState();\n  }, [updateState]);\n\n  const exportHistory = useCallback((): string => {\n    return managerRef.current?.exportHistory() || '';\n  }, []);\n\n  const importHistory = useCallback((historyData: string): boolean => {\n    if (!managerRef.current) return false;\n    const success = managerRef.current.importHistory(historyData);\n    if (success) {\n      updateState();\n    }\n    return success;\n  }, [updateState]);\n\n  const updateConfig = useCallback((newConfig: Partial<UndoRedoConfig>): void => {\n    if (!managerRef.current) return;\n    managerRef.current.updateConfig(newConfig);\n    updateState();\n  }, [updateState]);\n\n  // Keyboard shortcuts\n  useEffect(() => {\n    if (!options.enableKeyboardShortcuts) return;\n\n    const shortcuts = { ...DEFAULT_SHORTCUTS, ...options.keyboardShortcuts };\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      const key = `${event.ctrlKey || event.metaKey ? 'ctrl+' : ''}${event.shiftKey ? 'shift+' : ''}${event.key.toLowerCase()}`;\n      const cmdKey = `${event.ctrlKey || event.metaKey ? 'cmd+' : ''}${event.shiftKey ? 'shift+' : ''}${event.key.toLowerCase()}`;\n\n      if (shortcuts.undo.includes(key) || shortcuts.undo.includes(cmdKey)) {\n        event.preventDefault();\n        undo();\n      } else if (shortcuts.redo.includes(key) || shortcuts.redo.includes(cmdKey)) {\n        event.preventDefault();\n        redo();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [options.enableKeyboardShortcuts, options.keyboardShortcuts, undo, redo]);\n\n  // Update state when operations change\n  useEffect(() => {\n    updateState();\n  }, [updateState]);\n\n  return {\n    canvas,\n    manager: managerRef.current,\n    state,\n    canUndo: state.canUndo,\n    canRedo: state.canRedo,\n    undo,\n    redo,\n    executeOperation,\n    startComposite,\n    endComposite,\n    jumpToOperation,\n    clearHistory,\n    getHistory,\n    getOperation,\n    cleanup,\n    exportHistory,\n    importHistory,\n    updateConfig\n  };\n}\n\n/**\n * Hook for simple undo/redo operations without full state management\n */\nexport function useSimpleUndoRedo<T>(\n  initialState: T,\n  maxHistorySize: number = 50\n): {\n  state: T;\n  canUndo: boolean;\n  canRedo: boolean;\n  undo: () => void;\n  redo: () => void;\n  pushState: (newState: T) => void;\n  clearHistory: () => void;\n  getHistory: () => T[];\n} {\n  const [history, setHistory] = useState<T[]>([initialState]);\n  const [currentIndex, setCurrentIndex] = useState(0);\n\n  const canUndo = currentIndex > 0;\n  const canRedo = currentIndex < history.length - 1;\n  const state = history[currentIndex];\n\n  const undo = useCallback(() => {\n    if (canUndo) {\n      setCurrentIndex(prev => prev - 1);\n    }\n  }, [canUndo]);\n\n  const redo = useCallback(() => {\n    if (canRedo) {\n      setCurrentIndex(prev => prev + 1);\n    }\n  }, [canRedo]);\n\n  const pushState = useCallback((newState: T) => {\n    setHistory(prev => {\n      // Remove any states after current index\n      const newHistory = prev.slice(0, currentIndex + 1);\n      newHistory.push(newState);\n      \n      // Enforce max history size\n      if (newHistory.length > maxHistorySize) {\n        newHistory.splice(0, newHistory.length - maxHistorySize);\n        setCurrentIndex(maxHistorySize - 1);\n        return newHistory;\n      }\n      \n      setCurrentIndex(newHistory.length - 1);\n      return newHistory;\n    });\n  }, [currentIndex, maxHistorySize]);\n\n  const clearHistory = useCallback(() => {\n    setHistory([state]);\n    setCurrentIndex(0);\n  }, [state]);\n\n  const getHistory = useCallback(() => {\n    return [...history];\n  }, [history]);\n\n  return {\n    state,\n    canUndo,\n    canRedo,\n    undo,\n    redo,\n    pushState,\n    clearHistory,\n    getHistory\n  };\n}\n\n/**\n * Hook for operation batching and atomic commits\n */\nexport function useOperationBatching(\n  undoRedoManager: UndoRedoManager,\n  autoCommitDelay: number = 1000\n): {\n  startBatch: (description: string) => string;\n  addOperation: (\n    type: OperationType,\n    description: string,\n    operationFn: () => void | Promise<void>,\n    operationData?: Record<string, unknown>\n  ) => Promise<string>;\n  commitBatch: () => void;\n  discardBatch: () => void;\n  isBatching: boolean;\n  batchOperationCount: number;\n} {\n  const [isBatching, setIsBatching] = useState(false);\n  const [batchOperationCount, setBatchOperationCount] = useState(0);\n  const batchTimeoutRef = useRef<NodeJS.Timeout>();\n  const currentBatchRef = useRef<string | null>(null);\n\n  const startBatch = useCallback((description: string): string => {\n    if (currentBatchRef.current) {\n      commitBatch();\n    }\n\n    const batchId = undoRedoManager.startCompositeOperation(description);\n    currentBatchRef.current = batchId;\n    setIsBatching(true);\n    setBatchOperationCount(0);\n\n    // Auto-commit after delay\n    if (batchTimeoutRef.current) {\n      clearTimeout(batchTimeoutRef.current);\n    }\n    \n    batchTimeoutRef.current = setTimeout(() => {\n      commitBatch();\n    }, autoCommitDelay);\n\n    return batchId;\n  }, [autoCommitDelay]);\n\n  const addOperation = useCallback(async (\n    type: OperationType,\n    description: string,\n    operationFn: () => void | Promise<void>,\n    operationData?: Record<string, unknown>\n  ): Promise<string> => {\n    const operationId = await undoRedoManager.executeOperation(\n      type,\n      description,\n      operationFn,\n      operationData\n    );\n\n    setBatchOperationCount(prev => prev + 1);\n    return operationId;\n  }, [undoRedoManager]);\n\n  const commitBatch = useCallback(() => {\n    if (currentBatchRef.current) {\n      undoRedoManager.endCompositeOperation();\n      currentBatchRef.current = null;\n      setIsBatching(false);\n      setBatchOperationCount(0);\n\n      if (batchTimeoutRef.current) {\n        clearTimeout(batchTimeoutRef.current);\n        batchTimeoutRef.current = undefined;\n      }\n    }\n  }, [undoRedoManager]);\n\n  const discardBatch = useCallback(() => {\n    if (currentBatchRef.current) {\n      // Note: In a real implementation, you'd need to revert operations\n      // For now, we just clear the batch state\n      currentBatchRef.current = null;\n      setIsBatching(false);\n      setBatchOperationCount(0);\n\n      if (batchTimeoutRef.current) {\n        clearTimeout(batchTimeoutRef.current);\n        batchTimeoutRef.current = undefined;\n      }\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (batchTimeoutRef.current) {\n        clearTimeout(batchTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    startBatch,\n    addOperation,\n    commitBatch,\n    discardBatch,\n    isBatching,\n    batchOperationCount\n  };\n}\n\n/**\n * Hook for history persistence\n */\nexport function useHistoryPersistence(\n  undoRedoManager: UndoRedoManager,\n  storageKey: string = 'canvas-history'\n): {\n  saveHistory: () => boolean;\n  loadHistory: () => boolean;\n  autoSave: boolean;\n  setAutoSave: (enabled: boolean) => void;\n  lastSaved: Date | null;\n} {\n  const [autoSave, setAutoSave] = useState(false);\n  const [lastSaved, setLastSaved] = useState<Date | null>(null);\n\n  const saveHistory = useCallback((): boolean => {\n    try {\n      const historyData = undoRedoManager.exportHistory();\n      localStorage.setItem(storageKey, historyData);\n      setLastSaved(new Date());\n      return true;\n    } catch (error) {\n      console.error('Failed to save history:', error);\n      return false;\n    }\n  }, [undoRedoManager, storageKey]);\n\n  const loadHistory = useCallback((): boolean => {\n    try {\n      const historyData = localStorage.getItem(storageKey);\n      if (historyData) {\n        const success = undoRedoManager.importHistory(historyData);\n        if (success) {\n          setLastSaved(new Date());\n        }\n        return success;\n      }\n      return false;\n    } catch (error) {\n      console.error('Failed to load history:', error);\n      return false;\n    }\n  }, [undoRedoManager, storageKey]);\n\n  // Auto-save functionality\n  useEffect(() => {\n    if (!autoSave) return;\n\n    const handleBeforeUnload = () => {\n      saveHistory();\n    };\n\n    const autoSaveInterval = setInterval(() => {\n      saveHistory();\n    }, 30000); // Save every 30 seconds\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    return () => {\n      clearInterval(autoSaveInterval);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [autoSave, saveHistory]);\n\n  // Load history on mount\n  useEffect(() => {\n    loadHistory();\n  }, [loadHistory]);\n\n  return {\n    saveHistory,\n    loadHistory,\n    autoSave,\n    setAutoSave,\n    lastSaved\n  };\n}"],"names":["useHistoryPersistence","useOperationBatching","useSimpleUndoRedo","useUndoRedo","DEFAULT_SHORTCUTS","undo","redo","canvasWidth","canvasHeight","canvasId","options","canvas","useManagedCanvas","managerRef","useRef","state","setState","useState","currentIndex","operations","canUndo","canRedo","memoryUsage","stats","totalOperations","undoCount","redoCount","memoryPeakUsage","lastCleanup","Date","now","current","createUndoRedoManager","config","updateState","useCallback","getState","executeOperation","type","description","operationFn","operationData","metadata","Error","operationId","operation","getOperation","onOperationExecuted","currentOperation","getHistory","success","onUndo","nextOperation","length","onRedo","startComposite","startCompositeOperation","endComposite","endCompositeOperation","jumpToOperation","index","clearHistory","onHistoryCleared","id","cleanup","targetMemoryMB","exportHistory","importHistory","historyData","updateConfig","newConfig","useEffect","enableKeyboardShortcuts","shortcuts","keyboardShortcuts","handleKeyDown","event","key","ctrlKey","metaKey","shiftKey","toLowerCase","cmdKey","includes","preventDefault","document","addEventListener","removeEventListener","manager","initialState","maxHistorySize","history","setHistory","setCurrentIndex","prev","pushState","newState","newHistory","slice","push","splice","undoRedoManager","autoCommitDelay","isBatching","setIsBatching","batchOperationCount","setBatchOperationCount","batchTimeoutRef","currentBatchRef","startBatch","commitBatch","batchId","clearTimeout","setTimeout","addOperation","undefined","discardBatch","storageKey","autoSave","setAutoSave","lastSaved","setLastSaved","saveHistory","localStorage","setItem","error","console","loadHistory","getItem","handleBeforeUnload","autoSaveInterval","setInterval","window","clearInterval"],"mappings":"AAAA;;;;;;;;;;;;IAsdgBA,qBAAqB;eAArBA;;IA/GAC,oBAAoB;eAApBA;;IA1EAC,iBAAiB;eAAjBA;;IAzOAC,WAAW;eAAXA;;;uBA/CyC;gCACJ;+BAU9C;AAyBP;;CAEC,GACD,MAAMC,oBAAoB;IACxBC,MAAM;QAAC;QAAU;KAAQ;IACzBC,MAAM;QAAC;QAAU;QAAS;QAAgB;KAAc;AAC1D;AAKO,SAASH,YACdI,WAAmB,EACnBC,YAAoB,EACpBC,QAAiB,EACjBC,UAA8B,CAAC,CAAC;IA2BhC,MAAMC,SAASC,IAAAA,gCAAgB,EAACL,aAAaC,cAAcC;IAC3D,MAAMI,aAAaC,IAAAA,aAAM;IACzB,MAAM,CAACC,OAAOC,SAAS,GAAGC,IAAAA,eAAQ,EAAgB;QAChDC,cAAc,CAAC;QACfC,YAAY,EAAE;QACdC,SAAS;QACTC,SAAS;QACTC,aAAa;QACbC,OAAO;YACLC,iBAAiB;YACjBC,WAAW;YACXC,WAAW;YACXC,iBAAiB;YACjBC,aAAaC,KAAKC,GAAG;QACvB;IACF;IAEA,qBAAqB;IACrB,IAAI,CAACjB,WAAWkB,OAAO,EAAE;QACvBlB,WAAWkB,OAAO,GAAGC,IAAAA,oCAAqB,EAACrB,QAAQD,QAAQuB,MAAM;IACnE;IAEA,MAAMC,cAAcC,IAAAA,kBAAW,EAAC;QAC9B,IAAItB,WAAWkB,OAAO,EAAE;YACtBf,SAASH,WAAWkB,OAAO,CAACK,QAAQ;QACtC;IACF,GAAG,EAAE;IAEL,MAAMC,mBAAmBF,IAAAA,kBAAW,EAAC,OACnCG,MACAC,aACAC,aACAC,eACAC;QAEA,IAAI,CAAC7B,WAAWkB,OAAO,EAAE,MAAM,IAAIY,MAAM;QAEzC,MAAMC,cAAc,MAAM/B,WAAWkB,OAAO,CAACM,gBAAgB,CAC3DC,MACAC,aACAC,aACAC,eACAC;QAGFR;QAEA,MAAMW,YAAYhC,WAAWkB,OAAO,CAACe,YAAY,CAACF;QAClD,IAAIC,WAAW;YACbnC,QAAQqC,mBAAmB,GAAGF;QAChC;QAEA,OAAOD;IACT,GAAG;QAACV;QAAaxB;KAAQ;IAEzB,MAAML,OAAO8B,IAAAA,kBAAW,EAAC;QACvB,IAAI,CAACtB,WAAWkB,OAAO,EAAE,OAAO;QAEhC,MAAMiB,mBAAmBjC,MAAMG,YAAY,IAAI,IAC3CL,WAAWkB,OAAO,CAACkB,UAAU,EAAE,CAAClC,MAAMG,YAAY,CAAC,GACnD;QAEJ,MAAMgC,UAAUrC,WAAWkB,OAAO,CAAC1B,IAAI;QACvC,IAAI6C,SAAS;YACXhB;YACA,IAAIc,kBAAkB;gBACpBtC,QAAQyC,MAAM,GAAGH;YACnB;QACF;QACA,OAAOE;IACT,GAAG;QAACnC,MAAMG,YAAY;QAAEgB;QAAaxB;KAAQ;IAE7C,MAAMJ,OAAO6B,IAAAA,kBAAW,EAAC;QACvB,IAAI,CAACtB,WAAWkB,OAAO,EAAE,OAAO;QAEhC,MAAMqB,gBAAgBrC,MAAMG,YAAY,GAAG,IAAIH,MAAMI,UAAU,CAACkC,MAAM,GAClEtC,MAAMI,UAAU,CAACJ,MAAMG,YAAY,GAAG,EAAE,GACxC;QAEJ,MAAMgC,UAAUrC,WAAWkB,OAAO,CAACzB,IAAI;QACvC,IAAI4C,SAAS;YACXhB;YACA,IAAIkB,eAAe;gBACjB1C,QAAQ4C,MAAM,GAAGF;YACnB;QACF;QACA,OAAOF;IACT,GAAG;QAACnC,MAAMG,YAAY;QAAEH,MAAMI,UAAU;QAAEe;QAAaxB;KAAQ;IAE/D,MAAM6C,iBAAiBpB,IAAAA,kBAAW,EAAC,CAACI,aAAqBG;QACvD,IAAI,CAAC7B,WAAWkB,OAAO,EAAE,MAAM,IAAIY,MAAM;QACzC,OAAO9B,WAAWkB,OAAO,CAACyB,uBAAuB,CAACjB,aAAaG;IACjE,GAAG,EAAE;IAEL,MAAMe,eAAetB,IAAAA,kBAAW,EAAC;QAC/B,IAAI,CAACtB,WAAWkB,OAAO,EAAE;QACzBlB,WAAWkB,OAAO,CAAC2B,qBAAqB;QACxCxB;IACF,GAAG;QAACA;KAAY;IAEhB,MAAMyB,kBAAkBxB,IAAAA,kBAAW,EAAC,CAACyB;QACnC,IAAI,CAAC/C,WAAWkB,OAAO,EAAE,OAAO;QAChC,MAAMmB,UAAUrC,WAAWkB,OAAO,CAAC4B,eAAe,CAACC;QACnD,IAAIV,SAAS;YACXhB;QACF;QACA,OAAOgB;IACT,GAAG;QAAChB;KAAY;IAEhB,MAAM2B,eAAe1B,IAAAA,kBAAW,EAAC;QAC/B,IAAI,CAACtB,WAAWkB,OAAO,EAAE;QACzBlB,WAAWkB,OAAO,CAAC8B,YAAY;QAC/B3B;QACAxB,QAAQoD,gBAAgB;IAC1B,GAAG;QAAC5B;QAAaxB;KAAQ;IAEzB,MAAMuC,aAAad,IAAAA,kBAAW,EAAC;QAC7B,OAAOtB,WAAWkB,OAAO,EAAEkB,gBAAgB,EAAE;IAC/C,GAAG,EAAE;IAEL,MAAMH,eAAeX,IAAAA,kBAAW,EAAC,CAAC4B;QAChC,OAAOlD,WAAWkB,OAAO,EAAEe,aAAaiB,OAAO;IACjD,GAAG,EAAE;IAEL,MAAMC,UAAU7B,IAAAA,kBAAW,EAAC,CAAC8B;QAC3B,IAAI,CAACpD,WAAWkB,OAAO,EAAE;QACzBlB,WAAWkB,OAAO,CAACiC,OAAO,CAACC;QAC3B/B;IACF,GAAG;QAACA;KAAY;IAEhB,MAAMgC,gBAAgB/B,IAAAA,kBAAW,EAAC;QAChC,OAAOtB,WAAWkB,OAAO,EAAEmC,mBAAmB;IAChD,GAAG,EAAE;IAEL,MAAMC,gBAAgBhC,IAAAA,kBAAW,EAAC,CAACiC;QACjC,IAAI,CAACvD,WAAWkB,OAAO,EAAE,OAAO;QAChC,MAAMmB,UAAUrC,WAAWkB,OAAO,CAACoC,aAAa,CAACC;QACjD,IAAIlB,SAAS;YACXhB;QACF;QACA,OAAOgB;IACT,GAAG;QAAChB;KAAY;IAEhB,MAAMmC,eAAelC,IAAAA,kBAAW,EAAC,CAACmC;QAChC,IAAI,CAACzD,WAAWkB,OAAO,EAAE;QACzBlB,WAAWkB,OAAO,CAACsC,YAAY,CAACC;QAChCpC;IACF,GAAG;QAACA;KAAY;IAEhB,qBAAqB;IACrBqC,IAAAA,gBAAS,EAAC;QACR,IAAI,CAAC7D,QAAQ8D,uBAAuB,EAAE;QAEtC,MAAMC,YAAY;YAAE,GAAGrE,iBAAiB;YAAE,GAAGM,QAAQgE,iBAAiB;QAAC;QAEvE,MAAMC,gBAAgB,CAACC;YACrB,MAAMC,MAAM,GAAGD,MAAME,OAAO,IAAIF,MAAMG,OAAO,GAAG,UAAU,KAAKH,MAAMI,QAAQ,GAAG,WAAW,KAAKJ,MAAMC,GAAG,CAACI,WAAW,IAAI;YACzH,MAAMC,SAAS,GAAGN,MAAME,OAAO,IAAIF,MAAMG,OAAO,GAAG,SAAS,KAAKH,MAAMI,QAAQ,GAAG,WAAW,KAAKJ,MAAMC,GAAG,CAACI,WAAW,IAAI;YAE3H,IAAIR,UAAUpE,IAAI,CAAC8E,QAAQ,CAACN,QAAQJ,UAAUpE,IAAI,CAAC8E,QAAQ,CAACD,SAAS;gBACnEN,MAAMQ,cAAc;gBACpB/E;YACF,OAAO,IAAIoE,UAAUnE,IAAI,CAAC6E,QAAQ,CAACN,QAAQJ,UAAUnE,IAAI,CAAC6E,QAAQ,CAACD,SAAS;gBAC1EN,MAAMQ,cAAc;gBACpB9E;YACF;QACF;QAEA+E,SAASC,gBAAgB,CAAC,WAAWX;QACrC,OAAO,IAAMU,SAASE,mBAAmB,CAAC,WAAWZ;IACvD,GAAG;QAACjE,QAAQ8D,uBAAuB;QAAE9D,QAAQgE,iBAAiB;QAAErE;QAAMC;KAAK;IAE3E,sCAAsC;IACtCiE,IAAAA,gBAAS,EAAC;QACRrC;IACF,GAAG;QAACA;KAAY;IAEhB,OAAO;QACLvB;QACA6E,SAAS3E,WAAWkB,OAAO;QAC3BhB;QACAK,SAASL,MAAMK,OAAO;QACtBC,SAASN,MAAMM,OAAO;QACtBhB;QACAC;QACA+B;QACAkB;QACAE;QACAE;QACAE;QACAZ;QACAH;QACAkB;QACAE;QACAC;QACAE;IACF;AACF;AAKO,SAASnE,kBACduF,YAAe,EACfC,iBAAyB,EAAE;IAW3B,MAAM,CAACC,SAASC,WAAW,GAAG3E,IAAAA,eAAQ,EAAM;QAACwE;KAAa;IAC1D,MAAM,CAACvE,cAAc2E,gBAAgB,GAAG5E,IAAAA,eAAQ,EAAC;IAEjD,MAAMG,UAAUF,eAAe;IAC/B,MAAMG,UAAUH,eAAeyE,QAAQtC,MAAM,GAAG;IAChD,MAAMtC,QAAQ4E,OAAO,CAACzE,aAAa;IAEnC,MAAMb,OAAO8B,IAAAA,kBAAW,EAAC;QACvB,IAAIf,SAAS;YACXyE,gBAAgBC,CAAAA,OAAQA,OAAO;QACjC;IACF,GAAG;QAAC1E;KAAQ;IAEZ,MAAMd,OAAO6B,IAAAA,kBAAW,EAAC;QACvB,IAAId,SAAS;YACXwE,gBAAgBC,CAAAA,OAAQA,OAAO;QACjC;IACF,GAAG;QAACzE;KAAQ;IAEZ,MAAM0E,YAAY5D,IAAAA,kBAAW,EAAC,CAAC6D;QAC7BJ,WAAWE,CAAAA;YACT,wCAAwC;YACxC,MAAMG,aAAaH,KAAKI,KAAK,CAAC,GAAGhF,eAAe;YAChD+E,WAAWE,IAAI,CAACH;YAEhB,2BAA2B;YAC3B,IAAIC,WAAW5C,MAAM,GAAGqC,gBAAgB;gBACtCO,WAAWG,MAAM,CAAC,GAAGH,WAAW5C,MAAM,GAAGqC;gBACzCG,gBAAgBH,iBAAiB;gBACjC,OAAOO;YACT;YAEAJ,gBAAgBI,WAAW5C,MAAM,GAAG;YACpC,OAAO4C;QACT;IACF,GAAG;QAAC/E;QAAcwE;KAAe;IAEjC,MAAM7B,eAAe1B,IAAAA,kBAAW,EAAC;QAC/ByD,WAAW;YAAC7E;SAAM;QAClB8E,gBAAgB;IAClB,GAAG;QAAC9E;KAAM;IAEV,MAAMkC,aAAad,IAAAA,kBAAW,EAAC;QAC7B,OAAO;eAAIwD;SAAQ;IACrB,GAAG;QAACA;KAAQ;IAEZ,OAAO;QACL5E;QACAK;QACAC;QACAhB;QACAC;QACAyF;QACAlC;QACAZ;IACF;AACF;AAKO,SAAShD,qBACdoG,eAAgC,EAChCC,kBAA0B,IAAI;IAc9B,MAAM,CAACC,YAAYC,cAAc,GAAGvF,IAAAA,eAAQ,EAAC;IAC7C,MAAM,CAACwF,qBAAqBC,uBAAuB,GAAGzF,IAAAA,eAAQ,EAAC;IAC/D,MAAM0F,kBAAkB7F,IAAAA,aAAM;IAC9B,MAAM8F,kBAAkB9F,IAAAA,aAAM,EAAgB;IAE9C,MAAM+F,aAAa1E,IAAAA,kBAAW,EAAC,CAACI;QAC9B,IAAIqE,gBAAgB7E,OAAO,EAAE;YAC3B+E;QACF;QAEA,MAAMC,UAAUV,gBAAgB7C,uBAAuB,CAACjB;QACxDqE,gBAAgB7E,OAAO,GAAGgF;QAC1BP,cAAc;QACdE,uBAAuB;QAEvB,0BAA0B;QAC1B,IAAIC,gBAAgB5E,OAAO,EAAE;YAC3BiF,aAAaL,gBAAgB5E,OAAO;QACtC;QAEA4E,gBAAgB5E,OAAO,GAAGkF,WAAW;YACnCH;QACF,GAAGR;QAEH,OAAOS;IACT,GAAG;QAACT;KAAgB;IAEpB,MAAMY,eAAe/E,IAAAA,kBAAW,EAAC,OAC/BG,MACAC,aACAC,aACAC;QAEA,MAAMG,cAAc,MAAMyD,gBAAgBhE,gBAAgB,CACxDC,MACAC,aACAC,aACAC;QAGFiE,uBAAuBZ,CAAAA,OAAQA,OAAO;QACtC,OAAOlD;IACT,GAAG;QAACyD;KAAgB;IAEpB,MAAMS,cAAc3E,IAAAA,kBAAW,EAAC;QAC9B,IAAIyE,gBAAgB7E,OAAO,EAAE;YAC3BsE,gBAAgB3C,qBAAqB;YACrCkD,gBAAgB7E,OAAO,GAAG;YAC1ByE,cAAc;YACdE,uBAAuB;YAEvB,IAAIC,gBAAgB5E,OAAO,EAAE;gBAC3BiF,aAAaL,gBAAgB5E,OAAO;gBACpC4E,gBAAgB5E,OAAO,GAAGoF;YAC5B;QACF;IACF,GAAG;QAACd;KAAgB;IAEpB,MAAMe,eAAejF,IAAAA,kBAAW,EAAC;QAC/B,IAAIyE,gBAAgB7E,OAAO,EAAE;YAC3B,kEAAkE;YAClE,yCAAyC;YACzC6E,gBAAgB7E,OAAO,GAAG;YAC1ByE,cAAc;YACdE,uBAAuB;YAEvB,IAAIC,gBAAgB5E,OAAO,EAAE;gBAC3BiF,aAAaL,gBAAgB5E,OAAO;gBACpC4E,gBAAgB5E,OAAO,GAAGoF;YAC5B;QACF;IACF,GAAG,EAAE;IAEL,qBAAqB;IACrB5C,IAAAA,gBAAS,EAAC;QACR,OAAO;YACL,IAAIoC,gBAAgB5E,OAAO,EAAE;gBAC3BiF,aAAaL,gBAAgB5E,OAAO;YACtC;QACF;IACF,GAAG,EAAE;IAEL,OAAO;QACL8E;QACAK;QACAJ;QACAM;QACAb;QACAE;IACF;AACF;AAKO,SAASzG,sBACdqG,eAAgC,EAChCgB,aAAqB,gBAAgB;IAQrC,MAAM,CAACC,UAAUC,YAAY,GAAGtG,IAAAA,eAAQ,EAAC;IACzC,MAAM,CAACuG,WAAWC,aAAa,GAAGxG,IAAAA,eAAQ,EAAc;IAExD,MAAMyG,cAAcvF,IAAAA,kBAAW,EAAC;QAC9B,IAAI;YACF,MAAMiC,cAAciC,gBAAgBnC,aAAa;YACjDyD,aAAaC,OAAO,CAACP,YAAYjD;YACjCqD,aAAa,IAAI5F;YACjB,OAAO;QACT,EAAE,OAAOgG,OAAO;YACdC,QAAQD,KAAK,CAAC,2BAA2BA;YACzC,OAAO;QACT;IACF,GAAG;QAACxB;QAAiBgB;KAAW;IAEhC,MAAMU,cAAc5F,IAAAA,kBAAW,EAAC;QAC9B,IAAI;YACF,MAAMiC,cAAcuD,aAAaK,OAAO,CAACX;YACzC,IAAIjD,aAAa;gBACf,MAAMlB,UAAUmD,gBAAgBlC,aAAa,CAACC;gBAC9C,IAAIlB,SAAS;oBACXuE,aAAa,IAAI5F;gBACnB;gBACA,OAAOqB;YACT;YACA,OAAO;QACT,EAAE,OAAO2E,OAAO;YACdC,QAAQD,KAAK,CAAC,2BAA2BA;YACzC,OAAO;QACT;IACF,GAAG;QAACxB;QAAiBgB;KAAW;IAEhC,0BAA0B;IAC1B9C,IAAAA,gBAAS,EAAC;QACR,IAAI,CAAC+C,UAAU;QAEf,MAAMW,qBAAqB;YACzBP;QACF;QAEA,MAAMQ,mBAAmBC,YAAY;YACnCT;QACF,GAAG,QAAQ,wBAAwB;QAEnCU,OAAO9C,gBAAgB,CAAC,gBAAgB2C;QAExC,OAAO;YACLI,cAAcH;YACdE,OAAO7C,mBAAmB,CAAC,gBAAgB0C;QAC7C;IACF,GAAG;QAACX;QAAUI;KAAY;IAE1B,wBAAwB;IACxBnD,IAAAA,gBAAS,EAAC;QACRwD;IACF,GAAG;QAACA;KAAY;IAEhB,OAAO;QACLL;QACAK;QACAT;QACAC;QACAC;IACF;AACF"}