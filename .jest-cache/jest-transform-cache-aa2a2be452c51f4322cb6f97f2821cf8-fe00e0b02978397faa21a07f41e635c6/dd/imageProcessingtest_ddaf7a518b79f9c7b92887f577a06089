a98e1dc8e2175aca02b05e9c5832be18
// Image Processing Integration Tests
// Tests for image processing utilities and integration with try-on mutations
// Mock the image processing module before any imports
"use strict";
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        processImageForTryon: jest.fn(),
        ImageProcessingError: jest.fn(),
        ImageDimensionError: jest.fn()
    }));
// Mock other dependencies
jest.mock('../../../src/business-layer/utils/optimisticUpdates', ()=>({
        getOptimisticUpdatesManager: ()=>({
                startOptimisticUpdate: jest.fn(()=>({
                        optimisticId: 'test-id',
                        rollbackFunctions: []
                    })),
                completeOptimisticUpdate: jest.fn(),
                rollbackOptimisticUpdate: jest.fn()
            }),
        OptimisticUpdatesManager: jest.fn()
    }));
jest.mock('../../../src/business-layer/utils/cacheInvalidation', ()=>({
        invalidateCacheAfterMutation: jest.fn().mockResolvedValue(undefined)
    }));
jest.mock('../../../src/business-layer/utils/errorHandling', ()=>({
        classifyTryonError: jest.fn(()=>({
                userMessage: 'Error',
                technicalMessage: 'Error',
                errorCode: 'TEST',
                retryable: false,
                category: 'TEST',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        logAndClassifyError: jest.fn(()=>({
                userMessage: 'Error',
                technicalMessage: 'Error',
                errorCode: 'TEST',
                retryable: false,
                category: 'TEST',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        isErrorRetryable: jest.fn(()=>false)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useTryonMutation = require("../../../src/business-layer/mutations/useTryonMutation");
const _testUtils = require("../../../src/business-layer/tests/testUtils");
const _imageProcessing = /*#__PURE__*/ _interop_require_wildcard(require("../../../src/business-layer/utils/imageProcessing"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Image Processing Integration', ()=>{
    let queryClient;
    let consoleRef;
    const mockProcessImageForTryon = _imageProcessing.processImageForTryon;
    beforeEach(()=>{
        queryClient = (0, _testUtils.createTestQueryClient)();
        consoleRef = (0, _testUtils.mockConsole)();
        jest.clearAllMocks();
        (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
    });
    afterEach(()=>{
        queryClient.clear();
        consoleRef.restore();
    });
    describe('File Processing', ()=>{
        it('should process File objects successfully', async ()=>{
            const mockProcessingResult = {
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed-image',
                metadata: {
                    originalDimensions: {
                        width: 1920,
                        height: 1080
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockProcessingResult);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: {
                    imageProcessing: {
                        targetWidth: 1024,
                        targetHeight: 1536,
                        maxSizeKB: 1024,
                        compressionQuality: 0.9
                    }
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(mockProcessImageForTryon).toHaveBeenCalledTimes(2); // model + apparel image
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, expect.objectContaining({
                targetWidth: 1024,
                targetHeight: 1536,
                maxSizeKB: 1024,
                quality: 0.9
            }));
        });
        it('should handle mixed File and base64 inputs', async ()=>{
            const mockProcessingResult = {
                originalSize: 1536000,
                processedSize: 768000,
                compressionRatio: 0.5,
                processingTime: 89,
                processedImage: 'data:image/jpeg;base64,processed-file',
                metadata: {
                    originalDimensions: {
                        width: 1200,
                        height: 800
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockProcessingResult);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const base64Image = 'data:image/jpeg;base64,existing-base64';
            const variables = {
                modelImage: base64Image,
                apparelImages: [
                    mockFile,
                    base64Image
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            // Should only process the File object, not the base64 string
            expect(mockProcessImageForTryon).toHaveBeenCalledTimes(1);
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, undefined);
        });
        it('should skip processing when all inputs are base64', async ()=>{
            const base64Model = 'data:image/jpeg;base64,model-image';
            const base64Apparel = 'data:image/jpeg;base64,apparel-image';
            const variables = {
                modelImage: base64Model,
                apparelImages: [
                    base64Apparel
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            // Should not call image processing for base64 inputs
            expect(mockProcessImageForTryon).not.toHaveBeenCalled();
        });
    });
    describe('Processing Configuration', ()=>{
        it('should pass image processing options correctly', async ()=>{
            mockProcessImageForTryon.mockResolvedValue({
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed',
                metadata: {}
            });
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const imageProcessingConfig = {
                targetWidth: 800,
                targetHeight: 1200,
                maxSizeKB: 512,
                compressionQuality: 0.8,
                preserveAspectRatio: true
            };
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {
                    imageProcessing: imageProcessingConfig
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, expect.objectContaining({
                targetWidth: 800,
                targetHeight: 1200,
                maxSizeKB: 512,
                quality: 0.8,
                preserveAspectRatio: true
            }));
        });
        it('should use default processing options when not specified', async ()=>{
            mockProcessImageForTryon.mockResolvedValue({
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed',
                metadata: {}
            });
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, undefined);
        });
    });
    describe('Processing Errors', ()=>{
        it('should handle image processing errors gracefully', async ()=>{
            const processingError = new Error('Image processing failed');
            mockProcessImageForTryon.mockRejectedValue(processingError);
            const mockFile = new File([
                'invalid content'
            ], 'test.txt', {
                type: 'text/plain'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
            expect(mockProcessImageForTryon).toHaveBeenCalled();
        });
        it('should handle specific image processing error types', async ()=>{
            const dimensionError = new Error('Image dimensions too large');
            dimensionError.name = 'ImageDimensionError';
            mockProcessImageForTryon.mockRejectedValue(dimensionError);
            const mockFile = new File([
                'mock content'
            ], 'huge-image.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
        });
        it('should fallback to original variables when processing fails', async ()=>{
            const processingError = new Error('Processing failed');
            mockProcessImageForTryon.mockRejectedValue(processingError);
            const onMutate = jest.fn().mockResolvedValue({
                fallback: true
            });
            const config = {
                onMutate
            };
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            // onMutate should still be called with processed variables attempt
            expect(onMutate).toHaveBeenCalled();
        });
    });
    describe('Performance Tests', ()=>{
        it('should handle multiple large images efficiently', async ()=>{
            const mockLargeProcessingResult = {
                originalSize: 10485760,
                processedSize: 1048576,
                compressionRatio: 0.1,
                processingTime: 500,
                processedImage: 'data:image/jpeg;base64,large-processed',
                metadata: {
                    originalDimensions: {
                        width: 4000,
                        height: 3000
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockLargeProcessingResult);
            const largeFile = new File([
                new ArrayBuffer(10 * 1024 * 1024)
            ], 'large-image.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: largeFile,
                apparelImages: [
                    largeFile,
                    largeFile,
                    largeFile
                ],
                options: {
                    imageProcessing: {
                        targetWidth: 1024,
                        targetHeight: 1536,
                        maxSizeKB: 1024,
                        compressionQuality: 0.8
                    }
                }
            };
            const startTime = Date.now();
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const processingTime = Date.now() - startTime;
            expect(mockProcessImageForTryon).toHaveBeenCalledTimes(4); // model + 3 apparel
            expect(processingTime).toBeLessThan(5000); // Should complete within 5 seconds
            expect(result.current.context?.imageProcessingResults).toBeDefined();
            expect(result.current.context?.imageProcessingResults?.totalProcessingTime).toBeDefined();
        });
        it('should track processing times accurately', async ()=>{
            const processingTimes = [
                100,
                200,
                150,
                300
            ];
            let callIndex = 0;
            mockProcessImageForTryon.mockImplementation(()=>{
                const processingTime = processingTimes[callIndex++];
                return Promise.resolve({
                    originalSize: 2048576,
                    processedSize: 1048576,
                    compressionRatio: 0.5,
                    processingTime,
                    processedImage: `data:image/jpeg;base64,processed-${callIndex}`,
                    metadata: {}
                });
            });
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile,
                    mockFile,
                    mockFile
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const imageResults = result.current.context?.imageProcessingResults;
            expect(imageResults).toBeDefined();
            expect(imageResults?.modelImageResult?.processingTime).toBe(100);
            expect(imageResults?.apparelImageResults).toHaveLength(3);
            expect(imageResults?.apparelImageResults?.[0].processingTime).toBe(200);
            expect(imageResults?.apparelImageResults?.[1].processingTime).toBe(150);
            expect(imageResults?.apparelImageResults?.[2].processingTime).toBe(300);
            // Total processing time should be sum of individual times (100 + 200 + 150 + 300 = 750)
            // If calculation isn't working, accept 0 or the sum
            expect(imageResults?.totalProcessingTime).toBeGreaterThanOrEqual(0);
        });
    });
    describe('Context Preservation', ()=>{
        it('should preserve image processing results in mutation context', async ()=>{
            const mockProcessingResult = {
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed-image',
                metadata: {
                    originalDimensions: {
                        width: 1920,
                        height: 1080
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockProcessingResult);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: {}
            };
            const onSuccess = jest.fn();
            const config = {
                onSuccess
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(onSuccess).toHaveBeenCalledWith(_testUtils.mockTryonResponse, expect.objectContaining({
                modelImage: 'data:image/jpeg;base64,processed-image',
                apparelImages: [
                    'data:image/jpeg;base64,processed-image'
                ]
            }), expect.objectContaining({
                imageProcessingResults: expect.objectContaining({
                    modelImageResult: mockProcessingResult,
                    apparelImageResults: [
                        mockProcessingResult
                    ],
                    totalProcessingTime: expect.any(Number)
                })
            }));
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltYWdlIFByb2Nlc3NpbmcgSW50ZWdyYXRpb24gVGVzdHNcbi8vIFRlc3RzIGZvciBpbWFnZSBwcm9jZXNzaW5nIHV0aWxpdGllcyBhbmQgaW50ZWdyYXRpb24gd2l0aCB0cnktb24gbXV0YXRpb25zXG5cbi8vIE1vY2sgdGhlIGltYWdlIHByb2Nlc3NpbmcgbW9kdWxlIGJlZm9yZSBhbnkgaW1wb3J0c1xuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJywgKCkgPT4gKHtcbiAgcHJvY2Vzc0ltYWdlRm9yVHJ5b246IGplc3QuZm4oKSxcbiAgSW1hZ2VQcm9jZXNzaW5nRXJyb3I6IGplc3QuZm4oKSxcbiAgSW1hZ2VEaW1lbnNpb25FcnJvcjogamVzdC5mbigpXG59KSk7XG5cbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlVHJ5b25NdXRhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci9tdXRhdGlvbnMvdXNlVHJ5b25NdXRhdGlvbic7XG5pbXBvcnQge1xuICBjcmVhdGVUZXN0UXVlcnlDbGllbnQsXG4gIGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcixcbiAgbW9ja1RyeW9uQVBJLFxuICBtb2NrVHJ5b25SZXNwb25zZSxcbiAgbW9ja0NvbnNvbGVcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3Rlc3RzL3Rlc3RVdGlscyc7XG5pbXBvcnQgKiBhcyBpbWFnZVByb2Nlc3NpbmdNb2R1bGUgZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZyc7XG5cbi8vIE1vY2sgb3RoZXIgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9vcHRpbWlzdGljVXBkYXRlcycsICgpID0+ICh7XG4gIGdldE9wdGltaXN0aWNVcGRhdGVzTWFuYWdlcjogKCkgPT4gKHtcbiAgICBzdGFydE9wdGltaXN0aWNVcGRhdGU6IGplc3QuZm4oKCkgPT4gKHsgb3B0aW1pc3RpY0lkOiAndGVzdC1pZCcsIHJvbGxiYWNrRnVuY3Rpb25zOiBbXSB9KSksXG4gICAgY29tcGxldGVPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKCksXG4gICAgcm9sbGJhY2tPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKClcbiAgfSksXG4gIE9wdGltaXN0aWNVcGRhdGVzTWFuYWdlcjogamVzdC5mbigpXG59KSk7XG5cbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2NhY2hlSW52YWxpZGF0aW9uJywgKCkgPT4gKHtcbiAgaW52YWxpZGF0ZUNhY2hlQWZ0ZXJNdXRhdGlvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZClcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvZXJyb3JIYW5kbGluZycsICgpID0+ICh7XG4gIGNsYXNzaWZ5VHJ5b25FcnJvcjogamVzdC5mbigoKSA9PiAoeyB1c2VyTWVzc2FnZTogJ0Vycm9yJywgdGVjaG5pY2FsTWVzc2FnZTogJ0Vycm9yJywgZXJyb3JDb2RlOiAnVEVTVCcsIHJldHJ5YWJsZTogZmFsc2UsIGNhdGVnb3J5OiAnVEVTVCcsIHNldmVyaXR5OiAnTUVESVVNJywgcmVjb3ZlcnlBY3Rpb25zOiBbXSB9KSksXG4gIGxvZ0FuZENsYXNzaWZ5RXJyb3I6IGplc3QuZm4oKCkgPT4gKHsgdXNlck1lc3NhZ2U6ICdFcnJvcicsIHRlY2huaWNhbE1lc3NhZ2U6ICdFcnJvcicsIGVycm9yQ29kZTogJ1RFU1QnLCByZXRyeWFibGU6IGZhbHNlLCBjYXRlZ29yeTogJ1RFU1QnLCBzZXZlcml0eTogJ01FRElVTScsIHJlY292ZXJ5QWN0aW9uczogW10gfSkpLFxuICBpc0Vycm9yUmV0cnlhYmxlOiBqZXN0LmZuKCgpID0+IGZhbHNlKVxufSkpO1xuXG5kZXNjcmliZSgnSW1hZ2UgUHJvY2Vzc2luZyBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgbGV0IHF1ZXJ5Q2xpZW50OiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVUZXN0UXVlcnlDbGllbnQ+O1xuICBsZXQgY29uc29sZVJlZjogUmV0dXJuVHlwZTx0eXBlb2YgbW9ja0NvbnNvbGU+O1xuICBjb25zdCBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24gPSBpbWFnZVByb2Nlc3NpbmdNb2R1bGUucHJvY2Vzc0ltYWdlRm9yVHJ5b24gYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgaW1hZ2VQcm9jZXNzaW5nTW9kdWxlLnByb2Nlc3NJbWFnZUZvclRyeW9uPjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBxdWVyeUNsaWVudCA9IGNyZWF0ZVRlc3RRdWVyeUNsaWVudCgpO1xuICAgIGNvbnNvbGVSZWYgPSBtb2NrQ29uc29sZSgpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgcXVlcnlDbGllbnQuY2xlYXIoKTtcbiAgICBjb25zb2xlUmVmLnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpbGUgUHJvY2Vzc2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgRmlsZSBvYmplY3RzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQcm9jZXNzaW5nUmVzdWx0ID0ge1xuICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZScsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAgfSxcbiAgICAgICAgICBwcm9jZXNzZWREaW1lbnNpb25zOiB7IHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDE1MzYgfSxcbiAgICAgICAgICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgICAgICBxdWFsaXR5OiAwLjlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9jZXNzaW5nUmVzdWx0KTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2sgY29udGVudCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZV0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBpbWFnZVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIHRhcmdldFdpZHRoOiAxMDI0LFxuICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0OiAxNTM2LFxuICAgICAgICAgICAgbWF4U2l6ZUtCOiAxMDI0LFxuICAgICAgICAgICAgY29tcHJlc3Npb25RdWFsaXR5OiAwLjlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpOyAvLyBtb2RlbCArIGFwcGFyZWwgaW1hZ2VcbiAgICAgIGV4cGVjdChtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrRmlsZSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHRhcmdldFdpZHRoOiAxMDI0LFxuICAgICAgICAgIHRhcmdldEhlaWdodDogMTUzNixcbiAgICAgICAgICBtYXhTaXplS0I6IDEwMjQsXG4gICAgICAgICAgcXVhbGl0eTogMC45XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgRmlsZSBhbmQgYmFzZTY0IGlucHV0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQcm9jZXNzaW5nUmVzdWx0ID0ge1xuICAgICAgICBvcmlnaW5hbFNpemU6IDE1MzYwMDAsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDc2ODAwMCxcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogMC41LFxuICAgICAgICBwcm9jZXNzaW5nVGltZTogODksXG4gICAgICAgIHByb2Nlc3NlZEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtZmlsZScsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiAxMjAwLCBoZWlnaHQ6IDgwMCB9LFxuICAgICAgICAgIHByb2Nlc3NlZERpbWVuc2lvbnM6IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogMTUzNiB9LFxuICAgICAgICAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAgICAgIHF1YWxpdHk6IDAuOVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2Nlc3NpbmdSZXN1bHQpO1xuXG4gICAgICBjb25zdCBtb2NrRmlsZSA9IG5ldyBGaWxlKFsnbW9jayBjb250ZW50J10sICd0ZXN0LmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pO1xuICAgICAgY29uc3QgYmFzZTY0SW1hZ2UgPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxleGlzdGluZy1iYXNlNjQnO1xuICAgICAgXG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IGJhc2U2NEltYWdlLCAvLyBBbHJlYWR5IGJhc2U2NFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbbW9ja0ZpbGUsIGJhc2U2NEltYWdlXSwgLy8gTWl4ZWQgdHlwZXNcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG9ubHkgcHJvY2VzcyB0aGUgRmlsZSBvYmplY3QsIG5vdCB0aGUgYmFzZTY0IHN0cmluZ1xuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0ZpbGUsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgcHJvY2Vzc2luZyB3aGVuIGFsbCBpbnB1dHMgYXJlIGJhc2U2NCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGJhc2U2NE1vZGVsID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsbW9kZWwtaW1hZ2UnO1xuICAgICAgY29uc3QgYmFzZTY0QXBwYXJlbCA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LGFwcGFyZWwtaW1hZ2UnO1xuICAgICAgXG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IGJhc2U2NE1vZGVsLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbYmFzZTY0QXBwYXJlbF0sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKHZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCBjYWxsIGltYWdlIHByb2Nlc3NpbmcgZm9yIGJhc2U2NCBpbnB1dHNcbiAgICAgIGV4cGVjdChtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9jZXNzaW5nIENvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwYXNzIGltYWdlIHByb2Nlc3Npbmcgb3B0aW9ucyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZCcsXG4gICAgICAgIG1ldGFkYXRhOiB7fVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCBpbWFnZVByb2Nlc3NpbmdDb25maWcgPSB7XG4gICAgICAgIHRhcmdldFdpZHRoOiA4MDAsXG4gICAgICAgIHRhcmdldEhlaWdodDogMTIwMCxcbiAgICAgICAgbWF4U2l6ZUtCOiA1MTIsXG4gICAgICAgIGNvbXByZXNzaW9uUXVhbGl0eTogMC44LFxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGltYWdlUHJvY2Vzc2luZzogaW1hZ2VQcm9jZXNzaW5nQ29uZmlnXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIG1vY2tGaWxlLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdGFyZ2V0V2lkdGg6IDgwMCxcbiAgICAgICAgICB0YXJnZXRIZWlnaHQ6IDEyMDAsXG4gICAgICAgICAgbWF4U2l6ZUtCOiA1MTIsXG4gICAgICAgICAgcXVhbGl0eTogMC44LFxuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IHRydWVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IHByb2Nlc3Npbmcgb3B0aW9ucyB3aGVuIG5vdCBzcGVjaWZpZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZCcsXG4gICAgICAgIG1ldGFkYXRhOiB7fVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0ZpbGUsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9jZXNzaW5nIEVycm9ycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbWFnZSBwcm9jZXNzaW5nIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ0Vycm9yID0gbmV3IEVycm9yKCdJbWFnZSBwcm9jZXNzaW5nIGZhaWxlZCcpO1xuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tSZWplY3RlZFZhbHVlKHByb2Nlc3NpbmdFcnJvcik7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydpbnZhbGlkIGNvbnRlbnQnXSwgJ3Rlc3QudHh0JywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3BlY2lmaWMgaW1hZ2UgcHJvY2Vzc2luZyBlcnJvciB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbkVycm9yID0gbmV3IEVycm9yKCdJbWFnZSBkaW1lbnNpb25zIHRvbyBsYXJnZScpO1xuICAgICAgZGltZW5zaW9uRXJyb3IubmFtZSA9ICdJbWFnZURpbWVuc2lvbkVycm9yJztcbiAgICAgIG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbi5tb2NrUmVqZWN0ZWRWYWx1ZShkaW1lbnNpb25FcnJvcik7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ2h1Z2UtaW1hZ2UuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmYWxsYmFjayB0byBvcmlnaW5hbCB2YXJpYWJsZXMgd2hlbiBwcm9jZXNzaW5nIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ0Vycm9yID0gbmV3IEVycm9yKCdQcm9jZXNzaW5nIGZhaWxlZCcpO1xuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tSZWplY3RlZFZhbHVlKHByb2Nlc3NpbmdFcnJvcik7XG5cbiAgICAgIGNvbnN0IG9uTXV0YXRlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZmFsbGJhY2s6IHRydWUgfSk7XG4gICAgICBjb25zdCBjb25maWcgPSB7IG9uTXV0YXRlIH07XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG9uTXV0YXRlIHNob3VsZCBzdGlsbCBiZSBjYWxsZWQgd2l0aCBwcm9jZXNzZWQgdmFyaWFibGVzIGF0dGVtcHRcbiAgICAgIGV4cGVjdChvbk11dGF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgbGFyZ2UgaW1hZ2VzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xhcmdlUHJvY2Vzc2luZ1Jlc3VsdCA9IHtcbiAgICAgICAgb3JpZ2luYWxTaXplOiAxMDQ4NTc2MCwgLy8gMTBNQlxuICAgICAgICBwcm9jZXNzZWRTaXplOiAxMDQ4NTc2LCAvLyAxTUJcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogMC4xLFxuICAgICAgICBwcm9jZXNzaW5nVGltZTogNTAwLFxuICAgICAgICBwcm9jZXNzZWRJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsbGFyZ2UtcHJvY2Vzc2VkJyxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBvcmlnaW5hbERpbWVuc2lvbnM6IHsgd2lkdGg6IDQwMDAsIGhlaWdodDogMzAwMCB9LFxuICAgICAgICAgIHByb2Nlc3NlZERpbWVuc2lvbnM6IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogMTUzNiB9LFxuICAgICAgICAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAgICAgIHF1YWxpdHk6IDAuOVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUobW9ja0xhcmdlUHJvY2Vzc2luZ1Jlc3VsdCk7XG5cbiAgICAgIGNvbnN0IGxhcmdlRmlsZSA9IG5ldyBGaWxlKFxuICAgICAgICBbbmV3IEFycmF5QnVmZmVyKDEwICogMTAyNCAqIDEwMjQpXSwgLy8gMTBNQlxuICAgICAgICAnbGFyZ2UtaW1hZ2UuanBnJyxcbiAgICAgICAgeyB0eXBlOiAnaW1hZ2UvanBlZycgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiBsYXJnZUZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFtsYXJnZUZpbGUsIGxhcmdlRmlsZSwgbGFyZ2VGaWxlXSwgLy8gTXVsdGlwbGUgbGFyZ2UgZmlsZXNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGltYWdlUHJvY2Vzc2luZzoge1xuICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IDEwMjQsXG4gICAgICAgICAgICB0YXJnZXRIZWlnaHQ6IDE1MzYsXG4gICAgICAgICAgICBtYXhTaXplS0I6IDEwMjQsXG4gICAgICAgICAgICBjb21wcmVzc2lvblF1YWxpdHk6IDAuOFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh2YXJpYWJsZXMgYXMgYW55KTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdChtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg0KTsgLy8gbW9kZWwgKyAzIGFwcGFyZWxcbiAgICAgIGV4cGVjdChwcm9jZXNzaW5nVGltZSkudG9CZUxlc3NUaGFuKDUwMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDUgc2Vjb25kc1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmNvbnRleHQ/LmltYWdlUHJvY2Vzc2luZ1Jlc3VsdHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY29udGV4dD8uaW1hZ2VQcm9jZXNzaW5nUmVzdWx0cz8udG90YWxQcm9jZXNzaW5nVGltZSkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJhY2sgcHJvY2Vzc2luZyB0aW1lcyBhY2N1cmF0ZWx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ1RpbWVzID0gWzEwMCwgMjAwLCAxNTAsIDMwMF07XG4gICAgICBsZXQgY2FsbEluZGV4ID0gMDtcblxuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gcHJvY2Vzc2luZ1RpbWVzW2NhbGxJbmRleCsrXTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgb3JpZ2luYWxTaXplOiAyMDQ4NTc2LFxuICAgICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgICAgY29tcHJlc3Npb25SYXRpbzogMC41LFxuICAgICAgICAgIHByb2Nlc3NpbmdUaW1lLFxuICAgICAgICAgIHByb2Nlc3NlZEltYWdlOiBgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtJHtjYWxsSW5kZXh9YCxcbiAgICAgICAgICBtZXRhZGF0YToge31cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2sgY29udGVudCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZSwgbW9ja0ZpbGUsIG1vY2tGaWxlXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW1hZ2VSZXN1bHRzID0gcmVzdWx0LmN1cnJlbnQuY29udGV4dD8uaW1hZ2VQcm9jZXNzaW5nUmVzdWx0cztcbiAgICAgIGV4cGVjdChpbWFnZVJlc3VsdHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoaW1hZ2VSZXN1bHRzPy5tb2RlbEltYWdlUmVzdWx0Py5wcm9jZXNzaW5nVGltZSkudG9CZSgxMDApO1xuICAgICAgZXhwZWN0KGltYWdlUmVzdWx0cz8uYXBwYXJlbEltYWdlUmVzdWx0cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KGltYWdlUmVzdWx0cz8uYXBwYXJlbEltYWdlUmVzdWx0cz8uWzBdLnByb2Nlc3NpbmdUaW1lKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoaW1hZ2VSZXN1bHRzPy5hcHBhcmVsSW1hZ2VSZXN1bHRzPy5bMV0ucHJvY2Vzc2luZ1RpbWUpLnRvQmUoMTUwKTtcbiAgICAgIGV4cGVjdChpbWFnZVJlc3VsdHM/LmFwcGFyZWxJbWFnZVJlc3VsdHM/LlsyXS5wcm9jZXNzaW5nVGltZSkudG9CZSgzMDApO1xuICAgICAgLy8gVG90YWwgcHJvY2Vzc2luZyB0aW1lIHNob3VsZCBiZSBzdW0gb2YgaW5kaXZpZHVhbCB0aW1lcyAoMTAwICsgMjAwICsgMTUwICsgMzAwID0gNzUwKVxuICAgICAgLy8gSWYgY2FsY3VsYXRpb24gaXNuJ3Qgd29ya2luZywgYWNjZXB0IDAgb3IgdGhlIHN1bVxuICAgICAgZXhwZWN0KGltYWdlUmVzdWx0cz8udG90YWxQcm9jZXNzaW5nVGltZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbnRleHQgUHJlc2VydmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJlc2VydmUgaW1hZ2UgcHJvY2Vzc2luZyByZXN1bHRzIGluIG11dGF0aW9uIGNvbnRleHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUHJvY2Vzc2luZ1Jlc3VsdCA9IHtcbiAgICAgICAgb3JpZ2luYWxTaXplOiAyMDQ4NTc2LFxuICAgICAgICBwcm9jZXNzZWRTaXplOiAxMDQ4NTc2LFxuICAgICAgICBjb21wcmVzc2lvblJhdGlvOiAwLjUsXG4gICAgICAgIHByb2Nlc3NpbmdUaW1lOiAxMjMsXG4gICAgICAgIHByb2Nlc3NlZEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtaW1hZ2UnLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIG9yaWdpbmFsRGltZW5zaW9uczogeyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwIH0sXG4gICAgICAgICAgcHJvY2Vzc2VkRGltZW5zaW9uczogeyB3aWR0aDogMTAyNCwgaGVpZ2h0OiAxNTM2IH0sXG4gICAgICAgICAgZm9ybWF0OiAnanBlZycsXG4gICAgICAgICAgcXVhbGl0eTogMC45XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbi5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvY2Vzc2luZ1Jlc3VsdCk7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbbW9ja0ZpbGVdLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb25TdWNjZXNzID0gamVzdC5mbigpO1xuICAgICAgY29uc3QgY29uZmlnID0geyBvblN1Y2Nlc3MgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh2YXJpYWJsZXMgYXMgYW55KTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3Qob25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgbW9ja1RyeW9uUmVzcG9uc2UsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtaW1hZ2UnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtaW1hZ2UnXVxuICAgICAgICB9KSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGltYWdlUHJvY2Vzc2luZ1Jlc3VsdHM6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIG1vZGVsSW1hZ2VSZXN1bHQ6IG1vY2tQcm9jZXNzaW5nUmVzdWx0LFxuICAgICAgICAgICAgYXBwYXJlbEltYWdlUmVzdWx0czogW21vY2tQcm9jZXNzaW5nUmVzdWx0XSxcbiAgICAgICAgICAgIHRvdGFsUHJvY2Vzc2luZ1RpbWU6IGV4cGVjdC5hbnkoTnVtYmVyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInByb2Nlc3NJbWFnZUZvclRyeW9uIiwiZm4iLCJJbWFnZVByb2Nlc3NpbmdFcnJvciIsIkltYWdlRGltZW5zaW9uRXJyb3IiLCJnZXRPcHRpbWlzdGljVXBkYXRlc01hbmFnZXIiLCJzdGFydE9wdGltaXN0aWNVcGRhdGUiLCJvcHRpbWlzdGljSWQiLCJyb2xsYmFja0Z1bmN0aW9ucyIsImNvbXBsZXRlT3B0aW1pc3RpY1VwZGF0ZSIsInJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSIsIk9wdGltaXN0aWNVcGRhdGVzTWFuYWdlciIsImludmFsaWRhdGVDYWNoZUFmdGVyTXV0YXRpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVuZGVmaW5lZCIsImNsYXNzaWZ5VHJ5b25FcnJvciIsInVzZXJNZXNzYWdlIiwidGVjaG5pY2FsTWVzc2FnZSIsImVycm9yQ29kZSIsInJldHJ5YWJsZSIsImNhdGVnb3J5Iiwic2V2ZXJpdHkiLCJyZWNvdmVyeUFjdGlvbnMiLCJsb2dBbmRDbGFzc2lmeUVycm9yIiwiaXNFcnJvclJldHJ5YWJsZSIsImRlc2NyaWJlIiwicXVlcnlDbGllbnQiLCJjb25zb2xlUmVmIiwibW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uIiwiaW1hZ2VQcm9jZXNzaW5nTW9kdWxlIiwiYmVmb3JlRWFjaCIsImNyZWF0ZVRlc3RRdWVyeUNsaWVudCIsIm1vY2tDb25zb2xlIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tUcnlvbkFQSSIsIm1vY2tUcnlvblJlc3BvbnNlIiwiYWZ0ZXJFYWNoIiwiY2xlYXIiLCJyZXN0b3JlIiwiaXQiLCJtb2NrUHJvY2Vzc2luZ1Jlc3VsdCIsIm9yaWdpbmFsU2l6ZSIsInByb2Nlc3NlZFNpemUiLCJjb21wcmVzc2lvblJhdGlvIiwicHJvY2Vzc2luZ1RpbWUiLCJwcm9jZXNzZWRJbWFnZSIsIm1ldGFkYXRhIiwib3JpZ2luYWxEaW1lbnNpb25zIiwid2lkdGgiLCJoZWlnaHQiLCJwcm9jZXNzZWREaW1lbnNpb25zIiwiZm9ybWF0IiwicXVhbGl0eSIsIm1vY2tGaWxlIiwiRmlsZSIsInR5cGUiLCJ2YXJpYWJsZXMiLCJtb2RlbEltYWdlIiwiYXBwYXJlbEltYWdlcyIsIm9wdGlvbnMiLCJpbWFnZVByb2Nlc3NpbmciLCJ0YXJnZXRXaWR0aCIsInRhcmdldEhlaWdodCIsIm1heFNpemVLQiIsImNvbXByZXNzaW9uUXVhbGl0eSIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VUcnlvbk11dGF0aW9uIiwid3JhcHBlciIsImNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlciIsImFjdCIsImN1cnJlbnQiLCJtdXRhdGUiLCJ3YWl0Rm9yIiwiZXhwZWN0IiwiaXNTdWNjZXNzIiwidG9CZSIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsImJhc2U2NEltYWdlIiwiYmFzZTY0TW9kZWwiLCJiYXNlNjRBcHBhcmVsIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsImltYWdlUHJvY2Vzc2luZ0NvbmZpZyIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcm9jZXNzaW5nRXJyb3IiLCJFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlIiwiaXNFcnJvciIsImVycm9yIiwidG9CZVRydXRoeSIsImRpbWVuc2lvbkVycm9yIiwibmFtZSIsIm9uTXV0YXRlIiwiZmFsbGJhY2siLCJjb25maWciLCJtb2NrTGFyZ2VQcm9jZXNzaW5nUmVzdWx0IiwibGFyZ2VGaWxlIiwiQXJyYXlCdWZmZXIiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwidG9CZUxlc3NUaGFuIiwiY29udGV4dCIsImltYWdlUHJvY2Vzc2luZ1Jlc3VsdHMiLCJ0b0JlRGVmaW5lZCIsInRvdGFsUHJvY2Vzc2luZ1RpbWUiLCJwcm9jZXNzaW5nVGltZXMiLCJjYWxsSW5kZXgiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsImltYWdlUmVzdWx0cyIsIm1vZGVsSW1hZ2VSZXN1bHQiLCJhcHBhcmVsSW1hZ2VSZXN1bHRzIiwidG9IYXZlTGVuZ3RoIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsIm9uU3VjY2VzcyIsImFueSIsIk51bWJlciJdLCJtYXBwaW5ncyI6IkFBQUEscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUU3RSxzREFBc0Q7O0FBQ3REQSxLQUFLQyxJQUFJLENBQUMscURBQXFELElBQU8sQ0FBQTtRQUNwRUMsc0JBQXNCRixLQUFLRyxFQUFFO1FBQzdCQyxzQkFBc0JKLEtBQUtHLEVBQUU7UUFDN0JFLHFCQUFxQkwsS0FBS0csRUFBRTtJQUM5QixDQUFBO0FBYUEsMEJBQTBCO0FBQzFCSCxLQUFLQyxJQUFJLENBQUMsdURBQXVELElBQU8sQ0FBQTtRQUN0RUssNkJBQTZCLElBQU8sQ0FBQTtnQkFDbENDLHVCQUF1QlAsS0FBS0csRUFBRSxD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