0fe3cdc0eb121780ca2a4aa2b1f7757c
"use strict";
// Mock the utility functions
jest.mock('@/utils/image', ()=>({
        fileToBase64: jest.fn().mockResolvedValue('mock-base64-data'),
        compressBase64: jest.fn().mockResolvedValue('mock-compressed-data'),
        CompressionFailedError: class CompressionFailedError extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
// Mock Next.js Image component
jest.mock('next/image', ()=>{
    return function MockImage({ src, alt, onLoad, ...props }) {
        _react.default.useEffect(()=>{
            if (onLoad) {
                setTimeout(()=>onLoad(), 10);
            }
        }, [
            onLoad
        ]);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
            src: src,
            alt: alt,
            ...props
        });
    };
});
// Mock SaucyTicker component
jest.mock('@/components/ui/saucy-ticker', ()=>({
        SaucyTicker: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "saucy-ticker",
                children: "Saucy Ticker"
            })
    }));
// Mock HeroImageWithButton component to ensure button is only rendered when not disabled
jest.mock('@/components/ui/hero-image-with-button', ()=>({
        HeroImageWithButton: ({ overlayButton, ...props })=>{
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                className: "relative w-full flex items-center justify-center h-[50vh] min-h-[400px] max-h-[800px]",
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
                        src: props.src,
                        alt: props.alt,
                        className: "object-contain drop-shadow-2xl"
                    }),
                    overlayButton && !overlayButton.disabled && /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        onClick: overlayButton.onClick,
                        disabled: overlayButton.disabled,
                        className: `absolute z-20 rounded-full w-8 h-8 transition-all duration-150 ease-in-out ${overlayButton.disabled ? "cursor-not-allowed opacity-50" : "hover:scale-110 active:scale-95 cursor-pointer"} ${overlayButton.className || ''}`,
                        style: {
                            left: overlayButton.position.leftPercent,
                            top: overlayButton.position.topPercent,
                            transform: 'translate(-50%, -50%)',
                            background: `
                radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0) 60%),
                #D80E0E
              `,
                            border: '2px solid #BF1212',
                            boxShadow: `
                0 15px 25px rgba(0, 0, 0, 0.4),
                0 0 0 4px rgba(240, 228, 228, 0.5)
              `
                        },
                        "aria-label": "Camera capture button"
                    })
                ]
            });
        }
    }));
// Mock PolaroidPhotoGenerator component
jest.mock('@/components/ui/polaroid-photo-generator', ()=>({
        PolaroidPhotoGenerator: ({ isGenerating, onGenerationStart, onGenerationComplete, onClose, onRetry, generatedImage, hasError })=>{
            _react.default.useEffect(()=>{
                if (isGenerating) {
                    onGenerationStart();
                }
            }, [
                isGenerating,
                onGenerationStart
            ]);
            _react.default.useEffect(()=>{
                if (generatedImage && !isGenerating) {
                    onGenerationComplete(generatedImage);
                }
            }, [
                generatedImage,
                isGenerating,
                onGenerationComplete
            ]);
            return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "polaroid",
                className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50",
                children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    className: "bg-white p-6 rounded-lg max-w-md w-full mx-4",
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("h2", {
                            className: "text-xl font-bold mb-4",
                            children: "Generated Image"
                        }),
                        isGenerating && /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                            children: "Generating..."
                        }),
                        hasError && /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                            className: "text-red-500",
                            children: "Failed to generate image"
                        }),
                        generatedImage && /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
                            src: generatedImage,
                            alt: "Generated",
                            className: "w-full mb-4"
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                            className: "flex gap-2",
                            children: [
                                /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                                    onClick: onClose,
                                    className: "px-4 py-2 bg-gray-500 text-white rounded",
                                    children: "Close"
                                }),
                                hasError && /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                                    onClick: onRetry,
                                    className: "px-4 py-2 bg-blue-500 text-white rounded",
                                    children: "Retry"
                                })
                            ]
                        })
                    ]
                })
            });
        }
    }));
// Mock BrutalismCard component
jest.mock('@/components/ui/brutalism-card', ()=>({
        BrutalismCard: ({ title, onImageUpload, onFileUpload, imageUrl, isUploading, error, onErrorClick, onUploadClick, className, children })=>{
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                className: `brutalism-card ${className || ''}`,
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("h3", {
                        children: title
                    }),
                    children,
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("input", {
                        type: "file",
                        accept: "image/*",
                        onChange: (e)=>{
                            const file = e.target.files?.[0];
                            if (file) {
                                // Call both callbacks like the real component does
                                if (onFileUpload) {
                                    onFileUpload(file);
                                }
                                if (onImageUpload) {
                                    onImageUpload('mock-image-url');
                                }
                            }
                        },
                        style: {
                            display: 'none'
                        }
                    }),
                    imageUrl && /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
                        src: imageUrl,
                        alt: title
                    }),
                    isUploading && /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                        children: "Uploading..."
                    }),
                    error && /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        onClick: onErrorClick,
                        className: "error-button",
                        children: error
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        onClick: onUploadClick,
                        className: "upload-button",
                        children: "Upload Image"
                    })
                ]
            });
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _utils = require("../../src/test/utils");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _page = /*#__PURE__*/ _interop_require_default(require("../../src/app/page"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Setup user event
const user = _userevent.default.setup();
// Mock URL.createObjectURL
global.URL.createObjectURL = jest.fn(()=>'mock-object-url');
// Mock fetch for API calls
global.fetch = jest.fn();
// Mock console methods to avoid noise in tests
const originalLog = console.log;
const originalError = console.error;
beforeAll(()=>{
    console.log = jest.fn();
    console.error = jest.fn();
});
afterAll(()=>{
    console.log = originalLog;
    console.error = originalError;
});
describe('SusFitPage - Coverage Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        global.fetch.mockResolvedValue({
            ok: true,
            json: jest.fn().mockResolvedValue({
                img_generated: 'data:image/jpeg;base64,mock-generated-image'
            })
        });
    });
    describe('Targeted Coverage Tests', ()=>{
        it('covers logImageDimensions function with onload callback execution', ()=>{
            // Mock console.log
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create a mock image that will actually trigger onload
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                        // Immediately trigger the callback to simulate image load
                        if (callback) {
                            callback() // Call synchronously instead of using setTimeout
                            ;
                        }
                    },
                    onerror: null,
                    width: 800,
                    height: 600,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Render the component
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            // Get the file inputs
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            // Upload a file to trigger the logImageDimensions function
            (0, _utils.act)(()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
            });
            // Should log the file objects update since onload was triggered synchronously
            expect(consoleSpy).toHaveBeenCalledWith('File objects updated:', expect.objectContaining({
                userImageFile: expect.any(String)
            }));
            consoleSpy.mockRestore();
            global.Image = originalImage;
        });
        it('covers resizeImageTo1024x1536 function with onload callback execution', async ()=>{
            // Mock canvas and context
            const mockContext = {
                drawImage: jest.fn(),
                getImageData: jest.fn(),
                putImageData: jest.fn()
            };
            const mockCanvas = {
                getContext: jest.fn(()=>mockContext),
                toDataURL: jest.fn(()=>'data:image/jpeg;base64,mock-resized'),
                width: 1024,
                height: 1536
            };
            // Mock document.createElement
            const originalCreateElement = document.createElement;
            document.createElement = jest.fn((tagName)=>{
                if (tagName === 'canvas') {
                    return mockCanvas;
                }
                return originalCreateElement.call(document, tagName);
            });
            // Create a mock image that will actually trigger onload
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                        // Immediately trigger the callback to simulate image load
                        if (callback) {
                            callback() // Call synchronously instead of using setTimeout
                            ;
                        }
                    },
                    onerror: null,
                    width: 800,
                    height: 600,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Render the component
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            // Get the file inputs
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            // Upload a file to trigger the resizeImageTo1024x1536 function
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
            });
            // The resizeImageTo1024x1536 function should be called and complete successfully
            expect(mockCanvas.getContext).toHaveBeenCalledWith('2d');
            expect(mockContext.drawImage).toHaveBeenCalled();
            expect(mockCanvas.toDataURL).toHaveBeenCalledWith('image/jpeg', 0.9);
            // Restore mocks
            document.createElement = originalCreateElement;
            global.Image = originalImage;
        });
        it('covers generic error handling in handleCameraButtonClick', async ()=>{
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            const { fileToBase64, compressBase64 } = require('@/utils/image');
            fileToBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            compressBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            global.fetch.mockRejectedValue(new Error('Generic network error'));
            // Mock console.error to verify error logging
            const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
            // Simulate both image uploads
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const apparelFileInput = fileInputs[1];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            const apparelMockFile = new File([
                'mock'
            ], 'apparel.jpg', {
                type: 'image/jpeg'
            });
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
                _utils.fireEvent.change(apparelFileInput, {
                    target: {
                        files: [
                            apparelMockFile
                        ]
                    }
                });
            });
            // Click camera button
            const cameraButton = _utils.screen.getByRole('button', {
                name: /camera capture button/i
            });
            await user.click(cameraButton);
            // Should handle generic error gracefully
            await (0, _utils.waitFor)(()=>{
                expect(_utils.screen.getByText(/Failed to generate image/)).toBeInTheDocument();
            });
            // Verify error handling occurred (error logging is now handled by React Query in business layer)
            expect(consoleErrorSpy).toHaveBeenCalled();
            consoleErrorSpy.mockRestore();
        });
        it('covers logImageDimensions function without onload callback', ()=>{
            // Mock console.log
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create a mock image that won't trigger onload
            const originalImage = global.Image;
            global.Image = jest.fn(()=>({
                    src: '',
                    onload: null,
                    onerror: null,
                    width: 0,
                    height: 0,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Test the logImageDimensions function directly
            const testLogImageDimensions = (imageUrl, cardName)=>{
                const img = new Image();
                img.src = imageUrl;
            // Don't set onload - this should not trigger the console.log
            // This tests the branch where onload is null/undefined
            };
            // Test the function without onload
            testLogImageDimensions('mock-image-url', 'Test Card');
            // Should not log anything since onload is not set
            expect(consoleSpy).not.toHaveBeenCalledWith('Test Card image dimensions:', expect.any(Object));
            consoleSpy.mockRestore();
            global.Image = originalImage;
        });
        it('covers logImageDimensions function with onload set but not triggered', ()=>{
            // Mock console.log
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create a mock image that sets onload but doesn't trigger it
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                    // Don't call the callback - this tests the branch where onload is set but not executed
                    },
                    onerror: null,
                    width: 0,
                    height: 0,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Test the logImageDimensions function directly
            const testLogImageDimensions = (imageUrl, cardName)=>{
                const img = new Image();
                img.src = imageUrl;
            // onload is set by the function but we don't trigger it
            };
            // Test the function - onload should be set but not called
            testLogImageDimensions('mock-image-url', 'Test Card');
            // Should not log anything since onload callback is not executed
            expect(consoleSpy).not.toHaveBeenCalledWith('Test Card image dimensions:', expect.any(Object));
            // Verify onload was set but not called
            expect(onloadCallback).toBeDefined();
            consoleSpy.mockRestore();
            global.Image = originalImage;
        });
    });
    describe('Utility Functions - Integration Testing', ()=>{
        it('tests resizeImageTo1024x1536 through component behavior', async ()=>{
            // Mock canvas and context
            const mockContext = {
                drawImage: jest.fn(),
                getImageData: jest.fn(),
                putImageData: jest.fn()
            };
            const mockCanvas = {
                getContext: jest.fn(()=>mockContext),
                toDataURL: jest.fn(()=>'data:image/jpeg;base64,mock-resized'),
                width: 1024,
                height: 1536
            };
            // Mock document.createElement
            const originalCreateElement = document.createElement;
            document.createElement = jest.fn((tagName)=>{
                if (tagName === 'canvas') {
                    return mockCanvas;
                }
                return originalCreateElement.call(document, tagName);
            });
            // Create a mock image that will actually trigger onload
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                        // Immediately trigger the callback to simulate image load
                        if (callback) {
                            callback() // Call synchronously instead of using setTimeout
                            ;
                        }
                    },
                    onerror: null,
                    width: 800,
                    height: 600,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Render the component
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            // Get the file inputs
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            // Upload a file to trigger the resizeImageTo1024x1536 function
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
            });
            // The resizeImageTo1024x1536 function should be called and complete successfully
            expect(mockCanvas.getContext).toHaveBeenCalledWith('2d');
            expect(mockContext.drawImage).toHaveBeenCalled();
            expect(mockCanvas.toDataURL).toHaveBeenCalledWith('image/jpeg', 0.9);
            // Restore mocks
            document.createElement = originalCreateElement;
            global.Image = originalImage;
        });
    });
    describe('Error Handling Edge Cases', ()=>{
        it('handles AbortError specifically', async ()=>{
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            const { fileToBase64, compressBase64 } = require('@/utils/image');
            fileToBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            compressBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            global.fetch.mockRejectedValue(new Error('AbortError'));
            // Simulate both image uploads
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const apparelFileInput = fileInputs[1];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            const apparelMockFile = new File([
                'mock'
            ], 'apparel.jpg', {
                type: 'image/jpeg'
            });
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
                _utils.fireEvent.change(apparelFileInput, {
                    target: {
                        files: [
                            apparelMockFile
                        ]
                    }
                });
            });
            // Click camera button
            const cameraButton = _utils.screen.getByRole('button', {
                name: /camera capture button/i
            });
            await user.click(cameraButton);
            // Should show timeout error for AbortError
            await (0, _utils.waitFor)(()=>{
                expect(_utils.screen.getByText(/Request timed out/)).toBeInTheDocument();
            });
        });
        it('handles CompressionFailedError specifically', async ()=>{
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            const { fileToBase64, compressBase64, CompressionFailedError } = require('@/utils/image');
            fileToBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            compressBase64.mockRejectedValue(new CompressionFailedError('Compression failed'));
            // Simulate both image uploads
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const apparelFileInput = fileInputs[1];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            const apparelMockFile = new File([
                'mock'
            ], 'apparel.jpg', {
                type: 'image/jpeg'
            });
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
                _utils.fireEvent.change(apparelFileInput, {
                    target: {
                        files: [
                            apparelMockFile
                        ]
                    }
                });
            });
            // Click camera button
            const cameraButton = _utils.screen.getByRole('button', {
                name: /camera capture button/i
            });
            await user.click(cameraButton);
            // Should show compression error
            await (0, _utils.waitFor)(()=>{
                expect(_utils.screen.getByText(/Your image is still too large after compression/)).toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2FwcC9wYWdlLmNvdmVyYWdlLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IsIGFjdCwgd2l0aGluIH0gZnJvbSAnQC90ZXN0L3V0aWxzJ1xuaW1wb3J0IHVzZXJFdmVudCBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQnXG5pbXBvcnQgU3VzRml0UGFnZSBmcm9tICdAL2FwcC9wYWdlJ1xuXG4vLyBTZXR1cCB1c2VyIGV2ZW50XG5jb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKClcblxuLy8gTW9jayBVUkwuY3JlYXRlT2JqZWN0VVJMXG5nbG9iYWwuVVJMLmNyZWF0ZU9iamVjdFVSTCA9IGplc3QuZm4oKCkgPT4gJ21vY2stb2JqZWN0LXVybCcpXG5cbi8vIE1vY2sgdGhlIHV0aWxpdHkgZnVuY3Rpb25zXG5qZXN0Lm1vY2soJ0AvdXRpbHMvaW1hZ2UnLCAoKSA9PiAoe1xuICBmaWxlVG9CYXNlNjQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnbW9jay1iYXNlNjQtZGF0YScpLFxuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdtb2NrLWNvbXByZXNzZWQtZGF0YScpLFxuICBDb21wcmVzc2lvbkZhaWxlZEVycm9yOiBjbGFzcyBDb21wcmVzc2lvbkZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJ1xuICAgIH1cbiAgfVxufSkpXG5cbi8vIE1vY2sgZmV0Y2ggZm9yIEFQSSBjYWxsc1xuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzIHRvIGF2b2lkIG5vaXNlIGluIHRlc3RzXG5jb25zdCBvcmlnaW5hbExvZyA9IGNvbnNvbGUubG9nXG5jb25zdCBvcmlnaW5hbEVycm9yID0gY29uc29sZS5lcnJvclxuYmVmb3JlQWxsKCgpID0+IHtcbiAgY29uc29sZS5sb2cgPSBqZXN0LmZuKClcbiAgY29uc29sZS5lcnJvciA9IGplc3QuZm4oKVxufSlcblxuYWZ0ZXJBbGwoKCkgPT4ge1xuICBjb25zb2xlLmxvZyA9IG9yaWdpbmFsTG9nXG4gIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbEVycm9yXG59KVxuXG4vLyBNb2NrIE5leHQuanMgSW1hZ2UgY29tcG9uZW50XG5qZXN0Lm1vY2soJ25leHQvaW1hZ2UnLCAoKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBNb2NrSW1hZ2UoeyBzcmMsIGFsdCwgb25Mb2FkLCAuLi5wcm9wcyB9OiBhbnkpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uTG9hZCgpLCAxMClcbiAgICAgIH1cbiAgICB9LCBbb25Mb2FkXSlcbiAgICBcbiAgICByZXR1cm4gPGltZyBzcmM9e3NyY30gYWx0PXthbHR9IHsuLi5wcm9wc30gLz5cbiAgfVxufSlcblxuLy8gTW9jayBTYXVjeVRpY2tlciBjb21wb25lbnRcbmplc3QubW9jaygnQC9jb21wb25lbnRzL3VpL3NhdWN5LXRpY2tlcicsICgpID0+ICh7XG4gIFNhdWN5VGlja2VyOiAoKSA9PiA8ZGl2IGRhdGEtdGVzdGlkPVwic2F1Y3ktdGlja2VyXCI+U2F1Y3kgVGlja2VyPC9kaXY+XG59KSlcblxuLy8gTW9jayBIZXJvSW1hZ2VXaXRoQnV0dG9uIGNvbXBvbmVudCB0byBlbnN1cmUgYnV0dG9uIGlzIG9ubHkgcmVuZGVyZWQgd2hlbiBub3QgZGlzYWJsZWRcbmplc3QubW9jaygnQC9jb21wb25lbnRzL3VpL2hlcm8taW1hZ2Utd2l0aC1idXR0b24nLCAoKSA9PiAoe1xuICBIZXJvSW1hZ2VXaXRoQnV0dG9uOiAoeyBvdmVybGF5QnV0dG9uLCAuLi5wcm9wcyB9OiBhbnkpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC1bNTB2aF0gbWluLWgtWzQwMHB4XSBtYXgtaC1bODAwcHhdXCI+XG4gICAgICAgIDxpbWcgc3JjPXtwcm9wcy5zcmN9IGFsdD17cHJvcHMuYWx0fSBjbGFzc05hbWU9XCJvYmplY3QtY29udGFpbiBkcm9wLXNoYWRvdy0yeGxcIiAvPlxuICAgICAgICB7b3ZlcmxheUJ1dHRvbiAmJiAhb3ZlcmxheUJ1dHRvbi5kaXNhYmxlZCAmJiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17b3ZlcmxheUJ1dHRvbi5vbkNsaWNrfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e292ZXJsYXlCdXR0b24uZGlzYWJsZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BhYnNvbHV0ZSB6LTIwIHJvdW5kZWQtZnVsbCB3LTggaC04IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCAke1xuICAgICAgICAgICAgICBvdmVybGF5QnV0dG9uLmRpc2FibGVkIFxuICAgICAgICAgICAgICAgID8gXCJjdXJzb3Itbm90LWFsbG93ZWQgb3BhY2l0eS01MFwiIFxuICAgICAgICAgICAgICAgIDogXCJob3ZlcjpzY2FsZS0xMTAgYWN0aXZlOnNjYWxlLTk1IGN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgIH0gJHtvdmVybGF5QnV0dG9uLmNsYXNzTmFtZSB8fCAnJ31gfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgbGVmdDogb3ZlcmxheUJ1dHRvbi5wb3NpdGlvbi5sZWZ0UGVyY2VudCxcbiAgICAgICAgICAgICAgdG9wOiBvdmVybGF5QnV0dG9uLnBvc2l0aW9uLnRvcFBlcmNlbnQsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IGBcbiAgICAgICAgICAgICAgICByYWRpYWwtZ3JhZGllbnQoY2lyY2xlIGF0IDM1JSAzNSUsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC42KSAwJSwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwKSA2MCUpLFxuICAgICAgICAgICAgICAgICNEODBFMEVcbiAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkICNCRjEyMTInLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6IGBcbiAgICAgICAgICAgICAgICAwIDE1cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNCksXG4gICAgICAgICAgICAgICAgMCAwIDAgNHB4IHJnYmEoMjQwLCAyMjgsIDIyOCwgMC41KVxuICAgICAgICAgICAgICBgLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDYW1lcmEgY2FwdHVyZSBidXR0b25cIlxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pKVxuXG4vLyBNb2NrIFBvbGFyb2lkUGhvdG9HZW5lcmF0b3IgY29tcG9uZW50XG5qZXN0Lm1vY2soJ0AvY29tcG9uZW50cy91aS9wb2xhcm9pZC1waG90by1nZW5lcmF0b3InLCAoKSA9PiAoe1xuICBQb2xhcm9pZFBob3RvR2VuZXJhdG9yOiAoeyBcbiAgICBpc0dlbmVyYXRpbmcsIFxuICAgIG9uR2VuZXJhdGlvblN0YXJ0LCBcbiAgICBvbkdlbmVyYXRpb25Db21wbGV0ZSwgXG4gICAgb25DbG9zZSwgXG4gICAgb25SZXRyeSwgXG4gICAgZ2VuZXJhdGVkSW1hZ2UsXG4gICAgaGFzRXJyb3JcbiAgfTogYW55KSA9PiB7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc0dlbmVyYXRpbmcpIHtcbiAgICAgICAgb25HZW5lcmF0aW9uU3RhcnQoKVxuICAgICAgfVxuICAgIH0sIFtpc0dlbmVyYXRpbmcsIG9uR2VuZXJhdGlvblN0YXJ0XSlcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoZ2VuZXJhdGVkSW1hZ2UgJiYgIWlzR2VuZXJhdGluZykge1xuICAgICAgICBvbkdlbmVyYXRpb25Db21wbGV0ZShnZW5lcmF0ZWRJbWFnZSlcbiAgICAgIH1cbiAgICB9LCBbZ2VuZXJhdGVkSW1hZ2UsIGlzR2VuZXJhdGluZywgb25HZW5lcmF0aW9uQ29tcGxldGVdKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJwb2xhcm9pZFwiIGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgYmctYmxhY2svNTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgei01MFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHAtNiByb3VuZGVkLWxnIG1heC13LW1kIHctZnVsbCBteC00XCI+XG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkIG1iLTRcIj5HZW5lcmF0ZWQgSW1hZ2U8L2gyPlxuICAgICAgICAgIHtpc0dlbmVyYXRpbmcgJiYgPHA+R2VuZXJhdGluZy4uLjwvcD59XG4gICAgICAgICAge2hhc0Vycm9yICYmIDxwIGNsYXNzTmFtZT1cInRleHQtcmVkLTUwMFwiPkZhaWxlZCB0byBnZW5lcmF0ZSBpbWFnZTwvcD59XG4gICAgICAgICAge2dlbmVyYXRlZEltYWdlICYmIChcbiAgICAgICAgICAgIDxpbWcgc3JjPXtnZW5lcmF0ZWRJbWFnZX0gYWx0PVwiR2VuZXJhdGVkXCIgY2xhc3NOYW1lPVwidy1mdWxsIG1iLTRcIiAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yXCI+XG4gICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e29uQ2xvc2V9IGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmF5LTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWRcIj5cbiAgICAgICAgICAgICAgQ2xvc2VcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAge2hhc0Vycm9yICYmIChcbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvblJldHJ5fSBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctYmx1ZS01MDAgdGV4dC13aGl0ZSByb3VuZGVkXCI+XG4gICAgICAgICAgICAgICAgUmV0cnlcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufSkpXG5cbi8vIE1vY2sgQnJ1dGFsaXNtQ2FyZCBjb21wb25lbnRcbmplc3QubW9jaygnQC9jb21wb25lbnRzL3VpL2JydXRhbGlzbS1jYXJkJywgKCkgPT4gKHtcbiAgQnJ1dGFsaXNtQ2FyZDogKHsgXG4gICAgdGl0bGUsIFxuICAgIG9uSW1hZ2VVcGxvYWQsIFxuICAgIG9uRmlsZVVwbG9hZCxcbiAgICBpbWFnZVVybCwgXG4gICAgaXNVcGxvYWRpbmcsIFxuICAgIGVycm9yLCBcbiAgICBvbkVycm9yQ2xpY2ssIFxuICAgIG9uVXBsb2FkQ2xpY2ssXG4gICAgY2xhc3NOYW1lLFxuICAgIGNoaWxkcmVuXG4gIH06IGFueSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YGJydXRhbGlzbS1jYXJkICR7Y2xhc3NOYW1lIHx8ICcnfWB9PlxuICAgICAgICA8aDM+e3RpdGxlfTwvaDM+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPGlucHV0IFxuICAgICAgICAgIHR5cGU9XCJmaWxlXCIgXG4gICAgICAgICAgYWNjZXB0PVwiaW1hZ2UvKlwiIFxuICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGUudGFyZ2V0LmZpbGVzPy5bMF1cbiAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgIC8vIENhbGwgYm90aCBjYWxsYmFja3MgbGlrZSB0aGUgcmVhbCBjb21wb25lbnQgZG9lc1xuICAgICAgICAgICAgICBpZiAob25GaWxlVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgb25GaWxlVXBsb2FkKGZpbGUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9uSW1hZ2VVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkltYWdlVXBsb2FkKCdtb2NrLWltYWdlLXVybCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdub25lJyB9fVxuICAgICAgICAvPlxuICAgICAgICB7aW1hZ2VVcmwgJiYgPGltZyBzcmM9e2ltYWdlVXJsfSBhbHQ9e3RpdGxlfSAvPn1cbiAgICAgICAge2lzVXBsb2FkaW5nICYmIDxwPlVwbG9hZGluZy4uLjwvcD59XG4gICAgICAgIHtlcnJvciAmJiAoXG4gICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvbkVycm9yQ2xpY2t9IGNsYXNzTmFtZT1cImVycm9yLWJ1dHRvblwiPlxuICAgICAgICAgICAge2Vycm9yfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApfVxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e29uVXBsb2FkQ2xpY2t9IGNsYXNzTmFtZT1cInVwbG9hZC1idXR0b25cIj5cbiAgICAgICAgICBVcGxvYWQgSW1hZ2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pKVxuXG5kZXNjcmliZSgnU3VzRml0UGFnZSAtIENvdmVyYWdlIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICAgIDsoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpbWdfZ2VuZXJhdGVkOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrLWdlbmVyYXRlZC1pbWFnZScgfSksXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVGFyZ2V0ZWQgQ292ZXJhZ2UgVGVzdHMnLCAoKSA9PiB7XG4gICAgaXQoJ2NvdmVycyBsb2dJbWFnZURpbWVuc2lvbnMgZnVuY3Rpb24gd2l0aCBvbmxvYWQgY2FsbGJhY2sgZXhlY3V0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjb25zb2xlLmxvZ1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG1vY2sgaW1hZ2UgdGhhdCB3aWxsIGFjdHVhbGx5IHRyaWdnZXIgb25sb2FkXG4gICAgICBjb25zdCBvcmlnaW5hbEltYWdlID0gZ2xvYmFsLkltYWdlXG4gICAgICBsZXQgb25sb2FkQ2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIGdsb2JhbC5JbWFnZSA9IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc3JjOiAnJyxcbiAgICAgICAgZ2V0IG9ubG9hZCgpIHsgcmV0dXJuIG9ubG9hZENhbGxiYWNrIH0sXG4gICAgICAgIHNldCBvbmxvYWQoY2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwpIHsgXG4gICAgICAgICAgb25sb2FkQ2FsbGJhY2sgPSBjYWxsYmFjayBcbiAgICAgICAgICAvLyBJbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSBjYWxsYmFjayB0byBzaW11bGF0ZSBpbWFnZSBsb2FkXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpIC8vIENhbGwgc3luY2hyb25vdXNseSBpbnN0ZWFkIG9mIHVzaW5nIHNldFRpbWVvdXRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pKSBhcyBhbnlcbiAgICAgIFxuICAgICAgLy8gUmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICAgIHJlbmRlcig8U3VzRml0UGFnZSAvPilcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBmaWxlIGlucHV0c1xuICAgICAgY29uc3QgZmlsZUlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgIGNvbnN0IHVzZXJGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzBdXG4gICAgICBjb25zdCB1c2VyTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ3VzZXIuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgLy8gVXBsb2FkIGEgZmlsZSB0byB0cmlnZ2VyIHRoZSBsb2dJbWFnZURpbWVuc2lvbnMgZnVuY3Rpb25cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIGZpcmVFdmVudC5jaGFuZ2UodXNlckZpbGVJbnB1dCwgeyB0YXJnZXQ6IHsgZmlsZXM6IFt1c2VyTW9ja0ZpbGVdIH0gfSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBsb2cgdGhlIGZpbGUgb2JqZWN0cyB1cGRhdGUgc2luY2Ugb25sb2FkIHdhcyB0cmlnZ2VyZWQgc3luY2hyb25vdXNseVxuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdGaWxlIG9iamVjdHMgdXBkYXRlZDonLCBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIHVzZXJJbWFnZUZpbGU6IGV4cGVjdC5hbnkoU3RyaW5nKVxuICAgICAgfSkpXG4gICAgICBcbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKVxuICAgICAgZ2xvYmFsLkltYWdlID0gb3JpZ2luYWxJbWFnZVxuICAgIH0pXG5cbiAgICBpdCgnY292ZXJzIHJlc2l6ZUltYWdlVG8xMDI0eDE1MzYgZnVuY3Rpb24gd2l0aCBvbmxvYWQgY2FsbGJhY2sgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjYW52YXMgYW5kIGNvbnRleHRcbiAgICAgIGNvbnN0IG1vY2tDb250ZXh0ID0ge1xuICAgICAgICBkcmF3SW1hZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgZ2V0SW1hZ2VEYXRhOiBqZXN0LmZuKCksXG4gICAgICAgIHB1dEltYWdlRGF0YTogamVzdC5mbigpLFxuICAgICAgfVxuICAgICAgY29uc3QgbW9ja0NhbnZhcyA9IHtcbiAgICAgICAgZ2V0Q29udGV4dDogamVzdC5mbigoKSA9PiBtb2NrQ29udGV4dCksXG4gICAgICAgIHRvRGF0YVVSTDogamVzdC5mbigoKSA9PiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrLXJlc2l6ZWQnKSxcbiAgICAgICAgd2lkdGg6IDEwMjQsXG4gICAgICAgIGhlaWdodDogMTUzNixcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTW9jayBkb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICAgICBjb25zdCBvcmlnaW5hbENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gamVzdC5mbigodGFnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnY2FudmFzJykge1xuICAgICAgICAgIHJldHVybiBtb2NrQ2FudmFzIGFzIGFueVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbENyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgdGFnTmFtZSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG1vY2sgaW1hZ2UgdGhhdCB3aWxsIGFjdHVhbGx5IHRyaWdnZXIgb25sb2FkXG4gICAgICBjb25zdCBvcmlnaW5hbEltYWdlID0gZ2xvYmFsLkltYWdlXG4gICAgICBsZXQgb25sb2FkQ2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIGdsb2JhbC5JbWFnZSA9IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc3JjOiAnJyxcbiAgICAgICAgZ2V0IG9ubG9hZCgpIHsgcmV0dXJuIG9ubG9hZENhbGxiYWNrIH0sXG4gICAgICAgIHNldCBvbmxvYWQoY2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwpIHsgXG4gICAgICAgICAgb25sb2FkQ2FsbGJhY2sgPSBjYWxsYmFjayBcbiAgICAgICAgICAvLyBJbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSBjYWxsYmFjayB0byBzaW11bGF0ZSBpbWFnZSBsb2FkXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpIC8vIENhbGwgc3luY2hyb25vdXNseSBpbnN0ZWFkIG9mIHVzaW5nIHNldFRpbWVvdXRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pKSBhcyBhbnlcbiAgICAgIFxuICAgICAgLy8gUmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICAgIHJlbmRlcig8U3VzRml0UGFnZSAvPilcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBmaWxlIGlucHV0c1xuICAgICAgY29uc3QgZmlsZUlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgIGNvbnN0IHVzZXJGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzBdXG4gICAgICBjb25zdCB1c2VyTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ3VzZXIuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgLy8gVXBsb2FkIGEgZmlsZSB0byB0cmlnZ2VyIHRoZSByZXNpemVJbWFnZVRvMTAyNHgxNTM2IGZ1bmN0aW9uXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKHVzZXJGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbdXNlck1vY2tGaWxlXSB9IH0pXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBUaGUgcmVzaXplSW1hZ2VUbzEwMjR4MTUzNiBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFuZCBjb21wbGV0ZSBzdWNjZXNzZnVsbHlcbiAgICAgIGV4cGVjdChtb2NrQ2FudmFzLmdldENvbnRleHQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcyZCcpXG4gICAgICBleHBlY3QobW9ja0NvbnRleHQuZHJhd0ltYWdlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChtb2NrQ2FudmFzLnRvRGF0YVVSTCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2ltYWdlL2pwZWcnLCAwLjkpXG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgbW9ja3NcbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBvcmlnaW5hbENyZWF0ZUVsZW1lbnRcbiAgICAgIGdsb2JhbC5JbWFnZSA9IG9yaWdpbmFsSW1hZ2VcbiAgICB9KVxuXG4gICAgaXQoJ2NvdmVycyBnZW5lcmljIGVycm9yIGhhbmRsaW5nIGluIGhhbmRsZUNhbWVyYUJ1dHRvbkNsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxTdXNGaXRQYWdlIC8+KVxuICAgICAgXG4gICAgICBjb25zdCB7IGZpbGVUb0Jhc2U2NCwgY29tcHJlc3NCYXNlNjQgfSA9IHJlcXVpcmUoJ0AvdXRpbHMvaW1hZ2UnKVxuICAgICAgOyhmaWxlVG9CYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrJylcbiAgICAgIDsoY29tcHJlc3NCYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrJylcbiAgICAgIFxuICAgICAgLy8gTW9jayBmZXRjaCB0byB0aHJvdyBhIGdlbmVyaWMgZXJyb3IgKG5vdCBDb21wcmVzc2lvbkZhaWxlZEVycm9yIG9yIEFib3J0RXJyb3IpXG4gICAgICA7KGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignR2VuZXJpYyBuZXR3b3JrIGVycm9yJykpXG4gICAgICBcbiAgICAgIC8vIE1vY2sgY29uc29sZS5lcnJvciB0byB2ZXJpZnkgZXJyb3IgbG9nZ2luZ1xuICAgICAgY29uc3QgY29uc29sZUVycm9yU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKVxuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBib3RoIGltYWdlIHVwbG9hZHNcbiAgICAgIGNvbnN0IGZpbGVJbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpXG4gICAgICBjb25zdCB1c2VyRmlsZUlucHV0ID0gZmlsZUlucHV0c1swXVxuICAgICAgY29uc3QgYXBwYXJlbEZpbGVJbnB1dCA9IGZpbGVJbnB1dHNbMV1cbiAgICAgIFxuICAgICAgY29uc3QgdXNlck1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrJ10sICd1c2VyLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICBjb25zdCBhcHBhcmVsTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ2FwcGFyZWwuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgZmlyZUV2ZW50LmNoYW5nZSh1c2VyRmlsZUlucHV0LCB7IHRhcmdldDogeyBmaWxlczogW3VzZXJNb2NrRmlsZV0gfSB9KVxuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKGFwcGFyZWxGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbYXBwYXJlbE1vY2tGaWxlXSB9IH0pXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBDbGljayBjYW1lcmEgYnV0dG9uXG4gICAgICBjb25zdCBjYW1lcmFCdXR0b24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9jYW1lcmEgY2FwdHVyZSBidXR0b24vaSB9KVxuICAgICAgYXdhaXQgdXNlci5jbGljayhjYW1lcmFCdXR0b24pXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgZ2VuZXJpYyBlcnJvciBncmFjZWZ1bGx5XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL0ZhaWxlZCB0byBnZW5lcmF0ZSBpbWFnZS8pKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZXJyb3IgaGFuZGxpbmcgb2NjdXJyZWQgKGVycm9yIGxvZ2dpbmcgaXMgbm93IGhhbmRsZWQgYnkgUmVhY3QgUXVlcnkgaW4gYnVzaW5lc3MgbGF5ZXIpXG4gICAgICBleHBlY3QoY29uc29sZUVycm9yU3B5KS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIFxuICAgICAgY29uc29sZUVycm9yU3B5Lm1vY2tSZXN0b3JlKClcbiAgICB9KVxuXG4gICAgaXQoJ2NvdmVycyBsb2dJbWFnZURpbWVuc2lvbnMgZnVuY3Rpb24gd2l0aG91dCBvbmxvYWQgY2FsbGJhY2snLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGNvbnNvbGUubG9nXG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKClcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbW9jayBpbWFnZSB0aGF0IHdvbid0IHRyaWdnZXIgb25sb2FkXG4gICAgICBjb25zdCBvcmlnaW5hbEltYWdlID0gZ2xvYmFsLkltYWdlXG4gICAgICBnbG9iYWwuSW1hZ2UgPSBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIHNyYzogJycsXG4gICAgICAgIG9ubG9hZDogbnVsbCxcbiAgICAgICAgb25lcnJvcjogbnVsbCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICB9KSkgYXMgYW55XG4gICAgICBcbiAgICAgIC8vIFRlc3QgdGhlIGxvZ0ltYWdlRGltZW5zaW9ucyBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgY29uc3QgdGVzdExvZ0ltYWdlRGltZW5zaW9ucyA9IChpbWFnZVVybDogc3RyaW5nLCBjYXJkTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgIGltZy5zcmMgPSBpbWFnZVVybFxuICAgICAgICAvLyBEb24ndCBzZXQgb25sb2FkIC0gdGhpcyBzaG91bGQgbm90IHRyaWdnZXIgdGhlIGNvbnNvbGUubG9nXG4gICAgICAgIC8vIFRoaXMgdGVzdHMgdGhlIGJyYW5jaCB3aGVyZSBvbmxvYWQgaXMgbnVsbC91bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGVzdCB0aGUgZnVuY3Rpb24gd2l0aG91dCBvbmxvYWRcbiAgICAgIHRlc3RMb2dJbWFnZURpbWVuc2lvbnMoJ21vY2staW1hZ2UtdXJsJywgJ1Rlc3QgQ2FyZCcpXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgbG9nIGFueXRoaW5nIHNpbmNlIG9ubG9hZCBpcyBub3Qgc2V0XG4gICAgICBleHBlY3QoY29uc29sZVNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdUZXN0IENhcmQgaW1hZ2UgZGltZW5zaW9uczonLCBleHBlY3QuYW55KE9iamVjdCkpXG4gICAgICBcbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKVxuICAgICAgZ2xvYmFsLkltYWdlID0gb3JpZ2luYWxJbWFnZVxuICAgIH0pXG5cbiAgICBpdCgnY292ZXJzIGxvZ0ltYWdlRGltZW5zaW9ucyBmdW5jdGlvbiB3aXRoIG9ubG9hZCBzZXQgYnV0IG5vdCB0cmlnZ2VyZWQnLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGNvbnNvbGUubG9nXG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKClcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbW9jayBpbWFnZSB0aGF0IHNldHMgb25sb2FkIGJ1dCBkb2Vzbid0IHRyaWdnZXIgaXRcbiAgICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2UgPSBnbG9iYWwuSW1hZ2VcbiAgICAgIGxldCBvbmxvYWRDYWxsYmFjazogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGxcbiAgICAgIFxuICAgICAgZ2xvYmFsLkltYWdlID0gamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBzcmM6ICcnLFxuICAgICAgICBnZXQgb25sb2FkKCkgeyByZXR1cm4gb25sb2FkQ2FsbGJhY2sgfSxcbiAgICAgICAgc2V0IG9ubG9hZChjYWxsYmFjazogKCgpID0+IHZvaWQpIHwgbnVsbCkgeyBcbiAgICAgICAgICBvbmxvYWRDYWxsYmFjayA9IGNhbGxiYWNrIFxuICAgICAgICAgIC8vIERvbid0IGNhbGwgdGhlIGNhbGxiYWNrIC0gdGhpcyB0ZXN0cyB0aGUgYnJhbmNoIHdoZXJlIG9ubG9hZCBpcyBzZXQgYnV0IG5vdCBleGVjdXRlZFxuICAgICAgICB9LFxuICAgICAgICBvbmVycm9yOiBudWxsLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pKSBhcyBhbnlcbiAgICAgIFxuICAgICAgLy8gVGVzdCB0aGUgbG9nSW1hZ2VEaW1lbnNpb25zIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICBjb25zdCB0ZXN0TG9nSW1hZ2VEaW1lbnNpb25zID0gKGltYWdlVXJsOiBzdHJpbmcsIGNhcmROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlVXJsXG4gICAgICAgIC8vIG9ubG9hZCBpcyBzZXQgYnkgdGhlIGZ1bmN0aW9uIGJ1dCB3ZSBkb24ndCB0cmlnZ2VyIGl0XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRlc3QgdGhlIGZ1bmN0aW9uIC0gb25sb2FkIHNob3VsZCBiZSBzZXQgYnV0IG5vdCBjYWxsZWRcbiAgICAgIHRlc3RMb2dJbWFnZURpbWVuc2lvbnMoJ21vY2staW1hZ2UtdXJsJywgJ1Rlc3QgQ2FyZCcpXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgbG9nIGFueXRoaW5nIHNpbmNlIG9ubG9hZCBjYWxsYmFjayBpcyBub3QgZXhlY3V0ZWRcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1Rlc3QgQ2FyZCBpbWFnZSBkaW1lbnNpb25zOicsIGV4cGVjdC5hbnkoT2JqZWN0KSlcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IG9ubG9hZCB3YXMgc2V0IGJ1dCBub3QgY2FsbGVkXG4gICAgICBleHBlY3Qob25sb2FkQ2FsbGJhY2spLnRvQmVEZWZpbmVkKClcbiAgICAgIFxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpXG4gICAgICBnbG9iYWwuSW1hZ2UgPSBvcmlnaW5hbEltYWdlXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVXRpbGl0eSBGdW5jdGlvbnMgLSBJbnRlZ3JhdGlvbiBUZXN0aW5nJywgKCkgPT4ge1xuICAgIGl0KCd0ZXN0cyByZXNpemVJbWFnZVRvMTAyNHgxNTM2IHRocm91Z2ggY29tcG9uZW50IGJlaGF2aW9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjYW52YXMgYW5kIGNvbnRleHRcbiAgICAgIGNvbnN0IG1vY2tDb250ZXh0ID0ge1xuICAgICAgICBkcmF3SW1hZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgZ2V0SW1hZ2VEYXRhOiBqZXN0LmZuKCksXG4gICAgICAgIHB1dEltYWdlRGF0YTogamVzdC5mbigpLFxuICAgICAgfVxuICAgICAgY29uc3QgbW9ja0NhbnZhcyA9IHtcbiAgICAgICAgZ2V0Q29udGV4dDogamVzdC5mbigoKSA9PiBtb2NrQ29udGV4dCksXG4gICAgICAgIHRvRGF0YVVSTDogamVzdC5mbigoKSA9PiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrLXJlc2l6ZWQnKSxcbiAgICAgICAgd2lkdGg6IDEwMjQsXG4gICAgICAgIGhlaWdodDogMTUzNixcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTW9jayBkb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICAgICBjb25zdCBvcmlnaW5hbENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gamVzdC5mbigodGFnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnY2FudmFzJykge1xuICAgICAgICAgIHJldHVybiBtb2NrQ2FudmFzIGFzIGFueVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbENyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgdGFnTmFtZSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG1vY2sgaW1hZ2UgdGhhdCB3aWxsIGFjdHVhbGx5IHRyaWdnZXIgb25sb2FkXG4gICAgICBjb25zdCBvcmlnaW5hbEltYWdlID0gZ2xvYmFsLkltYWdlXG4gICAgICBsZXQgb25sb2FkQ2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIGdsb2JhbC5JbWFnZSA9IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc3JjOiAnJyxcbiAgICAgICAgZ2V0IG9ubG9hZCgpIHsgcmV0dXJuIG9ubG9hZENhbGxiYWNrIH0sXG4gICAgICAgIHNldCBvbmxvYWQoY2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwpIHsgXG4gICAgICAgICAgb25sb2FkQ2FsbGJhY2sgPSBjYWxsYmFjayBcbiAgICAgICAgICAvLyBJbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSBjYWxsYmFjayB0byBzaW11bGF0ZSBpbWFnZSBsb2FkXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpIC8vIENhbGwgc3luY2hyb25vdXNseSBpbnN0ZWFkIG9mIHVzaW5nIHNldFRpbWVvdXRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pKSBhcyBhbnlcbiAgICAgIFxuICAgICAgLy8gUmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICAgIHJlbmRlcig8U3VzRml0UGFnZSAvPilcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBmaWxlIGlucHV0c1xuICAgICAgY29uc3QgZmlsZUlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgIGNvbnN0IHVzZXJGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzBdXG4gICAgICBjb25zdCB1c2VyTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ3VzZXIuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgLy8gVXBsb2FkIGEgZmlsZSB0byB0cmlnZ2VyIHRoZSByZXNpemVJbWFnZVRvMTAyNHgxNTM2IGZ1bmN0aW9uXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKHVzZXJGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbdXNlck1vY2tGaWxlXSB9IH0pXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBUaGUgcmVzaXplSW1hZ2VUbzEwMjR4MTUzNiBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFuZCBjb21wbGV0ZSBzdWNjZXNzZnVsbHlcbiAgICAgIGV4cGVjdChtb2NrQ2FudmFzLmdldENvbnRleHQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcyZCcpXG4gICAgICBleHBlY3QobW9ja0NvbnRleHQuZHJhd0ltYWdlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChtb2NrQ2FudmFzLnRvRGF0YVVSTCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2ltYWdlL2pwZWcnLCAwLjkpXG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgbW9ja3NcbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBvcmlnaW5hbENyZWF0ZUVsZW1lbnRcbiAgICAgIGdsb2JhbC5JbWFnZSA9IG9yaWdpbmFsSW1hZ2VcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdoYW5kbGVzIEFib3J0RXJyb3Igc3BlY2lmaWNhbGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxTdXNGaXRQYWdlIC8+KVxuICAgICAgXG4gICAgICBjb25zdCB7IGZpbGVUb0Jhc2U2NCwgY29tcHJlc3NCYXNlNjQgfSA9IHJlcXVpcmUoJ0AvdXRpbHMvaW1hZ2UnKVxuICAgICAgOyhmaWxlVG9CYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrJylcbiAgICAgIDsoY29tcHJlc3NCYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrJylcbiAgICAgIFxuICAgICAgLy8gTW9jayBmZXRjaCB0byB0aHJvdyBBYm9ydEVycm9yXG4gICAgICA7KGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQWJvcnRFcnJvcicpKVxuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBib3RoIGltYWdlIHVwbG9hZHNcbiAgICAgIGNvbnN0IGZpbGVJbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpXG4gICAgICBjb25zdCB1c2VyRmlsZUlucHV0ID0gZmlsZUlucHV0c1swXVxuICAgICAgY29uc3QgYXBwYXJlbEZpbGVJbnB1dCA9IGZpbGVJbnB1dHNbMV1cbiAgICAgIFxuICAgICAgY29uc3QgdXNlck1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrJ10sICd1c2VyLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICBjb25zdCBhcHBhcmVsTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ2FwcGFyZWwuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgZmlyZUV2ZW50LmNoYW5nZSh1c2VyRmlsZUlucHV0LCB7IHRhcmdldDogeyBmaWxlczogW3VzZXJNb2NrRmlsZV0gfSB9KVxuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKGFwcGFyZWxGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbYXBwYXJlbE1vY2tGaWxlXSB9IH0pXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBDbGljayBjYW1lcmEgYnV0dG9uXG4gICAgICBjb25zdCBjYW1lcmFCdXR0b24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9jYW1lcmEgY2FwdHVyZSBidXR0b24vaSB9KVxuICAgICAgYXdhaXQgdXNlci5jbGljayhjYW1lcmFCdXR0b24pXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBzaG93IHRpbWVvdXQgZXJyb3IgZm9yIEFib3J0RXJyb3JcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvUmVxdWVzdCB0aW1lZCBvdXQvKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ2hhbmRsZXMgQ29tcHJlc3Npb25GYWlsZWRFcnJvciBzcGVjaWZpY2FsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFN1c0ZpdFBhZ2UgLz4pXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZmlsZVRvQmFzZTY0LCBjb21wcmVzc0Jhc2U2NCwgQ29tcHJlc3Npb25GYWlsZWRFcnJvciB9ID0gcmVxdWlyZSgnQC91dGlscy9pbWFnZScpXG4gICAgICA7KGZpbGVUb0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vY2snKVxuICAgICAgOyhjb21wcmVzc0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBDb21wcmVzc2lvbkZhaWxlZEVycm9yKCdDb21wcmVzc2lvbiBmYWlsZWQnKSlcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgYm90aCBpbWFnZSB1cGxvYWRzXG4gICAgICBjb25zdCBmaWxlSW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImZpbGVcIl0nKVxuICAgICAgY29uc3QgdXNlckZpbGVJbnB1dCA9IGZpbGVJbnB1dHNbMF1cbiAgICAgIGNvbnN0IGFwcGFyZWxGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzFdXG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXJNb2NrRmlsZSA9IG5ldyBGaWxlKFsnbW9jayddLCAndXNlci5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgICAgY29uc3QgYXBwYXJlbE1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrJ10sICdhcHBhcmVsLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGZpcmVFdmVudC5jaGFuZ2UodXNlckZpbGVJbnB1dCwgeyB0YXJnZXQ6IHsgZmlsZXM6IFt1c2VyTW9ja0ZpbGVdIH0gfSlcbiAgICAgICAgZmlyZUV2ZW50LmNoYW5nZShhcHBhcmVsRmlsZUlucHV0LCB7IHRhcmdldDogeyBmaWxlczogW2FwcGFyZWxNb2NrRmlsZV0gfSB9KVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gQ2xpY2sgY2FtZXJhIGJ1dHRvblxuICAgICAgY29uc3QgY2FtZXJhQnV0dG9uID0gc2NyZWVuLmdldEJ5Um9sZSgnYnV0dG9uJywgeyBuYW1lOiAvY2FtZXJhIGNhcHR1cmUgYnV0dG9uL2kgfSlcbiAgICAgIGF3YWl0IHVzZXIuY2xpY2soY2FtZXJhQnV0dG9uKVxuICAgICAgXG4gICAgICAvLyBTaG91bGQgc2hvdyBjb21wcmVzc2lvbiBlcnJvclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9Zb3VyIGltYWdlIGlzIHN0aWxsIHRvbyBsYXJnZSBhZnRlciBjb21wcmVzc2lvbi8pKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59KVxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZmlsZVRvQmFzZTY0IiwiZm4iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImNvbXByZXNzQmFzZTY0IiwiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIk1vY2tJbWFnZSIsInNyYyIsImFsdCIsIm9uTG9hZCIsInByb3BzIiwiUmVhY3QiLCJ1c2VFZmZlY3QiLCJzZXRUaW1lb3V0IiwiaW1nIiwiU2F1Y3lUaWNrZXIiLCJkaXYiLCJkYXRhLXRlc3RpZCIsIkhlcm9JbWFnZVdpdGhCdXR0b24iLCJvdmVybGF5QnV0dG9uIiwiY2xhc3NOYW1lIiwiZGlzYWJsZWQiLCJidXR0b24iLCJvbkNsaWNrIiwic3R5bGUiLCJsZWZ0IiwicG9zaXRpb24iLCJsZWZ0UGVyY2VudCIsInRvcCIsInRvcFBlcmNlbnQiLCJ0cmFuc2Zvcm0iLCJiYWNrZ3JvdW5kIiwiYm9yZGVyIiwiYm94U2hhZG93IiwiYXJpYS1sYWJlbCIsIlBvbGFyb2lkUGhvdG9HZW5lcmF0b3IiLCJpc0dlbmVyYXRpbmciLCJvbkdlbmVyYXRpb25TdGFydCIsIm9uR2VuZXJhdGlvbkNvbXBsZXRlIiwib25DbG9zZSIsIm9uUmV0cnkiLCJnZW5lcmF0ZWRJbWFnZSIsImhhc0Vycm9yIiwiaDIiLCJwIiwiQnJ1dGFsaXNtQ2FyZCIsInRpdGxlIiwib25JbWFnZVVwbG9hZCIsIm9uRmlsZVVwbG9hZCIsImltYWdlVXJsIiwiaXNVcGxvYWRpbmciLCJlcnJvciIsIm9uRXJyb3JDbGljayIsIm9uVXBsb2FkQ2xpY2siLCJjaGlsZHJlbiIsImgzIiwiaW5wdXQiLCJ0eXBlIiwiYWNjZXB0Iiwib25DaGFuZ2UiLCJlIiwiZmlsZSIsInRhcmdldCIsImZpbGVzIiwiZGlzcGxheSIsInVzZXIiLCJ1c2VyRXZlbnQiLCJzZXR1cCIsImdsb2JhbCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImZldGNoIiwib3JpZ2luYWxMb2ciLCJjb25zb2xlIiwibG9nIiwib3JpZ2luYWxFcnJvciIsImJlZm9yZUFsbCIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm9rIiwianNvbiIsImltZ19nZW5lcmF0ZWQiLCJpdCIsImNvbnNvbGVTcHkiLCJzcHlPbiIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIm9yaWdpbmFsSW1hZ2UiLCJJbWFnZSIsIm9ubG9hZENhbGxiYWNrIiwib25sb2FkIiwiY2FsbGJhY2siLCJvbmVycm9yIiwid2lkdGgiLCJoZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbmRlciIsIlN1c0ZpdFBhZ2UiLCJmaWxlSW5wdXRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidXNlckZpbGVJbnB1dCIsInVzZXJNb2NrRmlsZSIsIkZpbGUiLCJhY3QiLCJmaXJlRXZlbnQiLCJjaGFuZ2UiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm9iamVjdENvbnRhaW5pbmciLCJ1c2VySW1hZ2VGaWxlIiwiYW55IiwiU3RyaW5nIiwibW9ja1Jlc3RvcmUiLCJtb2NrQ29udGV4dCIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIm1vY2tDYW52YXMiLCJnZXRDb250ZXh0IiwidG9EYXRhVVJMIiwib3JpZ2luYWxDcmVhdGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsInRhZ05hbWUiLCJjYWxsIiwidG9IYXZlQmVlbkNhbGxlZCIsInJlcXVpcmUiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsImNvbnNvbGVFcnJvclNweSIsImFwcGFyZWxGaWxlSW5wdXQiLCJhcHBhcmVsTW9ja0ZpbGUiLCJjYW1lcmFCdXR0b24iLCJzY3JlZW4iLCJnZXRCeVJvbGUiLCJjbGljayIsIndhaXRGb3IiLCJnZXRCeVRleHQiLCJ0b0JlSW5UaGVEb2N1bWVudCIsInRlc3RMb2dJbWFnZURpbWVuc2lvbnMiLCJjYXJkTmFtZSIsIm5vdCIsIk9iamVjdCIsInRvQmVEZWZpbmVkIl0sIm1hcHBpbmdzIjoiO0FBV0EsNkJBQTZCO0FBQzdCQSxLQUFLQyxJQUFJLENBQUMsaUJBQWlCLElBQU8sQ0FBQTtRQUNoQ0MsY0FBY0YsS0FBS0csRUFBRSxHQUFHQyxpQkFBaUIsQ0FBQztRQUMxQ0MsZ0JBQWdCTCxLQUFLRyxFQUFFLEdBQUdDLGlCQUFpQixDQUFDO1FBQzVDRSx3QkFBd0IsTUFBTUEsK0JBQStCQztZQUMzREMsWUFBWUMsT0FBZSxDQUFFO2dCQUMzQixLQUFLLENBQUNBO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1lBQ2Q7UUFDRjtJQUNGLENBQUE7QUFrQkEsK0JBQStCO0FBQy9CVixLQUFLQyxJQUFJLENBQUMsY0FBYztJQUN0QixPQUFPLFNBQVNVLFVBQVUsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxPQUFZO1FBQzNEQyxjQUFLLENBQUNDLFNBQVMsQ0FBQztZQUNkLElBQUlILFFBQVE7Z0JBQ1ZJLFdBQVcsSUFBTUosVUFBVTtZQUM3QjtRQUNGLEdBQUc7WUFBQ0E7U0FBTztRQUVYLHFCQUFPLHFCQUFDSztZQUFJUCxLQUFLQTtZQUFLQyxLQUFLQTtZQUFNLEdBQUdFLEtBQUs7O0lBQzNDO0FBQ0Y7QUFFQSw2QkFBNkI7QUFDN0JmLEtBQUtDLElBQUksQ0FBQyxnQ0FBZ0MsSUFBTyxDQUFBO1FBQy9DbUIsYUFBYSxrQkFBTSxxQkFBQ0M7Z0JBQUlDLGVBQVk7MEJB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