{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/mutations/useTryonMutation.ts"],"sourcesContent":["'use client';\n\n// Try-On Mutation Hook\n// React Query mutation hook for handling try-on API calls with comprehensive error handling\n\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useCallback, useMemo, useEffect } from 'react';\nimport type {\n  TryonMutationVariables,\n  TryonMutationVariablesWithFiles,\n  TryonMutationResponse,\n  TryonMutationError,\n  TryonMutationContext,\n  UseTryonMutationReturn,\n  UseTryonMutationConfig\n} from '../types/tryon.types';\nimport {\n  processImageForTryon,\n  ImageProcessingError,\n  ImageDimensionError,\n  type ImageProcessingOptions\n} from '../utils/imageProcessing';\nimport {\n  FileTypeNotSupportedError,\n  FileTooLargeError,\n  CompressionFailedError\n} from '../../utils/image';\nimport {\n  classifyTryonError,\n  logAndClassifyError,\n  isErrorRetryable as isErrorRetryableFromClassification\n} from '../utils/errorHandling';\nimport {\n  getOptimisticUpdatesManager,\n  OptimisticUpdatesManager\n} from '../utils/optimisticUpdates';\nimport {\n  invalidateCacheAfterMutation\n} from '../utils/cacheInvalidation';\n\n/**\n * API endpoint for try-on requests\n */\nconst TRYON_API_ENDPOINT = '/api/tryon';\n\n/**\n * Default configuration for the try-on mutation\n */\nconst DEFAULT_CONFIG: Required<Pick<UseTryonMutationConfig, 'enableRetry' | 'maxRetries' | 'initialRetryDelay' | 'enableOptimisticUpdates'>> = {\n  enableRetry: true,\n  maxRetries: 3,\n  initialRetryDelay: 1000,\n  enableOptimisticUpdates: false\n};\n\n/**\n * Mutation function that calls the try-on API\n */\nasync function tryonMutationFn(variables: TryonMutationVariables): Promise<TryonMutationResponse> {\n  const { modelImage, apparelImages, options } = variables;\n  \n  // Prepare request payload\n  const payload = {\n    modelImage,\n    apparelImages,\n    ...(options?.metadata && { metadata: options.metadata })\n  };\n\n  // Configure request options\n  const requestInit: RequestInit = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(payload),\n  };\n\n  // Add timeout if specified\n  if (options?.timeout) {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), options.timeout);\n    requestInit.signal = controller.signal;\n    \n    try {\n      const response = await fetch(TRYON_API_ENDPOINT, requestInit);\n      clearTimeout(timeoutId);\n      return handleApiResponse(response);\n    } catch (error) {\n      clearTimeout(timeoutId);\n      throw error;\n    }\n  }\n\n  // Standard request without timeout\n  const response = await fetch(TRYON_API_ENDPOINT, requestInit);\n  return handleApiResponse(response);\n}\n\n/**\n * Handle API response and convert to appropriate format\n */\nasync function handleApiResponse(response: Response): Promise<TryonMutationResponse> {\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    const error: TryonMutationError = {\n      error: errorData.error || `HTTP ${response.status}: ${response.statusText}`,\n      details: errorData.details,\n      code: errorData.code,\n      status: response.status,\n      retryable: response.status >= 500 || response.status === 408 || response.status === 429\n    };\n    throw error;\n  }\n\n  const data = await response.json();\n  \n  // Validate response structure\n  if (!data.img_generated) {\n    throw new Error('Invalid API response: missing img_generated field');\n  }\n\n  return {\n    img_generated: data.img_generated,\n    metadata: data.metadata\n  };\n}\n\n/**\n * Determine if an error is retryable using comprehensive classification\n */\nfunction isRetryableError(error: unknown): boolean {\n  // First check if error has explicit retryable property\n  if (error && typeof error === 'object' && 'retryable' in error) {\n    return Boolean(error.retryable);\n  }\n  \n  // Use comprehensive error classification\n  return isErrorRetryableFromClassification(error);\n}\n\n/**\n * Process image inputs if they are File objects\n */\nasync function processImageInputs(\n  variables: TryonMutationVariables | TryonMutationVariablesWithFiles,\n  imageProcessingOptions?: ImageProcessingOptions\n): Promise<{\n  processedVariables: TryonMutationVariables;\n  imageProcessingResults?: {\n    modelImageResult?: import('../utils/imageProcessing').ImageProcessingResult;\n    apparelImageResults?: import('../utils/imageProcessing').ImageProcessingResult[];\n    totalProcessingTime: number;\n  };\n}> {\n  const startTime = Date.now();\n  \n  // Check if we have File objects to process\n  const hasFileInputs = variables.modelImage instanceof File || \n    variables.apparelImages.some(img => img instanceof File);\n  \n  if (!hasFileInputs) {\n    // All inputs are already base64 strings\n    return {\n      processedVariables: variables as TryonMutationVariables\n    };\n  }\n  \n  try {\n    let modelImageResult: import('../utils/imageProcessing').ImageProcessingResult | undefined;\n    const apparelImageResults: import('../utils/imageProcessing').ImageProcessingResult[] = [];\n    let processedModelImage: string;\n    const processedApparelImages: string[] = [];\n    \n    // Process model image if it's a File\n    if (variables.modelImage instanceof File) {\n      const processedImage = await processImageForTryon(variables.modelImage, imageProcessingOptions);\n      modelImageResult = processedImage;\n      processedModelImage = processedImage.processedImage;\n    } else {\n      processedModelImage = variables.modelImage;\n    }\n    \n    // Process apparel images\n    for (let i = 0; i < variables.apparelImages.length; i++) {\n      const image = variables.apparelImages[i];\n      if (image instanceof File) {\n        const processedImage = await processImageForTryon(image, imageProcessingOptions);\n        apparelImageResults.push(processedImage);\n        processedApparelImages.push(processedImage.processedImage);\n      } else {\n        processedApparelImages.push(image);\n      }\n    }\n    \n    const totalProcessingTime = Date.now() - startTime;\n    \n    return {\n      processedVariables: {\n        modelImage: processedModelImage,\n        apparelImages: processedApparelImages,\n        options: variables.options\n      },\n      imageProcessingResults: {\n        modelImageResult,\n        apparelImageResults: apparelImageResults.length > 0 ? apparelImageResults : undefined,\n        totalProcessingTime\n      }\n    };\n  } catch (error) {\n    // Re-throw known image processing errors\n    if (error instanceof FileTypeNotSupportedError ||\n        error instanceof FileTooLargeError ||\n        error instanceof CompressionFailedError ||\n        error instanceof ImageProcessingError ||\n        error instanceof ImageDimensionError) {\n      throw error;\n    }\n    \n    // Wrap unknown errors\n    throw new ImageProcessingError(\n      'Unexpected error during image processing',\n      error instanceof Error ? error : new Error(String(error))\n    );\n  }\n}\n\n/**\n * Create mutation context for lifecycle tracking\n */\nfunction createMutationContext(\n  variables: TryonMutationVariables,\n  retryCount = 0,\n  previousError?: Error,\n  imageProcessingResults?: {\n    modelImageResult?: import('../utils/imageProcessing').ImageProcessingResult;\n    apparelImageResults?: import('../utils/imageProcessing').ImageProcessingResult[];\n    totalProcessingTime: number;\n  }\n): TryonMutationContext {\n  return {\n    variables,\n    startTime: Date.now(),\n    retryCount,\n    previousError,\n    imageProcessingResults\n  };\n}\n\n/**\n * React Query mutation hook for try-on functionality\n * \n * @param config - Optional configuration for the mutation\n * @returns UseTryonMutationReturn object with mutation state and functions\n */\nexport function useTryonMutation(config: UseTryonMutationConfig = {}): UseTryonMutationReturn {\n  const queryClient = useQueryClient();\n  \n  // Merge configuration with defaults\n  const mergedConfig = useMemo(() => ({\n    ...DEFAULT_CONFIG,\n    ...config\n  }), [config]);\n\n  // Get optimistic updates manager instance\n  const optimisticManager = useMemo(() => {\n    try {\n      return getOptimisticUpdatesManager();\n    } catch {\n      // Initialize if not already initialized\n      return new OptimisticUpdatesManager(queryClient);\n    }\n  }, [queryClient]);\n\n  // Track active optimistic updates\n  const activeOptimisticUpdates = useMemo(() => new Map<string, string>(), []);\n\n  // Define lifecycle callbacks with useCallback\n  const onMutateCallback = useCallback(async (variables: TryonMutationVariables | TryonMutationVariablesWithFiles) => {\n    try {\n      // Extract image processing options from config and variables (variables take precedence)\n      const configOptions = mergedConfig.imageProcessing ? {\n        targetWidth: mergedConfig.imageProcessing.targetWidth,\n        targetHeight: mergedConfig.imageProcessing.targetHeight,\n        maxSizeKB: mergedConfig.imageProcessing.maxSizeKB,\n        quality: mergedConfig.imageProcessing.compressionQuality,\n        preserveAspectRatio: mergedConfig.imageProcessing.preserveAspectRatio\n      } : undefined;\n      \n      const variableOptions = variables.options?.imageProcessing ? {\n        targetWidth: variables.options.imageProcessing.targetWidth,\n        targetHeight: variables.options.imageProcessing.targetHeight,\n        maxSizeKB: variables.options.imageProcessing.maxSizeKB,\n        quality: variables.options.imageProcessing.compressionQuality,\n        preserveAspectRatio: variables.options.imageProcessing.preserveAspectRatio\n      } : undefined;\n      \n      // Merge options with variable options taking precedence\n      const imageProcessingOptions: ImageProcessingOptions | undefined = \n        configOptions || variableOptions ? {\n          ...configOptions,\n          ...variableOptions\n        } : undefined;\n      \n      // Process images if needed\n      const { processedVariables, imageProcessingResults } = await processImageInputs(\n        variables, \n        imageProcessingOptions\n      );\n      \n      // Create context with processed variables and image processing results\n      const context = createMutationContext(\n        processedVariables,\n        0,\n        undefined,\n        imageProcessingResults\n      );\n\n      // Start optimistic updates if enabled\n      let optimisticId: string | undefined;\n      if (mergedConfig.enableOptimisticUpdates) {\n        try {\n          const optimisticContext = optimisticManager.startOptimisticUpdate(\n            processedVariables,\n            mergedConfig.optimisticConfig\n          );\n          optimisticId = optimisticContext.optimisticId;\n          if (optimisticId) {\n            activeOptimisticUpdates.set(processedVariables.modelImage + processedVariables.apparelImages.join(''), optimisticId);\n          }\n          \n          // Add optimistic ID to context for tracking\n          context.optimisticId = optimisticId;\n        } catch (error) {\n          console.warn('Failed to start optimistic updates:', error);\n        }\n      }\n      \n      // Call user-provided onMutate if available\n      if (mergedConfig.onMutate) {\n        const userContext = await mergedConfig.onMutate(processedVariables);\n        if (userContext) {\n          return { ...context, ...userContext };\n        }\n      }\n      \n      return context;\n    } catch (error) {\n      // If image processing fails, still allow user's onMutate to be called\n      // The user's onMutate can decide how to handle the failure\n      let context;\n      \n      const hasFileInputs = variables.modelImage instanceof File || \n        variables.apparelImages.some(img => img instanceof File);\n      \n      if (hasFileInputs) {\n        // Create context manually for File inputs since createMutationContext expects strings\n        context = {\n          variables: variables as TryonMutationVariablesWithFiles,\n          startTime: Date.now(),\n          retryCount: 0\n        } as TryonMutationContext;\n      } else {\n        // All inputs are base64 strings, safe to cast\n        context = createMutationContext(variables as TryonMutationVariables);\n      }\n      \n      if (mergedConfig.onMutate && !hasFileInputs) {\n        try {\n          // onMutate expects TryonMutationVariables (strings only), so only call if no File inputs\n          const userContext = await mergedConfig.onMutate(variables as TryonMutationVariables);\n          if (userContext) {\n            context = { ...context, ...userContext };\n          }\n        } catch {\n          // If onMutate also fails, prefer the original processing error\n          console.warn('onMutate failed during error handling');\n        }\n      }\n      \n      // Always re-throw the error so mutation fails appropriately\n      throw error;\n    }\n  }, [mergedConfig, optimisticManager, activeOptimisticUpdates]);\n\n  const onSuccessCallback = useCallback(async (\n    data: TryonMutationResponse,\n    variables: TryonMutationVariables,\n    context: TryonMutationContext\n  ) => {\n    // Complete optimistic updates if they were started\n    const optimisticId = context.optimisticId;\n    if (optimisticId && mergedConfig.enableOptimisticUpdates) {\n      try {\n        optimisticManager.completeOptimisticUpdate(optimisticId, data, context);\n        \n        // Clean up tracking\n        const trackingKey = variables.modelImage + variables.apparelImages.join('');\n        activeOptimisticUpdates.delete(trackingKey);\n      } catch (error) {\n        console.warn('Failed to complete optimistic update:', error);\n      }\n    }\n\n    // Advanced cache invalidation with configurable strategies\n    try {\n      await invalidateCacheAfterMutation(\n        queryClient,\n        data,\n        variables,\n        context,\n        mergedConfig.cacheInvalidationConfig\n      );\n    } catch (error) {\n      console.warn('Failed to invalidate cache after mutation:', error);\n      \n      // Fallback to basic invalidation\n      await Promise.allSettled([\n        queryClient.invalidateQueries({ \n          queryKey: ['tryon-history'],\n          exact: false \n        }),\n        queryClient.invalidateQueries({ \n          queryKey: ['user-data'],\n          exact: false \n        }),\n        queryClient.invalidateQueries({ \n          queryKey: ['tryon-stats'],\n          exact: false \n        })\n      ]);\n    }\n    \n    // Call user-provided onSuccess with processed variables\n    if (mergedConfig.onSuccess) {\n      mergedConfig.onSuccess(data, context.variables, context);\n    }\n  }, [mergedConfig, queryClient, optimisticManager, activeOptimisticUpdates]);\n\n  const onErrorCallback = useCallback((\n    error: unknown,\n    variables: TryonMutationVariables,\n    context: TryonMutationContext | undefined\n  ) => {\n    // Rollback optimistic updates if they were started\n    const optimisticId = context?.optimisticId;\n    if (optimisticId && mergedConfig.enableOptimisticUpdates) {\n      try {\n        optimisticManager.rollbackOptimisticUpdate(optimisticId, error);\n        \n        // Clean up tracking\n        const trackingKey = variables.modelImage + variables.apparelImages.join('');\n        activeOptimisticUpdates.delete(trackingKey);\n      } catch (rollbackError) {\n        console.warn('Failed to rollback optimistic update:', rollbackError);\n      }\n    }\n\n    // Classify and log the error comprehensively\n    const classifiedError = logAndClassifyError(error, {\n      mutationVariables: variables,\n      mutationContext: context,\n      timestamp: new Date().toISOString()\n    });\n\n    // Format error for mutation system compatibility\n    const formattedError: TryonMutationError = {\n      error: classifiedError.userMessage,\n      details: classifiedError.technicalMessage,\n      code: classifiedError.errorCode,\n      retryable: classifiedError.retryable,\n      // Add classified error information\n      category: classifiedError.category,\n      severity: classifiedError.severity,\n      recoveryActions: classifiedError.recoveryActions\n    };\n\n    // Call user-provided onError with enhanced error information\n    if (mergedConfig.onError && context) {\n      mergedConfig.onError(formattedError, variables, context);\n    }\n  }, [mergedConfig, optimisticManager, activeOptimisticUpdates]);\n\n  const onSettledCallback = useCallback((\n    data: TryonMutationResponse | undefined,\n    error: unknown,\n    variables: TryonMutationVariables,\n    context: TryonMutationContext | undefined\n  ) => {\n    // Format error with comprehensive classification if error exists\n    let formattedError: TryonMutationError | null = null;\n    \n    if (error) {\n      const classifiedError = classifyTryonError(error, {\n        mutationVariables: variables,\n        mutationContext: context,\n        settled: true,\n        timestamp: new Date().toISOString()\n      });\n\n      formattedError = {\n        error: classifiedError.userMessage,\n        details: classifiedError.technicalMessage,\n        code: classifiedError.errorCode,\n        retryable: classifiedError.retryable,\n        category: classifiedError.category,\n        severity: classifiedError.severity,\n        recoveryActions: classifiedError.recoveryActions\n      };\n    }\n\n    // Final cleanup of any remaining optimistic updates\n    if (context) {\n      const optimisticId = context.optimisticId;\n      if (optimisticId) {\n        const trackingKey = variables.modelImage + variables.apparelImages.join('');\n        activeOptimisticUpdates.delete(trackingKey);\n      }\n    }\n\n    // Call user-provided onSettled\n    if (mergedConfig.onSettled && context) {\n      mergedConfig.onSettled(data, formattedError, variables, context);\n    }\n  }, [mergedConfig, activeOptimisticUpdates]);\n\n  // Cleanup effect for optimistic updates on unmount\n  useEffect(() => {\n    return () => {\n      // Rollback any remaining optimistic updates when component unmounts\n      activeOptimisticUpdates.forEach((optimisticId) => {\n        try {\n          optimisticManager.rollbackOptimisticUpdate(optimisticId, new Error('Component unmounted'));\n        } catch (error) {\n          console.warn('Failed to cleanup optimistic update on unmount:', error);\n        }\n      });\n      activeOptimisticUpdates.clear();\n    };\n  }, [optimisticManager, activeOptimisticUpdates]);\n\n  // Mutation configuration\n  const mutationConfig = useMemo(() => ({\n    mutationFn: tryonMutationFn,\n    \n    // Custom retry logic\n    retry: mergedConfig.enableRetry ? (failureCount: number, error: unknown) => {\n      if (failureCount >= mergedConfig.maxRetries) {\n        return false;\n      }\n      return isRetryableError(error);\n    } : false,\n    \n    // Exponential backoff delay\n    retryDelay: (attemptIndex: number) => {\n      return mergedConfig.initialRetryDelay * Math.pow(2, attemptIndex);\n    },\n\n    // Lifecycle callbacks\n    onMutate: onMutateCallback,\n    onSuccess: onSuccessCallback,\n    onError: onErrorCallback,\n    onSettled: onSettledCallback\n  }), [mergedConfig, onMutateCallback, onSuccessCallback, onErrorCallback, onSettledCallback]);\n\n  // Use React Query mutation\n  const mutation = useMutation(mutationConfig);\n\n  // Return hook interface\n  return useMemo<UseTryonMutationReturn>(() => ({\n    mutate: mutation.mutate,\n    mutateAsync: mutation.mutateAsync,\n    data: mutation.data,\n    error: mutation.error as TryonMutationError | null,\n    isLoading: mutation.isPending,\n    isSuccess: mutation.isSuccess,\n    isError: mutation.isError,\n    isIdle: mutation.isIdle,\n    status: mutation.status === 'pending' ? 'loading' : mutation.status,\n    reset: mutation.reset,\n    context: mutation.context as TryonMutationContext | undefined\n  }), [mutation]);\n}"],"names":["useTryonMutation","TRYON_API_ENDPOINT","DEFAULT_CONFIG","enableRetry","maxRetries","initialRetryDelay","enableOptimisticUpdates","tryonMutationFn","variables","modelImage","apparelImages","options","payload","metadata","requestInit","method","headers","body","JSON","stringify","timeout","controller","AbortController","timeoutId","setTimeout","abort","signal","response","fetch","clearTimeout","handleApiResponse","error","ok","errorData","json","catch","status","statusText","details","code","retryable","data","img_generated","Error","isRetryableError","Boolean","isErrorRetryableFromClassification","processImageInputs","imageProcessingOptions","startTime","Date","now","hasFileInputs","File","some","img","processedVariables","modelImageResult","apparelImageResults","processedModelImage","processedApparelImages","processedImage","processImageForTryon","i","length","image","push","totalProcessingTime","imageProcessingResults","undefined","FileTypeNotSupportedError","FileTooLargeError","CompressionFailedError","ImageProcessingError","ImageDimensionError","String","createMutationContext","retryCount","previousError","config","queryClient","useQueryClient","mergedConfig","useMemo","optimisticManager","getOptimisticUpdatesManager","OptimisticUpdatesManager","activeOptimisticUpdates","Map","onMutateCallback","useCallback","configOptions","imageProcessing","targetWidth","targetHeight","maxSizeKB","quality","compressionQuality","preserveAspectRatio","variableOptions","context","optimisticId","optimisticContext","startOptimisticUpdate","optimisticConfig","set","join","console","warn","onMutate","userContext","onSuccessCallback","completeOptimisticUpdate","trackingKey","delete","invalidateCacheAfterMutation","cacheInvalidationConfig","Promise","allSettled","invalidateQueries","queryKey","exact","onSuccess","onErrorCallback","rollbackOptimisticUpdate","rollbackError","classifiedError","logAndClassifyError","mutationVariables","mutationContext","timestamp","toISOString","formattedError","userMessage","technicalMessage","errorCode","category","severity","recoveryActions","onError","onSettledCallback","classifyTryonError","settled","onSettled","useEffect","forEach","clear","mutationConfig","mutationFn","retry","failureCount","retryDelay","attemptIndex","Math","pow","mutation","useMutation","mutate","mutateAsync","isLoading","isPending","isSuccess","isError","isIdle","reset"],"mappings":"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"}