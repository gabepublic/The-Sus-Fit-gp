{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/hooks/useStickerManagement.ts"],"sourcesContent":["'use client';\n\n// Sticker Management React Hooks\n// React hooks for managing stickers on canvas with interaction support\n\nimport { useCallback, useRef, useState, useEffect } from 'react';\nimport { useManagedCanvas, type ManagedCanvas } from '../providers/CanvasProvider';\nimport {\n  StickerManager,\n  createStickerManager,\n  type Sticker,\n  type StickerConfig,\n  type StickerTransform,\n  type GridSnapConfig,\n  type CollisionResult,\n  StickerAnchor,\n  DEFAULT_STICKER_CONFIG\n} from '../utils/stickerPlacement';\n\n/**\n * Sticker interaction event handlers\n */\nexport interface StickerInteractionHandlers {\n  onStickerSelect?: (stickerId: string | null) => void;\n  onStickerMove?: (stickerId: string, x: number, y: number) => void;\n  onStickerScale?: (stickerId: string, scale: number) => void;\n  onStickerRotate?: (stickerId: string, rotation: number) => void;\n  onStickerCollision?: (result: CollisionResult) => void;\n}\n\n/**\n * Mouse/touch interaction state\n */\ninterface InteractionState {\n  isInteracting: boolean;\n  mode: 'none' | 'drag' | 'scale' | 'rotate';\n  startX: number;\n  startY: number;\n  currentX: number;\n  currentY: number;\n  targetStickerId: string | null;\n  initialTransform?: StickerTransform;\n}\n\n/**\n * Hook for managing stickers on canvas\n */\nexport function useStickerManagement(\n  canvasWidth: number,\n  canvasHeight: number,\n  canvasId?: string,\n  handlers?: StickerInteractionHandlers\n): {\n  canvas: ManagedCanvas;\n  manager: StickerManager;\n  stickers: Sticker[];\n  selectedStickerId: string | null;\n  isInteracting: boolean;\n  addSticker: (config: Omit<StickerConfig, 'id'>) => Promise<string>;\n  removeSticker: (id: string) => boolean;\n  updateSticker: (id: string, updates: Partial<StickerConfig>) => boolean;\n  selectSticker: (id: string | null) => void;\n  moveSticker: (id: string, x: number, y: number) => boolean;\n  scaleSticker: (id: string, scale: number) => boolean;\n  rotateSticker: (id: string, rotation: number) => boolean;\n  flipSticker: (id: string, flipX?: boolean, flipY?: boolean) => boolean;\n  duplicateSticker: (id: string) => Promise<string | null>;\n  bringToFront: (id: string) => boolean;\n  sendToBack: (id: string) => boolean;\n  checkCollisions: (excludeId?: string) => CollisionResult;\n  renderAll: () => void;\n  clearAll: () => void;\n  exportStickers: () => StickerConfig[];\n  importStickers: (stickers: StickerConfig[]) => Promise<string[]>;\n  setGridConfig: (config: Partial<GridSnapConfig>) => void;\n  getGridConfig: () => GridSnapConfig;\n} {\n  const canvas = useManagedCanvas(canvasWidth, canvasHeight, canvasId);\n  const managerRef = useRef<StickerManager>(createStickerManager(canvas));\n  const [stickers, setStickers] = useState<Sticker[]>([]);\n  const [selectedStickerId, setSelectedStickerId] = useState<string | null>(null);\n  const [interactionState, setInteractionState] = useState<InteractionState>({\n    isInteracting: false,\n    mode: 'none',\n    startX: 0,\n    startY: 0,\n    currentX: 0,\n    currentY: 0,\n    targetStickerId: null\n  });\n\n  const refreshStickers = useCallback(() => {\n    setStickers(managerRef.current.getAllStickers());\n  }, []);\n\n  const addSticker = useCallback(async (config: Omit<StickerConfig, 'id'>): Promise<string> => {\n    const id = await managerRef.current.addSticker(config);\n    refreshStickers();\n    handlers?.onStickerSelect?.(id);\n    return id;\n  }, [refreshStickers, handlers]);\n\n  const removeSticker = useCallback((id: string): boolean => {\n    const success = managerRef.current.removeSticker(id);\n    if (success) {\n      refreshStickers();\n      if (selectedStickerId === id) {\n        setSelectedStickerId(null);\n        handlers?.onStickerSelect?.(null);\n      }\n    }\n    return success;\n  }, [refreshStickers, selectedStickerId, handlers]);\n\n  const updateSticker = useCallback((id: string, updates: Partial<StickerConfig>): boolean => {\n    const success = managerRef.current.updateSticker(id, updates);\n    if (success) {\n      refreshStickers();\n    }\n    return success;\n  }, [refreshStickers]);\n\n  const selectSticker = useCallback((id: string | null) => {\n    managerRef.current.selectSticker(id);\n    setSelectedStickerId(id);\n    refreshStickers();\n    handlers?.onStickerSelect?.(id);\n  }, [refreshStickers, handlers]);\n\n  const moveSticker = useCallback((id: string, x: number, y: number): boolean => {\n    const success = managerRef.current.moveStickerTo(id, x, y);\n    if (success) {\n      refreshStickers();\n      handlers?.onStickerMove?.(id, x, y);\n      \n      // Check for collisions\n      const collisions = managerRef.current.checkCollisions(id);\n      if (collisions.hasCollision) {\n        handlers?.onStickerCollision?.(collisions);\n      }\n    }\n    return success;\n  }, [refreshStickers, handlers]);\n\n  const scaleSticker = useCallback((id: string, scale: number): boolean => {\n    const success = managerRef.current.scaleSticker(id, scale);\n    if (success) {\n      refreshStickers();\n      handlers?.onStickerScale?.(id, scale);\n    }\n    return success;\n  }, [refreshStickers, handlers]);\n\n  const rotateSticker = useCallback((id: string, rotation: number): boolean => {\n    const success = managerRef.current.rotateSticker(id, rotation);\n    if (success) {\n      refreshStickers();\n      handlers?.onStickerRotate?.(id, rotation);\n    }\n    return success;\n  }, [refreshStickers, handlers]);\n\n  const flipSticker = useCallback((id: string, flipX?: boolean, flipY?: boolean): boolean => {\n    const success = managerRef.current.flipSticker(id, flipX, flipY);\n    if (success) {\n      refreshStickers();\n    }\n    return success;\n  }, [refreshStickers]);\n\n  const duplicateSticker = useCallback(async (id: string): Promise<string | null> => {\n    const sticker = managerRef.current.getSticker(id);\n    if (!sticker) return null;\n\n    // Create duplicate with offset position\n    const duplicateConfig = {\n      ...sticker,\n      transform: {\n        ...sticker.transform,\n        x: sticker.transform.x + 20,\n        y: sticker.transform.y + 20\n      }\n    };\n\n    try {\n      const newId = await addSticker(duplicateConfig);\n      selectSticker(newId);\n      return newId;\n    } catch (error) {\n      console.error('Failed to duplicate sticker:', error);\n      return null;\n    }\n  }, [addSticker, selectSticker]);\n\n  const bringToFront = useCallback((id: string): boolean => {\n    const success = managerRef.current.bringToFront(id);\n    if (success) {\n      refreshStickers();\n    }\n    return success;\n  }, [refreshStickers]);\n\n  const sendToBack = useCallback((id: string): boolean => {\n    const success = managerRef.current.sendToBack(id);\n    if (success) {\n      refreshStickers();\n    }\n    return success;\n  }, [refreshStickers]);\n\n  const checkCollisions = useCallback((excludeId?: string): CollisionResult => {\n    return managerRef.current.checkCollisions(excludeId);\n  }, []);\n\n  const renderAll = useCallback(() => {\n    managerRef.current.renderAllStickers();\n  }, []);\n\n  const clearAll = useCallback(() => {\n    managerRef.current.clearAllStickers();\n    setStickers([]);\n    setSelectedStickerId(null);\n    handlers?.onStickerSelect?.(null);\n  }, [handlers]);\n\n  const exportStickers = useCallback((): StickerConfig[] => {\n    return managerRef.current.exportStickers();\n  }, []);\n\n  const importStickers = useCallback(async (stickerConfigs: StickerConfig[]): Promise<string[]> => {\n    const importedIds = await managerRef.current.importStickers(stickerConfigs);\n    refreshStickers();\n    return importedIds;\n  }, [refreshStickers]);\n\n  const setGridConfig = useCallback((config: Partial<GridSnapConfig>) => {\n    managerRef.current.setGridConfig(config);\n  }, []);\n\n  const getGridConfig = useCallback((): GridSnapConfig => {\n    return managerRef.current.getGridConfig();\n  }, []);\n\n  // Auto-render when stickers change\n  useEffect(() => {\n    renderAll();\n  }, [stickers, renderAll]);\n\n  return {\n    canvas,\n    manager: managerRef.current,\n    stickers,\n    selectedStickerId,\n    isInteracting: interactionState.isInteracting,\n    addSticker,\n    removeSticker,\n    updateSticker,\n    selectSticker,\n    moveSticker,\n    scaleSticker,\n    rotateSticker,\n    flipSticker,\n    duplicateSticker,\n    bringToFront,\n    sendToBack,\n    checkCollisions,\n    renderAll,\n    clearAll,\n    exportStickers,\n    importStickers,\n    setGridConfig,\n    getGridConfig\n  };\n}\n\n/**\n * Hook for handling mouse/touch interactions with stickers\n */\nexport function useStickerInteraction(\n  canvas: HTMLCanvasElement,\n  manager: StickerManager,\n  onStickerSelect?: (id: string | null) => void,\n  onStickerUpdate?: () => void\n): {\n  isInteracting: boolean;\n  startInteraction: (x: number, y: number, mode?: 'drag' | 'scale' | 'rotate') => void;\n  updateInteraction: (x: number, y: number) => void;\n  endInteraction: () => void;\n} {\n  const [isInteracting, setIsInteracting] = useState(false);\n  const interactionRef = useRef<InteractionState>({\n    isInteracting: false,\n    mode: 'none',\n    startX: 0,\n    startY: 0,\n    currentX: 0,\n    currentY: 0,\n    targetStickerId: null\n  });\n\n  const getCanvasCoordinates = useCallback((clientX: number, clientY: number) => {\n    const rect = canvas.getBoundingClientRect();\n    return {\n      x: clientX - rect.left,\n      y: clientY - rect.top\n    };\n  }, [canvas]);\n\n  const startInteraction = useCallback((clientX: number, clientY: number, mode: 'drag' | 'scale' | 'rotate' = 'drag') => {\n    const { x, y } = getCanvasCoordinates(clientX, clientY);\n    const stickerId = manager.getStickerAtPosition(x, y);\n    \n    if (stickerId) {\n      const sticker = manager.getSticker(stickerId);\n      if (sticker && !sticker.locked) {\n        manager.selectSticker(stickerId);\n        onStickerSelect?.(stickerId);\n        \n        interactionRef.current = {\n          isInteracting: true,\n          mode,\n          startX: x,\n          startY: y,\n          currentX: x,\n          currentY: y,\n          targetStickerId: stickerId,\n          initialTransform: { ...sticker.transform }\n        };\n        \n        setIsInteracting(true);\n      }\n    } else {\n      // Clicked on empty area, deselect\n      manager.selectSticker(null);\n      onStickerSelect?.(null);\n    }\n  }, [canvas, manager, onStickerSelect, getCanvasCoordinates]);\n\n  const updateInteraction = useCallback((clientX: number, clientY: number) => {\n    if (!interactionRef.current.isInteracting || !interactionRef.current.targetStickerId) return;\n    \n    const { x, y } = getCanvasCoordinates(clientX, clientY);\n    const state = interactionRef.current;\n    const sticker = manager.getSticker(state.targetStickerId);\n    \n    if (!sticker || !state.initialTransform) return;\n    \n    state.currentX = x;\n    state.currentY = y;\n    \n    const deltaX = x - state.startX;\n    const deltaY = y - state.startY;\n    \n    switch (state.mode) {\n      case 'drag':\n        manager.moveStickerTo(\n          state.targetStickerId,\n          state.initialTransform.x + deltaX,\n          state.initialTransform.y + deltaY\n        );\n        break;\n        \n      case 'scale':\n        // Calculate scale based on distance from center\n        const centerX = state.initialTransform.x;\n        const centerY = state.initialTransform.y;\n        const initialDistance = Math.sqrt(\n          Math.pow(state.startX - centerX, 2) + Math.pow(state.startY - centerY, 2)\n        );\n        const currentDistance = Math.sqrt(\n          Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)\n        );\n        const scaleFactor = initialDistance > 0 ? currentDistance / initialDistance : 1;\n        const newScale = state.initialTransform.scale * scaleFactor;\n        \n        manager.scaleSticker(state.targetStickerId, Math.max(0.1, Math.min(5, newScale)));\n        break;\n        \n      case 'rotate':\n        // Calculate rotation based on angle from center\n        const centerRotX = state.initialTransform.x;\n        const centerRotY = state.initialTransform.y;\n        const initialAngle = Math.atan2(state.startY - centerRotY, state.startX - centerRotX);\n        const currentAngle = Math.atan2(y - centerRotY, x - centerRotX);\n        const rotationDelta = currentAngle - initialAngle;\n        const newRotation = state.initialTransform.rotation + rotationDelta;\n        \n        manager.rotateSticker(state.targetStickerId, newRotation);\n        break;\n    }\n    \n    onStickerUpdate?.();\n  }, [canvas, manager, onStickerUpdate, getCanvasCoordinates]);\n\n  const endInteraction = useCallback(() => {\n    interactionRef.current = {\n      isInteracting: false,\n      mode: 'none',\n      startX: 0,\n      startY: 0,\n      currentX: 0,\n      currentY: 0,\n      targetStickerId: null\n    };\n    setIsInteracting(false);\n  }, []);\n\n  return {\n    isInteracting,\n    startInteraction,\n    updateInteraction,\n    endInteraction\n  };\n}\n\n/**\n * Hook for sticker library management\n */\nexport function useStickerLibrary(): {\n  categories: string[];\n  getStickersInCategory: (category: string) => StickerConfig[];\n  addStickerToLibrary: (sticker: StickerConfig, category: string) => void;\n  removeStickerFromLibrary: (stickerId: string) => void;\n  searchStickers: (query: string) => StickerConfig[];\n  getFavoriteStickers: () => StickerConfig[];\n  addToFavorites: (stickerId: string) => void;\n  removeFromFavorites: (stickerId: string) => void;\n} {\n  const [library, setLibrary] = useState<Map<string, StickerConfig[]>>(new Map());\n  const [favorites, setFavorites] = useState<Set<string>>(new Set());\n\n  const categories = Array.from(library.keys());\n\n  const getStickersInCategory = useCallback((category: string): StickerConfig[] => {\n    return library.get(category) || [];\n  }, [library]);\n\n  const addStickerToLibrary = useCallback((sticker: StickerConfig, category: string) => {\n    setLibrary(prev => {\n      const newLibrary = new Map(prev);\n      const categoryStickers = newLibrary.get(category) || [];\n      newLibrary.set(category, [...categoryStickers, sticker]);\n      return newLibrary;\n    });\n  }, []);\n\n  const removeStickerFromLibrary = useCallback((stickerId: string) => {\n    setLibrary(prev => {\n      const newLibrary = new Map();\n      prev.forEach((stickers, category) => {\n        newLibrary.set(category, stickers.filter(s => s.id !== stickerId));\n      });\n      return newLibrary;\n    });\n  }, []);\n\n  const searchStickers = useCallback((query: string): StickerConfig[] => {\n    const results: StickerConfig[] = [];\n    const lowerQuery = query.toLowerCase();\n    \n    library.forEach(stickers => {\n      stickers.forEach(sticker => {\n        if (sticker.metadata?.name?.toLowerCase().includes(lowerQuery) ||\n            sticker.metadata?.tags?.some(tag => tag.toLowerCase().includes(lowerQuery))) {\n          results.push(sticker);\n        }\n      });\n    });\n    \n    return results;\n  }, [library]);\n\n  const getFavoriteStickers = useCallback((): StickerConfig[] => {\n    const favoriteStickers: StickerConfig[] = [];\n    \n    library.forEach(stickers => {\n      stickers.forEach(sticker => {\n        if (favorites.has(sticker.id)) {\n          favoriteStickers.push(sticker);\n        }\n      });\n    });\n    \n    return favoriteStickers;\n  }, [library, favorites]);\n\n  const addToFavorites = useCallback((stickerId: string) => {\n    setFavorites(prev => new Set(prev).add(stickerId));\n  }, []);\n\n  const removeFromFavorites = useCallback((stickerId: string) => {\n    setFavorites(prev => {\n      const newFavorites = new Set(prev);\n      newFavorites.delete(stickerId);\n      return newFavorites;\n    });\n  }, []);\n\n  return {\n    categories,\n    getStickersInCategory,\n    addStickerToLibrary,\n    removeStickerFromLibrary,\n    searchStickers,\n    getFavoriteStickers,\n    addToFavorites,\n    removeFromFavorites\n  };\n}"],"names":["useStickerInteraction","useStickerLibrary","useStickerManagement","canvasWidth","canvasHeight","canvasId","handlers","canvas","useManagedCanvas","managerRef","useRef","createStickerManager","stickers","setStickers","useState","selectedStickerId","setSelectedStickerId","interactionState","setInteractionState","isInteracting","mode","startX","startY","currentX","currentY","targetStickerId","refreshStickers","useCallback","current","getAllStickers","addSticker","config","id","onStickerSelect","removeSticker","success","updateSticker","updates","selectSticker","moveSticker","x","y","moveStickerTo","onStickerMove","collisions","checkCollisions","hasCollision","onStickerCollision","scaleSticker","scale","onStickerScale","rotateSticker","rotation","onStickerRotate","flipSticker","flipX","flipY","duplicateSticker","sticker","getSticker","duplicateConfig","transform","newId","error","console","bringToFront","sendToBack","excludeId","renderAll","renderAllStickers","clearAll","clearAllStickers","exportStickers","importStickers","stickerConfigs","importedIds","setGridConfig","getGridConfig","useEffect","manager","onStickerUpdate","setIsInteracting","interactionRef","getCanvasCoordinates","clientX","clientY","rect","getBoundingClientRect","left","top","startInteraction","stickerId","getStickerAtPosition","locked","initialTransform","updateInteraction","state","deltaX","deltaY","centerX","centerY","initialDistance","Math","sqrt","pow","currentDistance","scaleFactor","newScale","max","min","centerRotX","centerRotY","initialAngle","atan2","currentAngle","rotationDelta","newRotation","endInteraction","library","setLibrary","Map","favorites","setFavorites","Set","categories","Array","from","keys","getStickersInCategory","category","get","addStickerToLibrary","prev","newLibrary","categoryStickers","set","removeStickerFromLibrary","forEach","filter","s","searchStickers","query","results","lowerQuery","toLowerCase","metadata","name","includes","tags","some","tag","push","getFavoriteStickers","favoriteStickers","has","addToFavorites","add","removeFromFavorites","newFavorites","delete"],"mappings":"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"}