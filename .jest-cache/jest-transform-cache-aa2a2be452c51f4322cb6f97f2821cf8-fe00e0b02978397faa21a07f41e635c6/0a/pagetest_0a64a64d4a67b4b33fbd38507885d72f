426616815ef18cdda93f48318abb4bd7
"use strict";
// Mock the utility functions
jest.mock('@/utils/image', ()=>({
        fileToBase64: jest.fn(),
        compressBase64: jest.fn(),
        CompressionFailedError: class CompressionFailedError extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _image = require("../../src/utils/image");
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
// Mock console methods
const mockConsoleLog = jest.spyOn(console, 'log').mockImplementation();
const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();
// Mock File constructor
global.File = jest.fn().mockImplementation((content, name, options)=>({
        name,
        size: content.length,
        type: options?.type || 'image/jpeg',
        arrayBuffer: jest.fn().mockResolvedValue(new ArrayBuffer(content.length)),
        stream: jest.fn(),
        text: jest.fn().mockResolvedValue(''),
        slice: jest.fn(),
        lastModified: Date.now()
    }));
// Mock AbortController
global.AbortController = jest.fn().mockImplementation(()=>({
        signal: 'mock-signal',
        abort: jest.fn()
    }));
// Mock setTimeout and clearTimeout
jest.useFakeTimers();
// Spy on the timer functions after fake timers are set up
const mockSetTimeout = jest.spyOn(globalThis, 'setTimeout');
const mockClearTimeout = jest.spyOn(globalThis, 'clearTimeout');
describe('handleCameraButtonClick Logic Tests', ()=>{
    let mockUserFile;
    let mockApparelFile;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Create mock files
        mockUserFile = new File([
            'user-image-content'
        ], 'user.jpg', {
            type: 'image/jpeg'
        });
        mockApparelFile = new File([
            'apparel-image-content'
        ], 'apparel.jpg', {
            type: 'image/jpeg'
        });
        _image.fileToBase64.mockResolvedValue('mock-base64-string');
        _image.compressBase64.mockResolvedValue('compressed-base64-string');
        mockFetch.mockClear();
    });
    afterEach(()=>{
        jest.clearAllTimers();
    });
    // Test the core logic function that would be extracted from handleCameraButtonClick
    const processImagesAndCallAPI = async (userFile, apparelFile)=>{
        try {
            // Process images concurrently
            const [modelB64, apparelB64] = await Promise.all([
                (0, _image.fileToBase64)(userFile),
                (0, _image.fileToBase64)(apparelFile)
            ]);
            // Compress both images
            const [compressedModel, compressedApparel] = await Promise.all([
                (0, _image.compressBase64)(modelB64, 2048),
                (0, _image.compressBase64)(apparelB64, 2048)
            ]);
            // Create AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(()=>controller.abort(), 30000);
            try {
                // Make API call
                const response = await fetch('/api/tryon', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        modelImage: compressedModel,
                        apparelImages: [
                            compressedApparel
                        ]
                    }),
                    signal: controller.signal
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API request failed: ${response.status} ${errorText}`);
                }
                const { img_generated } = await response.json();
                console.log('Successfully received generated image from API');
                return {
                    success: true,
                    img_generated
                };
            } finally{
                clearTimeout(timeoutId);
            }
        } catch (error) {
            console.error('Error in processImagesAndCallAPI:', error);
            throw error;
        }
    };
    describe('Success Path', ()=>{
        it('should successfully process images and make API call', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'generated-image-base64'
                })
            });
            // Act
            const result = await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockUserFile);
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockApparelFile);
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelImage: 'compressed-base64-string',
                    apparelImages: [
                        'compressed-base64-string'
                    ]
                }),
                signal: 'mock-signal'
            });
            expect(mockConsoleLog).toHaveBeenCalledWith('Successfully received generated image from API');
            expect(result).toEqual({
                success: true,
                img_generated: 'generated-image-base64'
            });
        });
    });
    describe('Error Handling', ()=>{
        it('should handle compression failures', async ()=>{
            // Arrange
            ;
            _image.compressBase64.mockRejectedValueOnce(new _image.CompressionFailedError('Compression failed'));
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('Compression failed');
        });
        it('should handle API request failures', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                text: jest.fn().mockResolvedValue('Bad request')
            });
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('API request failed: 400 Bad request');
        });
        it('should handle timeout errors', async ()=>{
            // Arrange
            const abortError = new Error('Request aborted');
            abortError.name = 'AbortError';
            mockFetch.mockRejectedValueOnce(abortError);
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('Request aborted');
        });
    });
    describe('Timeout Management', ()=>{
        it('should create AbortController with 30-second timeout', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(global.AbortController).toHaveBeenCalled();
            expect(mockSetTimeout).toHaveBeenCalledWith(expect.any(Function), 30000);
        });
        it('should clear timeout on successful completion', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(mockClearTimeout).toHaveBeenCalled();
        });
    });
    describe('Image Processing', ()=>{
        it('should process both images concurrently', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockUserFile);
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockApparelFile);
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
        });
        it('should use correct compression limit', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
        });
    });
    describe('API Request Format', ()=>{
        it('should send correct request body format', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelImage: 'compressed-base64-string',
                    apparelImages: [
                        'compressed-base64-string'
                    ]
                }),
                signal: 'mock-signal'
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2NvbXBvbmVudHMvcGFnZS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaWxlVG9CYXNlNjQsIGNvbXByZXNzQmFzZTY0LCBDb21wcmVzc2lvbkZhaWxlZEVycm9yIH0gZnJvbSAnQC91dGlscy9pbWFnZSdcblxuLy8gTW9jayB0aGUgdXRpbGl0eSBmdW5jdGlvbnNcbmplc3QubW9jaygnQC91dGlscy9pbWFnZScsICgpID0+ICh7XG4gIGZpbGVUb0Jhc2U2NDogamVzdC5mbigpLFxuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigpLFxuICBDb21wcmVzc2lvbkZhaWxlZEVycm9yOiBjbGFzcyBDb21wcmVzc2lvbkZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJ1xuICAgIH1cbiAgfVxufSkpXG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKVxuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBtb2NrQ29uc29sZUxvZyA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG5jb25zdCBtb2NrQ29uc29sZUVycm9yID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKVxuXG4vLyBNb2NrIEZpbGUgY29uc3RydWN0b3Jcbmdsb2JhbC5GaWxlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoY29udGVudCwgbmFtZSwgb3B0aW9ucykgPT4gKHtcbiAgbmFtZSxcbiAgc2l6ZTogY29udGVudC5sZW5ndGgsXG4gIHR5cGU6IG9wdGlvbnM/LnR5cGUgfHwgJ2ltYWdlL2pwZWcnLFxuICBhcnJheUJ1ZmZlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG5ldyBBcnJheUJ1ZmZlcihjb250ZW50Lmxlbmd0aCkpLFxuICBzdHJlYW06IGplc3QuZm4oKSxcbiAgdGV4dDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCcnKSxcbiAgc2xpY2U6IGplc3QuZm4oKSxcbiAgbGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxufSkpXG5cbi8vIE1vY2sgQWJvcnRDb250cm9sbGVyXG5nbG9iYWwuQWJvcnRDb250cm9sbGVyID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICBzaWduYWw6ICdtb2NrLXNpZ25hbCcsXG4gIGFib3J0OiBqZXN0LmZuKCksXG59KSlcblxuLy8gTW9jayBzZXRUaW1lb3V0IGFuZCBjbGVhclRpbWVvdXRcbmplc3QudXNlRmFrZVRpbWVycygpXG4vLyBTcHkgb24gdGhlIHRpbWVyIGZ1bmN0aW9ucyBhZnRlciBmYWtlIHRpbWVycyBhcmUgc2V0IHVwXG5jb25zdCBtb2NrU2V0VGltZW91dCA9IGplc3Quc3B5T24oZ2xvYmFsVGhpcywgJ3NldFRpbWVvdXQnKVxuY29uc3QgbW9ja0NsZWFyVGltZW91dCA9IGplc3Quc3B5T24oZ2xvYmFsVGhpcywgJ2NsZWFyVGltZW91dCcpXG5cbmRlc2NyaWJlKCdoYW5kbGVDYW1lcmFCdXR0b25DbGljayBMb2dpYyBUZXN0cycsICgpID0+IHtcbiAgbGV0IG1vY2tVc2VyRmlsZTogRmlsZVxuICBsZXQgbW9ja0FwcGFyZWxGaWxlOiBGaWxlXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgICBcbiAgICAvLyBDcmVhdGUgbW9jayBmaWxlc1xuICAgIG1vY2tVc2VyRmlsZSA9IG5ldyBGaWxlKFsndXNlci1pbWFnZS1jb250ZW50J10sICd1c2VyLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgbW9ja0FwcGFyZWxGaWxlID0gbmV3IEZpbGUoWydhcHBhcmVsLWltYWdlLWNvbnRlbnQnXSwgJ2FwcGFyZWwuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICBcbiAgICAvLyBSZXNldCBtb2NrIGltcGxlbWVudGF0aW9uc1xuICAgIDsoZmlsZVRvQmFzZTY0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoJ21vY2stYmFzZTY0LXN0cmluZycpXG4gICAgOyhjb21wcmVzc0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKCdjb21wcmVzc2VkLWJhc2U2NC1zdHJpbmcnKVxuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxuICB9KVxuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbFRpbWVycygpXG4gIH0pXG5cbiAgLy8gVGVzdCB0aGUgY29yZSBsb2dpYyBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIGV4dHJhY3RlZCBmcm9tIGhhbmRsZUNhbWVyYUJ1dHRvbkNsaWNrXG4gIGNvbnN0IHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJID0gYXN5bmMgKHVzZXJGaWxlOiBGaWxlLCBhcHBhcmVsRmlsZTogRmlsZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBQcm9jZXNzIGltYWdlcyBjb25jdXJyZW50bHlcbiAgICAgIGNvbnN0IFttb2RlbEI2NCwgYXBwYXJlbEI2NF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGZpbGVUb0Jhc2U2NCh1c2VyRmlsZSksXG4gICAgICAgIGZpbGVUb0Jhc2U2NChhcHBhcmVsRmlsZSlcbiAgICAgIF0pXG5cbiAgICAgIC8vIENvbXByZXNzIGJvdGggaW1hZ2VzXG4gICAgICBjb25zdCBbY29tcHJlc3NlZE1vZGVsLCBjb21wcmVzc2VkQXBwYXJlbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGNvbXByZXNzQmFzZTY0KG1vZGVsQjY0LCAyMDQ4KSxcbiAgICAgICAgY29tcHJlc3NCYXNlNjQoYXBwYXJlbEI2NCwgMjA0OClcbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSBBYm9ydENvbnRyb2xsZXIgZm9yIHRpbWVvdXRcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAzMDAwMClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTWFrZSBBUEkgY2FsbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3RyeW9uJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1vZGVsSW1hZ2U6IGNvbXByZXNzZWRNb2RlbCxcbiAgICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFtjb21wcmVzc2VkQXBwYXJlbF1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtlcnJvclRleHR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaW1nX2dlbmVyYXRlZCB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgcmVjZWl2ZWQgZ2VuZXJhdGVkIGltYWdlIGZyb20gQVBJJylcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGltZ19nZW5lcmF0ZWQgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcHJvY2Vzc0ltYWdlc0FuZENhbGxBUEk6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGRlc2NyaWJlKCdTdWNjZXNzIFBhdGgnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgcHJvY2VzcyBpbWFnZXMgYW5kIG1ha2UgQVBJIGNhbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICdnZW5lcmF0ZWQtaW1hZ2UtYmFzZTY0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZmlsZVRvQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrVXNlckZpbGUpXG4gICAgICBleHBlY3QoZmlsZVRvQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrQXBwYXJlbEZpbGUpXG4gICAgICBleHBlY3QoY29tcHJlc3NCYXNlNjQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdtb2NrLWJhc2U2NC1zdHJpbmcnLCAyMDQ4KVxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvdHJ5b24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG1vZGVsSW1hZ2U6ICdjb21wcmVzc2VkLWJhc2U2NC1zdHJpbmcnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnY29tcHJlc3NlZC1iYXNlNjQtc3RyaW5nJ11cbiAgICAgICAgfSksXG4gICAgICAgIHNpZ25hbDogJ21vY2stc2lnbmFsJ1xuICAgICAgfSlcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZUxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1N1Y2Nlc3NmdWxseSByZWNlaXZlZCBnZW5lcmF0ZWQgaW1hZ2UgZnJvbSBBUEknKVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IHN1Y2Nlc3M6IHRydWUsIGltZ19nZW5lcmF0ZWQ6ICdnZW5lcmF0ZWQtaW1hZ2UtYmFzZTY0JyB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbXByZXNzaW9uIGZhaWx1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgOyhjb21wcmVzc0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgQ29tcHJlc3Npb25GYWlsZWRFcnJvcignQ29tcHJlc3Npb24gZmFpbGVkJykpXG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJKG1vY2tVc2VyRmlsZSwgbW9ja0FwcGFyZWxGaWxlKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnQ29tcHJlc3Npb24gZmFpbGVkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQVBJIHJlcXVlc3QgZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgdGV4dDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdCYWQgcmVxdWVzdCcpXG4gICAgICB9KVxuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0FQSSByZXF1ZXN0IGZhaWxlZDogNDAwIEJhZCByZXF1ZXN0JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdGltZW91dCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKVxuICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgICBtb2NrRmV0Y2gubW9ja1JlamVjdGVkVmFsdWVPbmNlKGFib3J0RXJyb3IpXG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJKG1vY2tVc2VyRmlsZSwgbW9ja0FwcGFyZWxGaWxlKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnUmVxdWVzdCBhYm9ydGVkJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdUaW1lb3V0IE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgQWJvcnRDb250cm9sbGVyIHdpdGggMzAtc2Vjb25kIHRpbWVvdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICd0ZXN0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZ2xvYmFsLkFib3J0Q29udHJvbGxlcikudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QobW9ja1NldFRpbWVvdXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5hbnkoRnVuY3Rpb24pLCAzMDAwMClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjbGVhciB0aW1lb3V0IG9uIHN1Y2Nlc3NmdWwgY29tcGxldGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaW1nX2dlbmVyYXRlZDogJ3Rlc3QnIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBBY3RcbiAgICAgIGF3YWl0IHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJKG1vY2tVc2VyRmlsZSwgbW9ja0FwcGFyZWxGaWxlKVxuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChtb2NrQ2xlYXJUaW1lb3V0KS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdJbWFnZSBQcm9jZXNzaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBib3RoIGltYWdlcyBjb25jdXJyZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICd0ZXN0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZmlsZVRvQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrVXNlckZpbGUpXG4gICAgICBleHBlY3QoZmlsZVRvQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrQXBwYXJlbEZpbGUpXG4gICAgICBleHBlY3QoY29tcHJlc3NCYXNlNjQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdtb2NrLWJhc2U2NC1zdHJpbmcnLCAyMDQ4KVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHVzZSBjb3JyZWN0IGNvbXByZXNzaW9uIGxpbWl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpbWdfZ2VuZXJhdGVkOiAndGVzdCcgfSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgcHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkobW9ja1VzZXJGaWxlLCBtb2NrQXBwYXJlbEZpbGUpXG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGNvbXByZXNzQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnbW9jay1iYXNlNjQtc3RyaW5nJywgMjA0OClcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdBUEkgUmVxdWVzdCBGb3JtYXQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzZW5kIGNvcnJlY3QgcmVxdWVzdCBib2R5IGZvcm1hdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaW1nX2dlbmVyYXRlZDogJ3Rlc3QnIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBBY3RcbiAgICAgIGF3YWl0IHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJKG1vY2tVc2VyRmlsZSwgbW9ja0FwcGFyZWxGaWxlKVxuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL3RyeW9uJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBtb2RlbEltYWdlOiAnY29tcHJlc3NlZC1iYXNlNjQtc3RyaW5nJyxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2NvbXByZXNzZWQtYmFzZTY0LXN0cmluZyddXG4gICAgICAgIH0pLFxuICAgICAgICBzaWduYWw6ICdtb2NrLXNpZ25hbCdcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn0pICJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImZpbGVUb0Jhc2U2NCIsImZuIiwiY29tcHJlc3NCYXNlNjQiLCJDb21wcmVzc2lvbkZhaWxlZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwibW9ja0ZldGNoIiwiZ2xvYmFsIiwiZmV0Y2giLCJtb2NrQ29uc29sZUxvZyIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIm1vY2tDb25zb2xlRXJyb3IiLCJGaWxlIiwiY29udGVudCIsIm9wdGlvbnMiLCJzaXplIiwibGVuZ3RoIiwidHlwZSIsImFycmF5QnVmZmVyIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJBcnJheUJ1ZmZlciIsInN0cmVhbSIsInRleHQiLCJzbGljZSIsImxhc3RNb2RpZmllZCIsIkRhdGUiLCJub3ciLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJhYm9ydCIsInVzZUZha2VUaW1lcnMiLCJtb2NrU2V0VGltZW91dCIsImdsb2JhbFRoaXMiLCJtb2NrQ2xlYXJUaW1lb3V0IiwiZGVzY3JpYmUiLCJtb2NrVXNlckZpbGUiLCJtb2NrQXBwYXJlbEZpbGUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyRWFjaCIsImNsZWFyQWxsVGltZXJzIiwicHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkiLCJ1c2VyRmlsZSIsImFwcGFyZWxGaWxlIiwibW9kZWxCNjQiLCJhcHBhcmVsQjY0IiwiUHJvbWlzZSIsImFsbCIsImNvbXByZXNzZWRNb2RlbCIsImNvbXByZXNzZWRBcHBhcmVsIiwiY29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJyZXNwb25zZSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwib2siLCJlcnJvclRleHQiLCJzdGF0dXMiLCJpbWdfZ2VuZXJhdGVkIiwianNvbiIsImxvZyIsInN1Y2Nlc3MiLCJjbGVhclRpbWVvdXQiLCJlcnJvciIsIml0IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwicmVzdWx0IiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0VxdWFsIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJhYm9ydEVycm9yIiwidG9IYXZlQmVlbkNhbGxlZCIsImFueSIsIkZ1bmN0aW9uIl0sIm1hcHBpbmdzIjoiO0FBRUEsNkJBQTZCO0FBQzdCQSxLQUFLQyxJQUFJLENBQUMsaUJBQWlCLElBQU8sQ0FBQTtRQUNoQ0MsY0FBY0YsS0FBS0csRUFBRTtRQUNyQkMsZ0JBQWdCSixLQUFLRyxFQUFFO1FBQ3ZCRSx3QkFBd0IsTUFBTUEsK0JBQStCQztZQUMzREMsWUFBWUMsT0FBZSxDQUFFO2dCQUMzQixLQUFLLENBQUNBO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1lBQ2Q7UUFDRjtJQUNGLENBQUE7Ozs7dUJBWnFFO0FBY3JFLHNCQUFzQjtBQUN0QixNQUFNQyxZQUFZVixLQUFLRyxFQUFFO0FBQ3pCUSxPQUFPQyxLQUFLLEdBQUdGO0FBRWYsdUJBQXVCO0FBQ3ZCLE1BQU1HLGlCQUFpQmIsS0FBS2MsS0FBSyxDQUFDQyxTQUFTLE9BQU9DLGtCQUFrQjtBQUNwRSxNQUFNQyxtQkFBbUJqQixLQUFLYyxLQUFLLENBQUNDLFNBQVMsU0FBU0Msa0JBQWtCO0FBRXhFLHdCQUF3QjtBQUN4QkwsT0FBT08sSUFBSSxHQUFHbEIsS0FBS0csRUFBRSxHQUFHYSxrQkFBa0IsQ0FBQyxDQUFDRyxTQUFTVixNQUFNVyxVQUFhLENBQUE7UUFDdEVYO1FBQ0FZLE1BQU1GLFFBQVFHLE1BQU07UUFDcEJDLE1BQU1ILFNBQVNHLFFBQVE7UUFDdkJDLGFBQWF4QixLQUFLRyxFQUFFLEdBQUdzQixpQkFBaUIsQ0FBQyxJQUFJQyxZQUFZUCxRQUFRRyxNQUFNO1FBQ3ZFSyxRQUFRM0IsS0FBS0csRUFBRTtRQUNmeUIsTUFBTTVCLEtBQUtHLEVBQUUsR0FBR3NCLGlCQUFpQixDQUFDO1FBQ2xDSSxPQUFPN0IsS0FBS0csRUFBRTtRQUNkMkIsY0FBY0MsS0FBS0MsR0FBRztJQUN4QixDQUFBO0FBRUEsdUJBQXVCO0FBQ3ZCckIsT0FBT3NCLGVBQWUsR0FBR2pDLEtBQUtHLEVBQUUsR0FBR2Esa0JBQWtCLENBQUMsSUFBTyxDQUFBO1FBQzNEa0IsUUFBUTtRQUNSQyxPQUFPbkMsS0FBS0csRUFBRTtJQUNoQixDQUFBO0FBRUEsbUNBQW1DO0FBQ25DSCxLQUFLb0MsYUFBYTtBQUNsQiwwREFBMEQ7QUFDMUQsTUFBTUMsaUJBQWlCckMsS0FBS2MsS0FBSyxDQUFDd0IsWUFBWTtBQUM5QyxNQUFNQyxtQkFBbUJ2QyxLQUFLYyxLQUFLLENBQUN3QixZQUFZO0FBRWhERSxTQUFTLHVDQUF1QztJQUM5QyxJQUFJQztJQUNKLElBQUlDO0lBRUpDLFdBQVc7UUFDVDNDLEtBQUs0QyxhQUFhO1FBRWxCLG9CQUFvQjtRQUNwQkgsZUFBZSxJQUFJdkIsS0FBSztZQUFDO1NBQXFCLEVBQUUsWUFBWTtZQUFFSyxNQUFNO1FBQWE7UUFDakZtQixrQkFBa0IsSUFBSXhCLEtBQUs7WUFBQztTQUF3QixFQUFFLGVBQWU7WUFBRUssTUFBTTtRQUFhO1FBR3hGckIsbUJBQVksQ0FBZXVCLGlCQUFpQixDQUFDO1FBQzdDckIscUJBQWMsQ0FBZXFCLGlCQUFpQixDQUFDO1FBQ2pEZixVQUFVbUMsU0FBUztJQUNyQjtJQUVBQyxVQUFVO1FBQ1I5QyxLQUFLK0MsY0FBYztJQUNyQjtJQUVBLG9GQUFvRjtJQUNwRixNQUFNQywwQkFBMEIsT0FBT0MsVUFBZ0JDO1FBQ3JELElBQUk7WUFDRiw4QkFBOEI7WUFDOUIsTUFBTSxDQUFDQyxVQUFVQyxXQUFXLEdBQUcsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO2dCQUMvQ3BELElBQUFBLG1CQUFZLEVBQUMrQztnQkFDYi9DLElBQUFBLG1CQUFZLEVBQUNnRDthQUNkO1lBRUQsdUJBQXVCO1lBQ3ZCLE1BQU0sQ0FBQ0ssaUJBQWlCQyxrQkFBa0IsR0FBRyxNQUFNSCxRQUFRQyxHQUFHLENBQUM7Z0JBQzdEbEQsSUFBQUEscUJBQWMsRUFBQytDLFVBQVU7Z0JBQ3pCL0MsSUFBQUEscUJBQWMsRUFBQ2dELFlBQVk7YUFDNUI7WUFFRCxxQ0FBcUM7WUFDckMsTUFBTUssYUFBYSxJQUFJeEI7WUFDdkIsTUFBTXlCLFlBQVlDLFdBQVcsSUFBTUYsV0FBV3RCLEtBQUssSUFBSTtZQUV2RCxJQUFJO2dCQUNGLGdCQUFnQjtnQkFDaEIsTUFBTXlCLFdBQVcsTUFBTWhELE1BQU0sY0FBYztvQkFDekNpRCxRQUFRO29CQUNSQyxTQUFTO3dCQUFFLGdCQUFnQjtvQkFBbUI7b0JBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7d0JBQ25CQyxZQUFZWDt3QkFDWlksZUFBZTs0QkFBQ1g7eUJBQWtCO29CQUNwQztvQkFDQXRCLFFBQVF1QixXQUFXdkIsTUFBTTtnQkFDM0I7Z0JBRUEsSUFBSSxDQUFDMEIsU0FBU1EsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ULFNBQVNoQyxJQUFJO29CQUNyQyxNQUFNLElBQUl0QixNQUFNLENBQUMsb0JBQW9CLEVBQUVzRCxTQUFTVSxNQUFNLENBQUMsQ0FBQyxFQUFFRCxXQUFXO2dCQUN2RTtnQkFFQSxNQUFNLEVBQUVFLGFBQWEsRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUk7Z0JBQzdDekQsUUFBUTBELEdBQUcsQ0FBQztnQkFFWixPQUFPO29CQUFFQyxTQUFTO29CQUFNSDtnQkFBYztZQUN4QyxTQUFVO2dCQUNSSSxhQUFhakI7WUFDZjtRQUNGLEVBQUUsT0FBT2tCLE9BQU87WUFDZDdELFFBQVE2RCxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQXBDLFNBQVMsZ0JBQWdCO1FBQ3ZCcUMsR0FBRyx3REFBd0Q7WUFDekQsVUFBVTtZQUNWbkUsVUFBVW9FLHFCQUFxQixDQUFDO2dCQUM5QlYsSUFBSTtnQkFDSkksTUFBTXhFLEtBQUtHLEVBQUUsR0FBR3NCLGlCQUFpQixDQUFDO29CQUFFOEMsZUFBZTtnQkFBeUI7WUFDOUU7WUFFQSxNQUFNO1lBQ04sTUFBTVEsU0FBUyxNQUFNL0Isd0JBQXdCUCxjQUFjQztZQUUzRCxTQUFTO1lBQ1RzQyxPQUFPOUUsbUJBQVksRUFBRStFLG9CQUFvQixDQUFDeEM7WUFDMUN1QyxPQUFPOUUsbUJBQVksRUFBRStFLG9CQUFvQixDQUFDdkM7WUFDMUNzQyxPQUFPNUUscUJBQWMsRUFBRTZFLG9CQUFvQixDQUFDLHNCQUFzQjtZQUNsRUQsT0FBT3RFLFdBQVd1RSxvQkFBb0IsQ0FBQyxjQUFjO2dCQUNuRHBCLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFDbkJDLFlBQVk7b0JBQ1pDLGVBQWU7d0JBQUM7cUJBQTJCO2dCQUM3QztnQkFDQWpDLFFBQVE7WUFDVjtZQUNBOEMsT0FBT25FLGdCQUFnQm9FLG9CQUFvQixDQUFDO1lBQzVDRCxPQUFPRCxRQUFRRyxPQUFPLENBQUM7Z0JBQUVSLFNBQVM7Z0JBQU1ILGVBQWU7WUFBeUI7UUFDbEY7SUFDRjtJQUVBL0IsU0FBUyxrQkFBa0I7UUFDekJxQyxHQUFHLHNDQUFzQztZQUN2QyxVQUFVOztZQUNSekUscUJBQWMsQ0FBZStFLHFCQUFxQixDQUFDLElBQUk5RSw2QkFBc0IsQ0FBQztZQUVoRixlQUFlO1lBQ2YsTUFBTTJFLE9BQU9oQyx3QkFBd0JQLGNBQWNDLGtCQUNoRDBDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1FBQ3JCO1FBRUFSLEdBQUcsc0NBQXNDO1lBQ3ZDLFVBQVU7WUFDVm5FLFVBQVVvRSxxQkFBcUIsQ0FBQztnQkFDOUJWLElBQUk7Z0JBQ0pFLFFBQVE7Z0JBQ1IxQyxNQUFNNUIsS0FBS0csRUFBRSxHQUFHc0IsaUJBQWlCLENBQUM7WUFDcEM7WUFFQSxlQUFlO1lBQ2YsTUFBTXVELE9BQU9oQyx3QkFBd0JQLGNBQWNDLGtCQUNoRDBDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1FBQ3JCO1FBRUFSLEdBQUcsZ0NBQWdDO1lBQ2pDLFVBQVU7WUFDVixNQUFNUyxhQUFhLElBQUloRixNQUFNO1lBQzdCZ0YsV0FBVzdFLElBQUksR0FBRztZQUNsQkMsVUFBVXlFLHFCQUFxQixDQUFDRztZQUVoQyxlQUFlO1lBQ2YsTUFBTU4sT0FBT2hDLHdCQUF3QlAsY0FBY0Msa0JBQ2hEMEMsT0FBTyxDQUFDQyxPQUFPLENBQUM7UUFDckI7SUFDRjtJQUVBN0MsU0FBUyxzQkFBc0I7UUFDN0JxQyxHQUFHLHdEQUF3RDtZQUN6RCxVQUFVO1lBQ1ZuRSxVQUFVb0UscUJBQXFCLENBQUM7Z0JBQzlCVixJQUFJO2dCQUNKSSxNQUFNeEUsS0FBS0csRUFBRSxHQUFHc0IsaUJBQWlCLENBQUM7b0JBQUU4QyxlQUFlO2dCQUFPO1lBQzVEO1lBRUEsTUFBTTtZQUNOLE1BQU12Qix3QkFBd0JQLGNBQWNDO1lBRTVDLFNBQVM7WUFDVHNDLE9BQU9yRSxPQUFPc0IsZUFBZSxFQUFFc0QsZ0JBQWdCO1lBQy9DUCxPQUFPM0MsZ0JBQWdCNEMsb0JBQW9CLENBQUNELE9BQU9RLEdBQUcsQ0FBQ0MsV0FBVztRQUNwRTtRQUVBWixHQUFHLGlEQUFpRDtZQUNsRCxVQUFVO1lBQ1ZuRSxVQUFVb0UscUJBQXFCLENBQUM7Z0JBQzlCVixJQUFJO2dCQUNKSSxNQUFNeEUsS0FBS0csRUFBRSxHQUFHc0IsaUJBQWlCLENBQUM7b0JBQUU4QyxlQUFlO2dCQUFPO1lBQzVEO1lBRUEsTUFBTTtZQUNOLE1BQU12Qix3QkFBd0JQLGNBQWNDO1lBRTVDLFNBQVM7WUFDVHNDLE9BQU96QyxrQkFBa0JnRCxnQkFBZ0I7UUFDM0M7SUFDRjtJQUVBL0MsU0FBUyxvQkFBb0I7UUFDM0JxQyxHQUFHLDJDQUEyQztZQUM1QyxVQUFVO1lBQ1ZuRSxVQUFVb0UscUJBQXFCLENBQUM7Z0JBQzlCVixJQUFJO2dCQUNKSSxNQUFNeEUsS0FBS0csRUFBRSxHQUFHc0IsaUJBQWlCLENBQUM7b0JBQUU4QyxlQUFlO2dCQUFPO1lBQzVEO1lBRUEsTUFBTTtZQUNOLE1BQU12Qix3QkFBd0JQLGNBQWNDO1lBRTVDLFNBQVM7WUFDVHNDLE9BQU85RSxtQkFBWSxFQUFFK0Usb0JBQW9CLENBQUN4QztZQUMxQ3VDLE9BQU85RSxtQkFBWSxFQUFFK0Usb0JBQW9CLENBQUN2QztZQUMxQ3NDLE9BQU81RSxxQkFBYyxFQUFFNkUsb0JBQW9CLENBQUMsc0JBQXNCO1FBQ3BFO1FBRUFKLEdBQUcsd0NBQXdDO1lBQ3pDLFVBQVU7WUFDVm5FLFVBQVVvRSxxQkFBcUIsQ0FBQztnQkFDOUJWLElBQUk7Z0JBQ0pJLE1BQU14RSxLQUFLRyxFQUFFLEdBQUdzQixpQkFBaUIsQ0FBQztvQkFBRThDLGVBQWU7Z0JBQU87WUFDNUQ7WUFFQSxNQUFNO1lBQ04sTUFBTXZCLHdCQUF3QlAsY0FBY0M7WUFFNUMsU0FBUztZQUNUc0MsT0FBTzVFLHFCQUFjLEVBQUU2RSxvQkFBb0IsQ0FBQyxzQkFBc0I7UUFDcEU7SUFDRjtJQUVBekMsU0FBUyxzQkFBc0I7UUFDN0JxQyxHQUFHLDJDQUEyQztZQUM1QyxVQUFVO1lBQ1ZuRSxVQUFVb0UscUJBQXFCLENBQUM7Z0JBQzlCVixJQUFJO2dCQUNKSSxNQUFNeEUsS0FBS0csRUFBRSxHQUFHc0IsaUJBQWlCLENBQUM7b0JBQUU4QyxlQUFlO2dCQUFPO1lBQzVEO1lBRUEsTUFBTTtZQUNOLE1BQU12Qix3QkFBd0JQLGNBQWNDO1lBRTVDLFNBQVM7WUFDVHNDLE9BQU90RSxXQUFXdUUsb0JBQW9CLENBQUMsY0FBYztnQkFDbkRwQixRQUFRO2dCQUNSQyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7Z0JBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQ25CQyxZQUFZO29CQUNaQyxlQUFlO3dCQUFDO3FCQUEyQjtnQkFDN0M7Z0JBQ0FqQyxRQUFRO1lBQ1Y7UUFDRjtJQUNGO0FBQ0YifQ==