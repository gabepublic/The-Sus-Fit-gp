{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/hooks/useCanvasOperations.ts"],"sourcesContent":["'use client';\n\n// Canvas Operations Hooks\n// React hooks for common canvas operations and patterns\n\nimport { useCallback, useRef, useEffect, useState } from 'react';\nimport { \n  useCanvas, \n  useManagedCanvas, \n  type ManagedCanvas \n} from '../providers/CanvasProvider';\nimport { \n  AdvancedCanvasOperations,\n  CanvasAnimationUtils,\n  CanvasPerformanceUtils,\n  createAdvancedCanvasOperations,\n  createCanvasAnimationUtils,\n  BlendMode,\n  type CanvasState\n} from '../utils/canvasUtils';\n\n/**\n * Hook for advanced canvas operations\n */\nexport function useAdvancedCanvasOperations(\n  width: number,\n  height: number,\n  canvasId?: string\n): {\n  canvas: ManagedCanvas;\n  operations: AdvancedCanvasOperations;\n  saveState: () => CanvasState;\n  restoreState: (state: CanvasState) => void;\n  clear: () => void;\n} {\n  const canvas = useManagedCanvas(width, height, canvasId);\n  const operationsRef = useRef<AdvancedCanvasOperations>();\n  \n  if (!operationsRef.current) {\n    operationsRef.current = createAdvancedCanvasOperations(canvas);\n  }\n\n  const saveState = useCallback(() => {\n    return operationsRef.current!.saveState();\n  }, []);\n\n  const restoreState = useCallback((state: CanvasState) => {\n    operationsRef.current!.restoreState(state);\n  }, []);\n\n  const clear = useCallback(() => {\n    canvas.context.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);\n  }, [canvas]);\n\n  return {\n    canvas,\n    operations: operationsRef.current,\n    saveState,\n    restoreState,\n    clear\n  };\n}\n\n/**\n * Hook for canvas animation support\n */\nexport function useCanvasAnimation(): {\n  isRunning: boolean;\n  startAnimation: (callback: (timestamp: number) => void) => void;\n  stopAnimation: () => void;\n  animateProperty: (\n    from: number,\n    to: number,\n    duration: number,\n    easing: (t: number) => number,\n    onUpdate: (value: number) => void,\n    onComplete?: () => void\n  ) => (() => void);\n} {\n  const [isRunning, setIsRunning] = useState(false);\n  const animationUtilsRef = useRef<CanvasAnimationUtils>();\n\n  if (!animationUtilsRef.current) {\n    animationUtilsRef.current = createCanvasAnimationUtils();\n  }\n\n  const startAnimation = useCallback((callback: (timestamp: number) => void) => {\n    animationUtilsRef.current!.startAnimation(callback);\n    setIsRunning(true);\n  }, []);\n\n  const stopAnimation = useCallback(() => {\n    animationUtilsRef.current!.stopAnimation();\n    setIsRunning(false);\n  }, []);\n\n  const animateProperty = useCallback((\n    from: number,\n    to: number,\n    duration: number,\n    easing: (t: number) => number,\n    onUpdate: (value: number) => void,\n    onComplete?: () => void\n  ) => {\n    return CanvasAnimationUtils.animateProperty(\n      from, to, duration, easing, onUpdate, \n      () => {\n        onComplete?.();\n        setIsRunning(false);\n      }\n    );\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      stopAnimation();\n    };\n  }, [stopAnimation]);\n\n  return {\n    isRunning,\n    startAnimation,\n    stopAnimation,\n    animateProperty\n  };\n}\n\n/**\n * Hook for canvas state management with undo/redo functionality\n */\nexport function useCanvasHistory(\n  canvas: ManagedCanvas,\n  maxHistorySize: number = 20\n): {\n  canUndo: boolean;\n  canRedo: boolean;\n  saveState: () => void;\n  undo: () => void;\n  redo: () => void;\n  clear: () => void;\n  historySize: number;\n} {\n  const [history, setHistory] = useState<CanvasState[]>([]);\n  const [currentIndex, setCurrentIndex] = useState(-1);\n  const operationsRef = useRef<AdvancedCanvasOperations>(\n    createAdvancedCanvasOperations(canvas)\n  );\n\n  const canUndo = currentIndex > 0;\n  const canRedo = currentIndex < history.length - 1;\n\n  const saveState = useCallback(() => {\n    const state = operationsRef.current.saveState();\n    \n    setHistory(prev => {\n      const newHistory = prev.slice(0, currentIndex + 1);\n      newHistory.push(state);\n      \n      // Limit history size\n      if (newHistory.length > maxHistorySize) {\n        newHistory.shift();\n        return newHistory;\n      }\n      \n      return newHistory;\n    });\n    \n    setCurrentIndex(prev => {\n      const newIndex = prev + 1;\n      return newIndex >= maxHistorySize ? maxHistorySize - 1 : newIndex;\n    });\n  }, [currentIndex, maxHistorySize]);\n\n  const undo = useCallback(() => {\n    if (!canUndo) return;\n    \n    const newIndex = currentIndex - 1;\n    const state = history[newIndex];\n    \n    if (state) {\n      operationsRef.current.restoreState(state);\n      setCurrentIndex(newIndex);\n    }\n  }, [canUndo, currentIndex, history]);\n\n  const redo = useCallback(() => {\n    if (!canRedo) return;\n    \n    const newIndex = currentIndex + 1;\n    const state = history[newIndex];\n    \n    if (state) {\n      operationsRef.current.restoreState(state);\n      setCurrentIndex(newIndex);\n    }\n  }, [canRedo, currentIndex, history]);\n\n  const clear = useCallback(() => {\n    setHistory([]);\n    setCurrentIndex(-1);\n  }, []);\n\n  // Save initial state\n  useEffect(() => {\n    if (history.length === 0) {\n      saveState();\n    }\n  }, []);\n\n  return {\n    canUndo,\n    canRedo,\n    saveState,\n    undo,\n    redo,\n    clear,\n    historySize: history.length\n  };\n}\n\n/**\n * Hook for performance monitoring of canvas operations\n */\nexport function useCanvasPerformance(): {\n  measureOperation: <T>(operation: () => T, name?: string) => T;\n  debounce: <T extends (...args: any[]) => any>(func: T, wait: number) => (...args: Parameters<T>) => void;\n  throttle: <T extends (...args: any[]) => any>(func: T, limit: number) => (...args: Parameters<T>) => void;\n  isCanvasSizeSafe: (width: number, height: number) => boolean;\n} {\n  const measureOperation = useCallback(<T>(operation: () => T, name?: string) => {\n    return CanvasPerformanceUtils.measureOperation(operation, name);\n  }, []);\n\n  const debounce = useCallback(<T extends (...args: any[]) => any>(func: T, wait: number) => {\n    return CanvasPerformanceUtils.debounce(func, wait);\n  }, []);\n\n  const throttle = useCallback(<T extends (...args: any[]) => any>(func: T, limit: number) => {\n    return CanvasPerformanceUtils.throttle(func, limit);\n  }, []);\n\n  const isCanvasSizeSafe = useCallback((width: number, height: number) => {\n    return CanvasPerformanceUtils.isCanvasSizeSafe(width, height);\n  }, []);\n\n  return {\n    measureOperation,\n    debounce,\n    throttle,\n    isCanvasSizeSafe\n  };\n}\n\n/**\n * Hook for image loading and drawing on canvas\n */\nexport function useCanvasImageLoader(\n  canvas: ManagedCanvas\n): {\n  loadImage: (url: string) => Promise<HTMLImageElement>;\n  drawImage: (\n    image: HTMLImageElement,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number,\n    blendMode?: BlendMode,\n    opacity?: number\n  ) => void;\n  loadAndDrawImage: (\n    url: string,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number,\n    blendMode?: BlendMode,\n    opacity?: number\n  ) => Promise<void>;\n  isLoading: boolean;\n  error: string | null;\n} {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const { utils } = useCanvas();\n  const operationsRef = useRef<AdvancedCanvasOperations>(\n    createAdvancedCanvasOperations(canvas)\n  );\n\n  const loadImage = useCallback(async (url: string): Promise<HTMLImageElement> => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      \n      await new Promise<void>((resolve, reject) => {\n        img.onload = () => resolve();\n        img.onerror = () => reject(new Error('Failed to load image'));\n        img.src = url;\n      });\n\n      setIsLoading(false);\n      return img;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error loading image';\n      setError(errorMessage);\n      setIsLoading(false);\n      throw new Error(errorMessage);\n    }\n  }, []);\n\n  const drawImage = useCallback((\n    image: HTMLImageElement,\n    x: number = 0,\n    y: number = 0,\n    width?: number,\n    height?: number,\n    blendMode: BlendMode = BlendMode.Normal,\n    opacity: number = 1\n  ) => {\n    operationsRef.current.drawImageWithBlendMode(\n      image, x, y, width, height, blendMode, opacity\n    );\n  }, []);\n\n  const loadAndDrawImage = useCallback(async (\n    url: string,\n    x: number = 0,\n    y: number = 0,\n    width?: number,\n    height?: number,\n    blendMode: BlendMode = BlendMode.Normal,\n    opacity: number = 1\n  ) => {\n    const image = await loadImage(url);\n    drawImage(image, x, y, width, height, blendMode, opacity);\n  }, [loadImage, drawImage]);\n\n  return {\n    loadImage,\n    drawImage,\n    loadAndDrawImage,\n    isLoading,\n    error\n  };\n}\n\n/**\n * Hook for canvas resize handling\n */\nexport function useCanvasResize(\n  canvas: ManagedCanvas,\n  maintainContent: boolean = true\n): {\n  resize: (newWidth: number, newHeight: number) => void;\n  autoResize: (container: HTMLElement) => void;\n  dimensions: { width: number; height: number };\n} {\n  const [dimensions, setDimensions] = useState(canvas.dimensions);\n  const { utils } = useCanvas();\n\n  const resize = useCallback((newWidth: number, newHeight: number) => {\n    if (maintainContent) {\n      utils.resizeCanvas(canvas.canvas, newWidth, newHeight);\n    } else {\n      canvas.canvas.width = newWidth;\n      canvas.canvas.height = newHeight;\n      canvas.canvas.style.width = `${newWidth}px`;\n      canvas.canvas.style.height = `${newHeight}px`;\n    }\n    \n    canvas.dimensions = { width: newWidth, height: newHeight };\n    setDimensions({ width: newWidth, height: newHeight });\n  }, [canvas, maintainContent, utils]);\n\n  const autoResize = useCallback((container: HTMLElement) => {\n    const resizeObserver = new ResizeObserver(entries => {\n      const entry = entries[0];\n      if (entry) {\n        const { width, height } = entry.contentRect;\n        resize(width, height);\n      }\n    });\n\n    resizeObserver.observe(container);\n    \n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [resize]);\n\n  return {\n    resize,\n    autoResize,\n    dimensions\n  };\n}"],"names":["useAdvancedCanvasOperations","useCanvasAnimation","useCanvasHistory","useCanvasImageLoader","useCanvasPerformance","useCanvasResize","width","height","canvasId","canvas","useManagedCanvas","operationsRef","useRef","current","createAdvancedCanvasOperations","saveState","useCallback","restoreState","state","clear","context","clearRect","operations","isRunning","setIsRunning","useState","animationUtilsRef","createCanvasAnimationUtils","startAnimation","callback","stopAnimation","animateProperty","from","to","duration","easing","onUpdate","onComplete","CanvasAnimationUtils","useEffect","maxHistorySize","history","setHistory","currentIndex","setCurrentIndex","canUndo","canRedo","length","prev","newHistory","slice","push","shift","newIndex","undo","redo","historySize","measureOperation","operation","name","CanvasPerformanceUtils","debounce","func","wait","throttle","limit","isCanvasSizeSafe","isLoading","setIsLoading","error","setError","utils","useCanvas","loadImage","url","img","Image","crossOrigin","Promise","resolve","reject","onload","onerror","Error","src","err","errorMessage","message","drawImage","image","x","y","blendMode","BlendMode","Normal","opacity","drawImageWithBlendMode","loadAndDrawImage","maintainContent","dimensions","setDimensions","resize","newWidth","newHeight","resizeCanvas","style","autoResize","container","resizeObserver","ResizeObserver","entries","entry","contentRect","observe","disconnect"],"mappings":"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"}