3f68c40e3811cc4accdfc2c2bec2adcc
// Performance Tests for Try-On Mutations
// Tests to ensure mutations perform well under various load conditions
"use strict";
// Mock dependencies for performance testing
jest.mock('../../../src/business-layer/utils/optimisticUpdates', ()=>({
        getOptimisticUpdatesManager: ()=>({
                startOptimisticUpdate: jest.fn(()=>({
                        optimisticId: `perf-test-${Date.now()}-${Math.random()}`,
                        variables: {},
                        config: {},
                        startTime: Date.now(),
                        rollbackFunctions: []
                    })),
                completeOptimisticUpdate: jest.fn(),
                rollbackOptimisticUpdate: jest.fn(),
                getActiveOptimisticUpdates: jest.fn(()=>[])
            }),
        OptimisticUpdatesManager: jest.fn()
    }));
jest.mock('../../../src/business-layer/utils/cacheInvalidation', ()=>({
        invalidateCacheAfterMutation: jest.fn().mockResolvedValue(undefined)
    }));
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        processImageForTryon: jest.fn().mockImplementation(()=>{
            // Simulate realistic processing time
            return new Promise((resolve)=>{
                setTimeout(()=>{
                    resolve({
                        originalSize: 2048576,
                        processedSize: 1048576,
                        compressionRatio: 0.5,
                        processingTime: 50 + Math.random() * 100,
                        processedImage: 'data:image/jpeg;base64,processed-image',
                        metadata: {
                            originalDimensions: {
                                width: 1920,
                                height: 1080
                            },
                            processedDimensions: {
                                width: 1024,
                                height: 1536
                            },
                            format: 'jpeg',
                            quality: 0.9
                        }
                    });
                }, 50 + Math.random() * 100);
            });
        })
    }));
jest.mock('../../../src/business-layer/utils/errorHandling', ()=>({
        classifyTryonError: jest.fn(()=>({
                userMessage: 'Error',
                technicalMessage: 'Error',
                errorCode: 'TEST',
                retryable: false,
                category: 'TEST',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        logAndClassifyError: jest.fn(()=>({
                userMessage: 'Error',
                technicalMessage: 'Error',
                errorCode: 'TEST',
                retryable: false,
                category: 'TEST',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        isErrorRetryable: jest.fn(()=>false)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useTryonMutation = require("../../../src/business-layer/mutations/useTryonMutation");
const _useTryonWithProgress = require("../../../src/business-layer/hooks/useTryonWithProgress");
const _testUtils = require("../../../src/business-layer/tests/testUtils");
describe('Mutation Performance Tests', ()=>{
    let queryClient;
    let consoleRef;
    beforeEach(()=>{
        queryClient = (0, _testUtils.createTestQueryClient)();
        consoleRef = (0, _testUtils.mockConsole)();
        jest.clearAllMocks();
    });
    afterEach(()=>{
        queryClient.clear();
        consoleRef.restore();
    });
    describe('Single Mutation Performance', ()=>{
        it('should complete basic mutation within performance threshold', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 200); // 200ms API delay
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(1000); // Should complete within 1 second
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
        });
        it('should handle large base64 images efficiently', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 300);
            // Create a large base64 string to simulate real image data
            const largeBase64 = 'data:image/jpeg;base64,' + 'A'.repeat(1000000); // ~1MB base64
            const testVariables = {
                modelImage: largeBase64,
                apparelImages: [
                    largeBase64,
                    largeBase64
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(1500); // Should handle large images within 1.5 seconds
        });
        it('should process File objects within reasonable time', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 250);
            const mockFile = new File([
                new ArrayBuffer(5 * 1024 * 1024)
            ], 'large-image.jpg', {
                type: 'image/jpeg'
            });
            const testVariables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: {
                    imageProcessing: {
                        targetWidth: 1024,
                        targetHeight: 1536,
                        maxSizeKB: 1024,
                        compressionQuality: 0.9
                    }
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            }, {
                timeout: 5000
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(2000); // Should process files within 2 seconds
        });
    });
    describe('Concurrent Mutations Performance', ()=>{
        it('should handle multiple concurrent mutations efficiently', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 300);
            const numConcurrentMutations = 5;
            const mutations = [];
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            // Create multiple mutation hooks
            for(let i = 0; i < numConcurrentMutations; i++){
                const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                    wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
                });
                mutations.push(result);
            }
            const startTime = performance.now();
            // Start all mutations concurrently
            await (0, _react.act)(async ()=>{
                mutations.forEach((mutation)=>{
                    mutation.current.mutate(testVariables);
                });
            });
            // Wait for all to complete
            await (0, _react.waitFor)(()=>{
                expect(mutations.every((m)=>m.current.isSuccess)).toBe(true);
            }, {
                timeout: 10000
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(5000); // Should handle 5 concurrent within 5 seconds
            mutations.forEach((mutation)=>{
                expect(mutation.current.data).toEqual(_testUtils.mockTryonResponse);
            });
        });
        it('should handle batch operations efficiently', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 200);
            const batchSize = 3;
            const testVariablesList = Array.from({
                length: batchSize
            }, (_, i)=>({
                    modelImage: `data:image/jpeg;base64,test-model-${i}`,
                    apparelImages: [
                        `data:image/jpeg;base64,test-apparel-${i}`
                    ],
                    options: {}
                }));
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useBatchTryonWithProgress)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            let batchResults = [];
            await (0, _react.act)(async ()=>{
                batchResults = await result.current.executeBatch(testVariablesList);
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(3000); // Should handle batch within 3 seconds
            expect(batchResults).toHaveLength(batchSize);
            expect(result.current.batchProgress.completed).toBe(batchSize);
        });
    });
    describe('Memory Usage Performance', ()=>{
        it('should not cause memory leaks with repeated mutations', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 100);
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const numIterations = 20;
            for(let i = 0; i < numIterations; i++){
                await (0, _react.act)(async ()=>{
                    result.current.mutate(testVariables);
                });
                await (0, _react.waitFor)(()=>{
                    expect(result.current.isSuccess).toBe(true);
                });
                // Reset between iterations
                (0, _react.act)(()=>{
                    result.current.reset();
                });
                // Small delay to allow cleanup
                await (0, _testUtils.wait)(10);
            }
            // Verify final state is clean
            expect(result.current.isIdle).toBe(true);
            expect(result.current.data).toBeUndefined();
            expect(result.current.error).toBeNull();
        });
        it('should cleanup optimistic updates efficiently', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 150);
            const config = {
                enableOptimisticUpdates: true,
                optimisticConfig: {
                    showPreview: true,
                    updateHistory: true,
                    showProgress: true
                }
            };
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const numIterations = 10;
            for(let i = 0; i < numIterations; i++){
                const startTime = performance.now();
                await (0, _react.act)(async ()=>{
                    await result.current.executeTryon(testVariables);
                });
                const iterationTime = performance.now() - startTime;
                expect(iterationTime).toBeLessThan(1000); // Each iteration should be fast
                // Verify cleanup
                expect(result.current.currentOptimisticId).toBeNull();
                expect(result.current.hasActiveOptimistic).toBe(false);
            }
        });
    });
    describe('Cache Performance', ()=>{
        it('should handle cache invalidation efficiently', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 200);
            // Pre-populate cache with many entries
            const numCacheEntries = 100;
            for(let i = 0; i < numCacheEntries; i++){
                queryClient.setQueryData([
                    `test-cache-${i}`
                ], {
                    data: `entry-${i}`
                });
            }
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const config = {
                cacheInvalidationConfig: {
                    invalidateHistory: true,
                    invalidateUserData: true,
                    invalidateStats: true,
                    invalidateTags: true,
                    preloadRelated: true
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(1500); // Should handle cache operations efficiently
        });
        it('should perform well with large query cache', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 100);
            // Create a large query cache
            const numQueries = 500;
            for(let i = 0; i < numQueries; i++){
                queryClient.setQueryData([
                    `large-cache-${i}`
                ], {
                    data: Array.from({
                        length: 100
                    }, (_, j)=>({
                            id: j,
                            value: `item-${i}-${j}`
                        }))
                });
            }
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(1000); // Should not be significantly slowed by large cache
        });
    });
    describe('Error Handling Performance', ()=>{
        it('should handle retries efficiently', async ()=>{
            let attemptCount = 0;
            global.fetch.mockImplementation(()=>{
                attemptCount++;
                if (attemptCount <= 2) {
                    return Promise.resolve({
                        ok: false,
                        status: 500,
                        json: ()=>Promise.resolve({
                                error: 'Server Error'
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(_testUtils.mockTryonResponse)
                });
            });
            const config = {
                enableRetry: true,
                maxRetries: 3,
                initialRetryDelay: 50 // Fast retries for testing
            };
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            }, {
                timeout: 5000
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(1000); // Should handle retries quickly
            expect(attemptCount).toBe(3); // Initial + 2 retries
        });
        it('should cleanup efficiently after errors', async ()=>{
            const apiError = new Error('API Error');
            (0, _testUtils.mockTryonAPI)(undefined, apiError);
            const config = {
                enableOptimisticUpdates: true,
                optimisticConfig: {
                    showPreview: true,
                    updateHistory: true
                }
            };
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                try {
                    await result.current.executeTryon(testVariables);
                } catch (error) {
                // Expected to fail
                }
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeTruthy();
            });
            const totalTime = performance.now() - startTime;
            expect(totalTime).toBeLessThan(500); // Error handling should be fast
            expect(result.current.currentOptimisticId).toBeNull(); // Should cleanup optimistic state
        });
    });
    describe('Resource Cleanup Performance', ()=>{
        it('should cleanup resources quickly on component unmount', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 1000); // Long delay
            const config = {
                enableOptimisticUpdates: true
            };
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result, unmount } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Start mutation
            await (0, _react.act)(async ()=>{
                result.current.executeTryon(testVariables).catch(()=>{}); // Ignore rejection
            });
            const unmountStart = performance.now();
            // Unmount component
            unmount();
            const unmountTime = performance.now() - unmountStart;
            expect(unmountTime).toBeLessThan(100); // Unmount should be very fast
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL3BlcmZvcm1hbmNlL211dGF0aW9uLnBlcmZvcm1hbmNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGVyZm9ybWFuY2UgVGVzdHMgZm9yIFRyeS1PbiBNdXRhdGlvbnNcbi8vIFRlc3RzIHRvIGVuc3VyZSBtdXRhdGlvbnMgcGVyZm9ybSB3ZWxsIHVuZGVyIHZhcmlvdXMgbG9hZCBjb25kaXRpb25zXG5cbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgUXVlcnlDbGllbnQgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xuaW1wb3J0IHsgdXNlVHJ5b25NdXRhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci9tdXRhdGlvbnMvdXNlVHJ5b25NdXRhdGlvbic7XG5pbXBvcnQgeyB1c2VUcnlvbldpdGhQcm9ncmVzcywgdXNlQmF0Y2hUcnlvbldpdGhQcm9ncmVzcyB9IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci9ob29rcy91c2VUcnlvbldpdGhQcm9ncmVzcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZXN0UXVlcnlDbGllbnQsXG4gIGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcixcbiAgbW9ja1RyeW9uQVBJLFxuICBtb2NrVHJ5b25SZXNwb25zZSxcbiAgbW9ja0NvbnNvbGUsXG4gIHdhaXRcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3Rlc3RzL3Rlc3RVdGlscyc7XG5pbXBvcnQgdHlwZSB7IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgfSBmcm9tICcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdHlwZXMvdHJ5b24udHlwZXMnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llcyBmb3IgcGVyZm9ybWFuY2UgdGVzdGluZ1xuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvb3B0aW1pc3RpY1VwZGF0ZXMnLCAoKSA9PiAoe1xuICBnZXRPcHRpbWlzdGljVXBkYXRlc01hbmFnZXI6ICgpID0+ICh7XG4gICAgc3RhcnRPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICBvcHRpbWlzdGljSWQ6IGBwZXJmLXRlc3QtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YCxcbiAgICAgIHZhcmlhYmxlczoge30sXG4gICAgICBjb25maWc6IHt9LFxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgcm9sbGJhY2tGdW5jdGlvbnM6IFtdXG4gICAgfSkpLFxuICAgIGNvbXBsZXRlT3B0aW1pc3RpY1VwZGF0ZTogamVzdC5mbigpLFxuICAgIHJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZTogamVzdC5mbigpLFxuICAgIGdldEFjdGl2ZU9wdGltaXN0aWNVcGRhdGVzOiBqZXN0LmZuKCgpID0+IFtdKVxuICB9KSxcbiAgT3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyOiBqZXN0LmZuKClcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvY2FjaGVJbnZhbGlkYXRpb24nLCAoKSA9PiAoe1xuICBpbnZhbGlkYXRlQ2FjaGVBZnRlck11dGF0aW9uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKVxufSkpO1xuXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9pbWFnZVByb2Nlc3NpbmcnLCAoKSA9PiAoe1xuICBwcm9jZXNzSW1hZ2VGb3JUcnlvbjogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgLy8gU2ltdWxhdGUgcmVhbGlzdGljIHByb2Nlc3NpbmcgdGltZVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgICAgcHJvY2Vzc2VkU2l6ZTogMTA0ODU3NixcbiAgICAgICAgICBjb21wcmVzc2lvblJhdGlvOiAwLjUsXG4gICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDUwICsgTWF0aC5yYW5kb20oKSAqIDEwMCwgLy8gNTAtMTUwbXNcbiAgICAgICAgICBwcm9jZXNzZWRJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQscHJvY2Vzc2VkLWltYWdlJyxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAgfSxcbiAgICAgICAgICAgIHByb2Nlc3NlZERpbWVuc2lvbnM6IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogMTUzNiB9LFxuICAgICAgICAgICAgZm9ybWF0OiAnanBlZycsXG4gICAgICAgICAgICBxdWFsaXR5OiAwLjlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgNTAgKyBNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICB9KTtcbiAgfSlcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvZXJyb3JIYW5kbGluZycsICgpID0+ICh7XG4gIGNsYXNzaWZ5VHJ5b25FcnJvcjogamVzdC5mbigoKSA9PiAoeyB1c2VyTWVzc2FnZTogJ0Vycm9yJywgdGVjaG5pY2FsTWVzc2FnZTogJ0Vycm9yJywgZXJyb3JDb2RlOiAnVEVTVCcsIHJldHJ5YWJsZTogZmFsc2UsIGNhdGVnb3J5OiAnVEVTVCcsIHNldmVyaXR5OiAnTUVESVVNJywgcmVjb3ZlcnlBY3Rpb25zOiBbXSB9KSksXG4gIGxvZ0FuZENsYXNzaWZ5RXJyb3I6IGplc3QuZm4oKCkgPT4gKHsgdXNlck1lc3NhZ2U6ICdFcnJvcicsIHRlY2huaWNhbE1lc3NhZ2U6ICdFcnJvcicsIGVycm9yQ29kZTogJ1RFU1QnLCByZXRyeWFibGU6IGZhbHNlLCBjYXRlZ29yeTogJ1RFU1QnLCBzZXZlcml0eTogJ01FRElVTScsIHJlY292ZXJ5QWN0aW9uczogW10gfSkpLFxuICBpc0Vycm9yUmV0cnlhYmxlOiBqZXN0LmZuKCgpID0+IGZhbHNlKVxufSkpO1xuXG5kZXNjcmliZSgnTXV0YXRpb24gUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBxdWVyeUNsaWVudDogUXVlcnlDbGllbnQ7XG4gIGxldCBjb25zb2xlUmVmOiBSZXR1cm5UeXBlPHR5cGVvZiBtb2NrQ29uc29sZT47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgcXVlcnlDbGllbnQgPSBjcmVhdGVUZXN0UXVlcnlDbGllbnQoKTtcbiAgICBjb25zb2xlUmVmID0gbW9ja0NvbnNvbGUoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBxdWVyeUNsaWVudC5jbGVhcigpO1xuICAgIGNvbnNvbGVSZWYucmVzdG9yZSgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2luZ2xlIE11dGF0aW9uIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29tcGxldGUgYmFzaWMgbXV0YXRpb24gd2l0aGluIHBlcmZvcm1hbmNlIHRocmVzaG9sZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSwgdW5kZWZpbmVkLCAyMDApOyAvLyAyMDBtcyBBUEkgZGVsYXlcblxuICAgICAgY29uc3QgdGVzdFZhcmlhYmxlczogVHJ5b25NdXRhdGlvblZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1tb2RlbCcsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LWFwcGFyZWwnXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKHRlc3RWYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMSBzZWNvbmRcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tUcnlvblJlc3BvbnNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIGJhc2U2NCBpbWFnZXMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgMzAwKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbGFyZ2UgYmFzZTY0IHN0cmluZyB0byBzaW11bGF0ZSByZWFsIGltYWdlIGRhdGFcbiAgICAgIGNvbnN0IGxhcmdlQmFzZTY0ID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJyArICdBJy5yZXBlYXQoMTAwMDAwMCk7IC8vIH4xTUIgYmFzZTY0XG4gICAgICBcbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IGxhcmdlQmFzZTY0LFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbbGFyZ2VCYXNlNjQsIGxhcmdlQmFzZTY0XSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKHRlc3RWYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTUwMCk7IC8vIFNob3VsZCBoYW5kbGUgbGFyZ2UgaW1hZ2VzIHdpdGhpbiAxLjUgc2Vjb25kc1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIEZpbGUgb2JqZWN0cyB3aXRoaW4gcmVhc29uYWJsZSB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlLCB1bmRlZmluZWQsIDI1MCk7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoXG4gICAgICAgIFtuZXcgQXJyYXlCdWZmZXIoNSAqIDEwMjQgKiAxMDI0KV0sIC8vIDVNQiBmaWxlXG4gICAgICAgICdsYXJnZS1pbWFnZS5qcGcnLFxuICAgICAgICB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCB0ZXN0VmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiBtb2NrRmlsZSxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW21vY2tGaWxlXSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGltYWdlUHJvY2Vzc2luZzoge1xuICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IDEwMjQsXG4gICAgICAgICAgICB0YXJnZXRIZWlnaHQ6IDE1MzYsXG4gICAgICAgICAgICBtYXhTaXplS0I6IDEwMjQsXG4gICAgICAgICAgICBjb21wcmVzc2lvblF1YWxpdHk6IDAuOVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodGVzdFZhcmlhYmxlcyBhcyBhbnkpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgfSwgeyB0aW1lb3V0OiA1MDAwIH0pO1xuXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDIwMDApOyAvLyBTaG91bGQgcHJvY2VzcyBmaWxlcyB3aXRoaW4gMiBzZWNvbmRzXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25jdXJyZW50IE11dGF0aW9ucyBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBjb25jdXJyZW50IG11dGF0aW9ucyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSwgdW5kZWZpbmVkLCAzMDApO1xuXG4gICAgICBjb25zdCBudW1Db25jdXJyZW50TXV0YXRpb25zID0gNTtcbiAgICAgIGNvbnN0IG11dGF0aW9uczogYW55W10gPSBbXTtcbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICAvLyBDcmVhdGUgbXVsdGlwbGUgbXV0YXRpb24gaG9va3NcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29uY3VycmVudE11dGF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgICApO1xuICAgICAgICBtdXRhdGlvbnMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gU3RhcnQgYWxsIG11dGF0aW9ucyBjb25jdXJyZW50bHlcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi5jdXJyZW50Lm11dGF0ZSh0ZXN0VmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gV2FpdCBmb3IgYWxsIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG11dGF0aW9ucy5ldmVyeShtID0+IG0uY3VycmVudC5pc1N1Y2Nlc3MpKS50b0JlKHRydWUpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAxMDAwMCB9KTtcblxuICAgICAgY29uc3QgdG90YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gU2hvdWxkIGhhbmRsZSA1IGNvbmN1cnJlbnQgd2l0aGluIDUgc2Vjb25kc1xuICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICBleHBlY3QobXV0YXRpb24uY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tUcnlvblJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYmF0Y2ggb3BlcmF0aW9ucyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSwgdW5kZWZpbmVkLCAyMDApO1xuXG4gICAgICBjb25zdCBiYXRjaFNpemUgPSAzO1xuICAgICAgY29uc3QgdGVzdFZhcmlhYmxlc0xpc3Q6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXNbXSA9IEFycmF5LmZyb20oXG4gICAgICAgIHsgbGVuZ3RoOiBiYXRjaFNpemUgfSxcbiAgICAgICAgKF8sIGkpID0+ICh7XG4gICAgICAgICAgbW9kZWxJbWFnZTogYGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1tb2RlbC0ke2l9YCxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbYGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsLSR7aX1gXSxcbiAgICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZUJhdGNoVHJ5b25XaXRoUHJvZ3Jlc3MoKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBsZXQgYmF0Y2hSZXN1bHRzOiBhbnlbXSA9IFtdO1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYmF0Y2hSZXN1bHRzID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQuZXhlY3V0ZUJhdGNoKHRlc3RWYXJpYWJsZXNMaXN0KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDMwMDApOyAvLyBTaG91bGQgaGFuZGxlIGJhdGNoIHdpdGhpbiAzIHNlY29uZHNcbiAgICAgIGV4cGVjdChiYXRjaFJlc3VsdHMpLnRvSGF2ZUxlbmd0aChiYXRjaFNpemUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmJhdGNoUHJvZ3Jlc3MuY29tcGxldGVkKS50b0JlKGJhdGNoU2l6ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgVXNhZ2UgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBub3QgY2F1c2UgbWVtb3J5IGxlYWtzIHdpdGggcmVwZWF0ZWQgbXV0YXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlLCB1bmRlZmluZWQsIDEwMCk7XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbnVtSXRlcmF0aW9ucyA9IDIwO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh0ZXN0VmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzZXQgYmV0d2VlbiBpdGVyYXRpb25zXG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQucmVzZXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU21hbGwgZGVsYXkgdG8gYWxsb3cgY2xlYW51cFxuICAgICAgICBhd2FpdCB3YWl0KDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IGZpbmFsIHN0YXRlIGlzIGNsZWFuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNJZGxlKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYW51cCBvcHRpbWlzdGljIHVwZGF0ZXMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgMTUwKTtcblxuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBlbmFibGVPcHRpbWlzdGljVXBkYXRlczogdHJ1ZSxcbiAgICAgICAgb3B0aW1pc3RpY0NvbmZpZzoge1xuICAgICAgICAgIHNob3dQcmV2aWV3OiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6IHRydWUsXG4gICAgICAgICAgc2hvd1Byb2dyZXNzOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25XaXRoUHJvZ3Jlc3MoY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG51bUl0ZXJhdGlvbnMgPSAxMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgZXhwZWN0KGl0ZXJhdGlvblRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTsgLy8gRWFjaCBpdGVyYXRpb24gc2hvdWxkIGJlIGZhc3RcblxuICAgICAgICAvLyBWZXJpZnkgY2xlYW51cFxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY3VycmVudE9wdGltaXN0aWNJZCkudG9CZU51bGwoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmhhc0FjdGl2ZU9wdGltaXN0aWMpLnRvQmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgaW52YWxpZGF0aW9uIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlLCB1bmRlZmluZWQsIDIwMCk7XG5cbiAgICAgIC8vIFByZS1wb3B1bGF0ZSBjYWNoZSB3aXRoIG1hbnkgZW50cmllc1xuICAgICAgY29uc3QgbnVtQ2FjaGVFbnRyaWVzID0gMTAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DYWNoZUVudHJpZXM7IGkrKykge1xuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoW2B0ZXN0LWNhY2hlLSR7aX1gXSwgeyBkYXRhOiBgZW50cnktJHtpfWAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGNhY2hlSW52YWxpZGF0aW9uQ29uZmlnOiB7XG4gICAgICAgICAgaW52YWxpZGF0ZUhpc3Rvcnk6IHRydWUsXG4gICAgICAgICAgaW52YWxpZGF0ZVVzZXJEYXRhOiB0cnVlLFxuICAgICAgICAgIGludmFsaWRhdGVTdGF0czogdHJ1ZSxcbiAgICAgICAgICBpbnZhbGlkYXRlVGFnczogdHJ1ZSxcbiAgICAgICAgICBwcmVsb2FkUmVsYXRlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbihjb25maWcpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh0ZXN0VmFyaWFibGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDE1MDApOyAvLyBTaG91bGQgaGFuZGxlIGNhY2hlIG9wZXJhdGlvbnMgZWZmaWNpZW50bHlcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGVyZm9ybSB3ZWxsIHdpdGggbGFyZ2UgcXVlcnkgY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgMTAwKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbGFyZ2UgcXVlcnkgY2FjaGVcbiAgICAgIGNvbnN0IG51bVF1ZXJpZXMgPSA1MDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVF1ZXJpZXM7IGkrKykge1xuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoW2BsYXJnZS1jYWNoZS0ke2l9YF0sIHtcbiAgICAgICAgICBkYXRhOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGopID0+ICh7IGlkOiBqLCB2YWx1ZTogYGl0ZW0tJHtpfS0ke2p9YCB9KSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh0ZXN0VmFyaWFibGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDApOyAvLyBTaG91bGQgbm90IGJlIHNpZ25pZmljYW50bHkgc2xvd2VkIGJ5IGxhcmdlIGNhY2hlXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXRyaWVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGF0dGVtcHRDb3VudCA9IDA7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgYXR0ZW1wdENvdW50Kys7XG4gICAgICAgIGlmIChhdHRlbXB0Q291bnQgPD0gMikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBlcnJvcjogJ1NlcnZlciBFcnJvcicgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1RyeW9uUmVzcG9uc2UpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgZW5hYmxlUmV0cnk6IHRydWUsXG4gICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICAgIGluaXRpYWxSZXRyeURlbGF5OiA1MCAvLyBGYXN0IHJldHJpZXMgZm9yIHRlc3RpbmdcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbihjb25maWcpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh0ZXN0VmFyaWFibGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KTtcblxuICAgICAgY29uc3QgdG90YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTsgLy8gU2hvdWxkIGhhbmRsZSByZXRyaWVzIHF1aWNrbHlcbiAgICAgIGV4cGVjdChhdHRlbXB0Q291bnQpLnRvQmUoMyk7IC8vIEluaXRpYWwgKyAyIHJldHJpZXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYW51cCBlZmZpY2llbnRseSBhZnRlciBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcignQVBJIEVycm9yJyk7XG4gICAgICBtb2NrVHJ5b25BUEkodW5kZWZpbmVkLCBhcGlFcnJvcik7XG5cbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgZW5hYmxlT3B0aW1pc3RpY1VwZGF0ZXM6IHRydWUsXG4gICAgICAgIG9wdGltaXN0aWNDb25maWc6IHtcbiAgICAgICAgICBzaG93UHJldmlldzogdHJ1ZSxcbiAgICAgICAgICB1cGRhdGVIaXN0b3J5OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25XaXRoUHJvZ3Jlc3MoY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmV4ZWN1dGVUcnlvbih0ZXN0VmFyaWFibGVzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBFeHBlY3RlZCB0byBmYWlsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlVHJ1dGh5KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdG90YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbig1MDApOyAvLyBFcnJvciBoYW5kbGluZyBzaG91bGQgYmUgZmFzdFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRPcHRpbWlzdGljSWQpLnRvQmVOdWxsKCk7IC8vIFNob3VsZCBjbGVhbnVwIG9wdGltaXN0aWMgc3RhdGVcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jlc291cmNlIENsZWFudXAgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhbnVwIHJlc291cmNlcyBxdWlja2x5IG9uIGNvbXBvbmVudCB1bm1vdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlLCB1bmRlZmluZWQsIDEwMDApOyAvLyBMb25nIGRlbGF5XG5cbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgZW5hYmxlT3B0aW1pc3RpY1VwZGF0ZXM6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgdW5tb3VudCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25XaXRoUHJvZ3Jlc3MoY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIFN0YXJ0IG11dGF0aW9uXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcykuY2F0Y2goKCkgPT4ge30pOyAvLyBJZ25vcmUgcmVqZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5tb3VudFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFVubW91bnQgY29tcG9uZW50XG4gICAgICB1bm1vdW50KCk7XG5cbiAgICAgIGNvbnN0IHVubW91bnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB1bm1vdW50U3RhcnQ7XG5cbiAgICAgIGV4cGVjdCh1bm1vdW50VGltZSkudG9CZUxlc3NUaGFuKDEwMCk7IC8vIFVubW91bnQgc2hvdWxkIGJlIHZlcnkgZmFzdFxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldE9wdGltaXN0aWNVcGRhdGVzTWFuYWdlciIsInN0YXJ0T3B0aW1pc3RpY1VwZGF0ZSIsImZuIiwib3B0aW1pc3RpY0lkIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ2YXJpYWJsZXMiLCJjb25maWciLCJzdGFydFRpbWUiLCJyb2xsYmFja0Z1bmN0aW9ucyIsImNvbXBsZXRlT3B0aW1pc3RpY1VwZGF0ZSIsInJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSIsImdldEFjdGl2ZU9wdGltaXN0aWNVcGRhdGVzIiwiT3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyIiwiaW52YWxpZGF0ZUNhY2hlQWZ0ZXJNdXRhdGlvbiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidW5kZWZpbmVkIiwicHJvY2Vzc0ltYWdlRm9yVHJ5b24iLCJtb2NrSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJvcmlnaW5hbFNpemUiLCJwcm9jZXNzZWRTaXplIiwiY29tcHJlc3Npb25SYXRpbyIsInByb2Nlc3NpbmdUaW1lIiwicHJvY2Vzc2VkSW1hZ2UiLCJtZXRhZGF0YSIsIm9yaWdpbmFsRGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0IiwicHJvY2Vzc2VkRGltZW5zaW9ucyIsImZvcm1hdCIsInF1YWxpdHkiLCJjbGFzc2lmeVRyeW9uRXJyb3IiLCJ1c2VyTWVzc2FnZSIsInRlY2huaWNhbE1lc3NhZ2UiLCJlcnJvckNvZGUiLCJyZXRyeWFibGUiLCJjYXRlZ29yeSIsInNldmVyaXR5IiwicmVjb3ZlcnlBY3Rpb25zIiwibG9nQW5kQ2xhc3NpZnlFcnJvciIsImlzRXJyb3JSZXRyeWFibGUiLCJkZXNjcmliZSIsInF1ZXJ5Q2xpZW50IiwiY29uc29sZVJlZiIsImJlZm9yZUVhY2giLCJjcmVhdGVUZXN0UXVlcnlDbGllbnQiLCJtb2NrQ29uc29sZSIsImNsZWFyQWxsTW9ja3MiLCJhZnRlckVhY2giLCJjbGVhciIsInJlc3RvcmUiLCJpdCIsIm1vY2tUcnlvbkFQSSIsIm1vY2tUcnlvblJlc3BvbnNlIiwidGVzdFZhcmlhYmxlcyIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwib3B0aW9ucyIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VUcnlvbk11dGF0aW9uIiwid3JhcHBlciIsImNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlciIsInBlcmZvcm1hbmNlIiwiYWN0IiwiY3VycmVudCIsIm11dGF0ZSIsIndhaXRGb3IiLCJleHBlY3QiLCJpc1N1Y2Nlc3MiLCJ0b0JlIiwidG90YWxUaW1lIiwidG9CZUxlc3NUaGFuIiwiZGF0YSIsInRvRXF1YWwiLCJsYXJnZUJhc2U2NCIsInJlcGVhdCIsIm1vY2tGaWxlIiwiRmlsZSIsIkFycmF5QnVmZmVyIiwidHlwZSIsImltYWdlUHJvY2Vzc2luZyIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwibWF4U2l6ZUtCIiwiY29tcHJlc3Npb25RdWFsaXR5IiwidGltZW91dCIsIm51bUNvbmN1cnJlbnRNdXRhdGlvbnMiLCJtdXRhdGlvbnMiLCJpIiwicHVzaCIsImZvckVhY2giLCJtdXRhdGlvbiIsImV2ZXJ5IiwibSIsImJhdGNoU2l6ZSIsInRlc3RWYXJpYWJsZXNMaXN0IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsInVzZUJhdGNoVHJ5b25XaXRoUHJvZ3Jlc3MiLCJiYXRjaFJlc3VsdHMiLCJleGVjdXRlQmF0Y2giLCJ0b0hhdmVMZW5ndGgiLCJiYXRjaFByb2dyZXNzIiwiY29tcGxldGVkIiwibnVtSXRlcmF0aW9ucyIsInJlc2V0Iiwid2FpdCIsImlzSWRsZSIsInRvQmVVbmRlZmluZWQiLCJlcnJvciIsInRvQmVOdWxsIiwiZW5hYmxlT3B0aW1pc3RpY1VwZGF0ZXMiLCJvcHRpbWlzdGljQ29uZmlnIiwic2hvd1ByZXZpZXciLCJ1cGRhdGVIaXN0b3J5Iiwic2hvd1Byb2dyZXNzIiwidXNlVHJ5b25XaXRoUHJvZ3Jlc3MiLCJleGVjdXRlVHJ5b24iLCJpdGVyYXRpb25UaW1lIiwiY3VycmVudE9wdGltaXN0aWNJZCIsImhhc0FjdGl2ZU9wdGltaXN0aWMiLCJudW1DYWNoZUVudHJpZXMiLCJzZXRRdWVyeURhdGEiLCJjYWNoZUludmFsaWRhdGlvbkNvbmZpZyIsImludmFsaWRhdGVIaXN0b3J5IiwiaW52YWxpZGF0ZVVzZXJEYXRhIiwiaW52YWxpZGF0ZVN0YXRzIiwiaW52YWxpZGF0ZVRhZ3MiLCJwcmVsb2FkUmVsYXRlZCIsIm51bVF1ZXJpZXMiLCJqIiwiaWQiLCJ2YWx1ZSIsImF0dGVtcHRDb3VudCIsImdsb2JhbCIsImZldGNoIiwib2siLCJzdGF0dXMiLCJqc29uIiwiZW5hYmxlUmV0cnkiLCJtYXhSZXRyaWVzIiwiaW5pdGlhbFJldHJ5RGVsYXkiLCJhcGlFcnJvciIsIkVycm9yIiwidG9CZVRydXRoeSIsInVubW91bnQiLCJjYXRjaCIsInVubW91bnRTdGFydCIsInVubW91bnRUaW1lIl0sIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUM7QUFDekMsdUVBQXVFOztBQWdCdkUsNENBQTRDO0FBQzVDQSxLQUFLQyxJQUFJLENBQUMsdURBQXVELElBQU8sQ0FBQTtRQUN0RUMsNkJBQTZCLElBQU8sQ0FBQTtnQkFDbENDLHVCQUF1QkgsS0FBS0ksRUFBRSxDQUFDLElBQU8sQ0FBQTt3QkFDcENDLGNBQWMsQ0FBQyxVQUFVLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDLEVBQUVDLEtBQUtDLE1BQU0sSUFBSTt3QkFDeERDLFdBQVcsQ0FBQzt3QkFDWkMsUUFBUSxDQUFDO3dCQUNUQyxXQUFXTixLQUFLQyxHQUFHO3dCQUNuQk0sbUJBQW1CLEVBQUU7b0JBQ3ZCLENBQUE7Z0JBQ0FDLDBCQUEwQmQsS0FBS0ksRUFBRTtnQkFDakNXLDBCQUEwQmYsS0FBS0ksRUFBRTtnQkFDakNZLDRCQUE0QmhCLEtBQUtJLEVBQUUsQ0FBQyxJQUFNLEVBQUU7WUFDOUMsQ0FBQTtRQUNB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