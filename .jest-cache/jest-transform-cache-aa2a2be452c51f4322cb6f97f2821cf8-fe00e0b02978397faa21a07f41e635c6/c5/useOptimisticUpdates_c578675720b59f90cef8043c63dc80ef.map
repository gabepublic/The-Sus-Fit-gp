{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/hooks/useOptimisticUpdates.ts"],"sourcesContent":["// Optimistic Updates Hooks\n// React hooks for managing optimistic UI updates and progress indicators\n\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useCallback, useMemo, useRef, useEffect } from 'react';\nimport type {\n  OptimisticUpdateConfig,\n  OptimisticUpdateContext,\n  OptimisticUpdatesManager\n} from '../utils/optimisticUpdates';\nimport { getOptimisticUpdatesManager } from '../utils/optimisticUpdates';\n\n/**\n * Progress data structure for try-on operations\n */\nexport interface TryonProgress {\n  id: string;\n  status: 'processing' | 'completed' | 'error';\n  progress: number; // 0-100\n  stage: string;\n  estimatedTimeRemaining: number;\n  startTime: number;\n  completedAt?: number;\n  error?: string;\n  result?: unknown;\n}\n\n/**\n * Hook return type for optimistic updates\n */\nexport interface UseOptimisticUpdatesReturn {\n  /** Start an optimistic update */\n  startOptimistic: (config?: OptimisticUpdateConfig) => string;\n  /** Complete an optimistic update */\n  completeOptimistic: (optimisticId: string, result: unknown, context?: unknown) => void;\n  /** Rollback an optimistic update */\n  rollbackOptimistic: (optimisticId: string, error?: unknown) => void;\n  /** Check if optimistic updates are enabled */\n  isOptimisticEnabled: boolean;\n  /** Get current active optimistic updates */\n  activeUpdates: OptimisticUpdateContext[];\n}\n\n/**\n * Configuration for the optimistic updates hook\n */\nexport interface UseOptimisticUpdatesConfig {\n  /** Variables for the try-on mutation */\n  mutationVariables?: unknown;\n  /** Whether optimistic updates are enabled */\n  enabled?: boolean;\n  /** Custom optimistic updates manager */\n  optimisticManager?: OptimisticUpdatesManager;\n}\n\n/**\n * Hook for managing optimistic updates during try-on mutations\n */\nexport function useOptimisticUpdates(\n  config: UseOptimisticUpdatesConfig = {}\n): UseOptimisticUpdatesReturn {\n  const queryClient = useQueryClient();\n  const optimisticManager = config.optimisticManager || getOptimisticUpdatesManager();\n  const activeUpdatesRef = useRef<Set<string>>(new Set());\n\n  const isOptimisticEnabled = config.enabled !== false;\n\n  // Get active optimistic updates\n  const activeUpdates = useMemo(() => {\n    return optimisticManager.getActiveOptimisticUpdates();\n  }, [optimisticManager]);\n\n  const startOptimistic = useCallback((optimisticConfig?: OptimisticUpdateConfig): string => {\n    if (!isOptimisticEnabled || !config.mutationVariables) {\n      return '';\n    }\n\n    const context = optimisticManager.startOptimisticUpdate(\n      config.mutationVariables as any,\n      optimisticConfig\n    );\n\n    activeUpdatesRef.current.add(context.optimisticId);\n    return context.optimisticId;\n  }, [isOptimisticEnabled, config.mutationVariables, optimisticManager]);\n\n  const completeOptimistic = useCallback((\n    optimisticId: string,\n    result: unknown,\n    mutationContext?: unknown\n  ) => {\n    if (!optimisticId || !activeUpdatesRef.current.has(optimisticId)) {\n      return;\n    }\n\n    optimisticManager.completeOptimisticUpdate(\n      optimisticId,\n      result as any,\n      mutationContext as any\n    );\n\n    activeUpdatesRef.current.delete(optimisticId);\n  }, [optimisticManager]);\n\n  const rollbackOptimistic = useCallback((optimisticId: string, error?: unknown) => {\n    if (!optimisticId || !activeUpdatesRef.current.has(optimisticId)) {\n      return;\n    }\n\n    optimisticManager.rollbackOptimisticUpdate(optimisticId, error);\n    activeUpdatesRef.current.delete(optimisticId);\n  }, [optimisticManager]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Rollback any remaining optimistic updates\n      activeUpdatesRef.current.forEach(optimisticId => {\n        optimisticManager.rollbackOptimisticUpdate(optimisticId, new Error('Component unmounted'));\n      });\n      activeUpdatesRef.current.clear();\n    };\n  }, [optimisticManager]);\n\n  return {\n    startOptimistic,\n    completeOptimistic,\n    rollbackOptimistic,\n    isOptimisticEnabled,\n    activeUpdates\n  };\n}\n\n/**\n * Hook for tracking progress of try-on operations\n */\nexport function useTryonProgress(optimisticId: string): {\n  progress: TryonProgress | undefined;\n  isLoading: boolean;\n  error: Error | null;\n} {\n  const progressQuery = useQuery({\n    queryKey: ['tryon-progress', optimisticId],\n    enabled: Boolean(optimisticId),\n    refetchInterval: (data) => {\n      // Stop refetching once completed or errored\n      const progressData = data as unknown as TryonProgress | undefined;\n      return progressData?.status === 'processing' ? 500 : false;\n    },\n    staleTime: 0, // Always fresh for real-time updates\n    gcTime: 5000 // Keep in cache briefly after completion\n  });\n\n  return {\n    progress: progressQuery.data as TryonProgress | undefined,\n    isLoading: progressQuery.isLoading,\n    error: progressQuery.error\n  };\n}\n\n/**\n * Hook for tracking multiple try-on progress instances\n */\nexport function useMultipleTryonProgress(optimisticIds: string[]): {\n  progressMap: Record<string, TryonProgress>;\n  anyInProgress: boolean;\n  allCompleted: boolean;\n} {\n  const queries = optimisticIds.map(id => \n    useQuery({\n      queryKey: ['tryon-progress', id],\n      enabled: Boolean(id),\n      refetchInterval: 500,\n      staleTime: 0\n    })\n  );\n\n  const progressMap = useMemo(() => {\n    const map: Record<string, TryonProgress> = {};\n    optimisticIds.forEach((id, index) => {\n      const data = queries[index]?.data as TryonProgress | undefined;\n      if (data) {\n        map[id] = data;\n      }\n    });\n    return map;\n  }, [optimisticIds, queries]);\n\n  const anyInProgress = useMemo(() => {\n    return Object.values(progressMap).some(progress => progress.status === 'processing');\n  }, [progressMap]);\n\n  const allCompleted = useMemo(() => {\n    return optimisticIds.length > 0 && \n           Object.keys(progressMap).length === optimisticIds.length &&\n           Object.values(progressMap).every(progress => progress.status !== 'processing');\n  }, [optimisticIds, progressMap]);\n\n  return {\n    progressMap,\n    anyInProgress,\n    allCompleted\n  };\n}\n\n/**\n * Hook for getting try-on results\n */\nexport function useTryonResult(optimisticId: string): {\n  result: unknown;\n  isLoading: boolean;\n  isCompleted: boolean;\n  error: Error | null;\n  processingTime?: number;\n} {\n  const resultQuery = useQuery({\n    queryKey: ['tryon-result', optimisticId],\n    enabled: Boolean(optimisticId),\n    staleTime: Infinity, // Results don't change once set\n    gcTime: 60000 // Keep results for 1 minute\n  });\n\n  const data = resultQuery.data as any;\n  \n  return {\n    result: data?.result,\n    isLoading: resultQuery.isLoading,\n    isCompleted: data?.status === 'completed',\n    error: resultQuery.error,\n    processingTime: data?.processingTime\n  };\n}\n\n/**\n * Hook for progress visualization and UI feedback\n */\nexport function useProgressVisualization(\n  optimisticId: string,\n  config: {\n    enableStageMessages?: boolean;\n    enableTimeEstimates?: boolean;\n    enableAnimation?: boolean;\n  } = {}\n): {\n  progress: TryonProgress | undefined;\n  progressPercentage: number;\n  stageMessage: string;\n  timeRemaining: string;\n  progressColor: string;\n  isAnimating: boolean;\n} {\n  const { progress } = useTryonProgress(optimisticId);\n  \n  const progressPercentage = progress?.progress || 0;\n  \n  const stageMessage = useMemo(() => {\n    if (!config.enableStageMessages || !progress) return '';\n    \n    switch (progress.stage) {\n      case 'image-processing':\n        return 'Processing images...';\n      case 'ai-generation':\n        return 'Generating your try-on...';\n      case 'post-processing':\n        return 'Adding final touches...';\n      case 'finalizing':\n        return 'Almost done...';\n      case 'completed':\n        return 'Complete!';\n      case 'error':\n        return 'Something went wrong';\n      default:\n        return 'Processing...';\n    }\n  }, [config.enableStageMessages, progress]);\n  \n  const timeRemaining = useMemo(() => {\n    if (!config.enableTimeEstimates || !progress?.estimatedTimeRemaining) return '';\n    \n    const seconds = Math.ceil(progress.estimatedTimeRemaining / 1000);\n    if (seconds <= 0) return '';\n    if (seconds < 60) return `${seconds}s remaining`;\n    \n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}m ${remainingSeconds}s remaining`;\n  }, [config.enableTimeEstimates, progress]);\n  \n  const progressColor = useMemo(() => {\n    if (!progress) return '#e5e7eb';\n    \n    switch (progress.status) {\n      case 'processing':\n        return '#3b82f6'; // Blue for processing\n      case 'completed':\n        return '#10b981'; // Green for completed\n      case 'error':\n        return '#ef4444'; // Red for error\n      default:\n        return '#e5e7eb'; // Gray for idle\n    }\n  }, [progress]);\n  \n  const isAnimating = useMemo(() => {\n    return config.enableAnimation !== false && \n           progress?.status === 'processing';\n  }, [config.enableAnimation, progress]);\n\n  return {\n    progress,\n    progressPercentage,\n    stageMessage,\n    timeRemaining,\n    progressColor,\n    isAnimating\n  };\n}\n\n/**\n * Hook for optimistic cache invalidation strategies\n */\nexport function useOptimisticCacheInvalidation(): {\n  invalidateRelatedQueries: (context?: { userId?: string; tags?: string[] }) => Promise<void>;\n  preloadRelatedQueries: (context?: { userId?: string }) => Promise<void>;\n  warmupCache: (prefetchData?: unknown[]) => Promise<void>;\n} {\n  const queryClient = useQueryClient();\n\n  const invalidateRelatedQueries = useCallback(async (context?: { userId?: string; tags?: string[] }) => {\n    // Invalidate history queries\n    await queryClient.invalidateQueries({ \n      queryKey: ['tryon-history'],\n      exact: false \n    });\n\n    // Invalidate user-specific queries if userId provided\n    if (context?.userId) {\n      await queryClient.invalidateQueries({ \n        queryKey: ['user-data', context.userId],\n        exact: false \n      });\n    }\n\n    // Invalidate tag-specific queries if tags provided\n    if (context?.tags?.length) {\n      for (const tag of context.tags) {\n        await queryClient.invalidateQueries({ \n          queryKey: ['tryon-by-tag', tag],\n          exact: false \n        });\n      }\n    }\n\n    // Invalidate stats and aggregations\n    await queryClient.invalidateQueries({ \n      queryKey: ['tryon-stats'],\n      exact: false \n    });\n  }, [queryClient]);\n\n  const preloadRelatedQueries = useCallback(async (context?: { userId?: string }) => {\n    // Preload frequently accessed queries\n    const preloadPromises = [];\n\n    // Preload history\n    preloadPromises.push(\n      queryClient.prefetchQuery({\n        queryKey: ['tryon-history', 'entries'],\n        staleTime: 30000\n      })\n    );\n\n    // Preload stats\n    preloadPromises.push(\n      queryClient.prefetchQuery({\n        queryKey: ['tryon-history', 'stats'],\n        staleTime: 60000\n      })\n    );\n\n    if (context?.userId) {\n      preloadPromises.push(\n        queryClient.prefetchQuery({\n          queryKey: ['user-data', context.userId],\n          staleTime: 60000\n        })\n      );\n    }\n\n    await Promise.all(preloadPromises);\n  }, [queryClient]);\n\n  const warmupCache = useCallback(async (prefetchData?: unknown[]) => {\n    // Warm up the cache with commonly used data\n    if (prefetchData?.length) {\n      prefetchData.forEach((data, index) => {\n        queryClient.setQueryData(['warmup-cache', index], data);\n      });\n    }\n\n    // Prefetch critical queries that are likely to be needed\n    await preloadRelatedQueries();\n  }, [queryClient, preloadRelatedQueries]);\n\n  return {\n    invalidateRelatedQueries,\n    preloadRelatedQueries,\n    warmupCache\n  };\n}"],"names":["useMultipleTryonProgress","useOptimisticCacheInvalidation","useOptimisticUpdates","useProgressVisualization","useTryonProgress","useTryonResult","config","queryClient","useQueryClient","optimisticManager","getOptimisticUpdatesManager","activeUpdatesRef","useRef","Set","isOptimisticEnabled","enabled","activeUpdates","useMemo","getActiveOptimisticUpdates","startOptimistic","useCallback","optimisticConfig","mutationVariables","context","startOptimisticUpdate","current","add","optimisticId","completeOptimistic","result","mutationContext","has","completeOptimisticUpdate","delete","rollbackOptimistic","error","rollbackOptimisticUpdate","useEffect","forEach","Error","clear","progressQuery","useQuery","queryKey","Boolean","refetchInterval","data","progressData","status","staleTime","gcTime","progress","isLoading","optimisticIds","queries","map","id","progressMap","index","anyInProgress","Object","values","some","allCompleted","length","keys","every","resultQuery","Infinity","isCompleted","processingTime","progressPercentage","stageMessage","enableStageMessages","stage","timeRemaining","enableTimeEstimates","estimatedTimeRemaining","seconds","Math","ceil","minutes","floor","remainingSeconds","progressColor","isAnimating","enableAnimation","invalidateRelatedQueries","invalidateQueries","exact","userId","tags","tag","preloadRelatedQueries","preloadPromises","push","prefetchQuery","Promise","all","warmupCache","prefetchData","setQueryData"],"mappings":"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"}