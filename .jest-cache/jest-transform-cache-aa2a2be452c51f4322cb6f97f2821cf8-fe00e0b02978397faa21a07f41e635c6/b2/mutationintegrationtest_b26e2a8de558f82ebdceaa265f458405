278452c9e94add5f3fac3fc888b22124
// Integration Tests for Try-On Mutation System
// End-to-end tests covering the complete mutation flow
"use strict";
jest.mock('../../../src/business-layer/utils/optimisticUpdates', ()=>({
        getOptimisticUpdatesManager: ()=>mockOptimisticManager,
        OptimisticUpdatesManager: jest.fn(()=>mockOptimisticManager),
        initializeOptimisticUpdates: jest.fn(()=>mockOptimisticManager)
    }));
jest.mock('../../../src/business-layer/utils/cacheInvalidation', ()=>({
        invalidateCacheAfterMutation: mockCacheManager.invalidateAfterSuccess,
        getCacheInvalidationManager: ()=>mockCacheManager,
        initializeCacheInvalidation: jest.fn(()=>mockCacheManager)
    }));
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        processImageForTryon: jest.fn().mockResolvedValue({
            originalSize: 2048576,
            processedSize: 1048576,
            compressionRatio: 0.5,
            processingTime: 123,
            processedImage: 'data:image/jpeg;base64,processed-image',
            metadata: {
                originalDimensions: {
                    width: 1920,
                    height: 1080
                },
                processedDimensions: {
                    width: 1024,
                    height: 1536
                },
                format: 'jpeg',
                quality: 0.9
            }
        })
    }));
jest.mock('../../../src/business-layer/utils/errorHandling', ()=>({
        classifyTryonError: jest.fn((error)=>({
                userMessage: error.message || 'An error occurred',
                technicalMessage: error.message || 'Unknown error',
                errorCode: error.code || 'UNKNOWN_ERROR',
                retryable: false,
                category: 'NETWORK_ERROR',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        logAndClassifyError: jest.fn((error)=>({
                userMessage: error.message || 'An error occurred',
                technicalMessage: error.message || 'Unknown error',
                errorCode: error.code || 'UNKNOWN_ERROR',
                retryable: false,
                category: 'NETWORK_ERROR',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        isErrorRetryable: jest.fn(()=>true)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useTryonMutation = require("../../../src/business-layer/mutations/useTryonMutation");
const _useTryonWithProgress = require("../../../src/business-layer/hooks/useTryonWithProgress");
const _testUtils = require("../../../src/business-layer/tests/testUtils");
// Real implementation mocks for integration testing
const mockOptimisticManager = {
    startOptimisticUpdate: jest.fn(),
    completeOptimisticUpdate: jest.fn(),
    rollbackOptimisticUpdate: jest.fn(),
    getActiveOptimisticUpdates: jest.fn(()=>[]),
    isOptimisticUpdateActive: jest.fn(()=>false)
};
const mockCacheManager = {
    invalidateAfterSuccess: jest.fn(),
    invalidateAfterError: jest.fn(),
    warmCache: jest.fn(),
    cleanupStaleCache: jest.fn()
};
describe('Mutation Integration Tests', ()=>{
    let queryClient;
    let consoleRef;
    beforeEach(()=>{
        queryClient = (0, _testUtils.createTestQueryClient)();
        consoleRef = (0, _testUtils.mockConsole)();
        jest.clearAllMocks();
        // Setup default optimistic manager behavior
        mockOptimisticManager.startOptimisticUpdate.mockReturnValue({
            optimisticId: 'integration-test-optimistic-id',
            variables: {},
            config: {},
            startTime: Date.now(),
            rollbackFunctions: []
        });
    });
    afterEach(()=>{
        queryClient.clear();
        consoleRef.restore();
    });
    describe('Complete Success Flow', ()=>{
        it('should execute complete mutation flow with all integrations', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {
                    quality: 'high',
                    timeout: 10000
                }
            };
            const config = {
                enableOptimisticUpdates: true,
                optimisticConfig: {
                    showPreview: true,
                    updateHistory: true,
                    showProgress: true
                },
                cacheInvalidationConfig: {
                    invalidateHistory: true,
                    invalidateUserData: true,
                    invalidateStats: true
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Execute mutation
            let mutationResult;
            await (0, _react.act)(async ()=>{
                mutationResult = await result.current.executeTryon(testVariables);
            });
            // Verify result
            expect(mutationResult).toEqual(_testUtils.mockTryonResponse);
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            // Verify optimistic updates were handled
            expect(mockOptimisticManager.startOptimisticUpdate).toHaveBeenCalledWith(expect.objectContaining(testVariables), expect.objectContaining({
                showPreview: true,
                updateHistory: true,
                showProgress: true
            }));
            expect(mockOptimisticManager.completeOptimisticUpdate).toHaveBeenCalledWith('integration-test-optimistic-id', _testUtils.mockTryonResponse, expect.any(Object));
            // Verify cache invalidation was triggered
            expect(mockCacheManager.invalidateAfterSuccess).toHaveBeenCalledWith(queryClient, _testUtils.mockTryonResponse, expect.objectContaining(testVariables), expect.any(Object), expect.objectContaining({
                invalidateHistory: true,
                invalidateUserData: true,
                invalidateStats: true
            }));
        });
        it('should handle File objects in complete flow', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const testVariables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: {
                    imageProcessing: {
                        targetWidth: 1024,
                        targetHeight: 1536,
                        maxSizeKB: 1024,
                        compressionQuality: 0.9
                    }
                }
            };
            const config = {
                enableOptimisticUpdates: true,
                optimisticConfig: {
                    showPreview: true
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                await result.current.executeTryon(testVariables);
            });
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            // Verify image processing was called
            const { processImageForTryon } = require('../../../src/business-layer/utils/imageProcessing');
            expect(processImageForTryon).toHaveBeenCalledTimes(2); // model + apparel
        });
        it('should maintain proper state transitions during mutation', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 200); // Add delay
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Initial state
            expect(result.current.isIdle).toBe(true);
            expect(result.current.isLoading).toBe(false);
            // Start mutation
            let mutationPromise;
            await (0, _react.act)(async ()=>{
                mutationPromise = result.current.executeTryon(testVariables);
            });
            // Should be loading
            expect(result.current.isLoading).toBe(true);
            expect(result.current.isIdle).toBe(false);
            // Wait for completion
            await (0, _react.act)(async ()=>{
                await mutationPromise;
            });
            // Should be success
            expect(result.current.isSuccess).toBe(true);
            expect(result.current.isLoading).toBe(false);
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
        });
    });
    describe('Complete Error Flow', ()=>{
        it('should execute complete error flow with rollbacks', async ()=>{
            const apiError = {
                ..._testUtils.mockTryonError,
                message: 'API request failed'
            };
            (0, _testUtils.mockTryonAPI)(undefined, apiError);
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const config = {
                enableOptimisticUpdates: true,
                optimisticConfig: {
                    showPreview: true,
                    updateHistory: true
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            let mutationError;
            await (0, _react.act)(async ()=>{
                try {
                    await result.current.executeTryon(testVariables);
                } catch (error) {
                    mutationError = error;
                }
            });
            // Verify error state
            expect(mutationError).toBeDefined();
            expect(result.current.error).toBeTruthy();
            expect(result.current.isError).toBe(true);
            expect(result.current.data).toBeUndefined();
            // Verify optimistic updates were rolled back
            expect(mockOptimisticManager.startOptimisticUpdate).toHaveBeenCalled();
            expect(mockOptimisticManager.rollbackOptimisticUpdate).toHaveBeenCalledWith('integration-test-optimistic-id', expect.any(Error));
            // Complete optimistic update should not have been called
            expect(mockOptimisticManager.completeOptimisticUpdate).not.toHaveBeenCalled();
        });
        it('should handle image processing errors in complete flow', async ()=>{
            const { processImageForTryon } = require('../../../src/business-layer/utils/imageProcessing');
            processImageForTryon.mockRejectedValueOnce(new Error('Image processing failed'));
            const mockFile = new File([
                'invalid content'
            ], 'test.txt', {
                type: 'text/plain'
            });
            const testVariables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)({
                    enableOptimisticUpdates: true
                }), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            let error;
            await (0, _react.act)(async ()=>{
                try {
                    await result.current.executeTryon(testVariables);
                } catch (e) {
                    error = e;
                }
            });
            expect(error).toBeDefined();
            expect(result.current.error).toBeTruthy();
            // Should still attempt optimistic rollback
            expect(mockOptimisticManager.rollbackOptimisticUpdate).toHaveBeenCalled();
        });
        it('should handle partial failures gracefully', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            // Mock cache invalidation to fail
            mockCacheManager.invalidateAfterSuccess.mockRejectedValueOnce(new Error('Cache invalidation failed'));
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                await result.current.executeTryon(testVariables);
            });
            // Mutation should still succeed
            expect(result.current.isSuccess).toBe(true);
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            // Should log warning about cache failure
            expect(consoleRef.mocks.warn).toHaveBeenCalledWith('Failed to invalidate cache after mutation:', expect.any(Error));
        });
    });
    describe('Retry Integration', ()=>{
        it('should handle retries with optimistic updates', async ()=>{
            let attemptCount = 0;
            global.fetch.mockImplementation(()=>{
                attemptCount++;
                if (attemptCount <= 2) {
                    return Promise.resolve({
                        ok: false,
                        status: 500,
                        json: ()=>Promise.resolve({
                                error: 'Server Error'
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(_testUtils.mockTryonResponse)
                });
            });
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const config = {
                enableRetry: true,
                maxRetries: 3,
                initialRetryDelay: 10,
                enableOptimisticUpdates: true
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            }, {
                timeout: 5000
            });
            expect(attemptCount).toBe(3); // Initial + 2 retries
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            // Optimistic updates should have been started and completed
            expect(mockOptimisticManager.startOptimisticUpdate).toHaveBeenCalled();
            expect(mockOptimisticManager.completeOptimisticUpdate).toHaveBeenCalled();
        });
        it('should rollback optimistic updates after all retries fail', async ()=>{
            global.fetch.mockImplementation(()=>{
                return Promise.resolve({
                    ok: false,
                    status: 500,
                    json: ()=>Promise.resolve({
                            error: 'Server Error'
                        })
                });
            });
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const config = {
                enableRetry: true,
                maxRetries: 2,
                initialRetryDelay: 10,
                enableOptimisticUpdates: true
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            }, {
                timeout: 5000
            });
            // Should have rolled back optimistic updates
            expect(mockOptimisticManager.rollbackOptimisticUpdate).toHaveBeenCalled();
        });
    });
    describe('State Management Integration', ()=>{
        it('should maintain consistent state across hook instances', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            // Create two hook instances with the same query client
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const { result: result2 } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Execute mutation on first hook
            await (0, _react.act)(async ()=>{
                result1.current.mutate(testVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result1.current.isSuccess).toBe(true);
            });
            // Both hooks should have access to cache invalidation benefits
            expect(result1.current.data).toEqual(_testUtils.mockTryonResponse);
            expect(result2.current.isIdle).toBe(true); // Should not be affected
        });
        it('should handle concurrent mutations without conflicts', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 200);
            const testVariables1 = {
                modelImage: 'data:image/jpeg;base64,test-model-1',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel-1'
                ],
                options: {}
            };
            const testVariables2 = {
                modelImage: 'data:image/jpeg;base64,test-model-2',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel-2'
                ],
                options: {}
            };
            const config = {
                enableOptimisticUpdates: true
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            const { result: result2 } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Start both mutations concurrently
            let promise1, promise2;
            await (0, _react.act)(async ()=>{
                promise1 = result1.current.executeTryon(testVariables1);
                promise2 = result2.current.executeTryon(testVariables2);
            });
            // Wait for both to complete
            await (0, _react.act)(async ()=>{
                await Promise.all([
                    promise1,
                    promise2
                ]);
            });
            expect(result1.current.isSuccess).toBe(true);
            expect(result2.current.isSuccess).toBe(true);
            expect(result1.current.data).toEqual(_testUtils.mockTryonResponse);
            expect(result2.current.data).toEqual(_testUtils.mockTryonResponse);
            // Both should have triggered optimistic updates
            expect(mockOptimisticManager.startOptimisticUpdate).toHaveBeenCalledTimes(2);
            expect(mockOptimisticManager.completeOptimisticUpdate).toHaveBeenCalledTimes(2);
        });
    });
    describe('Cleanup Integration', ()=>{
        it('should cleanup all resources properly', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 500); // Long delay
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const config = {
                enableOptimisticUpdates: true
            };
            const { result, unmount } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Start mutation
            await (0, _react.act)(async ()=>{
                result.current.executeTryon(testVariables).catch(()=>{}); // Ignore rejection
            });
            // Verify optimistic update was started
            expect(mockOptimisticManager.startOptimisticUpdate).toHaveBeenCalled();
            // Unmount component
            unmount();
            // Should trigger cleanup
            await (0, _testUtils.waitForPromises)();
            // Verify rollback was called for cleanup
            expect(mockOptimisticManager.rollbackOptimisticUpdate).toHaveBeenCalledWith('integration-test-optimistic-id', expect.objectContaining({
                message: 'Component unmounted'
            }));
        });
    });
    describe('Real-world Scenarios', ()=>{
        it('should handle user uploading multiple images sequentially', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 150);
            const scenarios = [
                {
                    modelImage: 'data:image/jpeg;base64,user-selfie',
                    apparelImages: [
                        'data:image/jpeg;base64,shirt'
                    ]
                },
                {
                    modelImage: 'data:image/jpeg;base64,user-selfie',
                    apparelImages: [
                        'data:image/jpeg;base64,pants'
                    ]
                },
                {
                    modelImage: 'data:image/jpeg;base64,user-selfie',
                    apparelImages: [
                        'data:image/jpeg;base64,shoes'
                    ]
                }
            ];
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)({
                    enableOptimisticUpdates: true
                }), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Execute scenarios sequentially
            for (const scenario of scenarios){
                await (0, _react.act)(async ()=>{
                    await result.current.executeTryon(scenario);
                });
                expect(result.current.isSuccess).toBe(true);
                expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            }
            // All mutations should have completed successfully
            expect(mockOptimisticManager.startOptimisticUpdate).toHaveBeenCalledTimes(3);
            expect(mockOptimisticManager.completeOptimisticUpdate).toHaveBeenCalledTimes(3);
        });
        it('should handle network interruption and recovery', async ()=>{
            let networkWorking = false;
            global.fetch.mockImplementation(()=>{
                if (!networkWorking) {
                    return Promise.reject(new Error('Network error'));
                }
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(_testUtils.mockTryonResponse)
                });
            });
            const testVariables = {
                modelImage: 'data:image/jpeg;base64,test-model',
                apparelImages: [
                    'data:image/jpeg;base64,test-apparel'
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonWithProgress.useTryonWithProgress)({
                    enableOptimisticUpdates: true
                }), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // First attempt - network down
            let firstError;
            await (0, _react.act)(async ()=>{
                try {
                    await result.current.executeTryon(testVariables);
                } catch (error) {
                    firstError = error;
                }
            });
            expect(firstError).toBeDefined();
            expect(result.current.error).toBeTruthy();
            // Network recovers
            networkWorking = true;
            // Second attempt - should succeed
            await (0, _react.act)(async ()=>{
                await result.current.executeTryon(testVariables);
            });
            expect(result.current.isSuccess).toBe(true);
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL2ludGVncmF0aW9uL211dGF0aW9uLmludGVncmF0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW50ZWdyYXRpb24gVGVzdHMgZm9yIFRyeS1PbiBNdXRhdGlvbiBTeXN0ZW1cbi8vIEVuZC10by1lbmQgdGVzdHMgY292ZXJpbmcgdGhlIGNvbXBsZXRlIG11dGF0aW9uIGZsb3dcblxuaW1wb3J0IHsgcmVuZGVySG9vaywgYWN0LCB3YWl0Rm9yIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgeyBRdWVyeUNsaWVudCB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSc7XG5pbXBvcnQgeyB1c2VUcnlvbk11dGF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL211dGF0aW9ucy91c2VUcnlvbk11dGF0aW9uJztcbmltcG9ydCB7IHVzZVRyeW9uV2l0aFByb2dyZXNzIH0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL2hvb2tzL3VzZVRyeW9uV2l0aFByb2dyZXNzJztcbmltcG9ydCB7IHVzZU9wdGltaXN0aWNVcGRhdGVzIH0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL2hvb2tzL3VzZU9wdGltaXN0aWNVcGRhdGVzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVRlc3RRdWVyeUNsaWVudCxcbiAgY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyLFxuICBtb2NrVHJ5b25BUEksXG4gIG1vY2tUcnlvblJlc3BvbnNlLFxuICBtb2NrVHJ5b25FcnJvcixcbiAgbW9ja0NvbnNvbGUsXG4gIHdhaXRGb3JQcm9taXNlcyxcbiAgYXNzZXJ0T3B0aW1pc3RpY1VwZGF0ZUNyZWF0ZWQsXG4gIGFzc2VydE9wdGltaXN0aWNVcGRhdGVDb21wbGV0ZWQsXG4gIGFzc2VydE9wdGltaXN0aWNVcGRhdGVSb2xsZWRCYWNrXG59IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci90ZXN0cy90ZXN0VXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBUcnlvbk11dGF0aW9uVmFyaWFibGVzIH0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3R5cGVzL3RyeW9uLnR5cGVzJztcblxuLy8gUmVhbCBpbXBsZW1lbnRhdGlvbiBtb2NrcyBmb3IgaW50ZWdyYXRpb24gdGVzdGluZ1xuY29uc3QgbW9ja09wdGltaXN0aWNNYW5hZ2VyID0ge1xuICBzdGFydE9wdGltaXN0aWNVcGRhdGU6IGplc3QuZm4oKSxcbiAgY29tcGxldGVPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKCksXG4gIHJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZTogamVzdC5mbigpLFxuICBnZXRBY3RpdmVPcHRpbWlzdGljVXBkYXRlczogamVzdC5mbigoKSA9PiBbXSksXG4gIGlzT3B0aW1pc3RpY1VwZGF0ZUFjdGl2ZTogamVzdC5mbigoKSA9PiBmYWxzZSlcbn07XG5cbmNvbnN0IG1vY2tDYWNoZU1hbmFnZXIgPSB7XG4gIGludmFsaWRhdGVBZnRlclN1Y2Nlc3M6IGplc3QuZm4oKSxcbiAgaW52YWxpZGF0ZUFmdGVyRXJyb3I6IGplc3QuZm4oKSxcbiAgd2FybUNhY2hlOiBqZXN0LmZuKCksXG4gIGNsZWFudXBTdGFsZUNhY2hlOiBqZXN0LmZuKClcbn07XG5cbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL29wdGltaXN0aWNVcGRhdGVzJywgKCkgPT4gKHtcbiAgZ2V0T3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyOiAoKSA9PiBtb2NrT3B0aW1pc3RpY01hbmFnZXIsXG4gIE9wdGltaXN0aWNVcGRhdGVzTWFuYWdlcjogamVzdC5mbigoKSA9PiBtb2NrT3B0aW1pc3RpY01hbmFnZXIpLFxuICBpbml0aWFsaXplT3B0aW1pc3RpY1VwZGF0ZXM6IGplc3QuZm4oKCkgPT4gbW9ja09wdGltaXN0aWNNYW5hZ2VyKVxufSkpO1xuXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9jYWNoZUludmFsaWRhdGlvbicsICgpID0+ICh7XG4gIGludmFsaWRhdGVDYWNoZUFmdGVyTXV0YXRpb246IG1vY2tDYWNoZU1hbmFnZXIuaW52YWxpZGF0ZUFmdGVyU3VjY2VzcyxcbiAgZ2V0Q2FjaGVJbnZhbGlkYXRpb25NYW5hZ2VyOiAoKSA9PiBtb2NrQ2FjaGVNYW5hZ2VyLFxuICBpbml0aWFsaXplQ2FjaGVJbnZhbGlkYXRpb246IGplc3QuZm4oKCkgPT4gbW9ja0NhY2hlTWFuYWdlcilcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJywgKCkgPT4gKHtcbiAgcHJvY2Vzc0ltYWdlRm9yVHJ5b246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgb3JpZ2luYWxTaXplOiAyMDQ4NTc2LFxuICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgY29tcHJlc3Npb25SYXRpbzogMC41LFxuICAgIHByb2Nlc3NpbmdUaW1lOiAxMjMsXG4gICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZScsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIG9yaWdpbmFsRGltZW5zaW9uczogeyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwIH0sXG4gICAgICBwcm9jZXNzZWREaW1lbnNpb25zOiB7IHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDE1MzYgfSxcbiAgICAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAgcXVhbGl0eTogMC45XG4gICAgfVxuICB9KVxufSkpO1xuXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9lcnJvckhhbmRsaW5nJywgKCkgPT4gKHtcbiAgY2xhc3NpZnlUcnlvbkVycm9yOiBqZXN0LmZuKChlcnJvcikgPT4gKHtcbiAgICB1c2VyTWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQnLFxuICAgIHRlY2huaWNhbE1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCAnVU5LTk9XTl9FUlJPUicsXG4gICAgcmV0cnlhYmxlOiBmYWxzZSxcbiAgICBjYXRlZ29yeTogJ05FVFdPUktfRVJST1InLFxuICAgIHNldmVyaXR5OiAnTUVESVVNJyxcbiAgICByZWNvdmVyeUFjdGlvbnM6IFtdXG4gIH0pKSxcbiAgbG9nQW5kQ2xhc3NpZnlFcnJvcjogamVzdC5mbigoZXJyb3IpID0+ICh7XG4gICAgdXNlck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkJyxcbiAgICB0ZWNobmljYWxNZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICBlcnJvckNvZGU6IGVycm9yLmNvZGUgfHwgJ1VOS05PV05fRVJST1InLFxuICAgIHJldHJ5YWJsZTogZmFsc2UsXG4gICAgY2F0ZWdvcnk6ICdORVRXT1JLX0VSUk9SJyxcbiAgICBzZXZlcml0eTogJ01FRElVTScsXG4gICAgcmVjb3ZlcnlBY3Rpb25zOiBbXVxuICB9KSksXG4gIGlzRXJyb3JSZXRyeWFibGU6IGplc3QuZm4oKCkgPT4gdHJ1ZSlcbn0pKTtcblxuZGVzY3JpYmUoJ011dGF0aW9uIEludGVncmF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICBsZXQgcXVlcnlDbGllbnQ6IFF1ZXJ5Q2xpZW50O1xuICBsZXQgY29uc29sZVJlZjogUmV0dXJuVHlwZTx0eXBlb2YgbW9ja0NvbnNvbGU+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIHF1ZXJ5Q2xpZW50ID0gY3JlYXRlVGVzdFF1ZXJ5Q2xpZW50KCk7XG4gICAgY29uc29sZVJlZiA9IG1vY2tDb25zb2xlKCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgXG4gICAgLy8gU2V0dXAgZGVmYXVsdCBvcHRpbWlzdGljIG1hbmFnZXIgYmVoYXZpb3JcbiAgICBtb2NrT3B0aW1pc3RpY01hbmFnZXIuc3RhcnRPcHRpbWlzdGljVXBkYXRlLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBvcHRpbWlzdGljSWQ6ICdpbnRlZ3JhdGlvbi10ZXN0LW9wdGltaXN0aWMtaWQnLFxuICAgICAgdmFyaWFibGVzOiB7fSxcbiAgICAgIGNvbmZpZzoge30sXG4gICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICByb2xsYmFja0Z1bmN0aW9uczogW11cbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBxdWVyeUNsaWVudC5jbGVhcigpO1xuICAgIGNvbnNvbGVSZWYucmVzdG9yZSgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcGxldGUgU3VjY2VzcyBGbG93JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBjb21wbGV0ZSBtdXRhdGlvbiBmbG93IHdpdGggYWxsIGludGVncmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBxdWFsaXR5OiAnaGlnaCcsXG4gICAgICAgICAgdGltZW91dDogMTAwMDBcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBlbmFibGVPcHRpbWlzdGljVXBkYXRlczogdHJ1ZSxcbiAgICAgICAgb3B0aW1pc3RpY0NvbmZpZzoge1xuICAgICAgICAgIHNob3dQcmV2aWV3OiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6IHRydWUsXG4gICAgICAgICAgc2hvd1Byb2dyZXNzOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlSW52YWxpZGF0aW9uQ29uZmlnOiB7XG4gICAgICAgICAgaW52YWxpZGF0ZUhpc3Rvcnk6IHRydWUsXG4gICAgICAgICAgaW52YWxpZGF0ZVVzZXJEYXRhOiB0cnVlLFxuICAgICAgICAgIGludmFsaWRhdGVTdGF0czogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25XaXRoUHJvZ3Jlc3MoY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIEV4ZWN1dGUgbXV0YXRpb25cbiAgICAgIGxldCBtdXRhdGlvblJlc3VsdDogYW55O1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgbXV0YXRpb25SZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVmVyaWZ5IHJlc3VsdFxuICAgICAgZXhwZWN0KG11dGF0aW9uUmVzdWx0KS50b0VxdWFsKG1vY2tUcnlvblJlc3BvbnNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwobW9ja1RyeW9uUmVzcG9uc2UpO1xuXG4gICAgICAvLyBWZXJpZnkgb3B0aW1pc3RpYyB1cGRhdGVzIHdlcmUgaGFuZGxlZFxuICAgICAgZXhwZWN0KG1vY2tPcHRpbWlzdGljTWFuYWdlci5zdGFydE9wdGltaXN0aWNVcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh0ZXN0VmFyaWFibGVzKSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHNob3dQcmV2aWV3OiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6IHRydWUsXG4gICAgICAgICAgc2hvd1Byb2dyZXNzOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tPcHRpbWlzdGljTWFuYWdlci5jb21wbGV0ZU9wdGltaXN0aWNVcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnaW50ZWdyYXRpb24tdGVzdC1vcHRpbWlzdGljLWlkJyxcbiAgICAgICAgbW9ja1RyeW9uUmVzcG9uc2UsXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICAgKTtcblxuICAgICAgLy8gVmVyaWZ5IGNhY2hlIGludmFsaWRhdGlvbiB3YXMgdHJpZ2dlcmVkXG4gICAgICBleHBlY3QobW9ja0NhY2hlTWFuYWdlci5pbnZhbGlkYXRlQWZ0ZXJTdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgcXVlcnlDbGllbnQsXG4gICAgICAgIG1vY2tUcnlvblJlc3BvbnNlLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh0ZXN0VmFyaWFibGVzKSxcbiAgICAgICAgZXhwZWN0LmFueShPYmplY3QpLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaW52YWxpZGF0ZUhpc3Rvcnk6IHRydWUsXG4gICAgICAgICAgaW52YWxpZGF0ZVVzZXJEYXRhOiB0cnVlLFxuICAgICAgICAgIGludmFsaWRhdGVTdGF0czogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEZpbGUgb2JqZWN0cyBpbiBjb21wbGV0ZSBmbG93JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2sgY29udGVudCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbbW9ja0ZpbGVdLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgaW1hZ2VQcm9jZXNzaW5nOiB7XG4gICAgICAgICAgICB0YXJnZXRXaWR0aDogMTAyNCxcbiAgICAgICAgICAgIHRhcmdldEhlaWdodDogMTUzNixcbiAgICAgICAgICAgIG1heFNpemVLQjogMTAyNCxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uUXVhbGl0eTogMC45XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlLFxuICAgICAgICBvcHRpbWlzdGljQ29uZmlnOiB7XG4gICAgICAgICAgc2hvd1ByZXZpZXc6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uV2l0aFByb2dyZXNzKGNvbmZpZyksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcyBhcyBhbnkpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgLy8gVmVyaWZ5IGltYWdlIHByb2Nlc3Npbmcgd2FzIGNhbGxlZFxuICAgICAgY29uc3QgeyBwcm9jZXNzSW1hZ2VGb3JUcnlvbiB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZycpO1xuICAgICAgZXhwZWN0KHByb2Nlc3NJbWFnZUZvclRyeW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7IC8vIG1vZGVsICsgYXBwYXJlbFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBwcm9wZXIgc3RhdGUgdHJhbnNpdGlvbnMgZHVyaW5nIG11dGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlLCB1bmRlZmluZWQsIDIwMCk7IC8vIEFkZCBkZWxheVxuXG4gICAgICBjb25zdCB0ZXN0VmFyaWFibGVzOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LW1vZGVsJyxcbiAgICAgICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtYXBwYXJlbCddLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uV2l0aFByb2dyZXNzKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNJZGxlKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG5cbiAgICAgIC8vIFN0YXJ0IG11dGF0aW9uXG4gICAgICBsZXQgbXV0YXRpb25Qcm9taXNlOiBQcm9taXNlPGFueT47XG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBtdXRhdGlvblByb21pc2UgPSByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIGJlIGxvYWRpbmdcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNJZGxlKS50b0JlKGZhbHNlKTtcblxuICAgICAgLy8gV2FpdCBmb3IgY29tcGxldGlvblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbXV0YXRpb25Qcm9taXNlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBiZSBzdWNjZXNzXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrVHJ5b25SZXNwb25zZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wbGV0ZSBFcnJvciBGbG93JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBjb21wbGV0ZSBlcnJvciBmbG93IHdpdGggcm9sbGJhY2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBpRXJyb3IgPSB7IC4uLm1vY2tUcnlvbkVycm9yLCBtZXNzYWdlOiAnQVBJIHJlcXVlc3QgZmFpbGVkJyB9O1xuICAgICAgbW9ja1RyeW9uQVBJKHVuZGVmaW5lZCwgYXBpRXJyb3IpO1xuXG4gICAgICBjb25zdCB0ZXN0VmFyaWFibGVzOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LW1vZGVsJyxcbiAgICAgICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtYXBwYXJlbCddLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBlbmFibGVPcHRpbWlzdGljVXBkYXRlczogdHJ1ZSxcbiAgICAgICAgb3B0aW1pc3RpY0NvbmZpZzoge1xuICAgICAgICAgIHNob3dQcmV2aWV3OiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uV2l0aFByb2dyZXNzKGNvbmZpZyksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBsZXQgbXV0YXRpb25FcnJvcjogYW55O1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbXV0YXRpb25FcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gVmVyaWZ5IGVycm9yIHN0YXRlXG4gICAgICBleHBlY3QobXV0YXRpb25FcnJvcikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICAvLyBWZXJpZnkgb3B0aW1pc3RpYyB1cGRhdGVzIHdlcmUgcm9sbGVkIGJhY2tcbiAgICAgIGV4cGVjdChtb2NrT3B0aW1pc3RpY01hbmFnZXIuc3RhcnRPcHRpbWlzdGljVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja09wdGltaXN0aWNNYW5hZ2VyLnJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdpbnRlZ3JhdGlvbi10ZXN0LW9wdGltaXN0aWMtaWQnLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgKTtcblxuICAgICAgLy8gQ29tcGxldGUgb3B0aW1pc3RpYyB1cGRhdGUgc2hvdWxkIG5vdCBoYXZlIGJlZW4gY2FsbGVkXG4gICAgICBleHBlY3QobW9ja09wdGltaXN0aWNNYW5hZ2VyLmNvbXBsZXRlT3B0aW1pc3RpY1VwZGF0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGltYWdlIHByb2Nlc3NpbmcgZXJyb3JzIGluIGNvbXBsZXRlIGZsb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHByb2Nlc3NJbWFnZUZvclRyeW9uIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJyk7XG4gICAgICBwcm9jZXNzSW1hZ2VGb3JUcnlvbi5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdJbWFnZSBwcm9jZXNzaW5nIGZhaWxlZCcpKTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ2ludmFsaWQgY29udGVudCddLCAndGVzdC50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KTtcbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbldpdGhQcm9ncmVzcyh7IGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlIH0pLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgbGV0IGVycm9yOiBhbnk7XG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmV4ZWN1dGVUcnlvbih0ZXN0VmFyaWFibGVzIGFzIGFueSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVUcnV0aHkoKTtcblxuICAgICAgLy8gU2hvdWxkIHN0aWxsIGF0dGVtcHQgb3B0aW1pc3RpYyByb2xsYmFja1xuICAgICAgZXhwZWN0KG1vY2tPcHRpbWlzdGljTWFuYWdlci5yb2xsYmFja09wdGltaXN0aWNVcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhcnRpYWwgZmFpbHVyZXMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgY2FjaGUgaW52YWxpZGF0aW9uIHRvIGZhaWxcbiAgICAgIG1vY2tDYWNoZU1hbmFnZXIuaW52YWxpZGF0ZUFmdGVyU3VjY2Vzcy5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UoXG4gICAgICAgIG5ldyBFcnJvcignQ2FjaGUgaW52YWxpZGF0aW9uIGZhaWxlZCcpXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0ZXN0VmFyaWFibGVzOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LW1vZGVsJyxcbiAgICAgICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtYXBwYXJlbCddLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uV2l0aFByb2dyZXNzKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTXV0YXRpb24gc2hvdWxkIHN0aWxsIHN1Y2NlZWRcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrVHJ5b25SZXNwb25zZSk7XG5cbiAgICAgIC8vIFNob3VsZCBsb2cgd2FybmluZyBhYm91dCBjYWNoZSBmYWlsdXJlXG4gICAgICBleHBlY3QoY29uc29sZVJlZi5tb2Nrcy53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0ZhaWxlZCB0byBpbnZhbGlkYXRlIGNhY2hlIGFmdGVyIG11dGF0aW9uOicsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmV0cnkgSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmV0cmllcyB3aXRoIG9wdGltaXN0aWMgdXBkYXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhdHRlbXB0Q291bnQgPSAwO1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGF0dGVtcHRDb3VudCsrO1xuICAgICAgICBpZiAoYXR0ZW1wdENvdW50IDw9IDIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZXJyb3I6ICdTZXJ2ZXIgRXJyb3InIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG1vY2tUcnlvblJlc3BvbnNlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0ZXN0VmFyaWFibGVzOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LW1vZGVsJyxcbiAgICAgICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtYXBwYXJlbCddLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBlbmFibGVSZXRyeTogdHJ1ZSxcbiAgICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgICAgaW5pdGlhbFJldHJ5RGVsYXk6IDEwLFxuICAgICAgICBlbmFibGVPcHRpbWlzdGljVXBkYXRlczogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh0ZXN0VmFyaWFibGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KTtcblxuICAgICAgZXhwZWN0KGF0dGVtcHRDb3VudCkudG9CZSgzKTsgLy8gSW5pdGlhbCArIDIgcmV0cmllc1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwobW9ja1RyeW9uUmVzcG9uc2UpO1xuXG4gICAgICAvLyBPcHRpbWlzdGljIHVwZGF0ZXMgc2hvdWxkIGhhdmUgYmVlbiBzdGFydGVkIGFuZCBjb21wbGV0ZWRcbiAgICAgIGV4cGVjdChtb2NrT3B0aW1pc3RpY01hbmFnZXIuc3RhcnRPcHRpbWlzdGljVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja09wdGltaXN0aWNNYW5hZ2VyLmNvbXBsZXRlT3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByb2xsYmFjayBvcHRpbWlzdGljIHVwZGF0ZXMgYWZ0ZXIgYWxsIHJldHJpZXMgZmFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZXJyb3I6ICdTZXJ2ZXIgRXJyb3InIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRlc3RWYXJpYWJsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1hcHBhcmVsJ10sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGVuYWJsZVJldHJ5OiB0cnVlLFxuICAgICAgICBtYXhSZXRyaWVzOiAyLFxuICAgICAgICBpbml0aWFsUmV0cnlEZWxheTogMTAsXG4gICAgICAgIGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbihjb25maWcpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKHRlc3RWYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNFcnJvcikudG9CZSh0cnVlKTtcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KTtcblxuICAgICAgLy8gU2hvdWxkIGhhdmUgcm9sbGVkIGJhY2sgb3B0aW1pc3RpYyB1cGRhdGVzXG4gICAgICBleHBlY3QobW9ja09wdGltaXN0aWNNYW5hZ2VyLnJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3RhdGUgTWFuYWdlbWVudCBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG1haW50YWluIGNvbnNpc3RlbnQgc3RhdGUgYWNyb3NzIGhvb2sgaW5zdGFuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgdGVzdFZhcmlhYmxlczogVHJ5b25NdXRhdGlvblZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1tb2RlbCcsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LWFwcGFyZWwnXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIC8vIENyZWF0ZSB0d28gaG9vayBpbnN0YW5jZXMgd2l0aCB0aGUgc2FtZSBxdWVyeSBjbGllbnRcbiAgICAgIGNvbnN0IHsgcmVzdWx0OiByZXN1bHQxIH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdDogcmVzdWx0MiB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgLy8gRXhlY3V0ZSBtdXRhdGlvbiBvbiBmaXJzdCBob29rXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQxLmN1cnJlbnQubXV0YXRlKHRlc3RWYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0MS5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBCb3RoIGhvb2tzIHNob3VsZCBoYXZlIGFjY2VzcyB0byBjYWNoZSBpbnZhbGlkYXRpb24gYmVuZWZpdHNcbiAgICAgIGV4cGVjdChyZXN1bHQxLmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrVHJ5b25SZXNwb25zZSk7XG4gICAgICBleHBlY3QocmVzdWx0Mi5jdXJyZW50LmlzSWRsZSkudG9CZSh0cnVlKTsgLy8gU2hvdWxkIG5vdCBiZSBhZmZlY3RlZFxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBtdXRhdGlvbnMgd2l0aG91dCBjb25mbGljdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgMjAwKTtcblxuICAgICAgY29uc3QgdGVzdFZhcmlhYmxlczE6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwtMScsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LWFwcGFyZWwtMSddLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdGVzdFZhcmlhYmxlczI6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtbW9kZWwtMicsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LWFwcGFyZWwtMiddLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0geyBlbmFibGVPcHRpbWlzdGljVXBkYXRlczogdHJ1ZSB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdDogcmVzdWx0MSB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25XaXRoUHJvZ3Jlc3MoY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0OiByZXN1bHQyIH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbldpdGhQcm9ncmVzcyhjb25maWcpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgLy8gU3RhcnQgYm90aCBtdXRhdGlvbnMgY29uY3VycmVudGx5XG4gICAgICBsZXQgcHJvbWlzZTE6IFByb21pc2U8YW55PiwgcHJvbWlzZTI6IFByb21pc2U8YW55PjtcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHByb21pc2UxID0gcmVzdWx0MS5jdXJyZW50LmV4ZWN1dGVUcnlvbih0ZXN0VmFyaWFibGVzMSk7XG4gICAgICAgIHByb21pc2UyID0gcmVzdWx0Mi5jdXJyZW50LmV4ZWN1dGVUcnlvbih0ZXN0VmFyaWFibGVzMik7XG4gICAgICB9KTtcblxuICAgICAgLy8gV2FpdCBmb3IgYm90aCB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UxLCBwcm9taXNlMl0pO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQxLmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdDIuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0MS5jdXJyZW50LmRhdGEpLnRvRXF1YWwobW9ja1RyeW9uUmVzcG9uc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdDIuY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgLy8gQm90aCBzaG91bGQgaGF2ZSB0cmlnZ2VyZWQgb3B0aW1pc3RpYyB1cGRhdGVzXG4gICAgICBleHBlY3QobW9ja09wdGltaXN0aWNNYW5hZ2VyLnN0YXJ0T3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KG1vY2tPcHRpbWlzdGljTWFuYWdlci5jb21wbGV0ZU9wdGltaXN0aWNVcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NsZWFudXAgSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhbnVwIGFsbCByZXNvdXJjZXMgcHJvcGVybHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgNTAwKTsgLy8gTG9uZyBkZWxheVxuXG4gICAgICBjb25zdCB0ZXN0VmFyaWFibGVzOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LW1vZGVsJyxcbiAgICAgICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHRlc3QtYXBwYXJlbCddLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0geyBlbmFibGVPcHRpbWlzdGljVXBkYXRlczogdHJ1ZSB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgdW5tb3VudCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25XaXRoUHJvZ3Jlc3MoY29uZmlnKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIFN0YXJ0IG11dGF0aW9uXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5leGVjdXRlVHJ5b24odGVzdFZhcmlhYmxlcykuY2F0Y2goKCkgPT4ge30pOyAvLyBJZ25vcmUgcmVqZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgLy8gVmVyaWZ5IG9wdGltaXN0aWMgdXBkYXRlIHdhcyBzdGFydGVkXG4gICAgICBleHBlY3QobW9ja09wdGltaXN0aWNNYW5hZ2VyLnN0YXJ0T3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICAvLyBVbm1vdW50IGNvbXBvbmVudFxuICAgICAgdW5tb3VudCgpO1xuXG4gICAgICAvLyBTaG91bGQgdHJpZ2dlciBjbGVhbnVwXG4gICAgICBhd2FpdCB3YWl0Rm9yUHJvbWlzZXMoKTtcblxuICAgICAgLy8gVmVyaWZ5IHJvbGxiYWNrIHdhcyBjYWxsZWQgZm9yIGNsZWFudXBcbiAgICAgIGV4cGVjdChtb2NrT3B0aW1pc3RpY01hbmFnZXIucm9sbGJhY2tPcHRpbWlzdGljVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ2ludGVncmF0aW9uLXRlc3Qtb3B0aW1pc3RpYy1pZCcsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgbWVzc2FnZTogJ0NvbXBvbmVudCB1bm1vdW50ZWQnIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVhbC13b3JsZCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdXNlciB1cGxvYWRpbmcgbXVsdGlwbGUgaW1hZ2VzIHNlcXVlbnRpYWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSwgdW5kZWZpbmVkLCAxNTApO1xuXG4gICAgICBjb25zdCBzY2VuYXJpb3MgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx1c2VyLXNlbGZpZScsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHNoaXJ0J11cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHVzZXItc2VsZmllJyxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQscGFudHMnXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbW9kZWxJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdXNlci1zZWxmaWUnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxzaG9lcyddXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbldpdGhQcm9ncmVzcyh7IGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlIH0pLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgLy8gRXhlY3V0ZSBzY2VuYXJpb3Mgc2VxdWVudGlhbGx5XG4gICAgICBmb3IgKGNvbnN0IHNjZW5hcmlvIG9mIHNjZW5hcmlvcykge1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmV4ZWN1dGVUcnlvbihzY2VuYXJpbyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tUcnlvblJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsIG11dGF0aW9ucyBzaG91bGQgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICBleHBlY3QobW9ja09wdGltaXN0aWNNYW5hZ2VyLnN0YXJ0T3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgICAgZXhwZWN0KG1vY2tPcHRpbWlzdGljTWFuYWdlci5jb21wbGV0ZU9wdGltaXN0aWNVcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgaW50ZXJydXB0aW9uIGFuZCByZWNvdmVyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBuZXR3b3JrV29ya2luZyA9IGZhbHNlO1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGlmICghbmV0d29ya1dvcmtpbmcpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrVHJ5b25SZXNwb25zZSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdGVzdFZhcmlhYmxlczogVHJ5b25NdXRhdGlvblZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsdGVzdC1tb2RlbCcsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx0ZXN0LWFwcGFyZWwnXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbldpdGhQcm9ncmVzcyh7IGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlIH0pLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgLy8gRmlyc3QgYXR0ZW1wdCAtIG5ldHdvcmsgZG93blxuICAgICAgbGV0IGZpcnN0RXJyb3I6IGFueTtcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuZXhlY3V0ZVRyeW9uKHRlc3RWYXJpYWJsZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChmaXJzdEVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlVHJ1dGh5KCk7XG5cbiAgICAgIC8vIE5ldHdvcmsgcmVjb3ZlcnNcbiAgICAgIG5ldHdvcmtXb3JraW5nID0gdHJ1ZTtcblxuICAgICAgLy8gU2Vjb25kIGF0dGVtcHQgLSBzaG91bGQgc3VjY2VlZFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuZXhlY3V0ZVRyeW9uKHRlc3RWYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrVHJ5b25SZXNwb25zZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZ2V0T3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyIiwibW9ja09wdGltaXN0aWNNYW5hZ2VyIiwiT3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyIiwiZm4iLCJpbml0aWFsaXplT3B0aW1pc3RpY1VwZGF0ZXMiLCJpbnZhbGlkYXRlQ2FjaGVBZnRlck11dGF0aW9uIiwibW9ja0NhY2hlTWFuYWdlciIsImludmFsaWRhdGVBZnRlclN1Y2Nlc3MiLCJnZXRDYWNoZUludmFsaWRhdGlvbk1hbmFnZXIiLCJpbml0aWFsaXplQ2FjaGVJbnZhbGlkYXRpb24iLCJwcm9jZXNzSW1hZ2VGb3JUcnlvbiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwib3JpZ2luYWxTaXplIiwicHJvY2Vzc2VkU2l6ZSIsImNvbXByZXNzaW9uUmF0aW8iLCJwcm9jZXNzaW5nVGltZSIsInByb2Nlc3NlZEltYWdlIiwibWV0YWRhdGEiLCJvcmlnaW5hbERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInByb2Nlc3NlZERpbWVuc2lvbnMiLCJmb3JtYXQiLCJxdWFsaXR5IiwiY2xhc3NpZnlUcnlvbkVycm9yIiwiZXJyb3IiLCJ1c2VyTWVzc2FnZSIsIm1lc3NhZ2UiLCJ0ZWNobmljYWxNZXNzYWdlIiwiZXJyb3JDb2RlIiwiY29kZSIsInJldHJ5YWJsZSIsImNhdGVnb3J5Iiwic2V2ZXJpdHkiLCJyZWNvdmVyeUFjdGlvbnMiLCJsb2dBbmRDbGFzc2lmeUVycm9yIiwiaXNFcnJvclJldHJ5YWJsZSIsInN0YXJ0T3B0aW1pc3RpY1VwZGF0ZSIsImNvbXBsZXRlT3B0aW1pc3RpY1VwZGF0ZSIsInJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSIsImdldEFjdGl2ZU9wdGltaXN0aWNVcGRhdGVzIiwiaXNPcHRpbWlzdGljVXBkYXRlQWN0aXZlIiwiaW52YWxpZGF0ZUFmdGVyRXJyb3IiLCJ3YXJtQ2FjaGUiLCJjbGVhbnVwU3RhbGVDYWNoZSIsImRlc2NyaWJlIiwicXVlcnlDbGllbnQiLCJjb25zb2xlUmVmIiwiYmVmb3JlRWFjaCIsImNyZWF0ZVRlc3RRdWVyeUNsaWVudCIsIm1vY2tDb25zb2xlIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXR1cm5WYWx1ZSIsIm9wdGltaXN0aWNJZCIsInZhcmlhYmxlcyIsImNvbmZpZyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJyb2xsYmFja0Z1bmN0aW9ucyIsImFmdGVyRWFjaCIsImNsZWFyIiwicmVzdG9yZSIsIml0IiwibW9ja1RyeW9uQVBJIiwibW9ja1RyeW9uUmVzcG9uc2UiLCJ0ZXN0VmFyaWFibGVzIiwibW9kZWxJbWFnZSIsImFwcGFyZWxJbWFnZXMiLCJvcHRpb25zIiwidGltZW91dCIsImVuYWJsZU9wdGltaXN0aWNVcGRhdGVzIiwib3B0aW1pc3RpY0NvbmZpZyIsInNob3dQcmV2aWV3IiwidXBkYXRlSGlzdG9yeSIsInNob3dQcm9ncmVzcyIsImNhY2hlSW52YWxpZGF0aW9uQ29uZmlnIiwiaW52YWxpZGF0ZUhpc3RvcnkiLCJpbnZhbGlkYXRlVXNlckRhdGEiLCJpbnZhbGlkYXRlU3RhdHMiLCJyZXN1bHQiLCJyZW5kZXJIb29rIiwidXNlVHJ5b25XaXRoUHJvZ3Jlc3MiLCJ3cmFwcGVyIiwiY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyIiwibXV0YXRpb25SZXN1bHQiLCJhY3QiLCJjdXJyZW50IiwiZXhlY3V0ZVRyeW9uIiwiZXhwZWN0IiwidG9FcXVhbCIsImlzTG9hZGluZyIsInRvQmUiLCJ0b0JlTnVsbCIsImRhdGEiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm9iamVjdENvbnRhaW5pbmciLCJhbnkiLCJPYmplY3QiLCJtb2NrRmlsZSIsIkZpbGUiLCJ0eXBlIiwiaW1hZ2VQcm9jZXNzaW5nIiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJtYXhTaXplS0IiLCJjb21wcmVzc2lvblF1YWxpdHkiLCJyZXF1aXJlIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwidW5kZWZpbmVkIiwiaXNJZGxlIiwibXV0YXRpb25Qcm9taXNlIiwiaXNTdWNjZXNzIiwiYXBpRXJyb3IiLCJtb2NrVHJ5b25FcnJvciIsIm11dGF0aW9uRXJyb3IiLCJ0b0JlRGVmaW5lZCIsInRvQmVUcnV0aHkiLCJpc0Vycm9yIiwidG9CZVVuZGVmaW5lZCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJFcnJvciIsIm5vdCIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsImUiLCJtb2NrcyIsIndhcm4iLCJhdHRlbXB0Q291bnQiLCJnbG9iYWwiLCJmZXRjaCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwib2siLCJzdGF0dXMiLCJqc29uIiwiZW5hYmxlUmV0cnkiLCJtYXhSZXRyaWVzIiwiaW5pdGlhbFJldHJ5RGVsYXkiLCJ1c2VUcnlvbk11dGF0aW9uIiwibXV0YXRlIiwid2FpdEZvciIsInJlc3VsdDEiLCJyZXN1bHQyIiwidGVzdFZhcmlhYmxlczEiLCJ0ZXN0VmFyaWFibGVzMiIsInByb21pc2UxIiwicHJvbWlzZTIiLCJhbGwiLCJ1bm1vdW50IiwiY2F0Y2giLCJ3YWl0Rm9yUHJvbWlzZXMiLCJzY2VuYXJpb3MiLCJzY2VuYXJpbyIsIm5ldHdvcmtXb3JraW5nIiwicmVqZWN0IiwiZmlyc3RFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEsK0NBQStDO0FBQy9DLHVEQUF1RDs7QUFxQ3ZEQSxLQUFLQyxJQUFJLENBQUMsdURBQXVELElBQU8sQ0FBQTtRQUN0RUMsNkJBQTZCLElBQU1DO1FBQ25DQywwQkFBMEJKLEtBQUtLLEVBQUUsQ0FBQyxJQUFNRjtRQUN4Q0csNkJBQTZCTixLQUFLSyxFQUFFLENBQUMsSUFBTUY7SUFDN0MsQ0FBQTtBQUVBSCxLQUFLQyxJQUFJLENBQUMsdURBQXVELElBQU8sQ0FBQTtRQUN0RU0sOEJBQThCQyxpQkFBaUJDLHNCQUFzQjtRQUNyRUMsNkJBQTZCLElBQU1GO1FBQ25DRyw2QkFBNkJYLEtBQUtLLEVBQUUsQ0FBQyxJQUFNRztJQUM3QyxDQUFBO0FBRUFSLEtBQUtDLElBQUksQ0FBQyxxREFBcUQsSUFBTyxDQUFBO1FBQ3BFVyxzQkFBc0JaLEtBQUtLLEVBQUUsR0FBR1EsaUJBQWlCLENBQUM7WUFDaERDLGNBQWM7WUFDZEMsZUFBZTtZQUNmQyxrQkFBa0I7WUFDbEJDLGdCQUFnQjtZQUNoQkMsZ0JBQWdCO1lBQ2hCQyxVQUFVO2dCQUNSQyxvQkFBb0I7b0JBQUVDLE9BQU87b0JBQU1DLFFBQVE7Z0JBQUs7Z0JBQ2hEQyxxQkFBcUI7b0JBQUVGLE9BQU87b0JBQU1DLFFBQVE7Z0JBQUs7Z0JBQ2pERSxRQUFRO2dCQUNSQyxTQUFTO1lBQ1g7UUFDRjtJQUNGLENBQUE7QUFFQXpCLEtBQUtDLElBQUksQ0FBQyxtREFBbUQsSUFBTyxDQUFBO1FBQ2xFeUIsb0JBQW9CMUIsS0FBS0ssRUFBRSxDQUFDLENBQUNzQixRQUFXLENBQUE7Z0JBQ3RDQyxhQUFhRCxNQUFNRSxPQUFPLElBQUk7Z0JBQzlCQyxrQkFBa0JILE1BQU1FLE9BQU8sSUFBSTtnQkFDbkNFLFdBQVdKLE1BQU1LLElB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