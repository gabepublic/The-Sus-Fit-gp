f4c2e17a184d3e4035b0ce7002f8bc5b
// Image Processing Utilities for Try-On Mutations
// Comprehensive image processing functions for the business layer
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    CompressionFailedError: function() {
        return _image.CompressionFailedError;
    },
    DEFAULT_PROCESSING_OPTIONS: function() {
        return DEFAULT_PROCESSING_OPTIONS;
    },
    FileTooLargeError: function() {
        return _image.FileTooLargeError;
    },
    FileTypeNotSupportedError: function() {
        return _image.FileTypeNotSupportedError;
    },
    ImageDimensionError: function() {
        return ImageDimensionError;
    },
    ImageFormat: function() {
        return ImageFormat;
    },
    ImageProcessingError: function() {
        return ImageProcessingError;
    },
    applyAutoColorCorrection: function() {
        return applyAutoColorCorrection;
    },
    applyNoiseReduction: function() {
        return applyNoiseReduction;
    },
    applySharpeningFilter: function() {
        return applySharpeningFilter;
    },
    compressBase64: function() {
        return _image.compressBase64;
    },
    convertImageFormat: function() {
        return convertImageFormat;
    },
    createImageThumbnail: function() {
        return createImageThumbnail;
    },
    extractImageMetadata: function() {
        return extractImageMetadata;
    },
    fileToBase64: function() {
        return _image.fileToBase64;
    },
    getBase64Size: function() {
        return getBase64Size;
    },
    getImageDimensions: function() {
        return getImageDimensions;
    },
    isImageFile: function() {
        return _image.isImageFile;
    },
    processImageAdvanced: function() {
        return processImageAdvanced;
    },
    processImageForTryon: function() {
        return processImageForTryon;
    },
    processImagesInBatch: function() {
        return processImagesInBatch;
    },
    processTryonImages: function() {
        return processTryonImages;
    },
    resizeImageTo1024x1536: function() {
        return resizeImageTo1024x1536;
    },
    validateImageDimensions: function() {
        return validateImageDimensions;
    }
});
const _image = require("../../utils/image");
class ImageProcessingError extends Error {
    constructor(message, originalError){
        super(message), this.originalError = originalError;
        this.name = 'ImageProcessingError';
    }
}
class ImageDimensionError extends Error {
    constructor(message, width, height){
        super(message), this.width = width, this.height = height;
        this.name = 'ImageDimensionError';
    }
}
const DEFAULT_PROCESSING_OPTIONS = {
    targetWidth: 1024,
    targetHeight: 1536,
    maxSizeKB: 1024,
    quality: 0.9,
    preserveAspectRatio: false
};
var ImageFormat = /*#__PURE__*/ function(ImageFormat) {
    ImageFormat["JPEG"] = "image/jpeg";
    ImageFormat["PNG"] = "image/png";
    ImageFormat["WEBP"] = "image/webp";
    ImageFormat["GIF"] = "image/gif";
    return ImageFormat;
}({});
function getImageDimensions(imageUrl) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            resolve({
                width: img.width,
                height: img.height
            });
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for dimension analysis'));
        };
        img.src = imageUrl;
    });
}
function resizeImageTo1024x1536(imageUrl, options = {}) {
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                let { targetWidth, targetHeight } = config;
                // Calculate dimensions preserving aspect ratio if requested
                if (config.preserveAspectRatio) {
                    const aspectRatio = img.width / img.height;
                    const targetAspectRatio = targetWidth / targetHeight;
                    if (aspectRatio > targetAspectRatio) {
                        // Image is wider, fit to width
                        targetHeight = Math.round(targetWidth / aspectRatio);
                    } else {
                        // Image is taller, fit to height
                        targetWidth = Math.round(targetHeight * aspectRatio);
                    }
                }
                // Set canvas dimensions
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                // Apply high-quality scaling
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                // Draw the image resized to fit the canvas
                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                // Convert to data URL with specified quality
                const resizedImageUrl = canvas.toDataURL('image/jpeg', config.quality);
                resolve(resizedImageUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to resize image', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for resizing'));
        };
        img.src = imageUrl;
    });
}
async function validateImageDimensions(imageUrl, minWidth = 512, minHeight = 512, maxWidth = 4096, maxHeight = 4096) {
    const dimensions = await getImageDimensions(imageUrl);
    if (dimensions.width < minWidth || dimensions.height < minHeight) {
        throw new ImageDimensionError(`Image dimensions too small. Minimum: ${minWidth}x${minHeight}, got: ${dimensions.width}x${dimensions.height}`, dimensions.width, dimensions.height);
    }
    if (dimensions.width > maxWidth || dimensions.height > maxHeight) {
        throw new ImageDimensionError(`Image dimensions too large. Maximum: ${maxWidth}x${maxHeight}, got: ${dimensions.width}x${dimensions.height}`, dimensions.width, dimensions.height);
    }
}
function getBase64Size(base64) {
    const base64Data = base64.split(',')[1];
    return atob(base64Data).length;
}
async function processImageForTryon(file, options = {}) {
    const startTime = Date.now();
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    try {
        // Step 1: Validate file type and convert to base64
        if (!(0, _image.isImageFile)(file)) {
            throw new _image.FileTypeNotSupportedError('Only image files are allowed');
        }
        const originalBase64 = await (0, _image.fileToBase64)(file);
        const originalSize = file.size;
        const originalDimensions = await getImageDimensions(originalBase64);
        // Step 2: Validate dimensions
        await validateImageDimensions(originalBase64);
        // Step 3: Resize image to target dimensions
        const resizedImage = await resizeImageTo1024x1536(originalBase64, config);
        const finalDimensions = await getImageDimensions(resizedImage);
        // Step 4: Compress if needed
        let processedImage = resizedImage;
        let wasCompressed = false;
        const resizedSize = getBase64Size(resizedImage);
        const targetSizeBytes = config.maxSizeKB * 1024;
        if (resizedSize > targetSizeBytes) {
            processedImage = await (0, _image.compressBase64)(resizedImage, config.maxSizeKB);
            wasCompressed = true;
        }
        const finalSize = getBase64Size(processedImage);
        const processingTime = Date.now() - startTime;
        return {
            processedImage,
            originalDimensions,
            finalDimensions,
            originalSize,
            finalSize,
            metadata: {
                wasResized: originalDimensions.width !== finalDimensions.width || originalDimensions.height !== finalDimensions.height,
                wasCompressed,
                compressionRatio: originalSize / finalSize,
                processingTime
            }
        };
    } catch (error) {
        if (error instanceof _image.FileTypeNotSupportedError || error instanceof _image.FileTooLargeError || error instanceof _image.CompressionFailedError || error instanceof ImageDimensionError || error instanceof ImageProcessingError) {
            throw error;
        }
        throw new ImageProcessingError('Unexpected error during image processing', error instanceof Error ? error : new Error(String(error)));
    }
}
async function processTryonImages(modelImage, apparelImages, options = {}) {
    // Process model image
    const modelImageResult = await processImageForTryon(modelImage, options);
    // Process all apparel images in parallel
    const apparelImageResults = await Promise.all(apparelImages.map((file)=>processImageForTryon(file, options)));
    return {
        modelImageResult,
        apparelImageResults
    };
}
async function extractImageMetadata(file) {
    const imageUrl = await (0, _image.fileToBase64)(file);
    const dimensions = await getImageDimensions(imageUrl);
    return {
        format: file.type,
        dimensions,
        size: file.size,
        dateCreated: file.lastModified ? new Date(file.lastModified) : undefined
    };
}
async function convertImageFormat(imageUrl, targetFormat, quality = 0.9) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                canvas.width = img.width;
                canvas.height = img.height;
                // For PNG with transparency, fill with white background for JPEG
                if (targetFormat === "image/jpeg") {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                ctx.drawImage(img, 0, 0);
                const convertedImageUrl = canvas.toDataURL(targetFormat, quality);
                resolve(convertedImageUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to convert image format', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for format conversion'));
        };
        img.src = imageUrl;
    });
}
function applySharpeningFilter(canvas, strength = 0.5) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    // Simple unsharp mask implementation
    const sharpenKernel = [
        0,
        -strength,
        0,
        -strength,
        1 + 4 * strength,
        -strength,
        0,
        -strength,
        0
    ];
    const newData = new Uint8ClampedArray(data);
    for(let y = 1; y < height - 1; y++){
        for(let x = 1; x < width - 1; x++){
            for(let c = 0; c < 3; c++){
                let sum = 0;
                for(let ky = -1; ky <= 1; ky++){
                    for(let kx = -1; kx <= 1; kx++){
                        const pixelIndex = ((y + ky) * width + (x + kx)) * 4 + c;
                        const kernelIndex = (ky + 1) * 3 + (kx + 1);
                        sum += data[pixelIndex] * sharpenKernel[kernelIndex];
                    }
                }
                newData[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));
            }
        }
    }
    // Copy the new data back
    for(let i = 0; i < data.length; i++){
        data[i] = newData[i];
    }
    ctx.putImageData(imageData, 0, 0);
}
function applyNoiseReduction(canvas, strength = 0.3) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    // Simple blur for noise reduction
    const radius = Math.ceil(strength * 3);
    const newData = new Uint8ClampedArray(data);
    for(let y = 0; y < height; y++){
        for(let x = 0; x < width; x++){
            for(let c = 0; c < 3; c++){
                let sum = 0;
                let count = 0;
                for(let dy = -radius; dy <= radius; dy++){
                    for(let dx = -radius; dx <= radius; dx++){
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            sum += data[(ny * width + nx) * 4 + c];
                            count++;
                        }
                    }
                }
                newData[(y * width + x) * 4 + c] = sum / count;
            }
        }
    }
    // Copy the new data back
    for(let i = 0; i < data.length; i += 4){
        data[i] = newData[i]; // R
        data[i + 1] = newData[i + 1]; // G
        data[i + 2] = newData[i + 2]; // B
    // Keep original alpha
    }
    ctx.putImageData(imageData, 0, 0);
}
function applyAutoColorCorrection(canvas) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new ImageProcessingError('Could not get canvas context');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    // Calculate histogram
    const histogram = {
        r: new Array(256).fill(0),
        g: new Array(256).fill(0),
        b: new Array(256).fill(0)
    };
    for(let i = 0; i < data.length; i += 4){
        histogram.r[data[i]]++;
        histogram.g[data[i + 1]]++;
        histogram.b[data[i + 2]]++;
    }
    // Find min/max values for each channel
    const getMinMax = (hist)=>{
        let min = 0, max = 255;
        for(let i = 0; i < 256; i++){
            if (hist[i] > 0) {
                min = i;
                break;
            }
        }
        for(let i = 255; i >= 0; i--){
            if (hist[i] > 0) {
                max = i;
                break;
            }
        }
        return {
            min,
            max
        };
    };
    const rMinMax = getMinMax(histogram.r);
    const gMinMax = getMinMax(histogram.g);
    const bMinMax = getMinMax(histogram.b);
    // Apply histogram stretching
    for(let i = 0; i < data.length; i += 4){
        data[i] = Math.max(0, Math.min(255, (data[i] - rMinMax.min) / (rMinMax.max - rMinMax.min) * 255));
        data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - gMinMax.min) / (gMinMax.max - gMinMax.min) * 255));
        data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - bMinMax.min) / (bMinMax.max - bMinMax.min) * 255));
    }
    ctx.putImageData(imageData, 0, 0);
}
async function processImageAdvanced(file, options = {}) {
    const startTime = Date.now();
    const config = {
        ...DEFAULT_PROCESSING_OPTIONS,
        ...options
    };
    const operationsApplied = [];
    try {
        // Step 1: Extract original metadata
        const originalMetadata = await extractImageMetadata(file);
        operationsApplied.push('metadata-extraction');
        // Step 2: Validate file type and convert to base64
        if (!(0, _image.isImageFile)(file)) {
            throw new _image.FileTypeNotSupportedError('Only image files are allowed');
        }
        let currentImage = await (0, _image.fileToBase64)(file);
        operationsApplied.push('base64-conversion');
        // Step 3: Validate dimensions
        await validateImageDimensions(currentImage);
        operationsApplied.push('dimension-validation');
        // Step 4: Format conversion (if needed)
        let wasFormatConverted = false;
        if (options.outputFormat && options.outputFormat !== file.type) {
            currentImage = await convertImageFormat(currentImage, options.outputFormat, config.quality);
            wasFormatConverted = true;
            operationsApplied.push('format-conversion');
        }
        // Step 5: Create canvas for advanced processing
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new ImageProcessingError('Could not get canvas context');
        // Load image onto canvas
        const img = new Image();
        img.crossOrigin = "anonymous";
        await new Promise((resolve, reject)=>{
            img.onload = ()=>resolve();
            img.onerror = ()=>reject(new ImageProcessingError('Failed to load image'));
            img.src = currentImage;
        });
        // Set canvas dimensions based on resize requirements
        const finalWidth = config.targetWidth || img.width;
        const finalHeight = config.targetHeight || img.height;
        canvas.width = finalWidth;
        canvas.height = finalHeight;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        // Draw resized image
        ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
        const wasResized = img.width !== finalWidth || img.height !== finalHeight;
        if (wasResized) {
            operationsApplied.push('resize');
        }
        // Step 6: Apply advanced processing
        let wasSharpened = false;
        if (options.enableSharpening && wasResized) {
            applySharpeningFilter(canvas, 0.3);
            wasSharpened = true;
            operationsApplied.push('sharpening');
        }
        let hadNoiseReduction = false;
        if (options.noiseReduction && options.noiseReduction > 0) {
            applyNoiseReduction(canvas, options.noiseReduction);
            hadNoiseReduction = true;
            operationsApplied.push('noise-reduction');
        }
        if (options.autoColorCorrection) {
            applyAutoColorCorrection(canvas);
            operationsApplied.push('color-correction');
        }
        // Step 7: Convert back to data URL
        const outputFormat = options.outputFormat || "image/jpeg";
        let processedImage = canvas.toDataURL(outputFormat, config.quality);
        // Step 8: Compress if needed
        let wasCompressed = false;
        const processedSize = getBase64Size(processedImage);
        const targetSizeBytes = config.maxSizeKB * 1024;
        if (processedSize > targetSizeBytes) {
            processedImage = await (0, _image.compressBase64)(processedImage, config.maxSizeKB);
            wasCompressed = true;
            operationsApplied.push('compression');
        }
        // Step 9: Generate final metadata
        const finalDimensions = await getImageDimensions(processedImage);
        const finalSize = getBase64Size(processedImage);
        const processingTime = Date.now() - startTime;
        const finalMetadata = {
            format: outputFormat,
            dimensions: finalDimensions,
            size: finalSize
        };
        return {
            processedImage,
            originalMetadata,
            finalMetadata,
            processingMetadata: {
                wasResized,
                wasCompressed,
                wasFormatConverted,
                wasSharpened,
                hadNoiseReduction,
                compressionRatio: originalMetadata.size / finalSize,
                processingTime,
                operationsApplied
            }
        };
    } catch (error) {
        if (error instanceof _image.FileTypeNotSupportedError || error instanceof _image.FileTooLargeError || error instanceof _image.CompressionFailedError || error instanceof ImageDimensionError || error instanceof ImageProcessingError) {
            throw error;
        }
        throw new ImageProcessingError('Unexpected error during advanced image processing', error instanceof Error ? error : new Error(String(error)));
    }
}
async function processImagesInBatch(files, options = {}, onProgress) {
    const results = [];
    for(let i = 0; i < files.length; i++){
        const file = files[i];
        onProgress?.(i, files.length, file.name);
        try {
            const result = await processImageAdvanced(file, options);
            results.push(result);
        } catch (error) {
            // For batch processing, we might want to continue with other files
            console.error(`Failed to process ${file.name}:`, error);
        // You could push a failed result or skip, depending on requirements
        }
    }
    onProgress?.(files.length, files.length, 'Complete');
    return results;
}
async function createImageThumbnail(file, size = 150, quality = 0.8) {
    const imageUrl = await (0, _image.fileToBase64)(file);
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>{
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new ImageProcessingError('Could not get canvas context'));
                    return;
                }
                // Calculate dimensions to maintain aspect ratio
                const aspectRatio = img.width / img.height;
                let width = size;
                let height = size;
                if (aspectRatio > 1) {
                    height = size / aspectRatio;
                } else {
                    width = size * aspectRatio;
                }
                canvas.width = width;
                canvas.height = height;
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, width, height);
                const thumbnailUrl = canvas.toDataURL('image/jpeg', quality);
                resolve(thumbnailUrl);
            } catch (error) {
                reject(new ImageProcessingError('Failed to create thumbnail', error instanceof Error ? error : new Error(String(error))));
            }
        };
        img.onerror = ()=>{
            reject(new ImageProcessingError('Failed to load image for thumbnail creation'));
        };
        img.src = imageUrl;
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbWFnZSBQcm9jZXNzaW5nIFV0aWxpdGllcyBmb3IgVHJ5LU9uIE11dGF0aW9uc1xuLy8gQ29tcHJlaGVuc2l2ZSBpbWFnZSBwcm9jZXNzaW5nIGZ1bmN0aW9ucyBmb3IgdGhlIGJ1c2luZXNzIGxheWVyXG5cbmltcG9ydCB7IFxuICBmaWxlVG9CYXNlNjQsIFxuICBjb21wcmVzc0Jhc2U2NCwgXG4gIGlzSW1hZ2VGaWxlLFxuICBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yLFxuICBGaWxlVG9vTGFyZ2VFcnJvcixcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcixcbiAgdHlwZSBJbWFnZUJhc2U2NFxufSBmcm9tICdAL3V0aWxzL2ltYWdlJztcblxuLy8gUmUtZXhwb3J0IHV0aWxpdGllcyBuZWVkZWQgYnkgb3RoZXIgYnVzaW5lc3MgbGF5ZXIgbW9kdWxlc1xuZXhwb3J0IHsgXG4gIGNvbXByZXNzQmFzZTY0LCBcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcixcbiAgRmlsZVR5cGVOb3RTdXBwb3J0ZWRFcnJvcixcbiAgRmlsZVRvb0xhcmdlRXJyb3IsXG4gIGZpbGVUb0Jhc2U2NCxcbiAgaXNJbWFnZUZpbGUsXG4gIHR5cGUgSW1hZ2VCYXNlNjQgXG59O1xuXG4vLyBnZXRCYXNlNjRTaXplIGZ1bmN0aW9uIGlzIGV4cG9ydGVkIHdoZXJlIGl0J3MgZGVmaW5lZCBiZWxvd1xuaW1wb3J0IHsgXG4gIEFkdmFuY2VkQ2FudmFzT3BlcmF0aW9ucywgXG4gIGNyZWF0ZUFkdmFuY2VkQ2FudmFzT3BlcmF0aW9ucyxcbiAgdHlwZSBNYW5hZ2VkQ2FudmFzIFxufSBmcm9tICcuLi9wcm92aWRlcnMvQ2FudmFzUHJvdmlkZXInO1xuXG4vKipcbiAqIEN1c3RvbSBlcnJvciBmb3IgaW1hZ2UgcHJvY2Vzc2luZyBmYWlsdXJlc1xuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VQcm9jZXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcHVibGljIHJlYWRvbmx5IG9yaWdpbmFsRXJyb3I/OiBFcnJvcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdJbWFnZVByb2Nlc3NpbmdFcnJvcic7XG4gIH1cbn1cblxuLyoqXG4gKiBDdXN0b20gZXJyb3IgZm9yIGltYWdlIGRpbWVuc2lvbiB2YWxpZGF0aW9uIGZhaWx1cmVzXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZURpbWVuc2lvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSB3aWR0aD86IG51bWJlciwgcHVibGljIHJlYWRvbmx5IGhlaWdodD86IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdJbWFnZURpbWVuc2lvbkVycm9yJztcbiAgfVxufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgaW1hZ2UgcHJvY2Vzc2luZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlUHJvY2Vzc2luZ09wdGlvbnMge1xuICAvKiogVGFyZ2V0IHdpZHRoIGZvciByZXNpemluZyAoZGVmYXVsdDogMTAyNCkgKi9cbiAgdGFyZ2V0V2lkdGg/OiBudW1iZXI7XG4gIC8qKiBUYXJnZXQgaGVpZ2h0IGZvciByZXNpemluZyAoZGVmYXVsdDogMTUzNikgKi9cbiAgdGFyZ2V0SGVpZ2h0PzogbnVtYmVyO1xuICAvKiogTWF4aW11bSBmaWxlIHNpemUgaW4gS0IgYWZ0ZXIgY29tcHJlc3Npb24gKGRlZmF1bHQ6IDEwMjQpICovXG4gIG1heFNpemVLQj86IG51bWJlcjtcbiAgLyoqIEpQRUcgcXVhbGl0eSBmb3IgY29tcHJlc3Npb24gKDAuMS0xLjAsIGRlZmF1bHQ6IDAuOSkgKi9cbiAgcXVhbGl0eT86IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgdG8gcHJlc2VydmUgYXNwZWN0IHJhdGlvIGR1cmluZyByZXNpemUgKGRlZmF1bHQ6IGZhbHNlKSAqL1xuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IHByb2Nlc3Npbmcgb3B0aW9ucyBmb3IgdHJ5LW9uIGltYWdlc1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9QUk9DRVNTSU5HX09QVElPTlM6IFJlcXVpcmVkPEltYWdlUHJvY2Vzc2luZ09wdGlvbnM+ID0ge1xuICB0YXJnZXRXaWR0aDogMTAyNCxcbiAgdGFyZ2V0SGVpZ2h0OiAxNTM2LFxuICBtYXhTaXplS0I6IDEwMjQsXG4gIHF1YWxpdHk6IDAuOSxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbzogZmFsc2Vcbn07XG5cbi8qKlxuICogU3VwcG9ydGVkIGltYWdlIGZvcm1hdHMgZm9yIGNvbnZlcnNpb25cbiAqL1xuZXhwb3J0IGVudW0gSW1hZ2VGb3JtYXQge1xuICBKUEVHID0gJ2ltYWdlL2pwZWcnLFxuICBQTkcgPSAnaW1hZ2UvcG5nJyxcbiAgV0VCUCA9ICdpbWFnZS93ZWJwJyxcbiAgR0lGID0gJ2ltYWdlL2dpZidcbn1cblxuLyoqXG4gKiBJbWFnZSBtZXRhZGF0YSBleHRyYWN0ZWQgZnJvbSBmaWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VNZXRhZGF0YSB7XG4gIC8qKiBJbWFnZSBmb3JtYXQvTUlNRSB0eXBlICovXG4gIGZvcm1hdDogc3RyaW5nO1xuICAvKiogSW1hZ2UgZGltZW5zaW9ucyAqL1xuICBkaW1lbnNpb25zOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG4gIC8qKiBGaWxlIHNpemUgaW4gYnl0ZXMgKi9cbiAgc2l6ZTogbnVtYmVyO1xuICAvKiogQ29sb3IgZGVwdGggaW5mb3JtYXRpb24gKi9cbiAgY29sb3JEZXB0aD86IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgaW1hZ2UgaGFzIHRyYW5zcGFyZW5jeSAqL1xuICBoYXNBbHBoYT86IGJvb2xlYW47XG4gIC8qKiBFc3RpbWF0ZWQgcXVhbGl0eSAoZm9yIEpQRUcpICovXG4gIGVzdGltYXRlZFF1YWxpdHk/OiBudW1iZXI7XG4gIC8qKiBDcmVhdGlvbiB0aW1lc3RhbXAgaWYgYXZhaWxhYmxlICovXG4gIGRhdGVDcmVhdGVkPzogRGF0ZTtcbiAgLyoqIERldmljZSBvcmllbnRhdGlvbiAoRVhJRikgKi9cbiAgb3JpZW50YXRpb24/OiBudW1iZXI7XG4gIC8qKiBEUEkvcmVzb2x1dGlvbiBpbmZvcm1hdGlvbiAqL1xuICByZXNvbHV0aW9uPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xufVxuXG4vKipcbiAqIEFkdmFuY2VkIGltYWdlIHByb2Nlc3Npbmcgb3B0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFkdmFuY2VkSW1hZ2VQcm9jZXNzaW5nT3B0aW9ucyBleHRlbmRzIEltYWdlUHJvY2Vzc2luZ09wdGlvbnMge1xuICAvKiogT3V0cHV0IGZvcm1hdCAqL1xuICBvdXRwdXRGb3JtYXQ/OiBJbWFnZUZvcm1hdDtcbiAgLyoqIEVuYWJsZSBzaGFycGVuaW5nIGFmdGVyIHJlc2l6ZSAqL1xuICBlbmFibGVTaGFycGVuaW5nPzogYm9vbGVhbjtcbiAgLyoqIE5vaXNlIHJlZHVjdGlvbiBzdHJlbmd0aCAoMC0xKSAqL1xuICBub2lzZVJlZHVjdGlvbj86IG51bWJlcjtcbiAgLyoqIEVuYWJsZSBhdXRvbWF0aWMgY29sb3IgY29ycmVjdGlvbiAqL1xuICBhdXRvQ29sb3JDb3JyZWN0aW9uPzogYm9vbGVhbjtcbiAgLyoqIFByZXNlcnZlIEVYSUYgZGF0YSAqL1xuICBwcmVzZXJ2ZUV4aWY/OiBib29sZWFuO1xuICAvKiogQ3VzdG9tIGNhbnZhcyBmb3IgcHJvY2Vzc2luZyAqL1xuICBjYW52YXM/OiBNYW5hZ2VkQ2FudmFzO1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIHJlc3VsdCBvZiBpbWFnZSBwcm9jZXNzaW5nIG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gIC8qKiBQcm9jZXNzZWQgaW1hZ2UgYXMgYmFzZTY0IGRhdGEgVVJMICovXG4gIHByb2Nlc3NlZEltYWdlOiBJbWFnZUJhc2U2NDtcbiAgLyoqIE9yaWdpbmFsIGltYWdlIG1ldGFkYXRhICovXG4gIG9yaWdpbmFsTWV0YWRhdGE6IEltYWdlTWV0YWRhdGE7XG4gIC8qKiBGaW5hbCBpbWFnZSBtZXRhZGF0YSAqL1xuICBmaW5hbE1ldGFkYXRhOiBJbWFnZU1ldGFkYXRhO1xuICAvKiogUHJvY2Vzc2luZyBtZXRhZGF0YSAqL1xuICBwcm9jZXNzaW5nTWV0YWRhdGE6IHtcbiAgICB3YXNSZXNpemVkOiBib29sZWFuO1xuICAgIHdhc0NvbXByZXNzZWQ6IGJvb2xlYW47XG4gICAgd2FzRm9ybWF0Q29udmVydGVkOiBib29sZWFuO1xuICAgIHdhc1NoYXJwZW5lZDogYm9vbGVhbjtcbiAgICBoYWROb2lzZVJlZHVjdGlvbjogYm9vbGVhbjtcbiAgICBjb21wcmVzc2lvblJhdGlvOiBudW1iZXI7XG4gICAgcHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcbiAgICBvcGVyYXRpb25zQXBwbGllZDogc3RyaW5nW107XG4gIH07XG59XG5cbi8qKlxuICogUmVzdWx0IG9mIGltYWdlIHByb2Nlc3Npbmcgb3BlcmF0aW9ucyAobGVnYWN5IGNvbXBhdGliaWxpdHkpXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VQcm9jZXNzaW5nUmVzdWx0IHtcbiAgLyoqIFByb2Nlc3NlZCBpbWFnZSBhcyBiYXNlNjQgZGF0YSBVUkwgKi9cbiAgcHJvY2Vzc2VkSW1hZ2U6IEltYWdlQmFzZTY0O1xuICAvKiogT3JpZ2luYWwgaW1hZ2UgZGltZW5zaW9ucyAqL1xuICBvcmlnaW5hbERpbWVuc2lvbnM6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfTtcbiAgLyoqIEZpbmFsIGltYWdlIGRpbWVuc2lvbnMgKi9cbiAgZmluYWxEaW1lbnNpb25zOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG4gIC8qKiBPcmlnaW5hbCBmaWxlIHNpemUgaW4gYnl0ZXMgKi9cbiAgb3JpZ2luYWxTaXplOiBudW1iZXI7XG4gIC8qKiBGaW5hbCBmaWxlIHNpemUgaW4gYnl0ZXMgKi9cbiAgZmluYWxTaXplOiBudW1iZXI7XG4gIC8qKiBQcm9jZXNzaW5nIG1ldGFkYXRhICovXG4gIG1ldGFkYXRhOiB7XG4gICAgd2FzUmVzaXplZDogYm9vbGVhbjtcbiAgICB3YXNDb21wcmVzc2VkOiBib29sZWFuO1xuICAgIGNvbXByZXNzaW9uUmF0aW86IG51bWJlcjtcbiAgICBwcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuICB9O1xufVxuXG4vKipcbiAqIEdldCBpbWFnZSBkaW1lbnNpb25zIGZyb20gYSBkYXRhIFVSTCBvciBpbWFnZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZURpbWVuc2lvbnMoaW1hZ2VVcmw6IHN0cmluZyk6IFByb21pc2U8eyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICBcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSh7IHdpZHRoOiBpbWcud2lkdGgsIGhlaWdodDogaW1nLmhlaWdodCB9KTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UgZm9yIGRpbWVuc2lvbiBhbmFseXNpcycpKTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5zcmMgPSBpbWFnZVVybDtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzaXplIGltYWdlIHRvIHNwZWNpZmljIGRpbWVuc2lvbnNcbiAqIFxuICogQHBhcmFtIGltYWdlVXJsIC0gU291cmNlIGltYWdlIGRhdGEgVVJMXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFJlc2l6ZSBvcHRpb25zXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byByZXNpemVkIGltYWdlIGRhdGEgVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNpemVJbWFnZVRvMTAyNHgxNTM2KFxuICBpbWFnZVVybDogc3RyaW5nLCBcbiAgb3B0aW9uczogUGFydGlhbDxJbWFnZVByb2Nlc3NpbmdPcHRpb25zPiA9IHt9XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBjb25maWcgPSB7IC4uLkRFRkFVTFRfUFJPQ0VTU0lOR19PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gIFxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCB7IHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQgfSA9IGNvbmZpZztcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkaW1lbnNpb25zIHByZXNlcnZpbmcgYXNwZWN0IHJhdGlvIGlmIHJlcXVlc3RlZFxuICAgICAgICBpZiAoY29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGltZy53aWR0aCAvIGltZy5oZWlnaHQ7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0QXNwZWN0UmF0aW8gPSB0YXJnZXRXaWR0aCAvIHRhcmdldEhlaWdodDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8gPiB0YXJnZXRBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgLy8gSW1hZ2UgaXMgd2lkZXIsIGZpdCB0byB3aWR0aFxuICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gTWF0aC5yb3VuZCh0YXJnZXRXaWR0aCAvIGFzcGVjdFJhdGlvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW1hZ2UgaXMgdGFsbGVyLCBmaXQgdG8gaGVpZ2h0XG4gICAgICAgICAgICB0YXJnZXRXaWR0aCA9IE1hdGgucm91bmQodGFyZ2V0SGVpZ2h0ICogYXNwZWN0UmF0aW8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgaGlnaC1xdWFsaXR5IHNjYWxpbmdcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ1F1YWxpdHkgPSAnaGlnaCc7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZSByZXNpemVkIHRvIGZpdCB0aGUgY2FudmFzXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZGF0YSBVUkwgd2l0aCBzcGVjaWZpZWQgcXVhbGl0eVxuICAgICAgICBjb25zdCByZXNpemVkSW1hZ2VVcmwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgY29uZmlnLnF1YWxpdHkpO1xuICAgICAgICByZXNvbHZlKHJlc2l6ZWRJbWFnZVVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gcmVzaXplIGltYWdlJyxcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlIGZvciByZXNpemluZycpKTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5zcmMgPSBpbWFnZVVybDtcbiAgfSk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgaW1hZ2UgZGltZW5zaW9ucyBhZ2FpbnN0IHJlcXVpcmVtZW50c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVJbWFnZURpbWVuc2lvbnMoXG4gIGltYWdlVXJsOiBzdHJpbmcsXG4gIG1pbldpZHRoID0gNTEyLFxuICBtaW5IZWlnaHQgPSA1MTIsXG4gIG1heFdpZHRoID0gNDA5NixcbiAgbWF4SGVpZ2h0ID0gNDA5NlxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBhd2FpdCBnZXRJbWFnZURpbWVuc2lvbnMoaW1hZ2VVcmwpO1xuICBcbiAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCBtaW5XaWR0aCB8fCBkaW1lbnNpb25zLmhlaWdodCA8IG1pbkhlaWdodCkge1xuICAgIHRocm93IG5ldyBJbWFnZURpbWVuc2lvbkVycm9yKFxuICAgICAgYEltYWdlIGRpbWVuc2lvbnMgdG9vIHNtYWxsLiBNaW5pbXVtOiAke21pbldpZHRofXgke21pbkhlaWdodH0sIGdvdDogJHtkaW1lbnNpb25zLndpZHRofXgke2RpbWVuc2lvbnMuaGVpZ2h0fWAsXG4gICAgICBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgZGltZW5zaW9ucy5oZWlnaHRcbiAgICApO1xuICB9XG4gIFxuICBpZiAoZGltZW5zaW9ucy53aWR0aCA+IG1heFdpZHRoIHx8IGRpbWVuc2lvbnMuaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgdGhyb3cgbmV3IEltYWdlRGltZW5zaW9uRXJyb3IoXG4gICAgICBgSW1hZ2UgZGltZW5zaW9ucyB0b28gbGFyZ2UuIE1heGltdW06ICR7bWF4V2lkdGh9eCR7bWF4SGVpZ2h0fSwgZ290OiAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9YCxcbiAgICAgIGRpbWVuc2lvbnMud2lkdGgsXG4gICAgICBkaW1lbnNpb25zLmhlaWdodFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZmlsZSBzaXplIGZyb20gYmFzZTY0IGRhdGEgVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlNjRTaXplKGJhc2U2NDogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgYmFzZTY0RGF0YSA9IGJhc2U2NC5zcGxpdCgnLCcpWzFdO1xuICByZXR1cm4gYXRvYihiYXNlNjREYXRhKS5sZW5ndGg7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGZpbGUgdGhyb3VnaCB0aGUgY29tcGxldGUgdHJ5LW9uIGltYWdlIHBpcGVsaW5lXG4gKiBcbiAqIEBwYXJhbSBmaWxlIC0gSW5wdXQgaW1hZ2UgZmlsZVxuICogQHBhcmFtIG9wdGlvbnMgLSBQcm9jZXNzaW5nIG9wdGlvbnNcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHByb2Nlc3NpbmcgcmVzdWx0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSW1hZ2VGb3JUcnlvbihcbiAgZmlsZTogRmlsZSxcbiAgb3B0aW9uczogUGFydGlhbDxJbWFnZVByb2Nlc3NpbmdPcHRpb25zPiA9IHt9XG4pOiBQcm9taXNlPEltYWdlUHJvY2Vzc2luZ1Jlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBjb25zdCBjb25maWcgPSB7IC4uLkRFRkFVTFRfUFJPQ0VTU0lOR19PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gIFxuICB0cnkge1xuICAgIC8vIFN0ZXAgMTogVmFsaWRhdGUgZmlsZSB0eXBlIGFuZCBjb252ZXJ0IHRvIGJhc2U2NFxuICAgIGlmICghaXNJbWFnZUZpbGUoZmlsZSkpIHtcbiAgICAgIHRocm93IG5ldyBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yKCdPbmx5IGltYWdlIGZpbGVzIGFyZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG9yaWdpbmFsQmFzZTY0ID0gYXdhaXQgZmlsZVRvQmFzZTY0KGZpbGUpO1xuICAgIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICBjb25zdCBvcmlnaW5hbERpbWVuc2lvbnMgPSBhd2FpdCBnZXRJbWFnZURpbWVuc2lvbnMob3JpZ2luYWxCYXNlNjQpO1xuICAgIFxuICAgIC8vIFN0ZXAgMjogVmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGF3YWl0IHZhbGlkYXRlSW1hZ2VEaW1lbnNpb25zKG9yaWdpbmFsQmFzZTY0KTtcbiAgICBcbiAgICAvLyBTdGVwIDM6IFJlc2l6ZSBpbWFnZSB0byB0YXJnZXQgZGltZW5zaW9uc1xuICAgIGNvbnN0IHJlc2l6ZWRJbWFnZSA9IGF3YWl0IHJlc2l6ZUltYWdlVG8xMDI0eDE1MzYob3JpZ2luYWxCYXNlNjQsIGNvbmZpZyk7XG4gICAgY29uc3QgZmluYWxEaW1lbnNpb25zID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKHJlc2l6ZWRJbWFnZSk7XG4gICAgXG4gICAgLy8gU3RlcCA0OiBDb21wcmVzcyBpZiBuZWVkZWRcbiAgICBsZXQgcHJvY2Vzc2VkSW1hZ2UgPSByZXNpemVkSW1hZ2U7XG4gICAgbGV0IHdhc0NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICBcbiAgICBjb25zdCByZXNpemVkU2l6ZSA9IGdldEJhc2U2NFNpemUocmVzaXplZEltYWdlKTtcbiAgICBjb25zdCB0YXJnZXRTaXplQnl0ZXMgPSBjb25maWcubWF4U2l6ZUtCICogMTAyNDtcbiAgICBcbiAgICBpZiAocmVzaXplZFNpemUgPiB0YXJnZXRTaXplQnl0ZXMpIHtcbiAgICAgIHByb2Nlc3NlZEltYWdlID0gYXdhaXQgY29tcHJlc3NCYXNlNjQocmVzaXplZEltYWdlLCBjb25maWcubWF4U2l6ZUtCKTtcbiAgICAgIHdhc0NvbXByZXNzZWQgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmaW5hbFNpemUgPSBnZXRCYXNlNjRTaXplKHByb2Nlc3NlZEltYWdlKTtcbiAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2Nlc3NlZEltYWdlLFxuICAgICAgb3JpZ2luYWxEaW1lbnNpb25zLFxuICAgICAgZmluYWxEaW1lbnNpb25zLFxuICAgICAgb3JpZ2luYWxTaXplLFxuICAgICAgZmluYWxTaXplLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgd2FzUmVzaXplZDogb3JpZ2luYWxEaW1lbnNpb25zLndpZHRoICE9PSBmaW5hbERpbWVuc2lvbnMud2lkdGggfHwgXG4gICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zLmhlaWdodCAhPT0gZmluYWxEaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgd2FzQ29tcHJlc3NlZCxcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogb3JpZ2luYWxTaXplIC8gZmluYWxTaXplLFxuICAgICAgICBwcm9jZXNzaW5nVGltZVxuICAgICAgfVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRmlsZVR5cGVOb3RTdXBwb3J0ZWRFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEZpbGVUb29MYXJnZUVycm9yIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgQ29tcHJlc3Npb25GYWlsZWRFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEltYWdlRGltZW5zaW9uRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBJbWFnZVByb2Nlc3NpbmdFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIFxuICAgIHRocm93IG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcihcbiAgICAgICdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbWFnZSBwcm9jZXNzaW5nJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9jZXNzIG11bHRpcGxlIGltYWdlcyBmb3IgdHJ5LW9uIChtb2RlbCArIGFwcGFyZWwgaW1hZ2VzKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1RyeW9uSW1hZ2VzKFxuICBtb2RlbEltYWdlOiBGaWxlLFxuICBhcHBhcmVsSW1hZ2VzOiBGaWxlW10sXG4gIG9wdGlvbnM6IFBhcnRpYWw8SW1hZ2VQcm9jZXNzaW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTx7XG4gIG1vZGVsSW1hZ2VSZXN1bHQ6IEltYWdlUHJvY2Vzc2luZ1Jlc3VsdDtcbiAgYXBwYXJlbEltYWdlUmVzdWx0czogSW1hZ2VQcm9jZXNzaW5nUmVzdWx0W107XG59PiB7XG4gIC8vIFByb2Nlc3MgbW9kZWwgaW1hZ2VcbiAgY29uc3QgbW9kZWxJbWFnZVJlc3VsdCA9IGF3YWl0IHByb2Nlc3NJbWFnZUZvclRyeW9uKG1vZGVsSW1hZ2UsIG9wdGlvbnMpO1xuICBcbiAgLy8gUHJvY2VzcyBhbGwgYXBwYXJlbCBpbWFnZXMgaW4gcGFyYWxsZWxcbiAgY29uc3QgYXBwYXJlbEltYWdlUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGFwcGFyZWxJbWFnZXMubWFwKGZpbGUgPT4gcHJvY2Vzc0ltYWdlRm9yVHJ5b24oZmlsZSwgb3B0aW9ucykpXG4gICk7XG4gIFxuICByZXR1cm4ge1xuICAgIG1vZGVsSW1hZ2VSZXN1bHQsXG4gICAgYXBwYXJlbEltYWdlUmVzdWx0c1xuICB9O1xufVxuXG4vKipcbiAqIEV4dHJhY3QgY29tcHJlaGVuc2l2ZSBtZXRhZGF0YSBmcm9tIGltYWdlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0SW1hZ2VNZXRhZGF0YShmaWxlOiBGaWxlKTogUHJvbWlzZTxJbWFnZU1ldGFkYXRhPiB7XG4gIGNvbnN0IGltYWdlVXJsID0gYXdhaXQgZmlsZVRvQmFzZTY0KGZpbGUpO1xuICBjb25zdCBkaW1lbnNpb25zID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKGltYWdlVXJsKTtcbiAgXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBmaWxlLnR5cGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgZGF0ZUNyZWF0ZWQ6IGZpbGUubGFzdE1vZGlmaWVkID8gbmV3IERhdGUoZmlsZS5sYXN0TW9kaWZpZWQpIDogdW5kZWZpbmVkLFxuICAgIC8vIEFkZGl0aW9uYWwgbWV0YWRhdGEgd291bGQgcmVxdWlyZSBFWElGIHBhcnNpbmcgbGlicmFyeVxuICAgIC8vIEZvciBub3csIHdlJ2xsIHByb3ZpZGUgYmFzaWMgbWV0YWRhdGFcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGltYWdlIHRvIGRpZmZlcmVudCBmb3JtYXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRJbWFnZUZvcm1hdChcbiAgaW1hZ2VVcmw6IHN0cmluZyxcbiAgdGFyZ2V0Rm9ybWF0OiBJbWFnZUZvcm1hdCxcbiAgcXVhbGl0eTogbnVtYmVyID0gMC45XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3IgUE5HIHdpdGggdHJhbnNwYXJlbmN5LCBmaWxsIHdpdGggd2hpdGUgYmFja2dyb3VuZCBmb3IgSlBFR1xuICAgICAgICBpZiAodGFyZ2V0Rm9ybWF0ID09PSBJbWFnZUZvcm1hdC5KUEVHKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZEltYWdlVXJsID0gY2FudmFzLnRvRGF0YVVSTCh0YXJnZXRGb3JtYXQsIHF1YWxpdHkpO1xuICAgICAgICByZXNvbHZlKGNvbnZlcnRlZEltYWdlVXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBjb252ZXJ0IGltYWdlIGZvcm1hdCcsXG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSBmb3IgZm9ybWF0IGNvbnZlcnNpb24nKSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IHNoYXJwZW5pbmcgZmlsdGVyIHRvIGltYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNoYXJwZW5pbmdGaWx0ZXIoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc3RyZW5ndGg6IG51bWJlciA9IDAuNSk6IHZvaWQge1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgaWYgKCFjdHgpIHRocm93IG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpO1xuICBcbiAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICBcbiAgLy8gU2ltcGxlIHVuc2hhcnAgbWFzayBpbXBsZW1lbnRhdGlvblxuICBjb25zdCBzaGFycGVuS2VybmVsID0gW1xuICAgIDAsIC1zdHJlbmd0aCwgMCxcbiAgICAtc3RyZW5ndGgsIDEgKyA0ICogc3RyZW5ndGgsIC1zdHJlbmd0aCxcbiAgICAwLCAtc3RyZW5ndGgsIDBcbiAgXTtcbiAgXG4gIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YSk7XG4gIFxuICBmb3IgKGxldCB5ID0gMTsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAxOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgMzsgYysrKSB7IC8vIFJHQiBjaGFubmVscyBvbmx5XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBreSA9IC0xOyBreSA8PSAxOyBreSsrKSB7XG4gICAgICAgICAgZm9yIChsZXQga3ggPSAtMTsga3ggPD0gMTsga3grKykge1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxJbmRleCA9ICgoeSArIGt5KSAqIHdpZHRoICsgKHggKyBreCkpICogNCArIGM7XG4gICAgICAgICAgICBjb25zdCBrZXJuZWxJbmRleCA9IChreSArIDEpICogMyArIChreCArIDEpO1xuICAgICAgICAgICAgc3VtICs9IGRhdGFbcGl4ZWxJbmRleF0gKiBzaGFycGVuS2VybmVsW2tlcm5lbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGF0YVsoeSAqIHdpZHRoICsgeCkgKiA0ICsgY10gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHN1bSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gQ29weSB0aGUgbmV3IGRhdGEgYmFja1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhW2ldID0gbmV3RGF0YVtpXTtcbiAgfVxuICBcbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xufVxuXG4vKipcbiAqIEFwcGx5IG5vaXNlIHJlZHVjdGlvbiBmaWx0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Tm9pc2VSZWR1Y3Rpb24oY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc3RyZW5ndGg6IG51bWJlciA9IDAuMyk6IHZvaWQge1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgaWYgKCFjdHgpIHRocm93IG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpO1xuICBcbiAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICBcbiAgLy8gU2ltcGxlIGJsdXIgZm9yIG5vaXNlIHJlZHVjdGlvblxuICBjb25zdCByYWRpdXMgPSBNYXRoLmNlaWwoc3RyZW5ndGggKiAzKTtcbiAgY29uc3QgbmV3RGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShkYXRhKTtcbiAgXG4gIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgMzsgYysrKSB7IC8vIFJHQiBjaGFubmVscyBvbmx5XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgZHkgPSAtcmFkaXVzOyBkeSA8PSByYWRpdXM7IGR5KyspIHtcbiAgICAgICAgICBmb3IgKGxldCBkeCA9IC1yYWRpdXM7IGR4IDw9IHJhZGl1czsgZHgrKykge1xuICAgICAgICAgICAgY29uc3QgbnggPSB4ICsgZHg7XG4gICAgICAgICAgICBjb25zdCBueSA9IHkgKyBkeTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG54ID49IDAgJiYgbnggPCB3aWR0aCAmJiBueSA+PSAwICYmIG55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHN1bSArPSBkYXRhWyhueSAqIHdpZHRoICsgbngpICogNCArIGNdO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbmV3RGF0YVsoeSAqIHdpZHRoICsgeCkgKiA0ICsgY10gPSBzdW0gLyBjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIENvcHkgdGhlIG5ldyBkYXRhIGJhY2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgZGF0YVtpXSA9IG5ld0RhdGFbaV07ICAgICAvLyBSXG4gICAgZGF0YVtpICsgMV0gPSBuZXdEYXRhW2kgKyAxXTsgLy8gR1xuICAgIGRhdGFbaSArIDJdID0gbmV3RGF0YVtpICsgMl07IC8vIEJcbiAgICAvLyBLZWVwIG9yaWdpbmFsIGFscGhhXG4gIH1cbiAgXG4gIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbn1cblxuLyoqXG4gKiBBcHBseSBhdXRvbWF0aWMgY29sb3IgY29ycmVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlBdXRvQ29sb3JDb3JyZWN0aW9uKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGlmICghY3R4KSB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGhpc3RvZ3JhbVxuICBjb25zdCBoaXN0b2dyYW0gPSB7XG4gICAgcjogbmV3IEFycmF5KDI1NikuZmlsbCgwKSxcbiAgICBnOiBuZXcgQXJyYXkoMjU2KS5maWxsKDApLFxuICAgIGI6IG5ldyBBcnJheSgyNTYpLmZpbGwoMClcbiAgfTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGhpc3RvZ3JhbS5yW2RhdGFbaV1dKys7XG4gICAgaGlzdG9ncmFtLmdbZGF0YVtpICsgMV1dKys7XG4gICAgaGlzdG9ncmFtLmJbZGF0YVtpICsgMl1dKys7XG4gIH1cbiAgXG4gIC8vIEZpbmQgbWluL21heCB2YWx1ZXMgZm9yIGVhY2ggY2hhbm5lbFxuICBjb25zdCBnZXRNaW5NYXggPSAoaGlzdDogbnVtYmVyW10pID0+IHtcbiAgICBsZXQgbWluID0gMCwgbWF4ID0gMjU1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChoaXN0W2ldID4gMCkgeyBtaW4gPSBpOyBicmVhazsgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMjU1OyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGhpc3RbaV0gPiAwKSB7IG1heCA9IGk7IGJyZWFrOyB9XG4gICAgfVxuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG4gIH07XG4gIFxuICBjb25zdCByTWluTWF4ID0gZ2V0TWluTWF4KGhpc3RvZ3JhbS5yKTtcbiAgY29uc3QgZ01pbk1heCA9IGdldE1pbk1heChoaXN0b2dyYW0uZyk7XG4gIGNvbnN0IGJNaW5NYXggPSBnZXRNaW5NYXgoaGlzdG9ncmFtLmIpO1xuICBcbiAgLy8gQXBwbHkgaGlzdG9ncmFtIHN0cmV0Y2hpbmdcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgZGF0YVtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgXG4gICAgICAoKGRhdGFbaV0gLSByTWluTWF4Lm1pbikgLyAock1pbk1heC5tYXggLSByTWluTWF4Lm1pbikpICogMjU1KSk7XG4gICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIFxuICAgICAgKChkYXRhW2kgKyAxXSAtIGdNaW5NYXgubWluKSAvIChnTWluTWF4Lm1heCAtIGdNaW5NYXgubWluKSkgKiAyNTUpKTtcbiAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgXG4gICAgICAoKGRhdGFbaSArIDJdIC0gYk1pbk1heC5taW4pIC8gKGJNaW5NYXgubWF4IC0gYk1pbk1heC5taW4pKSAqIDI1NSkpO1xuICB9XG4gIFxuICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG59XG5cbi8qKlxuICogQWR2YW5jZWQgaW1hZ2UgcHJvY2Vzc2luZyB3aXRoIGNvbXByZWhlbnNpdmUgb3B0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ltYWdlQWR2YW5jZWQoXG4gIGZpbGU6IEZpbGUsXG4gIG9wdGlvbnM6IFBhcnRpYWw8QWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdPcHRpb25zPiA9IHt9XG4pOiBQcm9taXNlPEFkdmFuY2VkSW1hZ2VQcm9jZXNzaW5nUmVzdWx0PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IGNvbmZpZyA9IHsgLi4uREVGQVVMVF9QUk9DRVNTSU5HX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgY29uc3Qgb3BlcmF0aW9uc0FwcGxpZWQ6IHN0cmluZ1tdID0gW107XG4gIFxuICB0cnkge1xuICAgIC8vIFN0ZXAgMTogRXh0cmFjdCBvcmlnaW5hbCBtZXRhZGF0YVxuICAgIGNvbnN0IG9yaWdpbmFsTWV0YWRhdGEgPSBhd2FpdCBleHRyYWN0SW1hZ2VNZXRhZGF0YShmaWxlKTtcbiAgICBvcGVyYXRpb25zQXBwbGllZC5wdXNoKCdtZXRhZGF0YS1leHRyYWN0aW9uJyk7XG4gICAgXG4gICAgLy8gU3RlcCAyOiBWYWxpZGF0ZSBmaWxlIHR5cGUgYW5kIGNvbnZlcnQgdG8gYmFzZTY0XG4gICAgaWYgKCFpc0ltYWdlRmlsZShmaWxlKSkge1xuICAgICAgdGhyb3cgbmV3IEZpbGVUeXBlTm90U3VwcG9ydGVkRXJyb3IoJ09ubHkgaW1hZ2UgZmlsZXMgYXJlIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgXG4gICAgbGV0IGN1cnJlbnRJbWFnZSA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgICBvcGVyYXRpb25zQXBwbGllZC5wdXNoKCdiYXNlNjQtY29udmVyc2lvbicpO1xuICAgIFxuICAgIC8vIFN0ZXAgMzogVmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGF3YWl0IHZhbGlkYXRlSW1hZ2VEaW1lbnNpb25zKGN1cnJlbnRJbWFnZSk7XG4gICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnZGltZW5zaW9uLXZhbGlkYXRpb24nKTtcbiAgICBcbiAgICAvLyBTdGVwIDQ6IEZvcm1hdCBjb252ZXJzaW9uIChpZiBuZWVkZWQpXG4gICAgbGV0IHdhc0Zvcm1hdENvbnZlcnRlZCA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLm91dHB1dEZvcm1hdCAmJiBvcHRpb25zLm91dHB1dEZvcm1hdCAhPT0gZmlsZS50eXBlKSB7XG4gICAgICBjdXJyZW50SW1hZ2UgPSBhd2FpdCBjb252ZXJ0SW1hZ2VGb3JtYXQoY3VycmVudEltYWdlLCBvcHRpb25zLm91dHB1dEZvcm1hdCwgY29uZmlnLnF1YWxpdHkpO1xuICAgICAgd2FzRm9ybWF0Q29udmVydGVkID0gdHJ1ZTtcbiAgICAgIG9wZXJhdGlvbnNBcHBsaWVkLnB1c2goJ2Zvcm1hdC1jb252ZXJzaW9uJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0ZXAgNTogQ3JlYXRlIGNhbnZhcyBmb3IgYWR2YW5jZWQgcHJvY2Vzc2luZ1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY3R4KSB0aHJvdyBuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICBcbiAgICAvLyBMb2FkIGltYWdlIG9udG8gY2FudmFzXG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZScpKTtcbiAgICAgIGltZy5zcmMgPSBjdXJyZW50SW1hZ2U7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIGJhc2VkIG9uIHJlc2l6ZSByZXF1aXJlbWVudHNcbiAgICBjb25zdCBmaW5hbFdpZHRoID0gY29uZmlnLnRhcmdldFdpZHRoIHx8IGltZy53aWR0aDtcbiAgICBjb25zdCBmaW5hbEhlaWdodCA9IGNvbmZpZy50YXJnZXRIZWlnaHQgfHwgaW1nLmhlaWdodDtcbiAgICBcbiAgICBjYW52YXMud2lkdGggPSBmaW5hbFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBmaW5hbEhlaWdodDtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gJ2hpZ2gnO1xuICAgIFxuICAgIC8vIERyYXcgcmVzaXplZCBpbWFnZVxuICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBmaW5hbFdpZHRoLCBmaW5hbEhlaWdodCk7XG4gICAgXG4gICAgY29uc3Qgd2FzUmVzaXplZCA9IGltZy53aWR0aCAhPT0gZmluYWxXaWR0aCB8fCBpbWcuaGVpZ2h0ICE9PSBmaW5hbEhlaWdodDtcbiAgICBpZiAod2FzUmVzaXplZCkge1xuICAgICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgncmVzaXplJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0ZXAgNjogQXBwbHkgYWR2YW5jZWQgcHJvY2Vzc2luZ1xuICAgIGxldCB3YXNTaGFycGVuZWQgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVTaGFycGVuaW5nICYmIHdhc1Jlc2l6ZWQpIHtcbiAgICAgIGFwcGx5U2hhcnBlbmluZ0ZpbHRlcihjYW52YXMsIDAuMyk7XG4gICAgICB3YXNTaGFycGVuZWQgPSB0cnVlO1xuICAgICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnc2hhcnBlbmluZycpO1xuICAgIH1cbiAgICBcbiAgICBsZXQgaGFkTm9pc2VSZWR1Y3Rpb24gPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5ub2lzZVJlZHVjdGlvbiAmJiBvcHRpb25zLm5vaXNlUmVkdWN0aW9uID4gMCkge1xuICAgICAgYXBwbHlOb2lzZVJlZHVjdGlvbihjYW52YXMsIG9wdGlvbnMubm9pc2VSZWR1Y3Rpb24pO1xuICAgICAgaGFkTm9pc2VSZWR1Y3Rpb24gPSB0cnVlO1xuICAgICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnbm9pc2UtcmVkdWN0aW9uJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChvcHRpb25zLmF1dG9Db2xvckNvcnJlY3Rpb24pIHtcbiAgICAgIGFwcGx5QXV0b0NvbG9yQ29ycmVjdGlvbihjYW52YXMpO1xuICAgICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnY29sb3ItY29ycmVjdGlvbicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGVwIDc6IENvbnZlcnQgYmFjayB0byBkYXRhIFVSTFxuICAgIGNvbnN0IG91dHB1dEZvcm1hdCA9IG9wdGlvbnMub3V0cHV0Rm9ybWF0IHx8IEltYWdlRm9ybWF0LkpQRUc7XG4gICAgbGV0IHByb2Nlc3NlZEltYWdlID0gY2FudmFzLnRvRGF0YVVSTChvdXRwdXRGb3JtYXQsIGNvbmZpZy5xdWFsaXR5KTtcbiAgICBcbiAgICAvLyBTdGVwIDg6IENvbXByZXNzIGlmIG5lZWRlZFxuICAgIGxldCB3YXNDb21wcmVzc2VkID0gZmFsc2U7XG4gICAgY29uc3QgcHJvY2Vzc2VkU2l6ZSA9IGdldEJhc2U2NFNpemUocHJvY2Vzc2VkSW1hZ2UpO1xuICAgIGNvbnN0IHRhcmdldFNpemVCeXRlcyA9IGNvbmZpZy5tYXhTaXplS0IgKiAxMDI0O1xuICAgIFxuICAgIGlmIChwcm9jZXNzZWRTaXplID4gdGFyZ2V0U2l6ZUJ5dGVzKSB7XG4gICAgICBwcm9jZXNzZWRJbWFnZSA9IGF3YWl0IGNvbXByZXNzQmFzZTY0KHByb2Nlc3NlZEltYWdlLCBjb25maWcubWF4U2l6ZUtCKTtcbiAgICAgIHdhc0NvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgb3BlcmF0aW9uc0FwcGxpZWQucHVzaCgnY29tcHJlc3Npb24nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RlcCA5OiBHZW5lcmF0ZSBmaW5hbCBtZXRhZGF0YVxuICAgIGNvbnN0IGZpbmFsRGltZW5zaW9ucyA9IGF3YWl0IGdldEltYWdlRGltZW5zaW9ucyhwcm9jZXNzZWRJbWFnZSk7XG4gICAgY29uc3QgZmluYWxTaXplID0gZ2V0QmFzZTY0U2l6ZShwcm9jZXNzZWRJbWFnZSk7XG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIFxuICAgIGNvbnN0IGZpbmFsTWV0YWRhdGE6IEltYWdlTWV0YWRhdGEgPSB7XG4gICAgICBmb3JtYXQ6IG91dHB1dEZvcm1hdCxcbiAgICAgIGRpbWVuc2lvbnM6IGZpbmFsRGltZW5zaW9ucyxcbiAgICAgIHNpemU6IGZpbmFsU2l6ZVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2Nlc3NlZEltYWdlLFxuICAgICAgb3JpZ2luYWxNZXRhZGF0YSxcbiAgICAgIGZpbmFsTWV0YWRhdGEsXG4gICAgICBwcm9jZXNzaW5nTWV0YWRhdGE6IHtcbiAgICAgICAgd2FzUmVzaXplZCxcbiAgICAgICAgd2FzQ29tcHJlc3NlZCxcbiAgICAgICAgd2FzRm9ybWF0Q29udmVydGVkLFxuICAgICAgICB3YXNTaGFycGVuZWQsXG4gICAgICAgIGhhZE5vaXNlUmVkdWN0aW9uLFxuICAgICAgICBjb21wcmVzc2lvblJhdGlvOiBvcmlnaW5hbE1ldGFkYXRhLnNpemUgLyBmaW5hbFNpemUsXG4gICAgICAgIHByb2Nlc3NpbmdUaW1lLFxuICAgICAgICBvcGVyYXRpb25zQXBwbGllZFxuICAgICAgfVxuICAgIH07XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRmlsZVR5cGVOb3RTdXBwb3J0ZWRFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEZpbGVUb29MYXJnZUVycm9yIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgQ29tcHJlc3Npb25GYWlsZWRFcnJvciB8fFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEltYWdlRGltZW5zaW9uRXJyb3IgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBJbWFnZVByb2Nlc3NpbmdFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIFxuICAgIHRocm93IG5ldyBJbWFnZVByb2Nlc3NpbmdFcnJvcihcbiAgICAgICdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBhZHZhbmNlZCBpbWFnZSBwcm9jZXNzaW5nJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBCYXRjaCBwcm9jZXNzIG11bHRpcGxlIGltYWdlcyB3aXRoIHByb2dyZXNzIHRyYWNraW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSW1hZ2VzSW5CYXRjaChcbiAgZmlsZXM6IEZpbGVbXSxcbiAgb3B0aW9uczogUGFydGlhbDxBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ09wdGlvbnM+ID0ge30sXG4gIG9uUHJvZ3Jlc3M/OiAoY29tcGxldGVkOiBudW1iZXIsIHRvdGFsOiBudW1iZXIsIGN1cnJlbnRGaWxlOiBzdHJpbmcpID0+IHZvaWRcbik6IFByb21pc2U8QWR2YW5jZWRJbWFnZVByb2Nlc3NpbmdSZXN1bHRbXT4ge1xuICBjb25zdCByZXN1bHRzOiBBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ1Jlc3VsdFtdID0gW107XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmlsZSA9IGZpbGVzW2ldO1xuICAgIG9uUHJvZ3Jlc3M/LihpLCBmaWxlcy5sZW5ndGgsIGZpbGUubmFtZSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NJbWFnZUFkdmFuY2VkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEZvciBiYXRjaCBwcm9jZXNzaW5nLCB3ZSBtaWdodCB3YW50IHRvIGNvbnRpbnVlIHdpdGggb3RoZXIgZmlsZXNcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzICR7ZmlsZS5uYW1lfTpgLCBlcnJvcik7XG4gICAgICAvLyBZb3UgY291bGQgcHVzaCBhIGZhaWxlZCByZXN1bHQgb3Igc2tpcCwgZGVwZW5kaW5nIG9uIHJlcXVpcmVtZW50c1xuICAgIH1cbiAgfVxuICBcbiAgb25Qcm9ncmVzcz8uKGZpbGVzLmxlbmd0aCwgZmlsZXMubGVuZ3RoLCAnQ29tcGxldGUnKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogQ3JlYXRlIGltYWdlIHRodW1ibmFpbCB3aXRoIGNvbnNpc3RlbnQgZGltZW5zaW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlSW1hZ2VUaHVtYm5haWwoXG4gIGZpbGU6IEZpbGUsXG4gIHNpemU6IG51bWJlciA9IDE1MCxcbiAgcXVhbGl0eTogbnVtYmVyID0gMC44XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBpbWFnZVVybCA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICBcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICByZWplY3QobmV3IEltYWdlUHJvY2Vzc2luZ0Vycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0JykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRpbWVuc2lvbnMgdG8gbWFpbnRhaW4gYXNwZWN0IHJhdGlvXG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gaW1nLndpZHRoIC8gaW1nLmhlaWdodDtcbiAgICAgICAgbGV0IHdpZHRoID0gc2l6ZTtcbiAgICAgICAgbGV0IGhlaWdodCA9IHNpemU7XG4gICAgICAgIFxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8gPiAxKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gc2l6ZSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoID0gc2l6ZSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gJ2hpZ2gnO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0aHVtYm5haWxVcmwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgcXVhbGl0eSk7XG4gICAgICAgIHJlc29sdmUodGh1bWJuYWlsVXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgdGh1bWJuYWlsJyxcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgSW1hZ2VQcm9jZXNzaW5nRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlIGZvciB0aHVtYm5haWwgY3JlYXRpb24nKSk7XG4gICAgfTtcbiAgICBcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gIH0pO1xufSJdLCJuYW1lcyI6WyJDb21wcmVzc2lvbkZhaWxlZEVycm9yIiwiREVGQVVMVF9QUk9DRVNTSU5HX09QVElPTlMiLCJGaWxlVG9vTGFyZ2VFcnJvciIsIkZpbGVUeXBlTm90U3VwcG9ydGVkRXJyb3IiLCJJbWFnZURpbWVuc2lvbkVycm9yIiwiSW1hZ2VGb3JtYXQiLCJJbWFnZVByb2Nlc3NpbmdFcnJvciIsImFwcGx5QXV0b0NvbG9yQ29ycmVjdGlvbiIsImFwcGx5Tm9pc2VSZWR1Y3Rpb24iLCJhcHBseVNoYXJwZW5pbmdGaWx0ZXIiLCJjb21wcmVzc0Jhc2U2NCIsImNvbnZlcnRJbWFnZUZvcm1hdCIsImNyZWF0ZUltYWdlVGh1bWJuYWlsIiwiZXh0cmFjdEltYWdlTWV0YWRhdGEiLCJmaWxlVG9CYXNlNjQiLCJnZXRCYXNlNjRTaXplIiwiZ2V0SW1hZ2VEaW1lbnNpb25zIiwiaXNJbWFnZUZpbGUiLCJwcm9jZXNzSW1hZ2VBZHZhbmNlZCIsInByb2Nlc3NJbWFnZUZvclRyeW9uIiwicHJvY2Vzc0ltYWdlc0luQmF0Y2giLCJwcm9jZXNzVHJ5b25JbWFnZXMiLCJyZXNpemVJbWFnZVRvMTAyNHgxNTM2IiwidmFsaWRhdGVJbWFnZURpbWVuc2lvbnMiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm9yaWdpbmFsRXJyb3IiLCJuYW1lIiwid2lkdGgiLCJoZWlnaHQiLCJ0YXJnZXRXaWR0aCIsInRhcmdldEhlaWdodCIsIm1heFNpemVLQiIsInF1YWxpdHkiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiaW1hZ2VVcmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwib3B0aW9ucyIsImNvbmZpZyIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJhc3BlY3RSYXRpbyIsInRhcmdldEFzcGVjdFJhdGlvIiwiTWF0aCIsInJvdW5kIiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiaW1hZ2VTbW9vdGhpbmdRdWFsaXR5IiwiZHJhd0ltYWdlIiwicmVzaXplZEltYWdlVXJsIiwidG9EYXRhVVJMIiwiZXJyb3IiLCJTdHJpbmciLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwiZGltZW5zaW9ucyIsImJhc2U2NCIsImJhc2U2NERhdGEiLCJzcGxpdCIsImF0b2IiLCJsZW5ndGgiLCJmaWxlIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsIm9yaWdpbmFsQmFzZTY0Iiwib3JpZ2luYWxTaXplIiwic2l6ZSIsIm9yaWdpbmFsRGltZW5zaW9ucyIsInJlc2l6ZWRJbWFnZSIsImZpbmFsRGltZW5zaW9ucyIsInByb2Nlc3NlZEltYWdlIiwid2FzQ29tcHJlc3NlZCIsInJlc2l6ZWRTaXplIiwidGFyZ2V0U2l6ZUJ5dGVzIiwiZmluYWxTaXplIiwicHJvY2Vzc2luZ1RpbWUiLCJtZXRhZGF0YSIsIndhc1Jlc2l6ZWQiLCJjb21wcmVzc2lvblJhdGlvIiwibW9kZWxJbWFnZSIsImFwcGFyZWxJbWFnZXMiLCJtb2RlbEltYWdlUmVzdWx0IiwiYXBwYXJlbEltYWdlUmVzdWx0cyIsImFsbCIsIm1hcCIsImZvcm1hdCIsInR5cGUiLCJkYXRlQ3JlYXRlZCIsImxhc3RNb2RpZmllZCIsInVuZGVmaW5lZCIsInRhcmdldEZvcm1hdCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiY29udmVydGVkSW1hZ2VVcmwiLCJzdHJlbmd0aCIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJzaGFycGVuS2VybmVsIiwibmV3RGF0YSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwieSIsIngiLCJjIiwic3VtIiwia3kiLCJreCIsInBpeGVsSW5kZXgiLCJrZXJuZWxJbmRleCIsIm1heCIsIm1pbiIsImkiLCJwdXRJbWFnZURhdGEiLCJyYWRpdXMiLCJjZWlsIiwiY291bnQiLCJkeSIsImR4IiwibngiLCJueSIsImhpc3RvZ3JhbSIsInIiLCJBcnJheSIsImZpbGwiLCJnIiwiYiIsImdldE1pbk1heCIsImhpc3QiLCJyTWluTWF4IiwiZ01pbk1heCIsImJNaW5NYXgiLCJvcGVyYXRpb25zQXBwbGllZCIsIm9yaWdpbmFsTWV0YWRhdGEiLCJwdXNoIiwiY3VycmVudEltYWdlIiwid2FzRm9ybWF0Q29udmVydGVkIiwib3V0cHV0Rm9ybWF0IiwiZmluYWxXaWR0aCIsImZpbmFsSGVpZ2h0Iiwid2FzU2hhcnBlbmVkIiwiZW5hYmxlU2hhcnBlbmluZyIsImhhZE5vaXNlUmVkdWN0aW9uIiwibm9pc2VSZWR1Y3Rpb24iLCJhdXRvQ29sb3JDb3JyZWN0aW9uIiwicHJvY2Vzc2VkU2l6ZSIsImZpbmFsTWV0YWRhdGEiLCJwcm9jZXNzaW5nTWV0YWRhdGEiLCJmaWxlcyIsIm9uUHJvZ3Jlc3MiLCJyZXN1bHRzIiwicmVzdWx0IiwiY29uc29sZSIsInRodW1ibmFpbFVybCJdLCJtYXBwaW5ncyI6IkFBQUEsa0RBQWtEO0FBQ2xELGtFQUFrRTs7Ozs7Ozs7Ozs7O0lBZWhFQSxzQkFBc0I7ZUFBdEJBLDZCQUFzQjs7SUFzRFhDLDBCQUEwQjtlQUExQkE7O0lBcERYQyxpQkFBaUI7ZUFBakJBLHdCQUFpQjs7SUFEakJDLHlCQUF5QjtlQUF6QkEsZ0NBQXlCOztJQTJCZEMsbUJBQW1CO2VBQW5CQTs7SUFxQ0RDLFdBQVc7ZUFBWEE7O0lBL0NDQyxvQkFBb0I7ZUFBcEJBOztJQTJoQkdDLHdCQUF3QjtlQUF4QkE7O0lBbERBQyxtQkFBbUI7ZUFBbkJBOztJQTdDQUMscUJBQXFCO2VBQXJCQTs7SUEvY2RDLGNBQWM7ZUFBZEEscUJBQWM7O0lBNFpNQyxrQkFBa0I7ZUFBbEJBOztJQW1YQUMsb0JBQW9CO2VBQXBCQTs7SUFwWUFDLG9CQUFvQjtlQUFwQkE7O0lBdllwQkMsWUFBWTtlQUFaQSxtQkFBWTs7SUEwUkVDLGFBQWE7ZUFBYkE7O0lBMUhBQyxrQkFBa0I7ZUFBbEJBOztJQS9KZEMsV0FBVztlQUFYQSxrQkFBVzs7SUE2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