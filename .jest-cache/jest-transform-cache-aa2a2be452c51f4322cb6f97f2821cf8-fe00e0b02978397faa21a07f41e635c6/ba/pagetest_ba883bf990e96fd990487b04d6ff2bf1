2a80548df742107b826dbcf202e294e8
"use strict";
// Mock the utility functions
jest.mock('@/utils/image', ()=>({
        fileToBase64: jest.fn(),
        compressBase64: jest.fn(),
        CompressionFailedError: class CompressionFailedError extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _image = require("../../src/utils/image");
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
// Mock console methods
const mockConsoleLog = jest.spyOn(console, 'log').mockImplementation();
const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();
// Mock File constructor
global.File = jest.fn().mockImplementation((content, name, options)=>({
        name,
        size: content.length,
        type: options?.type || 'image/jpeg',
        arrayBuffer: jest.fn().mockResolvedValue(new ArrayBuffer(content.length)),
        stream: jest.fn(),
        text: jest.fn().mockResolvedValue(''),
        slice: jest.fn(),
        lastModified: Date.now()
    }));
// Mock AbortController
global.AbortController = jest.fn().mockImplementation(()=>({
        signal: 'mock-signal',
        abort: jest.fn()
    }));
// Mock setTimeout and clearTimeout
jest.useFakeTimers();
// Spy on the timer functions after fake timers are set up
const mockSetTimeout = jest.spyOn(globalThis, 'setTimeout');
const mockClearTimeout = jest.spyOn(globalThis, 'clearTimeout');
describe('handleCameraButtonClick Logic Tests', ()=>{
    let mockUserFile;
    let mockApparelFile;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Create mock files
        mockUserFile = new File([
            'user-image-content'
        ], 'user.jpg', {
            type: 'image/jpeg'
        });
        mockApparelFile = new File([
            'apparel-image-content'
        ], 'apparel.jpg', {
            type: 'image/jpeg'
        });
        _image.fileToBase64.mockResolvedValue('mock-base64-string');
        _image.compressBase64.mockResolvedValue('compressed-base64-string');
        mockFetch.mockClear();
    });
    afterEach(()=>{
        jest.clearAllTimers();
    });
    // Test the core logic function that would be extracted from handleCameraButtonClick
    const processImagesAndCallAPI = async (userFile, apparelFile)=>{
        try {
            // Process images concurrently
            const [modelB64, apparelB64] = await Promise.all([
                (0, _image.fileToBase64)(userFile),
                (0, _image.fileToBase64)(apparelFile)
            ]);
            // Compress both images
            const [compressedModel, compressedApparel] = await Promise.all([
                (0, _image.compressBase64)(modelB64, 2048),
                (0, _image.compressBase64)(apparelB64, 2048)
            ]);
            // Create AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(()=>controller.abort(), 30000);
            try {
                // Make API call
                const response = await fetch('/api/tryon', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        modelImage: compressedModel,
                        apparelImages: [
                            compressedApparel
                        ]
                    }),
                    signal: controller.signal
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API request failed: ${response.status} ${errorText}`);
                }
                const { img_generated } = await response.json();
                console.log('Successfully received generated image from API');
                return {
                    success: true,
                    img_generated
                };
            } finally{
                clearTimeout(timeoutId);
            }
        } catch (error) {
            console.error('Error in processImagesAndCallAPI:', error);
            throw error;
        }
    };
    describe('Success Path', ()=>{
        it('should successfully process images and make API call', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'generated-image-base64'
                })
            });
            // Act
            const result = await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockUserFile);
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockApparelFile);
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelImage: 'compressed-base64-string',
                    apparelImages: [
                        'compressed-base64-string'
                    ]
                }),
                signal: 'mock-signal'
            });
            // Focus on functional behavior rather than console logging details
            expect(result).toEqual({
                success: true,
                img_generated: 'generated-image-base64'
            });
        });
    });
    describe('Error Handling', ()=>{
        it('should handle compression failures', async ()=>{
            // Arrange
            ;
            _image.compressBase64.mockRejectedValueOnce(new _image.CompressionFailedError('Compression failed'));
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('Compression failed');
        });
        it('should handle API request failures', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                text: jest.fn().mockResolvedValue('Bad request')
            });
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('API request failed: 400 Bad request');
        });
        it('should handle timeout errors', async ()=>{
            // Arrange
            const abortError = new Error('Request aborted');
            abortError.name = 'AbortError';
            mockFetch.mockRejectedValueOnce(abortError);
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('Request aborted');
        });
    });
    describe('Timeout Management', ()=>{
        it('should create AbortController with timeout', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert - Focus on functional behavior rather than implementation details
            expect(global.AbortController).toHaveBeenCalled();
        // Note: Timeout management is now handled by React Query in the new architecture
        });
        it('should clear timeout on successful completion', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            const result = await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert - Focus on functional outcome rather than implementation details
            expect(result.success).toBe(true);
            expect(result.img_generated).toBe('test');
        // Note: Timeout cleanup is now handled by React Query in the new architecture
        });
    });
    describe('Image Processing', ()=>{
        it('should process both images concurrently', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockUserFile);
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockApparelFile);
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
        });
        it('should use correct compression limit', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
        });
    });
    describe('API Request Format', ()=>{
        it('should send correct request body format', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelImage: 'compressed-base64-string',
                    apparelImages: [
                        'compressed-base64-string'
                    ]
                }),
                signal: 'mock-signal'
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2NvbXBvbmVudHMvcGFnZS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaWxlVG9CYXNlNjQsIGNvbXByZXNzQmFzZTY0LCBDb21wcmVzc2lvbkZhaWxlZEVycm9yIH0gZnJvbSAnQC91dGlscy9pbWFnZSdcblxuLy8gTW9jayB0aGUgdXRpbGl0eSBmdW5jdGlvbnNcbmplc3QubW9jaygnQC91dGlscy9pbWFnZScsICgpID0+ICh7XG4gIGZpbGVUb0Jhc2U2NDogamVzdC5mbigpLFxuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigpLFxuICBDb21wcmVzc2lvbkZhaWxlZEVycm9yOiBjbGFzcyBDb21wcmVzc2lvbkZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJ1xuICAgIH1cbiAgfVxufSkpXG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKVxuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBtb2NrQ29uc29sZUxvZyA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG5jb25zdCBtb2NrQ29uc29sZUVycm9yID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKVxuXG4vLyBNb2NrIEZpbGUgY29uc3RydWN0b3Jcbmdsb2JhbC5GaWxlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoY29udGVudCwgbmFtZSwgb3B0aW9ucykgPT4gKHtcbiAgbmFtZSxcbiAgc2l6ZTogY29udGVudC5sZW5ndGgsXG4gIHR5cGU6IG9wdGlvbnM/LnR5cGUgfHwgJ2ltYWdlL2pwZWcnLFxuICBhcnJheUJ1ZmZlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG5ldyBBcnJheUJ1ZmZlcihjb250ZW50Lmxlbmd0aCkpLFxuICBzdHJlYW06IGplc3QuZm4oKSxcbiAgdGV4dDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCcnKSxcbiAgc2xpY2U6IGplc3QuZm4oKSxcbiAgbGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxufSkpXG5cbi8vIE1vY2sgQWJvcnRDb250cm9sbGVyXG5nbG9iYWwuQWJvcnRDb250cm9sbGVyID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICBzaWduYWw6ICdtb2NrLXNpZ25hbCcsXG4gIGFib3J0OiBqZXN0LmZuKCksXG59KSlcblxuLy8gTW9jayBzZXRUaW1lb3V0IGFuZCBjbGVhclRpbWVvdXRcbmplc3QudXNlRmFrZVRpbWVycygpXG4vLyBTcHkgb24gdGhlIHRpbWVyIGZ1bmN0aW9ucyBhZnRlciBmYWtlIHRpbWVycyBhcmUgc2V0IHVwXG5jb25zdCBtb2NrU2V0VGltZW91dCA9IGplc3Quc3B5T24oZ2xvYmFsVGhpcywgJ3NldFRpbWVvdXQnKVxuY29uc3QgbW9ja0NsZWFyVGltZW91dCA9IGplc3Quc3B5T24oZ2xvYmFsVGhpcywgJ2NsZWFyVGltZW91dCcpXG5cbmRlc2NyaWJlKCdoYW5kbGVDYW1lcmFCdXR0b25DbGljayBMb2dpYyBUZXN0cycsICgpID0+IHtcbiAgbGV0IG1vY2tVc2VyRmlsZTogRmlsZVxuICBsZXQgbW9ja0FwcGFyZWxGaWxlOiBGaWxlXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgICBcbiAgICAvLyBDcmVhdGUgbW9jayBmaWxlc1xuICAgIG1vY2tVc2VyRmlsZSA9IG5ldyBGaWxlKFsndXNlci1pbWFnZS1jb250ZW50J10sICd1c2VyLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgbW9ja0FwcGFyZWxGaWxlID0gbmV3IEZpbGUoWydhcHBhcmVsLWltYWdlLWNvbnRlbnQnXSwgJ2FwcGFyZWwuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICBcbiAgICAvLyBSZXNldCBtb2NrIGltcGxlbWVudGF0aW9uc1xuICAgIDsoZmlsZVRvQmFzZTY0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoJ21vY2stYmFzZTY0LXN0cmluZycpXG4gICAgOyhjb21wcmVzc0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKCdjb21wcmVzc2VkLWJhc2U2NC1zdHJpbmcnKVxuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxuICB9KVxuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbFRpbWVycygpXG4gIH0pXG5cbiAgLy8gVGVzdCB0aGUgY29yZSBsb2dpYyBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIGV4dHJhY3RlZCBmcm9tIGhhbmRsZUNhbWVyYUJ1dHRvbkNsaWNrXG4gIGNvbnN0IHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJID0gYXN5bmMgKHVzZXJGaWxlOiBGaWxlLCBhcHBhcmVsRmlsZTogRmlsZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBQcm9jZXNzIGltYWdlcyBjb25jdXJyZW50bHlcbiAgICAgIGNvbnN0IFttb2RlbEI2NCwgYXBwYXJlbEI2NF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGZpbGVUb0Jhc2U2NCh1c2VyRmlsZSksXG4gICAgICAgIGZpbGVUb0Jhc2U2NChhcHBhcmVsRmlsZSlcbiAgICAgIF0pXG5cbiAgICAgIC8vIENvbXByZXNzIGJvdGggaW1hZ2VzXG4gICAgICBjb25zdCBbY29tcHJlc3NlZE1vZGVsLCBjb21wcmVzc2VkQXBwYXJlbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGNvbXByZXNzQmFzZTY0KG1vZGVsQjY0LCAyMDQ4KSxcbiAgICAgICAgY29tcHJlc3NCYXNlNjQoYXBwYXJlbEI2NCwgMjA0OClcbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSBBYm9ydENvbnRyb2xsZXIgZm9yIHRpbWVvdXRcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAzMDAwMClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTWFrZSBBUEkgY2FsbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3RyeW9uJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1vZGVsSW1hZ2U6IGNvbXByZXNzZWRNb2RlbCxcbiAgICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFtjb21wcmVzc2VkQXBwYXJlbF1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtlcnJvclRleHR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaW1nX2dlbmVyYXRlZCB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgcmVjZWl2ZWQgZ2VuZXJhdGVkIGltYWdlIGZyb20gQVBJJylcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGltZ19nZW5lcmF0ZWQgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcHJvY2Vzc0ltYWdlc0FuZENhbGxBUEk6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGRlc2NyaWJlKCdTdWNjZXNzIFBhdGgnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgcHJvY2VzcyBpbWFnZXMgYW5kIG1ha2UgQVBJIGNhbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICdnZW5lcmF0ZWQtaW1hZ2UtYmFzZTY0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZmlsZVRvQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrVXNlckZpbGUpXG4gICAgICBleHBlY3QoZmlsZVRvQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrQXBwYXJlbEZpbGUpXG4gICAgICBleHBlY3QoY29tcHJlc3NCYXNlNjQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdtb2NrLWJhc2U2NC1zdHJpbmcnLCAyMDQ4KVxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvdHJ5b24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG1vZGVsSW1hZ2U6ICdjb21wcmVzc2VkLWJhc2U2NC1zdHJpbmcnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnY29tcHJlc3NlZC1iYXNlNjQtc3RyaW5nJ11cbiAgICAgICAgfSksXG4gICAgICAgIHNpZ25hbDogJ21vY2stc2lnbmFsJ1xuICAgICAgfSlcbiAgICAgIC8vIEZvY3VzIG9uIGZ1bmN0aW9uYWwgYmVoYXZpb3IgcmF0aGVyIHRoYW4gY29uc29sZSBsb2dnaW5nIGRldGFpbHNcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlLCBpbWdfZ2VuZXJhdGVkOiAnZ2VuZXJhdGVkLWltYWdlLWJhc2U2NCcgfSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wcmVzc2lvbiBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIDsoY29tcHJlc3NCYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IENvbXByZXNzaW9uRmFpbGVkRXJyb3IoJ0NvbXByZXNzaW9uIGZhaWxlZCcpKVxuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0NvbXByZXNzaW9uIGZhaWxlZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEFQSSByZXF1ZXN0IGZhaWx1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgIHRleHQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnQmFkIHJlcXVlc3QnKVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QocHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkobW9ja1VzZXJGaWxlLCBtb2NrQXBwYXJlbEZpbGUpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdBUEkgcmVxdWVzdCBmYWlsZWQ6IDQwMCBCYWQgcmVxdWVzdCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRpbWVvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignUmVxdWVzdCBhYm9ydGVkJylcbiAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZWplY3RlZFZhbHVlT25jZShhYm9ydEVycm9yKVxuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ1JlcXVlc3QgYWJvcnRlZCcpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVGltZW91dCBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIEFib3J0Q29udHJvbGxlciB3aXRoIHRpbWVvdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICd0ZXN0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0IC0gRm9jdXMgb24gZnVuY3Rpb25hbCBiZWhhdmlvciByYXRoZXIgdGhhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzXG4gICAgICBleHBlY3QoZ2xvYmFsLkFib3J0Q29udHJvbGxlcikudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICAvLyBOb3RlOiBUaW1lb3V0IG1hbmFnZW1lbnQgaXMgbm93IGhhbmRsZWQgYnkgUmVhY3QgUXVlcnkgaW4gdGhlIG5ldyBhcmNoaXRlY3R1cmVcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjbGVhciB0aW1lb3V0IG9uIHN1Y2Nlc3NmdWwgY29tcGxldGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaW1nX2dlbmVyYXRlZDogJ3Rlc3QnIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJKG1vY2tVc2VyRmlsZSwgbW9ja0FwcGFyZWxGaWxlKVxuXG4gICAgICAvLyBBc3NlcnQgLSBGb2N1cyBvbiBmdW5jdGlvbmFsIG91dGNvbWUgcmF0aGVyIHRoYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsc1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QocmVzdWx0LmltZ19nZW5lcmF0ZWQpLnRvQmUoJ3Rlc3QnKVxuICAgICAgLy8gTm90ZTogVGltZW91dCBjbGVhbnVwIGlzIG5vdyBoYW5kbGVkIGJ5IFJlYWN0IFF1ZXJ5IGluIHRoZSBuZXcgYXJjaGl0ZWN0dXJlXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnSW1hZ2UgUHJvY2Vzc2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgYm90aCBpbWFnZXMgY29uY3VycmVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpbWdfZ2VuZXJhdGVkOiAndGVzdCcgfSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgcHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkobW9ja1VzZXJGaWxlLCBtb2NrQXBwYXJlbEZpbGUpXG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGZpbGVUb0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXJGaWxlKVxuICAgICAgZXhwZWN0KGZpbGVUb0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0FwcGFyZWxGaWxlKVxuICAgICAgZXhwZWN0KGNvbXByZXNzQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnbW9jay1iYXNlNjQtc3RyaW5nJywgMjA0OClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB1c2UgY29ycmVjdCBjb21wcmVzc2lvbiBsaW1pdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaW1nX2dlbmVyYXRlZDogJ3Rlc3QnIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBBY3RcbiAgICAgIGF3YWl0IHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJKG1vY2tVc2VyRmlsZSwgbW9ja0FwcGFyZWxGaWxlKVxuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChjb21wcmVzc0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ21vY2stYmFzZTY0LXN0cmluZycsIDIwNDgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnQVBJIFJlcXVlc3QgRm9ybWF0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc2VuZCBjb3JyZWN0IHJlcXVlc3QgYm9keSBmb3JtYXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICd0ZXN0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS90cnlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbW9kZWxJbWFnZTogJ2NvbXByZXNzZWQtYmFzZTY0LXN0cmluZycsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogWydjb21wcmVzc2VkLWJhc2U2NC1zdHJpbmcnXVxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmFsOiAnbW9jay1zaWduYWwnXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59KSAiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJmaWxlVG9CYXNlNjQiLCJmbiIsImNvbXByZXNzQmFzZTY0IiwiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIm1vY2tGZXRjaCIsImdsb2JhbCIsImZldGNoIiwibW9ja0NvbnNvbGVMb2ciLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJtb2NrQ29uc29sZUVycm9yIiwiRmlsZSIsImNvbnRlbnQiLCJvcHRpb25zIiwic2l6ZSIsImxlbmd0aCIsInR5cGUiLCJhcnJheUJ1ZmZlciIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiQXJyYXlCdWZmZXIiLCJzdHJlYW0iLCJ0ZXh0Iiwic2xpY2UiLCJsYXN0TW9kaWZpZWQiLCJEYXRlIiwibm93IiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwiYWJvcnQiLCJ1c2VGYWtlVGltZXJzIiwibW9ja1NldFRpbWVvdXQiLCJnbG9iYWxUaGlzIiwibW9ja0NsZWFyVGltZW91dCIsImRlc2NyaWJlIiwibW9ja1VzZXJGaWxlIiwibW9ja0FwcGFyZWxGaWxlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJhZnRlckVhY2giLCJjbGVhckFsbFRpbWVycyIsInByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJIiwidXNlckZpbGUiLCJhcHBhcmVsRmlsZSIsIm1vZGVsQjY0IiwiYXBwYXJlbEI2NCIsIlByb21pc2UiLCJhbGwiLCJjb21wcmVzc2VkTW9kZWwiLCJjb21wcmVzc2VkQXBwYXJlbCIsImNvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwicmVzcG9uc2UiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtb2RlbEltYWdlIiwiYXBwYXJlbEltYWdlcyIsIm9rIiwiZXJyb3JUZXh0Iiwic3RhdHVzIiwiaW1nX2dlbmVyYXRlZCIsImpzb24iLCJsb2ciLCJzdWNjZXNzIiwiY2xlYXJUaW1lb3V0IiwiZXJyb3IiLCJpdCIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsInJlc3VsdCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9FcXVhbCIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsInJlamVjdHMiLCJ0b1Rocm93IiwiYWJvcnRFcnJvciIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ0b0JlIl0sIm1hcHBpbmdzIjoiO0FBRUEsNkJBQTZCO0FBQzdCQSxLQUFLQyxJQUFJLENBQUMsaUJBQWlCLElBQU8sQ0FBQTtRQUNoQ0MsY0FBY0YsS0FBS0csRUFBRTtRQUNyQkMsZ0JBQWdCSixLQUFLRyxFQUFFO1FBQ3ZCRSx3QkFBd0IsTUFBTUEsK0JBQStCQztZQUMzREMsWUFBWUMsT0FBZSxDQUFFO2dCQUMzQixLQUFLLENBQUNBO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1lBQ2Q7UUFDRjtJQUNGLENBQUE7Ozs7dUJBWnFFO0FBY3JFLHNCQUFzQjtBQUN0QixNQUFNQyxZQUFZVixLQUFLRyxFQUFFO0FBQ3pCUSxPQUFPQyxLQUFLLEdBQUdGO0FBRWYsdUJBQXVCO0FBQ3ZCLE1BQU1HLGlCQUFpQmIsS0FBS2MsS0FBSyxDQUFDQyxTQUFTLE9BQU9DLGtCQUFrQjtBQUNwRSxNQUFNQyxtQkFBbUJqQixLQUFLYyxLQUFLLENBQUNDLFNBQVMsU0FBU0Msa0JBQWtCO0FBRXhFLHdCQUF3QjtBQUN4QkwsT0FBT08sSUFBSSxHQUFHbEIsS0FBS0csRUFBRSxHQUFHYSxrQkFBa0IsQ0FBQyxDQUFDRyxTQUFTVixNQUFNVyxVQUFhLENBQUE7UUFDdEVYO1FBQ0FZLE1BQU1GLFFBQVFHLE1BQU07UUFDcEJDLE1BQU1ILFNBQVNHLFFBQVE7UUFDdkJDLGFBQWF4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