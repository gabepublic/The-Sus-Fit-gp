{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/utils/undoRedoStack.ts"],"sourcesContent":["// Undo/Redo Stack Management for Image Editing\n// Immutable state management for tracking and reverting image editing operations\n\nimport type { ManagedCanvas } from '../providers/CanvasProvider';\n\n/**\n * Operation types that can be undone/redone\n */\nexport enum OperationType {\n  IMAGE_LOAD = 'image_load',\n  IMAGE_RESIZE = 'image_resize',\n  FILTER_APPLY = 'filter_apply',\n  TEXT_ADD = 'text_add',\n  TEXT_EDIT = 'text_edit',\n  TEXT_REMOVE = 'text_remove',\n  STICKER_ADD = 'sticker_add',\n  STICKER_MOVE = 'sticker_move',\n  STICKER_SCALE = 'sticker_scale',\n  STICKER_ROTATE = 'sticker_rotate',\n  STICKER_REMOVE = 'sticker_remove',\n  CANVAS_CLEAR = 'canvas_clear',\n  COMPOSITE_OPERATION = 'composite_operation'\n}\n\n/**\n * Base operation interface\n */\nexport interface BaseOperation {\n  id: string;\n  type: OperationType;\n  timestamp: number;\n  description: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Canvas snapshot for state preservation\n */\nexport interface CanvasSnapshot {\n  imageData: ImageData;\n  width: number;\n  height: number;\n  timestamp: number;\n  compressed?: boolean;\n  compressionLevel?: number;\n}\n\n/**\n * Operation with state data\n */\nexport interface Operation extends BaseOperation {\n  /** State before the operation */\n  beforeState: CanvasSnapshot;\n  /** State after the operation */\n  afterState: CanvasSnapshot;\n  /** Additional operation-specific data */\n  operationData?: Record<string, unknown>;\n  /** Memory usage in bytes */\n  memoryUsage?: number;\n}\n\n/**\n * Composite operation containing multiple sub-operations\n */\nexport interface CompositeOperation extends BaseOperation {\n  operations: Operation[];\n  beforeState: CanvasSnapshot;\n  afterState: CanvasSnapshot;\n}\n\n/**\n * Undo/Redo stack configuration\n */\nexport interface UndoRedoConfig {\n  /** Maximum number of operations to keep in history */\n  maxHistorySize: number;\n  /** Enable automatic snapshot compression */\n  enableCompression: boolean;\n  /** Compression quality (0-1) */\n  compressionQuality: number;\n  /** Memory usage limit in MB */\n  memoryLimit: number;\n  /** Auto-cleanup threshold in minutes */\n  autoCleanupThreshold: number;\n  /** Enable performance monitoring */\n  enablePerfMonitoring: boolean;\n}\n\n/**\n * Undo/Redo stack state\n */\nexport interface UndoRedoState {\n  /** Current position in the stack */\n  currentIndex: number;\n  /** Operations stack */\n  operations: (Operation | CompositeOperation)[];\n  /** Can undo */\n  canUndo: boolean;\n  /** Can redo */\n  canRedo: boolean;\n  /** Total memory usage */\n  memoryUsage: number;\n  /** Stack statistics */\n  stats: {\n    totalOperations: number;\n    undoCount: number;\n    redoCount: number;\n    memoryPeakUsage: number;\n    lastCleanup: number;\n  };\n}\n\n/**\n * Performance metrics for operations\n */\nexport interface OperationPerformance {\n  executionTime: number;\n  memoryBefore: number;\n  memoryAfter: number;\n  snapshotTime: number;\n  compressionTime?: number;\n  compressionRatio?: number;\n}\n\n/**\n * Default configuration\n */\nexport const DEFAULT_UNDO_REDO_CONFIG: UndoRedoConfig = {\n  maxHistorySize: 50,\n  enableCompression: true,\n  compressionQuality: 0.8,\n  memoryLimit: 100, // 100MB\n  autoCleanupThreshold: 30, // 30 minutes\n  enablePerfMonitoring: true\n};\n\n/**\n * Undo/Redo stack manager\n */\nexport class UndoRedoManager {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private config: UndoRedoConfig;\n  private state: UndoRedoState;\n  private currentComposite: CompositeOperation | null = null;\n  private lastSnapshot: CanvasSnapshot | null = null;\n\n  constructor(managedCanvas: ManagedCanvas, config: Partial<UndoRedoConfig> = {}) {\n    this.canvas = managedCanvas.canvas;\n    this.ctx = managedCanvas.context;\n    this.config = { ...DEFAULT_UNDO_REDO_CONFIG, ...config };\n    this.state = {\n      currentIndex: -1,\n      operations: [],\n      canUndo: false,\n      canRedo: false,\n      memoryUsage: 0,\n      stats: {\n        totalOperations: 0,\n        undoCount: 0,\n        redoCount: 0,\n        memoryPeakUsage: 0,\n        lastCleanup: Date.now()\n      }\n    };\n\n    // Setup automatic cleanup\n    if (this.config.autoCleanupThreshold > 0) {\n      this.setupAutoCleanup();\n    }\n  }\n\n  /**\n   * Create canvas snapshot\n   */\n  private createSnapshot(compress: boolean = this.config.enableCompression): CanvasSnapshot {\n    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    \n    let snapshot: CanvasSnapshot = {\n      imageData,\n      width: this.canvas.width,\n      height: this.canvas.height,\n      timestamp: Date.now()\n    };\n\n    if (compress) {\n      snapshot = this.compressSnapshot(snapshot);\n    }\n\n    return snapshot;\n  }\n\n  /**\n   * Compress snapshot to reduce memory usage\n   */\n  private compressSnapshot(snapshot: CanvasSnapshot): CanvasSnapshot {\n    const startTime = performance.now();\n    \n    try {\n      // Create temporary canvas for compression\n      const tempCanvas = document.createElement('canvas');\n      tempCanvas.width = snapshot.width;\n      tempCanvas.height = snapshot.height;\n      const tempCtx = tempCanvas.getContext('2d');\n      \n      if (!tempCtx) {\n        return snapshot; // Return uncompressed if context unavailable\n      }\n      \n      // Draw image data to temporary canvas\n      tempCtx.putImageData(snapshot.imageData, 0, 0);\n      \n      // Convert to compressed data URL\n      const dataUrl = tempCanvas.toDataURL('image/jpeg', this.config.compressionQuality);\n      \n      // Convert back to image data (this simulates compression)\n      const img = new Image();\n      return new Promise<CanvasSnapshot>((resolve) => {\n        img.onload = () => {\n          tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);\n          tempCtx.drawImage(img, 0, 0);\n          const compressedImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\n          \n          const compressionTime = performance.now() - startTime;\n          const originalSize = snapshot.imageData.data.length;\n          const compressedSize = compressedImageData.data.length;\n          \n          resolve({\n            ...snapshot,\n            imageData: compressedImageData,\n            compressed: true,\n            compressionLevel: this.config.compressionQuality\n          });\n        };\n        img.src = dataUrl;\n      });\n    } catch (error) {\n      console.warn('Snapshot compression failed, using uncompressed:', error);\n      return snapshot;\n    }\n  }\n\n  /**\n   * Calculate memory usage of snapshot\n   */\n  private calculateSnapshotMemory(snapshot: CanvasSnapshot): number {\n    const imageDataSize = snapshot.imageData.data.length * 4; // 4 bytes per pixel (RGBA)\n    const metadataSize = 100; // Approximate metadata size\n    return imageDataSize + metadataSize;\n  }\n\n  /**\n   * Apply snapshot to canvas\n   */\n  private applySnapshot(snapshot: CanvasSnapshot): void {\n    // Resize canvas if needed\n    if (this.canvas.width !== snapshot.width || this.canvas.height !== snapshot.height) {\n      this.canvas.width = snapshot.width;\n      this.canvas.height = snapshot.height;\n    }\n\n    // Apply image data\n    this.ctx.putImageData(snapshot.imageData, 0, 0);\n  }\n\n  /**\n   * Generate unique operation ID\n   */\n  private generateOperationId(): string {\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Update stack state\n   */\n  private updateState(): void {\n    this.state.canUndo = this.state.currentIndex >= 0;\n    this.state.canRedo = this.state.currentIndex < this.state.operations.length - 1;\n    \n    // Calculate total memory usage\n    this.state.memoryUsage = this.state.operations.reduce((total, op) => {\n      if ('operations' in op) {\n        // Composite operation\n        return total + this.calculateSnapshotMemory(op.beforeState) + \n               this.calculateSnapshotMemory(op.afterState);\n      } else {\n        // Regular operation\n        return total + this.calculateSnapshotMemory(op.beforeState) + \n               this.calculateSnapshotMemory(op.afterState);\n      }\n    }, 0);\n\n    // Update peak memory usage\n    if (this.state.memoryUsage > this.state.stats.memoryPeakUsage) {\n      this.state.stats.memoryPeakUsage = this.state.memoryUsage;\n    }\n\n    // Check memory limit\n    if (this.state.memoryUsage > this.config.memoryLimit * 1024 * 1024) {\n      this.cleanup();\n    }\n  }\n\n  /**\n   * Start composite operation\n   */\n  startCompositeOperation(description: string, metadata?: Record<string, unknown>): string {\n    if (this.currentComposite) {\n      throw new Error('Composite operation already in progress');\n    }\n\n    const id = this.generateOperationId();\n    this.currentComposite = {\n      id,\n      type: OperationType.COMPOSITE_OPERATION,\n      timestamp: Date.now(),\n      description,\n      metadata,\n      operations: [],\n      beforeState: this.createSnapshot(),\n      afterState: this.createSnapshot() // Will be updated when completed\n    };\n\n    return id;\n  }\n\n  /**\n   * End composite operation\n   */\n  endCompositeOperation(): void {\n    if (!this.currentComposite) {\n      throw new Error('No composite operation in progress');\n    }\n\n    // Update after state\n    this.currentComposite.afterState = this.createSnapshot();\n\n    // Add to operations stack if it contains sub-operations\n    if (this.currentComposite.operations.length > 0) {\n      this.addOperationToStack(this.currentComposite);\n    }\n\n    this.currentComposite = null;\n  }\n\n  /**\n   * Add operation to stack\n   */\n  private addOperationToStack(operation: Operation | CompositeOperation): void {\n    // Remove any operations after current index (for redo scenarios)\n    this.state.operations = this.state.operations.slice(0, this.state.currentIndex + 1);\n\n    // Add new operation\n    this.state.operations.push(operation);\n    this.state.currentIndex = this.state.operations.length - 1;\n\n    // Enforce history size limit\n    if (this.state.operations.length > this.config.maxHistorySize) {\n      const removeCount = this.state.operations.length - this.config.maxHistorySize;\n      this.state.operations.splice(0, removeCount);\n      this.state.currentIndex -= removeCount;\n    }\n\n    this.state.stats.totalOperations++;\n    this.updateState();\n  }\n\n  /**\n   * Execute operation with automatic state tracking\n   */\n  executeOperation(\n    type: OperationType,\n    description: string,\n    operationFn: () => void | Promise<void>,\n    operationData?: Record<string, unknown>,\n    metadata?: Record<string, unknown>\n  ): Promise<string> {\n    return new Promise(async (resolve, reject) => {\n      const startTime = performance.now();\n      const memoryBefore = this.state.memoryUsage;\n      \n      try {\n        // Capture before state\n        const beforeState = this.createSnapshot();\n        \n        // Execute the operation\n        await operationFn();\n        \n        // Capture after state\n        const afterState = this.createSnapshot();\n        \n        // Create operation record\n        const operation: Operation = {\n          id: this.generateOperationId(),\n          type,\n          timestamp: Date.now(),\n          description,\n          beforeState,\n          afterState,\n          operationData,\n          metadata\n        };\n\n        // Calculate memory usage\n        operation.memoryUsage = this.calculateSnapshotMemory(beforeState) + \n                               this.calculateSnapshotMemory(afterState);\n\n        // Add to current composite or directly to stack\n        if (this.currentComposite) {\n          this.currentComposite.operations.push(operation);\n        } else {\n          this.addOperationToStack(operation);\n        }\n\n        // Record performance metrics\n        if (this.config.enablePerfMonitoring) {\n          const performance: OperationPerformance = {\n            executionTime: Date.now() - startTime,\n            memoryBefore,\n            memoryAfter: this.state.memoryUsage,\n            snapshotTime: 0 // Would be calculated in real implementation\n          };\n          \n          if (metadata) {\n            metadata.performance = performance;\n          }\n        }\n\n        resolve(operation.id);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Undo last operation\n   */\n  undo(): boolean {\n    if (!this.state.canUndo) {\n      return false;\n    }\n\n    const operation = this.state.operations[this.state.currentIndex];\n    this.applySnapshot(operation.beforeState);\n    \n    this.state.currentIndex--;\n    this.state.stats.undoCount++;\n    this.updateState();\n\n    return true;\n  }\n\n  /**\n   * Redo next operation\n   */\n  redo(): boolean {\n    if (!this.state.canRedo) {\n      return false;\n    }\n\n    this.state.currentIndex++;\n    const operation = this.state.operations[this.state.currentIndex];\n    this.applySnapshot(operation.afterState);\n    \n    this.state.stats.redoCount++;\n    this.updateState();\n\n    return true;\n  }\n\n  /**\n   * Jump to specific operation in history\n   */\n  jumpToOperation(index: number): boolean {\n    if (index < -1 || index >= this.state.operations.length) {\n      return false;\n    }\n\n    if (index === -1) {\n      // Jump to initial state (before any operations)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    } else {\n      const operation = this.state.operations[index];\n      this.applySnapshot(operation.afterState);\n    }\n\n    this.state.currentIndex = index;\n    this.updateState();\n\n    return true;\n  }\n\n  /**\n   * Clear entire history\n   */\n  clearHistory(): void {\n    this.state.operations = [];\n    this.state.currentIndex = -1;\n    this.state.memoryUsage = 0;\n    this.currentComposite = null;\n    this.updateState();\n  }\n\n  /**\n   * Cleanup old operations to free memory\n   */\n  cleanup(targetMemoryMB?: number): void {\n    const targetMemory = (targetMemoryMB || this.config.memoryLimit * 0.7) * 1024 * 1024;\n    \n    while (this.state.memoryUsage > targetMemory && this.state.operations.length > 10) {\n      // Remove oldest operation\n      this.state.operations.shift();\n      if (this.state.currentIndex > 0) {\n        this.state.currentIndex--;\n      }\n    }\n\n    this.state.stats.lastCleanup = Date.now();\n    this.updateState();\n  }\n\n  /**\n   * Setup automatic cleanup\n   */\n  private setupAutoCleanup(): void {\n    setInterval(() => {\n      const now = Date.now();\n      const timeSinceLastCleanup = now - this.state.stats.lastCleanup;\n      const thresholdMs = this.config.autoCleanupThreshold * 60 * 1000;\n\n      if (timeSinceLastCleanup > thresholdMs) {\n        this.cleanup();\n      }\n    }, 60 * 1000); // Check every minute\n  }\n\n  /**\n   * Get operation history\n   */\n  getHistory(): (Operation | CompositeOperation)[] {\n    return [...this.state.operations];\n  }\n\n  /**\n   * Get operation by ID\n   */\n  getOperation(id: string): Operation | CompositeOperation | null {\n    return this.state.operations.find(op => op.id === id) || null;\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): UndoRedoState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): UndoRedoConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<UndoRedoConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    \n    // Apply new limits\n    if (this.state.operations.length > this.config.maxHistorySize) {\n      const removeCount = this.state.operations.length - this.config.maxHistorySize;\n      this.state.operations.splice(0, removeCount);\n      this.state.currentIndex = Math.max(-1, this.state.currentIndex - removeCount);\n    }\n\n    this.updateState();\n  }\n\n  /**\n   * Export history for persistence\n   */\n  exportHistory(): string {\n    return JSON.stringify({\n      operations: this.state.operations.map(op => ({\n        ...op,\n        beforeState: { ...op.beforeState, imageData: null }, // Exclude image data\n        afterState: { ...op.afterState, imageData: null }\n      })),\n      currentIndex: this.state.currentIndex,\n      stats: this.state.stats\n    });\n  }\n\n  /**\n   * Import history from persistence\n   */\n  importHistory(historyData: string): boolean {\n    try {\n      const data = JSON.parse(historyData);\n      // Note: This is a simplified implementation\n      // In practice, you'd need to restore the image data\n      this.state.stats = data.stats || this.state.stats;\n      return true;\n    } catch (error) {\n      console.error('Failed to import history:', error);\n      return false;\n    }\n  }\n}\n\n/**\n * Factory function to create undo/redo manager\n */\nexport function createUndoRedoManager(\n  managedCanvas: ManagedCanvas, \n  config?: Partial<UndoRedoConfig>\n): UndoRedoManager {\n  return new UndoRedoManager(managedCanvas, config);\n}"],"names":["DEFAULT_UNDO_REDO_CONFIG","OperationType","UndoRedoManager","createUndoRedoManager","maxHistorySize","enableCompression","compressionQuality","memoryLimit","autoCleanupThreshold","enablePerfMonitoring","constructor","managedCanvas","config","currentComposite","lastSnapshot","canvas","ctx","context","state","currentIndex","operations","canUndo","canRedo","memoryUsage","stats","totalOperations","undoCount","redoCount","memoryPeakUsage","lastCleanup","Date","now","setupAutoCleanup","createSnapshot","compress","imageData","getImageData","width","height","snapshot","timestamp","compressSnapshot","startTime","performance","tempCanvas","document","createElement","tempCtx","getContext","putImageData","dataUrl","toDataURL","img","Image","Promise","resolve","onload","clearRect","drawImage","compressedImageData","compressionTime","originalSize","data","length","compressedSize","compressed","compressionLevel","src","error","console","warn","calculateSnapshotMemory","imageDataSize","metadataSize","applySnapshot","generateOperationId","Math","random","toString","substr","updateState","reduce","total","op","beforeState","afterState","cleanup","startCompositeOperation","description","metadata","Error","id","type","endCompositeOperation","addOperationToStack","operation","slice","push","removeCount","splice","executeOperation","operationFn","operationData","reject","memoryBefore","executionTime","memoryAfter","snapshotTime","undo","redo","jumpToOperation","index","clearHistory","targetMemoryMB","targetMemory","shift","setInterval","timeSinceLastCleanup","thresholdMs","getHistory","getOperation","find","getState","getConfig","updateConfig","newConfig","max","exportHistory","JSON","stringify","map","importHistory","historyData","parse"],"mappings":"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"}