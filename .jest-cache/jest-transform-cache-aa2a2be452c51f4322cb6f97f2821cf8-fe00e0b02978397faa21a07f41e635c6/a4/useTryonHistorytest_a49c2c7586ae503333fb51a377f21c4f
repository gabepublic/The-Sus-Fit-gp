5fb13bcbf389329caa68ffd818f42728
/**
 * @jest-environment jsdom
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _reactquery = require("@tanstack/react-query");
const _useTryonHistory = require("../../../src/business-layer/hooks/useTryonHistory");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock history service
const mockHistoryService = {
    addEntry: jest.fn(),
    getEntries: jest.fn(),
    getEntry: jest.fn(),
    updateEntry: jest.fn(),
    deleteEntry: jest.fn(),
    clearAll: jest.fn(),
    getStorageStats: jest.fn(),
    exportHistory: jest.fn(),
    importHistory: jest.fn()
};
// Test data
const sampleHistoryEntry = {
    id: 'test-entry-1',
    timestamp: '2023-01-01T00:00:00Z',
    generatedImage: 'data:image/jpeg;base64,generated',
    modelImage: 'data:image/jpeg;base64,model',
    apparelImages: [
        'data:image/jpeg;base64,apparel'
    ],
    processingTime: 5000,
    tags: [
        'test'
    ],
    notes: 'Test entry',
    isFavorite: false
};
const sampleHistoryCollection = {
    entries: [
        sampleHistoryEntry
    ],
    totalCount: 1,
    currentPage: 0,
    pageSize: 20,
    hasMore: false,
    lastUpdated: '2023-01-01T00:00:00Z'
};
// Test wrapper component
const createWrapper = ()=>{
    const queryClient = new _reactquery.QueryClient({
        defaultOptions: {
            queries: {
                retry: false
            },
            mutations: {
                retry: false
            }
        }
    });
    return ({ children })=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactquery.QueryClientProvider, {
            client: queryClient,
            children: children
        });
};
describe('useTryonHistory', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Setup default mock implementations
        mockHistoryService.getEntries.mockResolvedValue(sampleHistoryCollection);
        mockHistoryService.addEntry.mockResolvedValue(sampleHistoryEntry);
        mockHistoryService.updateEntry.mockResolvedValue(sampleHistoryEntry);
        mockHistoryService.deleteEntry.mockResolvedValue(true);
        mockHistoryService.clearAll.mockResolvedValue(true);
    });
    describe('Basic Functionality', ()=>{
        it('should initialize with default state', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            expect(result.current.entries).toEqual([]);
            expect(result.current.isLoading).toBe(true);
            expect(result.current.error).toBe(null);
            expect(result.current.hasMore).toBe(false);
            expect(result.current.currentPage).toBe(0);
            expect(result.current.totalCount).toBe(0);
            // Wait for query to complete
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            expect(result.current.entries).toEqual([
                sampleHistoryEntry
            ]);
            expect(result.current.totalCount).toBe(1);
        });
        it('should call getEntries with correct options', async ()=>{
            const wrapper = createWrapper();
            const queryOptions = {
                page: 0,
                pageSize: 10,
                sortBy: 'timestamp',
                sortDirection: 'desc'
            };
            (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)(queryOptions, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            await (0, _react1.waitFor)(()=>{
                expect(mockHistoryService.getEntries).toHaveBeenCalledWith({
                    page: 0,
                    pageSize: 10,
                    sortBy: 'timestamp',
                    sortDirection: 'desc'
                });
            });
        });
        it('should handle loading states correctly', async ()=>{
            const wrapper = createWrapper();
            // Make getEntries return a pending promise
            let resolveGetEntries;
            const pendingPromise = new Promise((resolve)=>{
                resolveGetEntries = resolve;
            });
            mockHistoryService.getEntries.mockReturnValue(pendingPromise);
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            expect(result.current.isLoading).toBe(true);
            // Resolve the promise
            (0, _react1.act)(()=>{
                resolveGetEntries(sampleHistoryCollection);
            });
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            expect(result.current.entries).toEqual([
                sampleHistoryEntry
            ]);
        });
    });
    describe('Adding Entries', ()=>{
        it('should add new entry successfully', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            // Wait for initial load
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            const newEntryOptions = {
                generatedImage: 'new-generated',
                modelImage: 'new-model',
                apparelImages: [
                    'new-apparel'
                ],
                notes: 'New entry'
            };
            await (0, _react1.act)(async ()=>{
                await result.current.addEntry(newEntryOptions);
            });
            expect(mockHistoryService.addEntry).toHaveBeenCalledWith(newEntryOptions);
        });
        it('should handle add entry errors', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            const error = new Error('Failed to add entry');
            mockHistoryService.addEntry.mockRejectedValue(error);
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            const newEntryOptions = {
                generatedImage: 'new-generated',
                modelImage: 'new-model',
                apparelImages: [
                    'new-apparel'
                ]
            };
            await expect((0, _react1.act)(async ()=>{
                await result.current.addEntry(newEntryOptions);
            })).rejects.toThrow('Failed to add entry');
        });
    });
    describe('Updating Entries', ()=>{
        it('should update entry successfully', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            const updates = {
                notes: 'Updated notes',
                isFavorite: true
            };
            await (0, _react1.act)(async ()=>{
                await result.current.updateEntry('test-entry-1', updates);
            });
            expect(mockHistoryService.updateEntry).toHaveBeenCalledWith('test-entry-1', updates);
        });
    });
    describe('Deleting Entries', ()=>{
        it('should delete entry successfully', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            await (0, _react1.act)(async ()=>{
                await result.current.deleteEntry('test-entry-1');
            });
            expect(mockHistoryService.deleteEntry).toHaveBeenCalledWith('test-entry-1');
        });
    });
    describe('Load More Functionality', ()=>{
        it('should load more entries when hasMore is true', async ()=>{
            const wrapper = createWrapper();
            const collectionWithMore = {
                ...sampleHistoryCollection,
                hasMore: true
            };
            mockHistoryService.getEntries.mockResolvedValue(collectionWithMore);
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            expect(result.current.hasMore).toBe(true);
            // Setup next page response
            const nextPageCollection = {
                entries: [
                    {
                        ...sampleHistoryEntry,
                        id: 'test-entry-2'
                    }
                ],
                totalCount: 2,
                currentPage: 1,
                pageSize: 20,
                hasMore: false,
                lastUpdated: '2023-01-01T00:00:00Z'
            };
            mockHistoryService.getEntries.mockResolvedValueOnce(nextPageCollection);
            await (0, _react1.act)(async ()=>{
                await result.current.loadMore();
            });
            expect(mockHistoryService.getEntries).toHaveBeenCalledWith(expect.objectContaining({
                page: 1
            }));
        });
        it('should not load more when hasMore is false', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            expect(result.current.hasMore).toBe(false);
            // Should not make additional calls
            const initialCallCount = mockHistoryService.getEntries.mock.calls.length;
            await (0, _react1.act)(async ()=>{
                await result.current.loadMore();
            });
            expect(mockHistoryService.getEntries.mock.calls.length).toBe(initialCallCount);
        });
    });
    describe('Refresh Functionality', ()=>{
        it('should refresh entries', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            await (0, _react1.act)(async ()=>{
                await result.current.refresh();
            });
            // Should trigger a refetch
            expect(mockHistoryService.getEntries).toHaveBeenCalledTimes(2);
        });
    });
    describe('Clear All Functionality', ()=>{
        it('should clear all entries', async ()=>{
            const wrapper = createWrapper();
            const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistory)({}, {
                    historyService: mockHistoryService
                }), {
                wrapper
            });
            await (0, _react1.waitFor)(()=>{
                expect(result.current.isLoading).toBe(false);
            });
            await (0, _react1.act)(async ()=>{
                await result.current.clearAll();
            });
            expect(mockHistoryService.clearAll).toHaveBeenCalled();
        });
    });
});
describe('useTryonHistoryEntry', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        mockHistoryService.getEntry.mockResolvedValue(sampleHistoryEntry);
    });
    it('should fetch single entry by ID', async ()=>{
        const wrapper = createWrapper();
        const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistoryEntry)('test-entry-1', {
                historyService: mockHistoryService
            }), {
            wrapper
        });
        await (0, _react1.waitFor)(()=>{
            expect(result.current.isLoading).toBe(false);
        });
        expect(mockHistoryService.getEntry).toHaveBeenCalledWith('test-entry-1');
        expect(result.current.data).toEqual(sampleHistoryEntry);
    });
    it('should not fetch when ID is empty', async ()=>{
        const wrapper = createWrapper();
        (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistoryEntry)('', {
                historyService: mockHistoryService
            }), {
            wrapper
        });
        // Should not make any calls when ID is empty
        expect(mockHistoryService.getEntry).not.toHaveBeenCalled();
    });
    it('should handle entry not found', async ()=>{
        const wrapper = createWrapper();
        mockHistoryService.getEntry.mockResolvedValue(null);
        const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistoryEntry)('non-existent-id', {
                historyService: mockHistoryService
            }), {
            wrapper
        });
        await (0, _react1.waitFor)(()=>{
            expect(result.current.isLoading).toBe(false);
        });
        expect(result.current.data).toBe(null);
    });
});
describe('useTryonHistoryStats', ()=>{
    const mockStats = {
        totalEntries: 10,
        totalSizeKB: 1024,
        oldestEntry: '2023-01-01T00:00:00Z',
        newestEntry: '2023-01-02T00:00:00Z'
    };
    beforeEach(()=>{
        jest.clearAllMocks();
        mockHistoryService.getStorageStats.mockResolvedValue(mockStats);
    });
    it('should fetch storage statistics', async ()=>{
        const wrapper = createWrapper();
        const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistoryStats)({
                historyService: mockHistoryService
            }), {
            wrapper
        });
        await (0, _react1.waitFor)(()=>{
            expect(result.current.isLoading).toBe(false);
        });
        expect(mockHistoryService.getStorageStats).toHaveBeenCalled();
        expect(result.current.data).toEqual(mockStats);
    });
    it('should handle stats loading error', async ()=>{
        const wrapper = createWrapper();
        const error = new Error('Failed to get stats');
        mockHistoryService.getStorageStats.mockRejectedValue(error);
        const { result } = (0, _react1.renderHook)(()=>(0, _useTryonHistory.useTryonHistoryStats)({
                historyService: mockHistoryService
            }), {
            wrapper
        });
        await (0, _react1.waitFor)(()=>{
            expect(result.current.isLoading).toBe(false);
        });
        expect(result.current.error).toBeTruthy();
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL2hvb2tzL3VzZVRyeW9uSGlzdG9yeS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBqZXN0LWVudmlyb25tZW50IGpzZG9tXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgUXVlcnlDbGllbnQsIFF1ZXJ5Q2xpZW50UHJvdmlkZXIgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xuaW1wb3J0IHsgdXNlVHJ5b25IaXN0b3J5LCB1c2VUcnlvbkhpc3RvcnlFbnRyeSwgdXNlVHJ5b25IaXN0b3J5U3RhdHMgfSBmcm9tICcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvaG9va3MvdXNlVHJ5b25IaXN0b3J5JztcbmltcG9ydCB0eXBlIHsgXG4gIFRyeW9uSGlzdG9yeVNlcnZpY2UsIFxuICBUcnlvbkhpc3RvcnlFbnRyeSwgXG4gIFRyeW9uSGlzdG9yeUNvbGxlY3Rpb24sXG4gIENyZWF0ZVRyeW9uSGlzdG9yeUVudHJ5T3B0aW9ucyBcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3R5cGVzL2hpc3RvcnkudHlwZXMnO1xuXG4vLyBNb2NrIGhpc3Rvcnkgc2VydmljZVxuY29uc3QgbW9ja0hpc3RvcnlTZXJ2aWNlOiBUcnlvbkhpc3RvcnlTZXJ2aWNlID0ge1xuICBhZGRFbnRyeTogamVzdC5mbigpLFxuICBnZXRFbnRyaWVzOiBqZXN0LmZuKCksXG4gIGdldEVudHJ5OiBqZXN0LmZuKCksXG4gIHVwZGF0ZUVudHJ5OiBqZXN0LmZuKCksXG4gIGRlbGV0ZUVudHJ5OiBqZXN0LmZuKCksXG4gIGNsZWFyQWxsOiBqZXN0LmZuKCksXG4gIGdldFN0b3JhZ2VTdGF0czogamVzdC5mbigpLFxuICBleHBvcnRIaXN0b3J5OiBqZXN0LmZuKCksXG4gIGltcG9ydEhpc3Rvcnk6IGplc3QuZm4oKVxufTtcblxuLy8gVGVzdCBkYXRhXG5jb25zdCBzYW1wbGVIaXN0b3J5RW50cnk6IFRyeW9uSGlzdG9yeUVudHJ5ID0ge1xuICBpZDogJ3Rlc3QtZW50cnktMScsXG4gIHRpbWVzdGFtcDogJzIwMjMtMDEtMDFUMDA6MDA6MDBaJyxcbiAgZ2VuZXJhdGVkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LGdlbmVyYXRlZCcsXG4gIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vZGVsJyxcbiAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LGFwcGFyZWwnXSxcbiAgcHJvY2Vzc2luZ1RpbWU6IDUwMDAsXG4gIHRhZ3M6IFsndGVzdCddLFxuICBub3RlczogJ1Rlc3QgZW50cnknLFxuICBpc0Zhdm9yaXRlOiBmYWxzZVxufTtcblxuY29uc3Qgc2FtcGxlSGlzdG9yeUNvbGxlY3Rpb246IFRyeW9uSGlzdG9yeUNvbGxlY3Rpb24gPSB7XG4gIGVudHJpZXM6IFtzYW1wbGVIaXN0b3J5RW50cnldLFxuICB0b3RhbENvdW50OiAxLFxuICBjdXJyZW50UGFnZTogMCxcbiAgcGFnZVNpemU6IDIwLFxuICBoYXNNb3JlOiBmYWxzZSxcbiAgbGFzdFVwZGF0ZWQ6ICcyMDIzLTAxLTAxVDAwOjAwOjAwWidcbn07XG5cbi8vIFRlc3Qgd3JhcHBlciBjb21wb25lbnRcbmNvbnN0IGNyZWF0ZVdyYXBwZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHF1ZXJ5Q2xpZW50ID0gbmV3IFF1ZXJ5Q2xpZW50KHtcbiAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgcXVlcmllczogeyByZXRyeTogZmFsc2UgfSxcbiAgICAgIG11dGF0aW9uczogeyByZXRyeTogZmFsc2UgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiAoXG4gICAgPFF1ZXJ5Q2xpZW50UHJvdmlkZXIgY2xpZW50PXtxdWVyeUNsaWVudH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9RdWVyeUNsaWVudFByb3ZpZGVyPlxuICApO1xufTtcblxuZGVzY3JpYmUoJ3VzZVRyeW9uSGlzdG9yeScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgXG4gICAgLy8gU2V0dXAgZGVmYXVsdCBtb2NrIGltcGxlbWVudGF0aW9uc1xuICAgIChtb2NrSGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHNhbXBsZUhpc3RvcnlDb2xsZWN0aW9uKTtcbiAgICAobW9ja0hpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoc2FtcGxlSGlzdG9yeUVudHJ5KTtcbiAgICAobW9ja0hpc3RvcnlTZXJ2aWNlLnVwZGF0ZUVudHJ5IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoc2FtcGxlSGlzdG9yeUVudHJ5KTtcbiAgICAobW9ja0hpc3RvcnlTZXJ2aWNlLmRlbGV0ZUVudHJ5IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgKG1vY2tIaXN0b3J5U2VydmljZS5jbGVhckFsbCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFzaWMgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgd2l0aCBkZWZhdWx0IHN0YXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZVdyYXBwZXIoKTtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VUcnlvbkhpc3Rvcnkoe30sIHsgaGlzdG9yeVNlcnZpY2U6IG1vY2tIaXN0b3J5U2VydmljZSB9KSwgXG4gICAgICAgIHsgd3JhcHBlciB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZW50cmllcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlKG51bGwpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmhhc01vcmUpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRQYWdlKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnRvdGFsQ291bnQpLnRvQmUoMCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHF1ZXJ5IHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVudHJpZXMpLnRvRXF1YWwoW3NhbXBsZUhpc3RvcnlFbnRyeV0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnRvdGFsQ291bnQpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNhbGwgZ2V0RW50cmllcyB3aXRoIGNvcnJlY3Qgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgIHBhZ2U6IDAsXG4gICAgICAgIHBhZ2VTaXplOiAxMCxcbiAgICAgICAgc29ydEJ5OiAndGltZXN0YW1wJyBhcyBjb25zdCxcbiAgICAgICAgc29ydERpcmVjdGlvbjogJ2Rlc2MnIGFzIGNvbnN0XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VUcnlvbkhpc3RvcnkocXVlcnlPcHRpb25zLCB7IGhpc3RvcnlTZXJ2aWNlOiBtb2NrSGlzdG9yeVNlcnZpY2UgfSksXG4gICAgICAgIHsgd3JhcHBlciB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tIaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgcGFnZTogMCxcbiAgICAgICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICAgICAgc29ydEJ5OiAndGltZXN0YW1wJyxcbiAgICAgICAgICBzb3J0RGlyZWN0aW9uOiAnZGVzYydcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxvYWRpbmcgc3RhdGVzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgICBcbiAgICAgIC8vIE1ha2UgZ2V0RW50cmllcyByZXR1cm4gYSBwZW5kaW5nIHByb21pc2VcbiAgICAgIGxldCByZXNvbHZlR2V0RW50cmllczogKHZhbHVlOiBUcnlvbkhpc3RvcnlDb2xsZWN0aW9uKSA9PiB2b2lkO1xuICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZTxUcnlvbkhpc3RvcnlDb2xsZWN0aW9uPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlR2V0RW50cmllcyA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIChtb2NrSGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZShwZW5kaW5nUHJvbWlzZSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VUcnlvbkhpc3Rvcnkoe30sIHsgaGlzdG9yeVNlcnZpY2U6IG1vY2tIaXN0b3J5U2VydmljZSB9KSxcbiAgICAgICAgeyB3cmFwcGVyIH1cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2VcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmVHZXRFbnRyaWVzIShzYW1wbGVIaXN0b3J5Q29sbGVjdGlvbik7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lbnRyaWVzKS50b0VxdWFsKFtzYW1wbGVIaXN0b3J5RW50cnldKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FkZGluZyBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWRkIG5ldyBlbnRyeSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlV3JhcHBlcigpO1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZVRyeW9uSGlzdG9yeSh7fSwgeyBoaXN0b3J5U2VydmljZTogbW9ja0hpc3RvcnlTZXJ2aWNlIH0pLFxuICAgICAgICB7IHdyYXBwZXIgfVxuICAgICAgKTtcblxuICAgICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBsb2FkXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbmV3RW50cnlPcHRpb25zOiBDcmVhdGVUcnlvbkhpc3RvcnlFbnRyeU9wdGlvbnMgPSB7XG4gICAgICAgIGdlbmVyYXRlZEltYWdlOiAnbmV3LWdlbmVyYXRlZCcsXG4gICAgICAgIG1vZGVsSW1hZ2U6ICduZXctbW9kZWwnLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ25ldy1hcHBhcmVsJ10sXG4gICAgICAgIG5vdGVzOiAnTmV3IGVudHJ5J1xuICAgICAgfTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWRkRW50cnkobmV3RW50cnlPcHRpb25zKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0hpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXdFbnRyeU9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYWRkIGVudHJ5IGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlVHJ5b25IaXN0b3J5KHt9LCB7IGhpc3RvcnlTZXJ2aWNlOiBtb2NrSGlzdG9yeVNlcnZpY2UgfSksXG4gICAgICAgIHsgd3JhcHBlciB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRmFpbGVkIHRvIGFkZCBlbnRyeScpO1xuICAgICAgKG1vY2tIaXN0b3J5U2VydmljZS5hZGRFbnRyeSBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG5ld0VudHJ5T3B0aW9uczogQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zID0ge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZTogJ25ldy1nZW5lcmF0ZWQnLFxuICAgICAgICBtb2RlbEltYWdlOiAnbmV3LW1vZGVsJyxcbiAgICAgICAgYXBwYXJlbEltYWdlczogWyduZXctYXBwYXJlbCddXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYWRkRW50cnkobmV3RW50cnlPcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdGYWlsZWQgdG8gYWRkIGVudHJ5Jyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdVcGRhdGluZyBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdXBkYXRlIGVudHJ5IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlVHJ5b25IaXN0b3J5KHt9LCB7IGhpc3RvcnlTZXJ2aWNlOiBtb2NrSGlzdG9yeVNlcnZpY2UgfSksXG4gICAgICAgIHsgd3JhcHBlciB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXBkYXRlcyA9IHsgbm90ZXM6ICdVcGRhdGVkIG5vdGVzJywgaXNGYXZvcml0ZTogdHJ1ZSB9O1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC51cGRhdGVFbnRyeSgndGVzdC1lbnRyeS0xJywgdXBkYXRlcyk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tIaXN0b3J5U2VydmljZS51cGRhdGVFbnRyeSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rlc3QtZW50cnktMScsIHVwZGF0ZXMpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGVsZXRpbmcgRW50cmllcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBlbnRyeSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlV3JhcHBlcigpO1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZVRyeW9uSGlzdG9yeSh7fSwgeyBoaXN0b3J5U2VydmljZTogbW9ja0hpc3RvcnlTZXJ2aWNlIH0pLFxuICAgICAgICB7IHdyYXBwZXIgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmRlbGV0ZUVudHJ5KCd0ZXN0LWVudHJ5LTEnKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0hpc3RvcnlTZXJ2aWNlLmRlbGV0ZUVudHJ5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdC1lbnRyeS0xJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2FkIE1vcmUgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvYWQgbW9yZSBlbnRyaWVzIHdoZW4gaGFzTW9yZSBpcyB0cnVlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZVdyYXBwZXIoKTtcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb25XaXRoTW9yZTogVHJ5b25IaXN0b3J5Q29sbGVjdGlvbiA9IHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUNvbGxlY3Rpb24sXG4gICAgICAgIGhhc01vcmU6IHRydWVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIChtb2NrSGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKGNvbGxlY3Rpb25XaXRoTW9yZSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VUcnlvbkhpc3Rvcnkoe30sIHsgaGlzdG9yeVNlcnZpY2U6IG1vY2tIaXN0b3J5U2VydmljZSB9KSxcbiAgICAgICAgeyB3cmFwcGVyIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaGFzTW9yZSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gU2V0dXAgbmV4dCBwYWdlIHJlc3BvbnNlXG4gICAgICBjb25zdCBuZXh0UGFnZUNvbGxlY3Rpb246IFRyeW9uSGlzdG9yeUNvbGxlY3Rpb24gPSB7XG4gICAgICAgIGVudHJpZXM6IFt7IC4uLnNhbXBsZUhpc3RvcnlFbnRyeSwgaWQ6ICd0ZXN0LWVudHJ5LTInIH1dLFxuICAgICAgICB0b3RhbENvdW50OiAyLFxuICAgICAgICBjdXJyZW50UGFnZTogMSxcbiAgICAgICAgcGFnZVNpemU6IDIwLFxuICAgICAgICBoYXNNb3JlOiBmYWxzZSxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6ICcyMDIzLTAxLTAxVDAwOjAwOjAwWidcbiAgICAgIH07XG4gICAgICBcbiAgICAgIChtb2NrSGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZShuZXh0UGFnZUNvbGxlY3Rpb24pO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5sb2FkTW9yZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrSGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgcGFnZTogMSB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGxvYWQgbW9yZSB3aGVuIGhhc01vcmUgaXMgZmFsc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlV3JhcHBlcigpO1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZVRyeW9uSGlzdG9yeSh7fSwgeyBoaXN0b3J5U2VydmljZTogbW9ja0hpc3RvcnlTZXJ2aWNlIH0pLFxuICAgICAgICB7IHdyYXBwZXIgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNNb3JlKS50b0JlKGZhbHNlKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCBtYWtlIGFkZGl0aW9uYWwgY2FsbHNcbiAgICAgIGNvbnN0IGluaXRpYWxDYWxsQ291bnQgPSAobW9ja0hpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMgYXMgamVzdC5Nb2NrKS5tb2NrLmNhbGxzLmxlbmd0aDtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQubG9hZE1vcmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoKG1vY2tIaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzIGFzIGplc3QuTW9jaykubW9jay5jYWxscy5sZW5ndGgpLnRvQmUoaW5pdGlhbENhbGxDb3VudCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWZyZXNoIEZ1bmN0aW9uYWxpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWZyZXNoIGVudHJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlV3JhcHBlcigpO1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZVRyeW9uSGlzdG9yeSh7fSwgeyBoaXN0b3J5U2VydmljZTogbW9ja0hpc3RvcnlTZXJ2aWNlIH0pLFxuICAgICAgICB7IHdyYXBwZXIgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnJlZnJlc2goKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgdHJpZ2dlciBhIHJlZmV0Y2hcbiAgICAgIGV4cGVjdChtb2NrSGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2xlYXIgQWxsIEZ1bmN0aW9uYWxpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhciBhbGwgZW50cmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlVHJ5b25IaXN0b3J5KHt9LCB7IGhpc3RvcnlTZXJ2aWNlOiBtb2NrSGlzdG9yeVNlcnZpY2UgfSksXG4gICAgICAgIHsgd3JhcHBlciB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuY2xlYXJBbGwoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0hpc3RvcnlTZXJ2aWNlLmNsZWFyQWxsKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCd1c2VUcnlvbkhpc3RvcnlFbnRyeScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgKG1vY2tIaXN0b3J5U2VydmljZS5nZXRFbnRyeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHNhbXBsZUhpc3RvcnlFbnRyeSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgZmV0Y2ggc2luZ2xlIGVudHJ5IGJ5IElEJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICB1c2VUcnlvbkhpc3RvcnlFbnRyeSgndGVzdC1lbnRyeS0xJywgeyBoaXN0b3J5U2VydmljZTogbW9ja0hpc3RvcnlTZXJ2aWNlIH0pLFxuICAgICAgeyB3cmFwcGVyIH1cbiAgICApO1xuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGV4cGVjdChtb2NrSGlzdG9yeVNlcnZpY2UuZ2V0RW50cnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0LWVudHJ5LTEnKTtcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChzYW1wbGVIaXN0b3J5RW50cnkpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCBmZXRjaCB3aGVuIElEIGlzIGVtcHR5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgcmVuZGVySG9vaygoKSA9PiBcbiAgICAgIHVzZVRyeW9uSGlzdG9yeUVudHJ5KCcnLCB7IGhpc3RvcnlTZXJ2aWNlOiBtb2NrSGlzdG9yeVNlcnZpY2UgfSksXG4gICAgICB7IHdyYXBwZXIgfVxuICAgICk7XG5cbiAgICAvLyBTaG91bGQgbm90IG1ha2UgYW55IGNhbGxzIHdoZW4gSUQgaXMgZW1wdHlcbiAgICBleHBlY3QobW9ja0hpc3RvcnlTZXJ2aWNlLmdldEVudHJ5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBlbnRyeSBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZVdyYXBwZXIoKTtcbiAgICAobW9ja0hpc3RvcnlTZXJ2aWNlLmdldEVudHJ5IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgIHVzZVRyeW9uSGlzdG9yeUVudHJ5KCdub24tZXhpc3RlbnQtaWQnLCB7IGhpc3RvcnlTZXJ2aWNlOiBtb2NrSGlzdG9yeVNlcnZpY2UgfSksXG4gICAgICB7IHdyYXBwZXIgfVxuICAgICk7XG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvQmUobnVsbCk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCd1c2VUcnlvbkhpc3RvcnlTdGF0cycsICgpID0+IHtcbiAgY29uc3QgbW9ja1N0YXRzID0ge1xuICAgIHRvdGFsRW50cmllczogMTAsXG4gICAgdG90YWxTaXplS0I6IDEwMjQsXG4gICAgb2xkZXN0RW50cnk6ICcyMDIzLTAxLTAxVDAwOjAwOjAwWicsXG4gICAgbmV3ZXN0RW50cnk6ICcyMDIzLTAxLTAyVDAwOjAwOjAwWidcbiAgfTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAobW9ja0hpc3RvcnlTZXJ2aWNlLmdldFN0b3JhZ2VTdGF0cyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdGF0cyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgZmV0Y2ggc3RvcmFnZSBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICB1c2VUcnlvbkhpc3RvcnlTdGF0cyh7IGhpc3RvcnlTZXJ2aWNlOiBtb2NrSGlzdG9yeVNlcnZpY2UgfSksXG4gICAgICB7IHdyYXBwZXIgfVxuICAgICk7XG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgZXhwZWN0KG1vY2tIaXN0b3J5U2VydmljZS5nZXRTdG9yYWdlU3RhdHMpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrU3RhdHMpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBzdGF0cyBsb2FkaW5nIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyKCk7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgc3RhdHMnKTtcbiAgICAobW9ja0hpc3RvcnlTZXJ2aWNlLmdldFN0b3JhZ2VTdGF0cyBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcblxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgdXNlVHJ5b25IaXN0b3J5U3RhdHMoeyBoaXN0b3J5U2VydmljZTogbW9ja0hpc3RvcnlTZXJ2aWNlIH0pLFxuICAgICAgeyB3cmFwcGVyIH1cbiAgICApO1xuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJtb2NrSGlzdG9yeVNlcnZpY2UiLCJhZGRFbnRyeSIsImplc3QiLCJmbiIsImdldEVudHJpZXMiLCJnZXRFbnRyeSIsInVwZGF0ZUVudHJ5IiwiZGVsZXRlRW50cnkiLCJjbGVhckFsbCIsImdldFN0b3JhZ2VTdGF0cyIsImV4cG9ydEhpc3RvcnkiLCJpbXBvcnRIaXN0b3J5Iiwic2FtcGxlSGlzdG9yeUVudHJ5IiwiaWQiLCJ0aW1lc3RhbXAiLCJnZW5lcmF0ZWRJbWFnZSIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwicHJvY2Vzc2luZ1RpbWUiLCJ0YWdzIiwibm90ZXMiLCJpc0Zhdm9yaXRlIiwic2FtcGxlSGlzdG9yeUNvbGxlY3Rpb24iLCJlbnRyaWVzIiwidG90YWxDb3VudCIsImN1cnJlbnRQYWdlIiwicGFnZVNpemUiLCJoYXNNb3JlIiwibGFzdFVwZGF0ZWQiLCJjcmVhdGVXcmFwcGVyIiwicXVlcnlDbGllbnQiLCJRdWVyeUNsaWVudCIsImRlZmF1bHRPcHRpb25zIiwicXVlcmllcyIsInJldHJ5IiwibXV0YXRpb25zIiwiY2hpbGRyZW4iLCJRdWVyeUNsaWVudFByb3ZpZGVyIiwiY2xpZW50IiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiaXQiLCJ3cmFwcGVyIiwicmVzdWx0IiwicmVuZGVySG9vayIsInVzZVRyeW9uSGlzdG9yeSIsImhpc3RvcnlTZXJ2aWNlIiwiZXhwZWN0IiwiY3VycmVudCIsInRvRXF1YWwiLCJpc0xvYWRpbmciLCJ0b0JlIiwiZXJyb3IiLCJ3YWl0Rm9yIiwicXVlcnlPcHRpb25zIiwicGFnZSIsInNvcnRCeSIsInNvcnREaXJlY3Rpb24iLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInJlc29sdmVHZXRFbnRyaWVzIiwicGVuZGluZ1Byb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1vY2tSZXR1cm5WYWx1ZSIsImFjdCIsIm5ld0VudHJ5T3B0aW9ucyIsIkVycm9yIiwibW9ja1JlamVjdGVkVmFsdWUiLCJyZWplY3RzIiwidG9UaHJvdyIsInVwZGF0ZXMiLCJjb2xsZWN0aW9uV2l0aE1vcmUiLCJuZXh0UGFnZUNvbGxlY3Rpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJsb2FkTW9yZSIsIm9iamVjdENvbnRhaW5pbmciLCJpbml0aWFsQ2FsbENvdW50IiwibW9jayIsImNhbGxzIiwibGVuZ3RoIiwicmVmcmVzaCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ1c2VUcnlvbkhpc3RvcnlFbnRyeSIsImRhdGEiLCJub3QiLCJtb2NrU3RhdHMiLCJ0b3RhbEVudHJpZXMiLCJ0b3RhbFNpemVLQiIsIm9sZGVzdEVudHJ5IiwibmV3ZXN0RW50cnkiLCJ1c2VUcnlvbkhpc3RvcnlTdGF0cyIsInRvQmVUcnV0aHkiXSwibWFwcGluZ3MiOiJBQUFB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