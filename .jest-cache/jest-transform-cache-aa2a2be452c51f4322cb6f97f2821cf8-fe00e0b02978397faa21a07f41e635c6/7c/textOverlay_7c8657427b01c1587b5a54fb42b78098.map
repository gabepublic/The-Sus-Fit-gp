{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/utils/textOverlay.ts"],"sourcesContent":["// Text Overlay System for Canvas\n// Comprehensive text rendering with styling, positioning, and measurement\n\nimport type { ManagedCanvas } from '../providers/CanvasProvider';\n\n/**\n * Text alignment options\n */\nexport enum TextAlign {\n  Left = 'left',\n  Center = 'center',\n  Right = 'right',\n  Start = 'start',\n  End = 'end'\n}\n\n/**\n * Text baseline options\n */\nexport enum TextBaseline {\n  Top = 'top',\n  Hanging = 'hanging',\n  Middle = 'middle',\n  Alphabetic = 'alphabetic',\n  Ideographic = 'ideographic',\n  Bottom = 'bottom'\n}\n\n/**\n * Text decoration styles\n */\nexport interface TextDecoration {\n  underline?: boolean;\n  overline?: boolean;\n  lineThrough?: boolean;\n  color?: string;\n  thickness?: number;\n}\n\n/**\n * Text shadow configuration\n */\nexport interface TextShadow {\n  color: string;\n  offsetX: number;\n  offsetY: number;\n  blur: number;\n}\n\n/**\n * Text outline/stroke configuration\n */\nexport interface TextOutline {\n  color: string;\n  width: number;\n}\n\n/**\n * Gradient text configuration\n */\nexport interface TextGradient {\n  type: 'linear' | 'radial';\n  colors: Array<{ offset: number; color: string }>;\n  x1?: number;\n  y1?: number;\n  x2?: number;\n  y2?: number;\n  r1?: number;\n  r2?: number;\n}\n\n/**\n * Comprehensive text styling options\n */\nexport interface TextStyle {\n  /** Font family */\n  fontFamily?: string;\n  /** Font size in pixels */\n  fontSize?: number;\n  /** Font weight */\n  fontWeight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900' | number;\n  /** Font style */\n  fontStyle?: 'normal' | 'italic' | 'oblique';\n  /** Text color */\n  color?: string;\n  /** Text alignment */\n  textAlign?: TextAlign;\n  /** Text baseline */\n  textBaseline?: TextBaseline;\n  /** Line height multiplier */\n  lineHeight?: number;\n  /** Letter spacing in pixels */\n  letterSpacing?: number;\n  /** Text decoration */\n  decoration?: TextDecoration;\n  /** Text shadow */\n  shadow?: TextShadow;\n  /** Text outline/stroke */\n  outline?: TextOutline;\n  /** Gradient fill */\n  gradient?: TextGradient;\n  /** Global alpha/opacity */\n  opacity?: number;\n  /** Text transform */\n  textTransform?: 'none' | 'uppercase' | 'lowercase' | 'capitalize';\n}\n\n/**\n * Text positioning and layout options\n */\nexport interface TextPosition {\n  /** X coordinate */\n  x: number;\n  /** Y coordinate */\n  y: number;\n  /** Maximum width for text wrapping */\n  maxWidth?: number;\n  /** Maximum height for text overflow */\n  maxHeight?: number;\n  /** Padding around text */\n  padding?: {\n    top?: number;\n    right?: number;\n    bottom?: number;\n    left?: number;\n  };\n  /** Text rotation in radians */\n  rotation?: number;\n  /** Anchor point for positioning */\n  anchor?: {\n    x: 'left' | 'center' | 'right';\n    y: 'top' | 'middle' | 'bottom';\n  };\n}\n\n/**\n * Text wrapping configuration\n */\nexport interface TextWrapOptions {\n  /** Enable word wrapping */\n  enabled: boolean;\n  /** Break long words */\n  breakWords?: boolean;\n  /** Hyphenation character */\n  hyphenChar?: string;\n  /** Minimum characters before hyphenation */\n  minCharsBeforeHyphen?: number;\n}\n\n/**\n * Text measurement result\n */\nexport interface TextMeasurement {\n  /** Text width */\n  width: number;\n  /** Text height */\n  height: number;\n  /** Line height */\n  lineHeight: number;\n  /** Number of lines */\n  lineCount: number;\n  /** Individual line measurements */\n  lines: Array<{\n    text: string;\n    width: number;\n    y: number;\n  }>;\n  /** Bounding box */\n  boundingBox: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}\n\n/**\n * Text overlay configuration\n */\nexport interface TextOverlayConfig {\n  /** Text content */\n  text: string;\n  /** Text styling */\n  style: TextStyle;\n  /** Text positioning */\n  position: TextPosition;\n  /** Text wrapping options */\n  wrap?: TextWrapOptions;\n  /** Background configuration */\n  background?: {\n    color?: string;\n    gradient?: TextGradient;\n    padding?: number;\n    borderRadius?: number;\n    opacity?: number;\n  };\n  /** Animation configuration */\n  animation?: {\n    type: 'none' | 'fadeIn' | 'slideIn' | 'typewriter' | 'pulse';\n    duration?: number;\n    delay?: number;\n    easing?: (t: number) => number;\n  };\n}\n\n/**\n * Default text style\n */\nexport const DEFAULT_TEXT_STYLE: Required<Omit<TextStyle, 'decoration' | 'shadow' | 'outline' | 'gradient'>> = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: 16,\n  fontWeight: 'normal',\n  fontStyle: 'normal',\n  color: '#000000',\n  textAlign: TextAlign.Left,\n  textBaseline: TextBaseline.Top,\n  lineHeight: 1.2,\n  letterSpacing: 0,\n  opacity: 1,\n  textTransform: 'none'\n};\n\n/**\n * Text overlay renderer class\n */\nexport class TextOverlayRenderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(managedCanvas: ManagedCanvas) {\n    this.canvas = managedCanvas.canvas;\n    this.ctx = managedCanvas.context;\n  }\n\n  /**\n   * Apply text transform\n   */\n  private applyTextTransform(text: string, transform: TextStyle['textTransform']): string {\n    switch (transform) {\n      case 'uppercase':\n        return text.toUpperCase();\n      case 'lowercase':\n        return text.toLowerCase();\n      case 'capitalize':\n        return text.replace(/\\b\\w/g, l => l.toUpperCase());\n      default:\n        return text;\n    }\n  }\n\n  /**\n   * Build font string from style\n   */\n  private buildFontString(style: TextStyle): string {\n    const fontStyle = style.fontStyle || DEFAULT_TEXT_STYLE.fontStyle;\n    const fontWeight = style.fontWeight || DEFAULT_TEXT_STYLE.fontWeight;\n    const fontSize = style.fontSize || DEFAULT_TEXT_STYLE.fontSize;\n    const fontFamily = style.fontFamily || DEFAULT_TEXT_STYLE.fontFamily;\n    \n    return `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n  }\n\n  /**\n   * Apply text styling to context\n   */\n  private applyTextStyle(style: TextStyle): void {\n    this.ctx.font = this.buildFontString(style);\n    this.ctx.textAlign = style.textAlign || DEFAULT_TEXT_STYLE.textAlign;\n    this.ctx.textBaseline = style.textBaseline || DEFAULT_TEXT_STYLE.textBaseline;\n    this.ctx.globalAlpha = style.opacity || DEFAULT_TEXT_STYLE.opacity;\n\n    // Handle gradient fill\n    if (style.gradient) {\n      this.ctx.fillStyle = this.createTextGradient(style.gradient);\n    } else {\n      this.ctx.fillStyle = style.color || DEFAULT_TEXT_STYLE.color;\n    }\n\n    // Handle outline\n    if (style.outline) {\n      this.ctx.strokeStyle = style.outline.color;\n      this.ctx.lineWidth = style.outline.width;\n    }\n  }\n\n  /**\n   * Create gradient for text\n   */\n  private createTextGradient(gradient: TextGradient): CanvasGradient {\n    let canvasGradient: CanvasGradient;\n\n    if (gradient.type === 'linear') {\n      canvasGradient = this.ctx.createLinearGradient(\n        gradient.x1 || 0,\n        gradient.y1 || 0,\n        gradient.x2 || 100,\n        gradient.y2 || 0\n      );\n    } else {\n      canvasGradient = this.ctx.createRadialGradient(\n        gradient.x1 || 0,\n        gradient.y1 || 0,\n        gradient.r1 || 0,\n        gradient.x2 || 0,\n        gradient.y2 || 0,\n        gradient.r2 || 100\n      );\n    }\n\n    gradient.colors.forEach(stop => {\n      canvasGradient.addColorStop(stop.offset, stop.color);\n    });\n\n    return canvasGradient;\n  }\n\n  /**\n   * Wrap text to fit within specified width\n   */\n  private wrapText(text: string, maxWidth: number, style: TextStyle, wrapOptions?: TextWrapOptions): string[] {\n    if (!wrapOptions?.enabled || !maxWidth) {\n      return [text];\n    }\n\n    this.applyTextStyle(style);\n    const words = text.split(' ');\n    const lines: string[] = [];\n    let currentLine = '';\n\n    for (const word of words) {\n      const testLine = currentLine + (currentLine ? ' ' : '') + word;\n      const metrics = this.ctx.measureText(testLine);\n      \n      if (metrics.width > maxWidth && currentLine) {\n        lines.push(currentLine);\n        currentLine = word;\n        \n        // Handle long words\n        if (wrapOptions.breakWords && this.ctx.measureText(currentLine).width > maxWidth) {\n          const chars = currentLine.split('');\n          let charLine = '';\n          \n          for (const char of chars) {\n            const testCharLine = charLine + char;\n            if (this.ctx.measureText(testCharLine).width > maxWidth && charLine) {\n              lines.push(charLine);\n              charLine = char;\n            } else {\n              charLine = testCharLine;\n            }\n          }\n          currentLine = charLine;\n        }\n      } else {\n        currentLine = testLine;\n      }\n    }\n\n    if (currentLine) {\n      lines.push(currentLine);\n    }\n\n    return lines;\n  }\n\n  /**\n   * Measure text dimensions\n   */\n  measureText(text: string, style: TextStyle, position: TextPosition, wrapOptions?: TextWrapOptions): TextMeasurement {\n    this.applyTextStyle(style);\n    \n    const transformedText = this.applyTextTransform(text, style.textTransform);\n    const lines = this.wrapText(transformedText, position.maxWidth || 0, style, wrapOptions);\n    const lineHeight = (style.fontSize || DEFAULT_TEXT_STYLE.fontSize) * (style.lineHeight || DEFAULT_TEXT_STYLE.lineHeight);\n    \n    let maxWidth = 0;\n    const lineData = lines.map((line, index) => {\n      const metrics = this.ctx.measureText(line);\n      maxWidth = Math.max(maxWidth, metrics.width);\n      \n      return {\n        text: line,\n        width: metrics.width,\n        y: index * lineHeight\n      };\n    });\n\n    const totalHeight = lines.length * lineHeight;\n    \n    // Calculate bounding box based on anchor\n    const anchor = position.anchor || { x: 'left', y: 'top' };\n    let boundingX = position.x;\n    let boundingY = position.y;\n    \n    if (anchor.x === 'center') {\n      boundingX -= maxWidth / 2;\n    } else if (anchor.x === 'right') {\n      boundingX -= maxWidth;\n    }\n    \n    if (anchor.y === 'middle') {\n      boundingY -= totalHeight / 2;\n    } else if (anchor.y === 'bottom') {\n      boundingY -= totalHeight;\n    }\n\n    return {\n      width: maxWidth,\n      height: totalHeight,\n      lineHeight,\n      lineCount: lines.length,\n      lines: lineData,\n      boundingBox: {\n        x: boundingX,\n        y: boundingY,\n        width: maxWidth,\n        height: totalHeight\n      }\n    };\n  }\n\n  /**\n   * Draw text shadow\n   */\n  private drawTextShadow(text: string, x: number, y: number, shadow: TextShadow): void {\n    this.ctx.save();\n    this.ctx.shadowColor = shadow.color;\n    this.ctx.shadowOffsetX = shadow.offsetX;\n    this.ctx.shadowOffsetY = shadow.offsetY;\n    this.ctx.shadowBlur = shadow.blur;\n    this.ctx.fillText(text, x, y);\n    this.ctx.restore();\n  }\n\n  /**\n   * Draw text decoration (underline, overline, strikethrough)\n   */\n  private drawTextDecoration(text: string, x: number, y: number, width: number, style: TextStyle): void {\n    if (!style.decoration) return;\n\n    const fontSize = style.fontSize || DEFAULT_TEXT_STYLE.fontSize;\n    const thickness = style.decoration.thickness || 1;\n    const color = style.decoration.color || style.color || DEFAULT_TEXT_STYLE.color;\n\n    this.ctx.save();\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = thickness;\n    this.ctx.beginPath();\n\n    if (style.decoration.underline) {\n      const underlineY = y + fontSize * 0.1;\n      this.ctx.moveTo(x, underlineY);\n      this.ctx.lineTo(x + width, underlineY);\n    }\n\n    if (style.decoration.overline) {\n      const overlineY = y - fontSize * 0.8;\n      this.ctx.moveTo(x, overlineY);\n      this.ctx.lineTo(x + width, overlineY);\n    }\n\n    if (style.decoration.lineThrough) {\n      const lineThroughY = y - fontSize * 0.3;\n      this.ctx.moveTo(x, lineThroughY);\n      this.ctx.lineTo(x + width, lineThroughY);\n    }\n\n    this.ctx.stroke();\n    this.ctx.restore();\n  }\n\n  /**\n   * Draw background for text\n   */\n  private drawTextBackground(measurement: TextMeasurement, background: NonNullable<TextOverlayConfig['background']>): void {\n    const padding = background.padding || 0;\n    const x = measurement.boundingBox.x - padding;\n    const y = measurement.boundingBox.y - padding;\n    const width = measurement.boundingBox.width + padding * 2;\n    const height = measurement.boundingBox.height + padding * 2;\n\n    this.ctx.save();\n    this.ctx.globalAlpha = background.opacity || 1;\n\n    if (background.gradient) {\n      this.ctx.fillStyle = this.createTextGradient(background.gradient);\n    } else {\n      this.ctx.fillStyle = background.color || 'rgba(255, 255, 255, 0.8)';\n    }\n\n    if (background.borderRadius) {\n      this.drawRoundedRect(x, y, width, height, background.borderRadius);\n      this.ctx.fill();\n    } else {\n      this.ctx.fillRect(x, y, width, height);\n    }\n\n    this.ctx.restore();\n  }\n\n  /**\n   * Draw rounded rectangle\n   */\n  private drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): void {\n    this.ctx.beginPath();\n    this.ctx.moveTo(x + radius, y);\n    this.ctx.lineTo(x + width - radius, y);\n    this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    this.ctx.lineTo(x + width, y + height - radius);\n    this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    this.ctx.lineTo(x + radius, y + height);\n    this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    this.ctx.lineTo(x, y + radius);\n    this.ctx.quadraticCurveTo(x, y, x + radius, y);\n    this.ctx.closePath();\n  }\n\n  /**\n   * Render text overlay\n   */\n  renderText(config: TextOverlayConfig): TextMeasurement {\n    const { text, style, position, wrap, background } = config;\n    \n    this.ctx.save();\n    \n    // Apply rotation if specified\n    if (position.rotation) {\n      this.ctx.translate(position.x, position.y);\n      this.ctx.rotate(position.rotation);\n      this.ctx.translate(-position.x, -position.y);\n    }\n\n    // Measure text\n    const measurement = this.measureText(text, style, position, wrap);\n\n    // Draw background if specified\n    if (background) {\n      this.drawTextBackground(measurement, background);\n    }\n\n    // Apply text styling\n    this.applyTextStyle(style);\n\n    // Calculate starting position based on anchor\n    const anchor = position.anchor || { x: 'left', y: 'top' };\n    let startX = position.x;\n    let startY = position.y;\n\n    if (anchor.x === 'center') {\n      startX -= measurement.width / 2;\n    } else if (anchor.x === 'right') {\n      startX -= measurement.width;\n    }\n\n    if (anchor.y === 'middle') {\n      startY -= measurement.height / 2;\n    } else if (anchor.y === 'bottom') {\n      startY -= measurement.height;\n    }\n\n    // Draw each line\n    measurement.lines.forEach((line, index) => {\n      const lineX = startX;\n      const lineY = startY + line.y;\n\n      // Adjust line position based on text alignment\n      let adjustedX = lineX;\n      if (style.textAlign === TextAlign.Center) {\n        adjustedX = startX + (measurement.width - line.width) / 2;\n      } else if (style.textAlign === TextAlign.Right) {\n        adjustedX = startX + measurement.width - line.width;\n      }\n\n      // Draw shadow first if specified\n      if (style.shadow) {\n        this.drawTextShadow(line.text, adjustedX, lineY, style.shadow);\n      }\n\n      // Draw text outline if specified\n      if (style.outline) {\n        this.ctx.strokeText(line.text, adjustedX, lineY);\n      }\n\n      // Draw main text\n      this.ctx.fillText(line.text, adjustedX, lineY);\n\n      // Draw text decoration if specified\n      if (style.decoration) {\n        this.drawTextDecoration(line.text, adjustedX, lineY, line.width, style);\n      }\n    });\n\n    this.ctx.restore();\n    return measurement;\n  }\n\n  /**\n   * Clear text from specific area\n   */\n  clearText(measurement: TextMeasurement, padding: number = 0): void {\n    const { x, y, width, height } = measurement.boundingBox;\n    this.ctx.clearRect(\n      x - padding,\n      y - padding,\n      width + padding * 2,\n      height + padding * 2\n    );\n  }\n}\n\n/**\n * Text overlay utilities\n */\nexport class TextOverlayUtils {\n  /**\n   * Calculate optimal font size to fit text in area\n   */\n  static calculateOptimalFontSize(\n    text: string,\n    maxWidth: number,\n    maxHeight: number,\n    style: TextStyle,\n    canvas: HTMLCanvasElement\n  ): number {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('Could not get canvas context');\n\n    let fontSize = style.fontSize || 16;\n    let testStyle = { ...style, fontSize };\n    \n    // Binary search for optimal font size\n    let minSize = 1;\n    let maxSize = 200;\n\n    while (minSize < maxSize - 1) {\n      fontSize = Math.floor((minSize + maxSize) / 2);\n      testStyle.fontSize = fontSize;\n      \n      ctx.font = `${testStyle.fontStyle || 'normal'} ${testStyle.fontWeight || 'normal'} ${fontSize}px ${testStyle.fontFamily || 'Arial'}`;\n      const metrics = ctx.measureText(text);\n      const textHeight = fontSize * (testStyle.lineHeight || 1.2);\n\n      if (metrics.width <= maxWidth && textHeight <= maxHeight) {\n        minSize = fontSize;\n      } else {\n        maxSize = fontSize;\n      }\n    }\n\n    return minSize;\n  }\n\n  /**\n   * Create text preset configurations\n   */\n  static createPresets() {\n    return {\n      title: {\n        style: {\n          ...DEFAULT_TEXT_STYLE,\n          fontSize: 32,\n          fontWeight: 'bold',\n          color: '#2c3e50'\n        }\n      },\n      subtitle: {\n        style: {\n          ...DEFAULT_TEXT_STYLE,\n          fontSize: 24,\n          fontWeight: '600',\n          color: '#34495e'\n        }\n      },\n      body: {\n        style: {\n          ...DEFAULT_TEXT_STYLE,\n          fontSize: 16,\n          color: '#2c3e50',\n          lineHeight: 1.5\n        }\n      },\n      caption: {\n        style: {\n          ...DEFAULT_TEXT_STYLE,\n          fontSize: 12,\n          color: '#7f8c8d',\n          fontStyle: 'italic'\n        }\n      },\n      watermark: {\n        style: {\n          ...DEFAULT_TEXT_STYLE,\n          fontSize: 14,\n          color: 'rgba(255, 255, 255, 0.7)',\n          shadow: {\n            color: 'rgba(0, 0, 0, 0.3)',\n            offsetX: 1,\n            offsetY: 1,\n            blur: 2\n          }\n        }\n      }\n    };\n  }\n}\n\n/**\n * Factory function to create text overlay renderer\n */\nexport function createTextOverlayRenderer(managedCanvas: ManagedCanvas): TextOverlayRenderer {\n  return new TextOverlayRenderer(managedCanvas);\n}"],"names":["DEFAULT_TEXT_STYLE","TextAlign","TextBaseline","TextOverlayRenderer","TextOverlayUtils","createTextOverlayRenderer","fontFamily","fontSize","fontWeight","fontStyle","color","textAlign","textBaseline","lineHeight","letterSpacing","opacity","textTransform","constructor","managedCanvas","canvas","ctx","context","applyTextTransform","text","transform","toUpperCase","toLowerCase","replace","l","buildFontString","style","applyTextStyle","font","globalAlpha","gradient","fillStyle","createTextGradient","outline","strokeStyle","lineWidth","width","canvasGradient","type","createLinearGradient","x1","y1","x2","y2","createRadialGradient","r1","r2","colors","forEach","stop","addColorStop","offset","wrapText","maxWidth","wrapOptions","enabled","words","split","lines","currentLine","word","testLine","metrics","measureText","push","breakWords","chars","charLine","char","testCharLine","position","transformedText","lineData","map","line","index","Math","max","y","totalHeight","length","anchor","x","boundingX","boundingY","height","lineCount","boundingBox","drawTextShadow","shadow","save","shadowColor","shadowOffsetX","offsetX","shadowOffsetY","offsetY","shadowBlur","blur","fillText","restore","drawTextDecoration","decoration","thickness","beginPath","underline","underlineY","moveTo","lineTo","overline","overlineY","lineThrough","lineThroughY","stroke","drawTextBackground","measurement","background","padding","borderRadius","drawRoundedRect","fill","fillRect","radius","quadraticCurveTo","closePath","renderText","config","wrap","rotation","translate","rotate","startX","startY","lineX","lineY","adjustedX","strokeText","clearText","clearRect","calculateOptimalFontSize","maxHeight","getContext","Error","testStyle","minSize","maxSize","floor","textHeight","createPresets","title","subtitle","body","caption","watermark"],"mappings":"AAAA,iCAAiC;AACjC,0EAA0E;;;;;;;;;;;;IA+M7DA,kBAAkB;eAAlBA;;IAxMDC,SAAS;eAATA;;IAWAC,YAAY;eAAZA;;IA8MCC,mBAAmB;eAAnBA;;IAoYAC,gBAAgB;eAAhBA;;IAgGGC,yBAAyB;eAAzBA;;;AA7rBT,IAAA,AAAKJ,mCAAAA;;;;;;WAAAA;;AAWL,IAAA,AAAKC,sCAAAA;;;;;;;WAAAA;;AA6LL,MAAMF,qBAAkG;IAC7GM,YAAY;IACZC,UAAU;IACVC,YAAY;IACZC,WAAW;IACXC,OAAO;IACPC,SAAS;IACTC,YAAY;IACZC,YAAY;IACZC,eAAe;IACfC,SAAS;IACTC,eAAe;AACjB;AAKO,MAAMb;IAIXc,YAAYC,aAA4B,CAAE;QACxC,IAAI,CAACC,MAAM,GAAGD,cAAcC,MAAM;QAClC,IAAI,CAACC,GAAG,GAAGF,cAAcG,OAAO;IAClC;IAEA;;GAEC,GACD,AAAQC,mBAAmBC,IAAY,EAAEC,SAAqC,EAAU;QACtF,OAAQA;YACN,KAAK;gBACH,OAAOD,KAAKE,WAAW;YACzB,KAAK;gBACH,OAAOF,KAAKG,WAAW;YACzB,KAAK;gBACH,OAAOH,KAAKI,OAAO,CAAC,SAASC,CAAAA,IAAKA,EAAEH,WAAW;YACjD;gBACE,OAAOF;QACX;IACF;IAEA;;GAEC,GACD,AAAQM,gBAAgBC,KAAgB,EAAU;QAChD,MAAMrB,YAAYqB,MAAMrB,SAAS,IAAIT,mBAAmBS,SAAS;QACjE,MAAMD,aAAasB,MAAMtB,UAAU,IAAIR,mBAAmBQ,UAAU;QACpE,MAAMD,WAAWuB,MAAMvB,QAAQ,IAAIP,mBAAmBO,QAAQ;QAC9D,MAAMD,aAAawB,MAAMxB,UAAU,IAAIN,mBAAmBM,UAAU;QAEpE,OAAO,GAAGG,UAAU,CAAC,EAAED,WAAW,CAAC,EAAED,SAAS,GAAG,EAAED,YAAY;IACjE;IAEA;;GAEC,GACD,AAAQyB,eAAeD,KAAgB,EAAQ;QAC7C,IAAI,CAACV,GAAG,CAACY,IAAI,GAAG,IAAI,CAACH,eAAe,CAACC;QACrC,IAAI,CAACV,GAAG,CAACT,SAAS,GAAGmB,MAAMnB,SAAS,IAAIX,mBAAmBW,SAAS;QACpE,IAAI,CAACS,GAAG,CAACR,YAAY,GAAGkB,MAAMlB,YAAY,IAAIZ,mBAAmBY,YAAY;QAC7E,IAAI,CAACQ,GAAG,CAACa,WAAW,GAAGH,MAAMf,OAAO,IAAIf,mBAAmBe,OAAO;QAElE,uBAAuB;QACvB,IAAIe,MAAMI,QAAQ,EAAE;YAClB,IAAI,CAACd,GAAG,CAACe,SAAS,GAAG,IAAI,CAACC,kBAAkB,CAACN,MAAMI,QAAQ;QAC7D,OAAO;YACL,IAAI,CAACd,GAAG,CAACe,SAAS,GAAGL,MAAMpB,KAAK,IAAIV,mBAAmBU,KAAK;QAC9D;QAEA,iBAAiB;QACjB,IAAIoB,MAAMO,OAAO,EAAE;YACjB,IAAI,CAACjB,GAAG,CAACkB,WAAW,GAAGR,MAAMO,OAAO,CAAC3B,KAAK;YAC1C,IAAI,CAACU,GAAG,CAACmB,SAAS,GAAGT,MAAMO,OAAO,CAACG,KAAK;QAC1C;IACF;IAEA;;GAEC,GACD,AAAQJ,mBAAmBF,QAAsB,EAAkB;QACjE,IAAIO;QAEJ,IAAIP,SAASQ,IAAI,KAAK,UAAU;YAC9BD,iBAAiB,IAAI,CAACrB,GAAG,CAACuB,oBAAoB,CAC5CT,SAASU,EAAE,IAAI,GACfV,SAASW,EAAE,IAAI,GACfX,SAASY,EAAE,IAAI,KACfZ,SAASa,EAAE,IAAI;QAEnB,OAAO;YACLN,iBAAiB,IAAI,CAACrB,GAAG,CAAC4B,oBAAoB,CAC5Cd,SAASU,EAAE,IAAI,GACfV,SAASW,EAAE,IAAI,GACfX,SAASe,EAAE,IAAI,GACff,SAASY,EAAE,IAAI,GACfZ,SAASa,EAAE,IAAI,GACfb,SAASgB,EAAE,IAAI;QAEnB;QAEAhB,SAASiB,MAAM,CAACC,OAAO,CAACC,CAAAA;YACtBZ,eAAea,YAAY,CAACD,KAAKE,MAAM,EAAEF,KAAK3C,KAAK;QACrD;QAEA,OAAO+B;IACT;IAEA;;GAEC,GACD,AAAQe,SAASjC,IAAY,EAAEkC,QAAgB,EAAE3B,KAAgB,EAAE4B,WAA6B,EAAY;QAC1G,IAAI,CAACA,aAAaC,WAAW,CAACF,UAAU;YACtC,OAAO;gBAAClC;aAAK;QACf;QAEA,IAAI,CAACQ,cAAc,CAACD;QACpB,MAAM8B,QAAQrC,KAAKsC,KAAK,CAAC;QACzB,MAAMC,QAAkB,EAAE;QAC1B,IAAIC,cAAc;QAElB,KAAK,MAAMC,QAAQJ,MAAO;YACxB,MAAMK,WAAWF,cAAeA,CAAAA,cAAc,MAAM,EAAC,IAAKC;YAC1D,MAAME,UAAU,IAAI,CAAC9C,GAAG,CAAC+C,WAAW,CAACF;YAErC,IAAIC,QAAQ1B,KAAK,GAAGiB,YAAYM,aAAa;gBAC3CD,MAAMM,IAAI,CAACL;gBACXA,cAAcC;gBAEd,oBAAoB;gBACpB,IAAIN,YAAYW,UAAU,IAAI,IAAI,CAACjD,GAAG,CAAC+C,WAAW,CAACJ,aAAavB,KAAK,GAAGiB,UAAU;oBAChF,MAAMa,QAAQP,YAAYF,KAAK,CAAC;oBAChC,IAAIU,WAAW;oBAEf,KAAK,MAAMC,QAAQF,MAAO;wBACxB,MAAMG,eAAeF,WAAWC;wBAChC,IAAI,IAAI,CAACpD,GAAG,CAAC+C,WAAW,CAACM,cAAcjC,KAAK,GAAGiB,YAAYc,UAAU;4BACnET,MAAMM,IAAI,CAACG;4BACXA,WAAWC;wBACb,OAAO;4BACLD,WAAWE;wBACb;oBACF;oBACAV,cAAcQ;gBAChB;YACF,OAAO;gBACLR,cAAcE;YAChB;QACF;QAEA,IAAIF,aAAa;YACfD,MAAMM,IAAI,CAACL;QACb;QAEA,OAAOD;IACT;IAEA;;GAEC,GACDK,YAAY5C,IAAY,EAAEO,KAAgB,EAAE4C,QAAsB,EAAEhB,WAA6B,EAAmB;QAClH,IAAI,CAAC3B,cAAc,CAACD;QAEpB,MAAM6C,kBAAkB,IAAI,CAACrD,kBAAkB,CAACC,MAAMO,MAAMd,aAAa;QACzE,MAAM8C,QAAQ,IAAI,CAACN,QAAQ,CAACmB,iBAAiBD,SAASjB,QAAQ,IAAI,GAAG3B,OAAO4B;QAC5E,MAAM7C,aAAa,AAACiB,CAAAA,MAAMvB,QAAQ,IAAIP,mBAAmBO,QAAQ,AAAD,IAAMuB,CAAAA,MAAMjB,UAAU,IAAIb,mBAAmBa,UAAU,AAAD;QAEtH,IAAI4C,WAAW;QACf,MAAMmB,WAAWd,MAAMe,GAAG,CAAC,CAACC,MAAMC;YAChC,MAAMb,UAAU,IAAI,CAAC9C,GAAG,CAAC+C,WAAW,CAACW;YACrCrB,WAAWuB,KAAKC,GAAG,CAACxB,UAAUS,QAAQ1B,KAAK;YAE3C,OAAO;gBACLjB,MAAMuD;gBACNtC,OAAO0B,QAAQ1B,KAAK;gBACpB0C,GAAGH,QAAQlE;YACb;QACF;QAEA,MAAMsE,cAAcrB,MAAMsB,MAAM,GAAGvE;QAEnC,yCAAyC;QACzC,MAAMwE,SAASX,SAASW,MAAM,IAAI;YAAEC,GAAG;YAAQJ,GAAG;QAAM;QACxD,IAAIK,YAAYb,SAASY,CAAC;QAC1B,IAAIE,YAAYd,SAASQ,CAAC;QAE1B,IAAIG,OAAOC,CAAC,KAAK,UAAU;YACzBC,aAAa9B,WAAW;QAC1B,OAAO,IAAI4B,OAAOC,CAAC,KAAK,SAAS;YAC/BC,aAAa9B;QACf;QAEA,IAAI4B,OAAOH,CAAC,KAAK,UAAU;YACzBM,aAAaL,cAAc;QAC7B,OAAO,IAAIE,OAAOH,CAAC,KAAK,UAAU;YAChCM,aAAaL;QACf;QAEA,OAAO;YACL3C,OAAOiB;YACPgC,QAAQN;YACRtE;YACA6E,WAAW5B,MAAMsB,MAAM;YACvBtB,OAAOc;YACPe,aAAa;gBACXL,GAAGC;gBACHL,GAAGM;gBACHhD,OAAOiB;gBACPgC,QAAQN;YACV;QACF;IACF;IAEA;;GAEC,GACD,AAAQS,eAAerE,IAAY,EAAE+D,CAAS,EAAEJ,CAAS,EAAEW,MAAkB,EAAQ;QACnF,IAAI,CAACzE,GAAG,CAAC0E,IAAI;QACb,IAAI,CAAC1E,GAAG,CAAC2E,WAAW,GAAGF,OAAOnF,KAAK;QACnC,IAAI,CAACU,GAAG,CAAC4E,aAAa,GAAGH,OAAOI,OAAO;QACvC,IAAI,CAAC7E,GAAG,CAAC8E,aAAa,GAAGL,OAAOM,OAAO;QACvC,IAAI,CAAC/E,GAAG,CAACgF,UAAU,GAAGP,OAAOQ,IAAI;QACjC,IAAI,CAACjF,GAAG,CAACkF,QAAQ,CAAC/E,MAAM+D,GAAGJ;QAC3B,IAAI,CAAC9D,GAAG,CAACmF,OAAO;IAClB;IAEA;;GAEC,GACD,AAAQC,mBAAmBjF,IAAY,EAAE+D,CAAS,EAAEJ,CAAS,EAAE1C,KAAa,EAAEV,KAAgB,EAAQ;QACpG,IAAI,CAACA,MAAM2E,UAAU,EAAE;QAEvB,MAAMlG,WAAWuB,MAAMvB,QAAQ,IAAIP,mBAAmBO,QAAQ;QAC9D,MAAMmG,YAAY5E,MAAM2E,UAAU,CAACC,SAAS,IAAI;QAChD,MAAMhG,QAAQoB,MAAM2E,UAAU,CAAC/F,KAAK,IAAIoB,MAAMpB,KAAK,IAAIV,mBAAmBU,KAAK;QAE/E,IAAI,CAACU,GAAG,CAAC0E,IAAI;QACb,IAAI,CAAC1E,GAAG,CAACkB,WAAW,GAAG5B;QACvB,IAAI,CAACU,GAAG,CAACmB,SAAS,GAAGmE;QACrB,IAAI,CAACtF,GAAG,CAACuF,SAAS;QAElB,IAAI7E,MAAM2E,UAAU,CAACG,SAAS,EAAE;YAC9B,MAAMC,aAAa3B,IAAI3E,WAAW;YAClC,IAAI,CAACa,GAAG,CAAC0F,MAAM,CAACxB,GAAGuB;YACnB,IAAI,CAACzF,GAAG,CAAC2F,MAAM,CAACzB,IAAI9C,OAAOqE;QAC7B;QAEA,IAAI/E,MAAM2E,UAAU,CAACO,QAAQ,EAAE;YAC7B,MAAMC,YAAY/B,IAAI3E,WAAW;YACjC,IAAI,CAACa,GAAG,CAAC0F,MAAM,CAACxB,GAAG2B;YACnB,IAAI,CAAC7F,GAAG,CAAC2F,MAAM,CAACzB,IAAI9C,OAAOyE;QAC7B;QAEA,IAAInF,MAAM2E,UAAU,CAACS,WAAW,EAAE;YAChC,MAAMC,eAAejC,IAAI3E,WAAW;YACpC,IAAI,CAACa,GAAG,CAAC0F,MAAM,CAACxB,GAAG6B;YACnB,IAAI,CAAC/F,GAAG,CAAC2F,MAAM,CAACzB,IAAI9C,OAAO2E;QAC7B;QAEA,IAAI,CAAC/F,GAAG,CAACgG,MAAM;QACf,IAAI,CAAChG,GAAG,CAACmF,OAAO;IAClB;IAEA;;GAEC,GACD,AAAQc,mBAAmBC,WAA4B,EAAEC,UAAwD,EAAQ;QACvH,MAAMC,UAAUD,WAAWC,OAAO,IAAI;QACtC,MAAMlC,IAAIgC,YAAY3B,WAAW,CAACL,CAAC,GAAGkC;QACtC,MAAMtC,IAAIoC,YAAY3B,WAAW,CAACT,CAAC,GAAGsC;QACtC,MAAMhF,QAAQ8E,YAAY3B,WAAW,CAACnD,KAAK,GAAGgF,UAAU;QACxD,MAAM/B,SAAS6B,YAAY3B,WAAW,CAACF,MAAM,GAAG+B,UAAU;QAE1D,IAAI,CAACpG,GAAG,CAAC0E,IAAI;QACb,IAAI,CAAC1E,GAAG,CAACa,WAAW,GAAGsF,WAAWxG,OAAO,IAAI;QAE7C,IAAIwG,WAAWrF,QAAQ,EAAE;YACvB,IAAI,CAACd,GAAG,CAACe,SAAS,GAAG,IAAI,CAACC,kBAAkB,CAACmF,WAAWrF,QAAQ;QAClE,OAAO;YACL,IAAI,CAACd,GAAG,CAACe,SAAS,GAAGoF,WAAW7G,KAAK,IAAI;QAC3C;QAEA,IAAI6G,WAAWE,YAAY,EAAE;YAC3B,IAAI,CAACC,eAAe,CAACpC,GAAGJ,GAAG1C,OAAOiD,QAAQ8B,WAAWE,YAAY;YACjE,IAAI,CAACrG,GAAG,CAACuG,IAAI;QACf,OAAO;YACL,IAAI,CAACvG,GAAG,CAACwG,QAAQ,CAACtC,GAAGJ,GAAG1C,OAAOiD;QACjC;QAEA,IAAI,CAACrE,GAAG,CAACmF,OAAO;IAClB;IAEA;;GAEC,GACD,AAAQmB,gBAAgBpC,CAAS,EAAEJ,CAAS,EAAE1C,KAAa,EAAEiD,MAAc,EAAEoC,MAAc,EAAQ;QACjG,IAAI,CAACzG,GAAG,CAACuF,SAAS;QAClB,IAAI,CAACvF,GAAG,CAAC0F,MAAM,CAACxB,IAAIuC,QAAQ3C;QAC5B,IAAI,CAAC9D,GAAG,CAAC2F,MAAM,CAACzB,IAAI9C,QAAQqF,QAAQ3C;QACpC,IAAI,CAAC9D,GAAG,CAAC0G,gBAAgB,CAACxC,IAAI9C,OAAO0C,GAAGI,IAAI9C,OAAO0C,IAAI2C;QACvD,IAAI,CAACzG,GAAG,CAAC2F,MAAM,CAACzB,IAAI9C,OAAO0C,IAAIO,SAASoC;QACxC,IAAI,CAACzG,GAAG,CAAC0G,gBAAgB,CAACxC,IAAI9C,OAAO0C,IAAIO,QAAQH,IAAI9C,QAAQqF,QAAQ3C,IAAIO;QACzE,IAAI,CAACrE,GAAG,CAAC2F,MAAM,CAACzB,IAAIuC,QAAQ3C,IAAIO;QAChC,IAAI,CAACrE,GAAG,CAAC0G,gBAAgB,CAACxC,GAAGJ,IAAIO,QAAQH,GAAGJ,IAAIO,SAASoC;QACzD,IAAI,CAACzG,GAAG,CAAC2F,MAAM,CAACzB,GAAGJ,IAAI2C;QACvB,IAAI,CAACzG,GAAG,CAAC0G,gBAAgB,CAACxC,GAAGJ,GAAGI,IAAIuC,QAAQ3C;QAC5C,IAAI,CAAC9D,GAAG,CAAC2G,SAAS;IACpB;IAEA;;GAEC,GACDC,WAAWC,MAAyB,EAAmB;QACrD,MAAM,EAAE1G,IAAI,EAAEO,KAAK,EAAE4C,QAAQ,EAAEwD,IAAI,EAAEX,UAAU,EAAE,GAAGU;QAEpD,IAAI,CAAC7G,GAAG,CAAC0E,IAAI;QAEb,8BAA8B;QAC9B,IAAIpB,SAASyD,QAAQ,EAAE;YACrB,IAAI,CAAC/G,GAAG,CAACgH,SAAS,CAAC1D,SAASY,CAAC,EAAEZ,SAASQ,CAAC;YACzC,IAAI,CAAC9D,GAAG,CAACiH,MAAM,CAAC3D,SAASyD,QAAQ;YACjC,IAAI,CAAC/G,GAAG,CAACgH,SAAS,CAAC,CAAC1D,SAASY,CAAC,EAAE,CAACZ,SAASQ,CAAC;QAC7C;QAEA,eAAe;QACf,MAAMoC,cAAc,IAAI,CAACnD,WAAW,CAAC5C,MAAMO,OAAO4C,UAAUwD;QAE5D,+BAA+B;QAC/B,IAAIX,YAAY;YACd,IAAI,CAACF,kBAAkB,CAACC,aAAaC;QACvC;QAEA,qBAAqB;QACrB,IAAI,CAACxF,cAAc,CAACD;QAEpB,8CAA8C;QAC9C,MAAMuD,SAASX,SAASW,MAAM,IAAI;YAAEC,GAAG;YAAQJ,GAAG;QAAM;QACxD,IAAIoD,SAAS5D,SAASY,CAAC;QACvB,IAAIiD,SAAS7D,SAASQ,CAAC;QAEvB,IAAIG,OAAOC,CAAC,KAAK,UAAU;YACzBgD,UAAUhB,YAAY9E,KAAK,GAAG;QAChC,OAAO,IAAI6C,OAAOC,CAAC,KAAK,SAAS;YAC/BgD,UAAUhB,YAAY9E,KAAK;QAC7B;QAEA,IAAI6C,OAAOH,CAAC,KAAK,UAAU;YACzBqD,UAAUjB,YAAY7B,MAAM,GAAG;QACjC,OAAO,IAAIJ,OAAOH,CAAC,KAAK,UAAU;YAChCqD,UAAUjB,YAAY7B,MAAM;QAC9B;QAEA,iBAAiB;QACjB6B,YAAYxD,KAAK,CAACV,OAAO,CAAC,CAAC0B,MAAMC;YAC/B,MAAMyD,QAAQF;YACd,MAAMG,QAAQF,SAASzD,KAAKI,CAAC;YAE7B,+CAA+C;YAC/C,IAAIwD,YAAYF;YAChB,IAAI1G,MAAMnB,SAAS,eAAuB;gBACxC+H,YAAYJ,SAAS,AAAChB,CAAAA,YAAY9E,KAAK,GAAGsC,KAAKtC,KAAK,AAAD,IAAK;YAC1D,OAAO,IAAIV,MAAMnB,SAAS,cAAsB;gBAC9C+H,YAAYJ,SAAShB,YAAY9E,KAAK,GAAGsC,KAAKtC,KAAK;YACrD;YAEA,iCAAiC;YACjC,IAAIV,MAAM+D,MAAM,EAAE;gBAChB,IAAI,CAACD,cAAc,CAACd,KAAKvD,IAAI,EAAEmH,WAAWD,OAAO3G,MAAM+D,MAAM;YAC/D;YAEA,iCAAiC;YACjC,IAAI/D,MAAMO,OAAO,EAAE;gBACjB,IAAI,CAACjB,GAAG,CAACuH,UAAU,CAAC7D,KAAKvD,IAAI,EAAEmH,WAAWD;YAC5C;YAEA,iBAAiB;YACjB,IAAI,CAACrH,GAAG,CAACkF,QAAQ,CAACxB,KAAKvD,IAAI,EAAEmH,WAAWD;YAExC,oCAAoC;YACpC,IAAI3G,MAAM2E,UAAU,EAAE;gBACpB,IAAI,CAACD,kBAAkB,CAAC1B,KAAKvD,IAAI,EAAEmH,WAAWD,OAAO3D,KAAKtC,KAAK,EAAEV;YACnE;QACF;QAEA,IAAI,CAACV,GAAG,CAACmF,OAAO;QAChB,OAAOe;IACT;IAEA;;GAEC,GACDsB,UAAUtB,WAA4B,EAAEE,UAAkB,CAAC,EAAQ;QACjE,MAAM,EAAElC,CAAC,EAAEJ,CAAC,EAAE1C,KAAK,EAAEiD,MAAM,EAAE,GAAG6B,YAAY3B,WAAW;QACvD,IAAI,CAACvE,GAAG,CAACyH,SAAS,CAChBvD,IAAIkC,SACJtC,IAAIsC,SACJhF,QAAQgF,UAAU,GAClB/B,SAAS+B,UAAU;IAEvB;AACF;AAKO,MAAMpH;IACX;;GAEC,GACD,OAAO0I,yBACLvH,IAAY,EACZkC,QAAgB,EAChBsF,SAAiB,EACjBjH,KAAgB,EAChBX,MAAyB,EACjB;QACR,MAAMC,MAAMD,OAAO6H,UAAU,CAAC;QAC9B,IAAI,CAAC5H,KAAK,MAAM,IAAI6H,MAAM;QAE1B,IAAI1I,WAAWuB,MAAMvB,QAAQ,IAAI;QACjC,IAAI2I,YAAY;YAAE,GAAGpH,KAAK;YAAEvB;QAAS;QAErC,sCAAsC;QACtC,IAAI4I,UAAU;QACd,IAAIC,UAAU;QAEd,MAAOD,UAAUC,UAAU,EAAG;YAC5B7I,WAAWyE,KAAKqE,KAAK,CAAC,AAACF,CAAAA,UAAUC,OAAM,IAAK;YAC5CF,UAAU3I,QAAQ,GAAGA;YAErBa,IAAIY,IAAI,GAAG,GAAGkH,UAAUzI,SAAS,IAAI,SAAS,CAAC,EAAEyI,UAAU1I,UAAU,IAAI,SAAS,CAAC,EAAED,SAAS,GAAG,EAAE2I,UAAU5I,UAAU,IAAI,SAAS;YACpI,MAAM4D,UAAU9C,IAAI+C,WAAW,CAAC5C;YAChC,MAAM+H,aAAa/I,WAAY2I,CAAAA,UAAUrI,UAAU,IAAI,GAAE;YAEzD,IAAIqD,QAAQ1B,KAAK,IAAIiB,YAAY6F,cAAcP,WAAW;gBACxDI,UAAU5I;YACZ,OAAO;gBACL6I,UAAU7I;YACZ;QACF;QAEA,OAAO4I;IACT;IAEA;;GAEC,GACD,OAAOI,gBAAgB;QACrB,OAAO;YACLC,OAAO;gBACL1H,OAAO;oBACL,GAAG9B,kBAAkB;oBACrBO,UAAU;oBACVC,YAAY;oBACZE,OAAO;gBACT;YACF;YACA+I,UAAU;gBACR3H,OAAO;oBACL,GAAG9B,kBAAkB;oBACrBO,UAAU;oBACVC,YAAY;oBACZE,OAAO;gBACT;YACF;YACAgJ,MAAM;gBACJ5H,OAAO;oBACL,GAAG9B,kBAAkB;oBACrBO,UAAU;oBACVG,OAAO;oBACPG,YAAY;gBACd;YACF;YACA8I,SAAS;gBACP7H,OAAO;oBACL,GAAG9B,kBAAkB;oBACrBO,UAAU;oBACVG,OAAO;oBACPD,WAAW;gBACb;YACF;YACAmJ,WAAW;gBACT9H,OAAO;oBACL,GAAG9B,kBAAkB;oBACrBO,UAAU;oBACVG,OAAO;oBACPmF,QAAQ;wBACNnF,OAAO;wBACPuF,SAAS;wBACTE,SAAS;wBACTE,MAAM;oBACR;gBACF;YACF;QACF;IACF;AACF;AAKO,SAAShG,0BAA0Ba,aAA4B;IACpE,OAAO,IAAIf,oBAAoBe;AACjC"}