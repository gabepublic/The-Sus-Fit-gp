95021b4b9bb47636525b14b3d439f4f1
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useBatchImageExport: function() {
        return useBatchImageExport;
    },
    useImageExport: function() {
        return useImageExport;
    },
    useSimpleImageExport: function() {
        return useSimpleImageExport;
    }
});
const _react = require("react");
const _CanvasProvider = require("../providers/CanvasProvider");
const _imageExport = require("../utils/imageExport");
const _errorHandling = require("../utils/errorHandling");
function useImageExport(canvasWidth, canvasHeight, canvasId, options = {}) {
    const canvas = (0, _CanvasProvider.useManagedCanvas)(canvasWidth, canvasHeight, canvasId);
    const exporterRef = (0, _react.useRef)();
    const [state, setState] = (0, _react.useState)({
        isExporting: false,
        progress: 0,
        currentExport: null,
        completedExports: [],
        failedExports: [],
        totalExports: 0
    });
    // Initialize exporter
    if (!exporterRef.current) {
        exporterRef.current = (0, _imageExport.createImageExporter)(canvas);
    }
    const updateProgress = (0, _react.useCallback)((progress)=>{
        setState((prev)=>({
                ...prev,
                progress
            }));
        options.onProgress?.(progress);
    }, [
        options
    ]);
    const exportImage = (0, _react.useCallback)(async (config = {})=>{
        if (!exporterRef.current) throw new Error('Exporter not initialized');
        const finalConfig = {
            ...options.defaultConfig,
            ...config
        };
        const exportId = `export_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        setState((prev)=>({
                ...prev,
                isExporting: true,
                progress: 0,
                currentExport: exportId,
                totalExports: prev.totalExports + 1
            }));
        try {
            updateProgress(25);
            const result = await exporterRef.current.exportImage(finalConfig);
            updateProgress(75);
            setState((prev)=>({
                    ...prev,
                    isExporting: false,
                    progress: 100,
                    currentExport: null,
                    completedExports: [
                        ...prev.completedExports,
                        result
                    ]
                }));
            updateProgress(100);
            // Auto-download if enabled
            if (options.autoDownload) {
                exporterRef.current.downloadImage(result);
            }
            options.onExportComplete?.(result);
            return result;
        } catch (error) {
            const classifiedError = (0, _errorHandling.classifyTryonError)(error);
            setState((prev)=>({
                    ...prev,
                    isExporting: false,
                    progress: 0,
                    currentExport: null,
                    failedExports: [
                        ...prev.failedExports,
                        {
                            config: finalConfig,
                            error: classifiedError
                        }
                    ]
                }));
            (0, _errorHandling.logAndClassifyError)(error, {
                operation: 'image_export',
                config: finalConfig,
                exportId
            });
            options.onExportError?.(classifiedError);
            throw classifiedError;
        }
    }, [
        options,
        updateProgress
    ]);
    const exportWithPreset = (0, _react.useCallback)(async (preset)=>{
        return exportImage({
            preset
        });
    }, [
        exportImage
    ]);
    const exportMultiple = (0, _react.useCallback)(async (configs)=>{
        if (!exporterRef.current) throw new Error('Exporter not initialized');
        setState((prev)=>({
                ...prev,
                isExporting: true,
                progress: 0,
                totalExports: prev.totalExports + configs.length
            }));
        const results = [];
        const totalConfigs = configs.length;
        try {
            for(let i = 0; i < configs.length; i++){
                const config = {
                    ...options.defaultConfig,
                    ...configs[i]
                };
                updateProgress(i / totalConfigs * 100);
                const result = await exporterRef.current.exportImage(config);
                results.push(result);
                setState((prev)=>({
                        ...prev,
                        completedExports: [
                            ...prev.completedExports,
                            result
                        ]
                    }));
            }
            setState((prev)=>({
                    ...prev,
                    isExporting: false,
                    progress: 100
                }));
            updateProgress(100);
            return results;
        } catch (error) {
            const classifiedError = (0, _errorHandling.classifyTryonError)(error);
            setState((prev)=>({
                    ...prev,
                    isExporting: false,
                    progress: 0,
                    failedExports: [
                        ...prev.failedExports,
                        {
                            config: configs[results.length],
                            error: classifiedError
                        }
                    ]
                }));
            (0, _errorHandling.logAndClassifyError)(error, {
                operation: 'batch_export',
                completedCount: results.length,
                totalCount: totalConfigs
            });
            options.onExportError?.(classifiedError);
            throw classifiedError;
        }
    }, [
        options,
        updateProgress
    ]);
    const downloadLastExport = (0, _react.useCallback)(()=>{
        if (!exporterRef.current || state.completedExports.length === 0) return;
        const lastExport = state.completedExports[state.completedExports.length - 1];
        exporterRef.current.downloadImage(lastExport);
    }, [
        state.completedExports
    ]);
    const clearHistory = (0, _react.useCallback)(()=>{
        setState((prev)=>({
                ...prev,
                completedExports: [],
                failedExports: [],
                totalExports: 0
            }));
    }, []);
    const getOptimalConfig = (0, _react.useCallback)((useCase)=>{
        const baseConfig = {
            ..._imageExport.DEFAULT_EXPORT_CONFIG,
            ...options.defaultConfig
        };
        switch(useCase){
            case 'web':
                return {
                    ...baseConfig,
                    format: _imageExport.ExportFormat.WEBP,
                    preset: _imageExport.QualityPreset.WEB,
                    quality: 0.8
                };
            case 'social':
                return {
                    ...baseConfig,
                    format: _imageExport.ExportFormat.JPEG,
                    preset: _imageExport.QualityPreset.SOCIAL,
                    quality: 0.85,
                    width: 1080,
                    height: 1080
                };
            case 'print':
                return {
                    ...baseConfig,
                    format: _imageExport.ExportFormat.PNG,
                    preset: _imageExport.QualityPreset.PRINT,
                    quality: 1.0,
                    dpi: 300
                };
            case 'archive':
                return {
                    ...baseConfig,
                    format: _imageExport.ExportFormat.PNG,
                    preset: _imageExport.QualityPreset.MAXIMUM,
                    quality: 1.0
                };
            default:
                return baseConfig;
        }
    }, [
        options.defaultConfig
    ]);
    const estimateSize = (0, _react.useCallback)((config = {})=>{
        const finalConfig = {
            ..._imageExport.DEFAULT_EXPORT_CONFIG,
            ...options.defaultConfig,
            ...config
        };
        const { estimateFileSize } = require('../utils/imageExport');
        return estimateFileSize(finalConfig.width || canvasWidth, finalConfig.height || canvasHeight, finalConfig.format, finalConfig.quality);
    }, [
        canvasWidth,
        canvasHeight,
        options.defaultConfig
    ]);
    return {
        canvas,
        exporter: exporterRef.current,
        state,
        exportImage,
        exportWithPreset,
        exportMultiple,
        downloadLastExport,
        clearHistory,
        getOptimalConfig,
        estimateSize
    };
}
function useBatchImageExport(canvasWidth, canvasHeight, canvasId, concurrency = 2) {
    const canvas = (0, _CanvasProvider.useManagedCanvas)(canvasWidth, canvasHeight, canvasId);
    const exporterRef = (0, _react.useRef)();
    const batchManagerRef = (0, _react.useRef)();
    const [queueStatus, setQueueStatus] = (0, _react.useState)({
        pending: 0,
        processing: false
    });
    // Initialize exporter and batch manager
    if (!exporterRef.current) {
        exporterRef.current = (0, _imageExport.createImageExporter)(canvas);
        batchManagerRef.current = (0, _imageExport.createBatchExportManager)(exporterRef.current, concurrency);
    }
    const updateQueueStatus = (0, _react.useCallback)(()=>{
        if (batchManagerRef.current) {
            setQueueStatus(batchManagerRef.current.getQueueStatus());
        }
    }, []);
    const queueExport = (0, _react.useCallback)(async (config)=>{
        if (!batchManagerRef.current) throw new Error('Batch manager not initialized');
        updateQueueStatus();
        const result = await batchManagerRef.current.queueExport(config);
        updateQueueStatus();
        return result;
    }, [
        updateQueueStatus
    ]);
    const queueMultiple = (0, _react.useCallback)(async (configs)=>{
        if (!batchManagerRef.current) throw new Error('Batch manager not initialized');
        const promises = configs.map((config)=>queueExport(config));
        return Promise.all(promises);
    }, [
        queueExport
    ]);
    const clearQueue = (0, _react.useCallback)(()=>{
        if (batchManagerRef.current) {
            batchManagerRef.current.clearQueue();
            updateQueueStatus();
        }
    }, [
        updateQueueStatus
    ]);
    const exportPresets = (0, _react.useCallback)(async (presets)=>{
        const configs = presets.map((preset)=>({
                preset
            }));
        return queueMultiple(configs);
    }, [
        queueMultiple
    ]);
    return {
        canvas,
        batchManager: batchManagerRef.current,
        queueExport,
        queueMultiple,
        clearQueue,
        queueStatus,
        exportPresets
    };
}
function useSimpleImageExport(canvasWidth, canvasHeight, canvasId) {
    const { canvas, state, exportImage, downloadLastExport, getOptimalConfig } = useImageExport(canvasWidth, canvasHeight, canvasId, {
        autoDownload: true
    });
    const exportForWeb = (0, _react.useCallback)(()=>{
        return exportImage(getOptimalConfig('web'));
    }, [
        exportImage,
        getOptimalConfig
    ]);
    const exportForSocial = (0, _react.useCallback)(()=>{
        return exportImage(getOptimalConfig('social'));
    }, [
        exportImage,
        getOptimalConfig
    ]);
    const exportForPrint = (0, _react.useCallback)(()=>{
        return exportImage(getOptimalConfig('print'));
    }, [
        exportImage,
        getOptimalConfig
    ]);
    const exportPNG = (0, _react.useCallback)(()=>{
        return exportImage({
            format: _imageExport.ExportFormat.PNG,
            quality: 1.0
        });
    }, [
        exportImage
    ]);
    const exportJPEG = (0, _react.useCallback)((quality = 0.9)=>{
        return exportImage({
            format: _imageExport.ExportFormat.JPEG,
            quality
        });
    }, [
        exportImage
    ]);
    return {
        canvas,
        exportForWeb,
        exportForSocial,
        exportForPrint,
        exportPNG,
        exportJPEG,
        isExporting: state.isExporting,
        lastExport: state.completedExports[state.completedExports.length - 1] || null,
        downloadLast: downloadLastExport
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL2hvb2tzL3VzZUltYWdlRXhwb3J0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuLy8gSW1hZ2UgRXhwb3J0IFJlYWN0IEhvb2tzXG4vLyBSZWFjdCBob29rcyBmb3IgbWFuYWdpbmcgaW1hZ2UgZXhwb3J0IG9wZXJhdGlvbnMgd2l0aCBwcm9ncmVzcyB0cmFja2luZyBhbmQgb3B0aW1pemF0aW9uXG5cbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTWFuYWdlZENhbnZhcyB9IGZyb20gJy4uL3Byb3ZpZGVycy9DYW52YXNQcm92aWRlcic7XG5pbXBvcnQge1xuICBJbWFnZUV4cG9ydGVyLFxuICBCYXRjaEV4cG9ydE1hbmFnZXIsXG4gIGNyZWF0ZUltYWdlRXhwb3J0ZXIsXG4gIGNyZWF0ZUJhdGNoRXhwb3J0TWFuYWdlcixcbiAgRXhwb3J0Rm9ybWF0LFxuICBRdWFsaXR5UHJlc2V0LFxuICB0eXBlIEV4cG9ydENvbmZpZyxcbiAgdHlwZSBFeHBvcnRSZXN1bHQsXG4gIHR5cGUgQmF0Y2hFeHBvcnRDb25maWcsXG4gIERFRkFVTFRfRVhQT1JUX0NPTkZJR1xufSBmcm9tICcuLi91dGlscy9pbWFnZUV4cG9ydCc7XG5pbXBvcnQge1xuICBjbGFzc2lmeVRyeW9uRXJyb3IsXG4gIGxvZ0FuZENsYXNzaWZ5RXJyb3IsXG4gIHR5cGUgQ2xhc3NpZmllZEVycm9yXG59IGZyb20gJy4uL3V0aWxzL2Vycm9ySGFuZGxpbmcnO1xuXG4vKipcbiAqIEV4cG9ydCBob29rIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VJbWFnZUV4cG9ydE9wdGlvbnMge1xuICAvKiogRGVmYXVsdCBleHBvcnQgY29uZmlndXJhdGlvbiAqL1xuICBkZWZhdWx0Q29uZmlnPzogUGFydGlhbDxFeHBvcnRDb25maWc+O1xuICAvKiogRW5hYmxlIGF1dG8tZG93bmxvYWQgYWZ0ZXIgZXhwb3J0ICovXG4gIGF1dG9Eb3dubG9hZD86IGJvb2xlYW47XG4gIC8qKiBDYWxsYmFjayB3aGVuIGV4cG9ydCBjb21wbGV0ZXMgKi9cbiAgb25FeHBvcnRDb21wbGV0ZT86IChyZXN1bHQ6IEV4cG9ydFJlc3VsdCkgPT4gdm9pZDtcbiAgLyoqIENhbGxiYWNrIHdoZW4gZXhwb3J0IGZhaWxzICovXG4gIG9uRXhwb3J0RXJyb3I/OiAoZXJyb3I6IENsYXNzaWZpZWRFcnJvcikgPT4gdm9pZDtcbiAgLyoqIENhbGxiYWNrIGZvciBleHBvcnQgcHJvZ3Jlc3MgKi9cbiAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEV4cG9ydCBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4cG9ydFN0YXRlIHtcbiAgaXNFeHBvcnRpbmc6IGJvb2xlYW47XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIGN1cnJlbnRFeHBvcnQ6IHN0cmluZyB8IG51bGw7XG4gIGNvbXBsZXRlZEV4cG9ydHM6IEV4cG9ydFJlc3VsdFtdO1xuICBmYWlsZWRFeHBvcnRzOiBBcnJheTx7IGNvbmZpZzogUGFydGlhbDxFeHBvcnRDb25maWc+OyBlcnJvcjogQ2xhc3NpZmllZEVycm9yIH0+O1xuICB0b3RhbEV4cG9ydHM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNYWluIGltYWdlIGV4cG9ydCBob29rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbWFnZUV4cG9ydChcbiAgY2FudmFzV2lkdGg6IG51bWJlcixcbiAgY2FudmFzSGVpZ2h0OiBudW1iZXIsXG4gIGNhbnZhc0lkPzogc3RyaW5nLFxuICBvcHRpb25zOiBVc2VJbWFnZUV4cG9ydE9wdGlvbnMgPSB7fVxuKToge1xuICBjYW52YXM6IGFueTtcbiAgZXhwb3J0ZXI6IEltYWdlRXhwb3J0ZXI7XG4gIHN0YXRlOiBFeHBvcnRTdGF0ZTtcbiAgZXhwb3J0SW1hZ2U6IChjb25maWc/OiBQYXJ0aWFsPEV4cG9ydENvbmZpZz4pID0+IFByb21pc2U8RXhwb3J0UmVzdWx0PjtcbiAgZXhwb3J0V2l0aFByZXNldDogKHByZXNldDogUXVhbGl0eVByZXNldCkgPT4gUHJvbWlzZTxFeHBvcnRSZXN1bHQ+O1xuICBleHBvcnRNdWx0aXBsZTogKGNvbmZpZ3M6IFBhcnRpYWw8RXhwb3J0Q29uZmlnPltdKSA9PiBQcm9taXNlPEV4cG9ydFJlc3VsdFtdPjtcbiAgZG93bmxvYWRMYXN0RXhwb3J0OiAoKSA9PiB2b2lkO1xuICBjbGVhckhpc3Rvcnk6ICgpID0+IHZvaWQ7XG4gIGdldE9wdGltYWxDb25maWc6ICh1c2VDYXNlOiAnd2ViJyB8ICdzb2NpYWwnIHwgJ3ByaW50JyB8ICdhcmNoaXZlJykgPT4gRXhwb3J0Q29uZmlnO1xuICBlc3RpbWF0ZVNpemU6IChjb25maWc/OiBQYXJ0aWFsPEV4cG9ydENvbmZpZz4pID0+IG51bWJlcjtcbn0ge1xuICBjb25zdCBjYW52YXMgPSB1c2VNYW5hZ2VkQ2FudmFzKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIGNhbnZhc0lkKTtcbiAgY29uc3QgZXhwb3J0ZXJSZWYgPSB1c2VSZWY8SW1hZ2VFeHBvcnRlcj4oKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxFeHBvcnRTdGF0ZT4oe1xuICAgIGlzRXhwb3J0aW5nOiBmYWxzZSxcbiAgICBwcm9ncmVzczogMCxcbiAgICBjdXJyZW50RXhwb3J0OiBudWxsLFxuICAgIGNvbXBsZXRlZEV4cG9ydHM6IFtdLFxuICAgIGZhaWxlZEV4cG9ydHM6IFtdLFxuICAgIHRvdGFsRXhwb3J0czogMFxuICB9KTtcblxuICAvLyBJbml0aWFsaXplIGV4cG9ydGVyXG4gIGlmICghZXhwb3J0ZXJSZWYuY3VycmVudCkge1xuICAgIGV4cG9ydGVyUmVmLmN1cnJlbnQgPSBjcmVhdGVJbWFnZUV4cG9ydGVyKGNhbnZhcyk7XG4gIH1cblxuICBjb25zdCB1cGRhdGVQcm9ncmVzcyA9IHVzZUNhbGxiYWNrKChwcm9ncmVzczogbnVtYmVyKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBwcm9ncmVzcyB9KSk7XG4gICAgb3B0aW9ucy5vblByb2dyZXNzPy4ocHJvZ3Jlc3MpO1xuICB9LCBbb3B0aW9uc10pO1xuXG4gIGNvbnN0IGV4cG9ydEltYWdlID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNvbmZpZzogUGFydGlhbDxFeHBvcnRDb25maWc+ID0ge30pOiBQcm9taXNlPEV4cG9ydFJlc3VsdD4gPT4ge1xuICAgIGlmICghZXhwb3J0ZXJSZWYuY3VycmVudCkgdGhyb3cgbmV3IEVycm9yKCdFeHBvcnRlciBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5vcHRpb25zLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZyB9O1xuICAgIGNvbnN0IGV4cG9ydElkID0gYGV4cG9ydF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG5cbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgaXNFeHBvcnRpbmc6IHRydWUsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIGN1cnJlbnRFeHBvcnQ6IGV4cG9ydElkLFxuICAgICAgdG90YWxFeHBvcnRzOiBwcmV2LnRvdGFsRXhwb3J0cyArIDFcbiAgICB9KSk7XG5cbiAgICB0cnkge1xuICAgICAgdXBkYXRlUHJvZ3Jlc3MoMjUpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHBvcnRlclJlZi5jdXJyZW50LmV4cG9ydEltYWdlKGZpbmFsQ29uZmlnKTtcbiAgICAgIFxuICAgICAgdXBkYXRlUHJvZ3Jlc3MoNzUpO1xuXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGlzRXhwb3J0aW5nOiBmYWxzZSxcbiAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICAgICAgY3VycmVudEV4cG9ydDogbnVsbCxcbiAgICAgICAgY29tcGxldGVkRXhwb3J0czogWy4uLnByZXYuY29tcGxldGVkRXhwb3J0cywgcmVzdWx0XVxuICAgICAgfSkpO1xuXG4gICAgICB1cGRhdGVQcm9ncmVzcygxMDApO1xuXG4gICAgICAvLyBBdXRvLWRvd25sb2FkIGlmIGVuYWJsZWRcbiAgICAgIGlmIChvcHRpb25zLmF1dG9Eb3dubG9hZCkge1xuICAgICAgICBleHBvcnRlclJlZi5jdXJyZW50IS5kb3dubG9hZEltYWdlKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMub25FeHBvcnRDb21wbGV0ZT8uKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBjbGFzc2lmaWVkRXJyb3IgPSBjbGFzc2lmeVRyeW9uRXJyb3IoZXJyb3IpO1xuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGlzRXhwb3J0aW5nOiBmYWxzZSxcbiAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIGN1cnJlbnRFeHBvcnQ6IG51bGwsXG4gICAgICAgIGZhaWxlZEV4cG9ydHM6IFsuLi5wcmV2LmZhaWxlZEV4cG9ydHMsIHsgY29uZmlnOiBmaW5hbENvbmZpZywgZXJyb3I6IGNsYXNzaWZpZWRFcnJvciB9XVxuICAgICAgfSkpO1xuXG4gICAgICBsb2dBbmRDbGFzc2lmeUVycm9yKGVycm9yLCB7XG4gICAgICAgIG9wZXJhdGlvbjogJ2ltYWdlX2V4cG9ydCcsXG4gICAgICAgIGNvbmZpZzogZmluYWxDb25maWcsXG4gICAgICAgIGV4cG9ydElkXG4gICAgICB9KTtcblxuICAgICAgb3B0aW9ucy5vbkV4cG9ydEVycm9yPy4oY2xhc3NpZmllZEVycm9yKTtcbiAgICAgIHRocm93IGNsYXNzaWZpZWRFcnJvcjtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCB1cGRhdGVQcm9ncmVzc10pO1xuXG4gIGNvbnN0IGV4cG9ydFdpdGhQcmVzZXQgPSB1c2VDYWxsYmFjayhhc3luYyAocHJlc2V0OiBRdWFsaXR5UHJlc2V0KTogUHJvbWlzZTxFeHBvcnRSZXN1bHQ+ID0+IHtcbiAgICByZXR1cm4gZXhwb3J0SW1hZ2UoeyBwcmVzZXQgfSk7XG4gIH0sIFtleHBvcnRJbWFnZV0pO1xuXG4gIGNvbnN0IGV4cG9ydE11bHRpcGxlID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNvbmZpZ3M6IFBhcnRpYWw8RXhwb3J0Q29uZmlnPltdKTogUHJvbWlzZTxFeHBvcnRSZXN1bHRbXT4gPT4ge1xuICAgIGlmICghZXhwb3J0ZXJSZWYuY3VycmVudCkgdGhyb3cgbmV3IEVycm9yKCdFeHBvcnRlciBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBpc0V4cG9ydGluZzogdHJ1ZSxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdG90YWxFeHBvcnRzOiBwcmV2LnRvdGFsRXhwb3J0cyArIGNvbmZpZ3MubGVuZ3RoXG4gICAgfSkpO1xuXG4gICAgY29uc3QgcmVzdWx0czogRXhwb3J0UmVzdWx0W10gPSBbXTtcbiAgICBjb25zdCB0b3RhbENvbmZpZ3MgPSBjb25maWdzLmxlbmd0aDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0geyAuLi5vcHRpb25zLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZ3NbaV0gfTtcbiAgICAgICAgdXBkYXRlUHJvZ3Jlc3MoKGkgLyB0b3RhbENvbmZpZ3MpICogMTAwKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4cG9ydGVyUmVmLmN1cnJlbnQuZXhwb3J0SW1hZ2UoY29uZmlnKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIFxuICAgICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBjb21wbGV0ZWRFeHBvcnRzOiBbLi4ucHJldi5jb21wbGV0ZWRFeHBvcnRzLCByZXN1bHRdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc0V4cG9ydGluZzogZmFsc2UsXG4gICAgICAgIHByb2dyZXNzOiAxMDBcbiAgICAgIH0pKTtcblxuICAgICAgdXBkYXRlUHJvZ3Jlc3MoMTAwKTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBjbGFzc2lmaWVkRXJyb3IgPSBjbGFzc2lmeVRyeW9uRXJyb3IoZXJyb3IpO1xuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGlzRXhwb3J0aW5nOiBmYWxzZSxcbiAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIGZhaWxlZEV4cG9ydHM6IFsuLi5wcmV2LmZhaWxlZEV4cG9ydHMsIHsgY29uZmlnOiBjb25maWdzW3Jlc3VsdHMubGVuZ3RoXSwgZXJyb3I6IGNsYXNzaWZpZWRFcnJvciB9XVxuICAgICAgfSkpO1xuXG4gICAgICBsb2dBbmRDbGFzc2lmeUVycm9yKGVycm9yLCB7XG4gICAgICAgIG9wZXJhdGlvbjogJ2JhdGNoX2V4cG9ydCcsXG4gICAgICAgIGNvbXBsZXRlZENvdW50OiByZXN1bHRzLmxlbmd0aCxcbiAgICAgICAgdG90YWxDb3VudDogdG90YWxDb25maWdzXG4gICAgICB9KTtcblxuICAgICAgb3B0aW9ucy5vbkV4cG9ydEVycm9yPy4oY2xhc3NpZmllZEVycm9yKTtcbiAgICAgIHRocm93IGNsYXNzaWZpZWRFcnJvcjtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCB1cGRhdGVQcm9ncmVzc10pO1xuXG4gIGNvbnN0IGRvd25sb2FkTGFzdEV4cG9ydCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWV4cG9ydGVyUmVmLmN1cnJlbnQgfHwgc3RhdGUuY29tcGxldGVkRXhwb3J0cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBsYXN0RXhwb3J0ID0gc3RhdGUuY29tcGxldGVkRXhwb3J0c1tzdGF0ZS5jb21wbGV0ZWRFeHBvcnRzLmxlbmd0aCAtIDFdO1xuICAgIGV4cG9ydGVyUmVmLmN1cnJlbnQuZG93bmxvYWRJbWFnZShsYXN0RXhwb3J0KTtcbiAgfSwgW3N0YXRlLmNvbXBsZXRlZEV4cG9ydHNdKTtcblxuICBjb25zdCBjbGVhckhpc3RvcnkgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGNvbXBsZXRlZEV4cG9ydHM6IFtdLFxuICAgICAgZmFpbGVkRXhwb3J0czogW10sXG4gICAgICB0b3RhbEV4cG9ydHM6IDBcbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBnZXRPcHRpbWFsQ29uZmlnID0gdXNlQ2FsbGJhY2soKHVzZUNhc2U6ICd3ZWInIHwgJ3NvY2lhbCcgfCAncHJpbnQnIHwgJ2FyY2hpdmUnKTogRXhwb3J0Q29uZmlnID0+IHtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0geyAuLi5ERUZBVUxUX0VYUE9SVF9DT05GSUcsIC4uLm9wdGlvbnMuZGVmYXVsdENvbmZpZyB9O1xuXG4gICAgc3dpdGNoICh1c2VDYXNlKSB7XG4gICAgICBjYXNlICd3ZWInOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2VDb25maWcsXG4gICAgICAgICAgZm9ybWF0OiBFeHBvcnRGb3JtYXQuV0VCUCxcbiAgICAgICAgICBwcmVzZXQ6IFF1YWxpdHlQcmVzZXQuV0VCLFxuICAgICAgICAgIHF1YWxpdHk6IDAuOFxuICAgICAgICB9O1xuICAgICAgY2FzZSAnc29jaWFsJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlQ29uZmlnLFxuICAgICAgICAgIGZvcm1hdDogRXhwb3J0Rm9ybWF0LkpQRUcsXG4gICAgICAgICAgcHJlc2V0OiBRdWFsaXR5UHJlc2V0LlNPQ0lBTCxcbiAgICAgICAgICBxdWFsaXR5OiAwLjg1LFxuICAgICAgICAgIHdpZHRoOiAxMDgwLFxuICAgICAgICAgIGhlaWdodDogMTA4MFxuICAgICAgICB9O1xuICAgICAgY2FzZSAncHJpbnQnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2VDb25maWcsXG4gICAgICAgICAgZm9ybWF0OiBFeHBvcnRGb3JtYXQuUE5HLFxuICAgICAgICAgIHByZXNldDogUXVhbGl0eVByZXNldC5QUklOVCxcbiAgICAgICAgICBxdWFsaXR5OiAxLjAsXG4gICAgICAgICAgZHBpOiAzMDBcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ2FyY2hpdmUnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2VDb25maWcsXG4gICAgICAgICAgZm9ybWF0OiBFeHBvcnRGb3JtYXQuUE5HLFxuICAgICAgICAgIHByZXNldDogUXVhbGl0eVByZXNldC5NQVhJTVVNLFxuICAgICAgICAgIHF1YWxpdHk6IDEuMFxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGJhc2VDb25maWc7XG4gICAgfVxuICB9LCBbb3B0aW9ucy5kZWZhdWx0Q29uZmlnXSk7XG5cbiAgY29uc3QgZXN0aW1hdGVTaXplID0gdXNlQ2FsbGJhY2soKGNvbmZpZzogUGFydGlhbDxFeHBvcnRDb25maWc+ID0ge30pOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5ERUZBVUxUX0VYUE9SVF9DT05GSUcsIC4uLm9wdGlvbnMuZGVmYXVsdENvbmZpZywgLi4uY29uZmlnIH07XG4gICAgY29uc3QgeyBlc3RpbWF0ZUZpbGVTaXplIH0gPSByZXF1aXJlKCcuLi91dGlscy9pbWFnZUV4cG9ydCcpO1xuICAgIFxuICAgIHJldHVybiBlc3RpbWF0ZUZpbGVTaXplKFxuICAgICAgZmluYWxDb25maWcud2lkdGggfHwgY2FudmFzV2lkdGgsXG4gICAgICBmaW5hbENvbmZpZy5oZWlnaHQgfHwgY2FudmFzSGVpZ2h0LFxuICAgICAgZmluYWxDb25maWcuZm9ybWF0LFxuICAgICAgZmluYWxDb25maWcucXVhbGl0eVxuICAgICk7XG4gIH0sIFtjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LCBvcHRpb25zLmRlZmF1bHRDb25maWddKTtcblxuICByZXR1cm4ge1xuICAgIGNhbnZhcyxcbiAgICBleHBvcnRlcjogZXhwb3J0ZXJSZWYuY3VycmVudCEsXG4gICAgc3RhdGUsXG4gICAgZXhwb3J0SW1hZ2UsXG4gICAgZXhwb3J0V2l0aFByZXNldCxcbiAgICBleHBvcnRNdWx0aXBsZSxcbiAgICBkb3dubG9hZExhc3RFeHBvcnQsXG4gICAgY2xlYXJIaXN0b3J5LFxuICAgIGdldE9wdGltYWxDb25maWcsXG4gICAgZXN0aW1hdGVTaXplXG4gIH07XG59XG5cbi8qKlxuICogQmF0Y2ggZXhwb3J0IGhvb2sgd2l0aCBxdWV1ZSBtYW5hZ2VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXRjaEltYWdlRXhwb3J0KFxuICBjYW52YXNXaWR0aDogbnVtYmVyLFxuICBjYW52YXNIZWlnaHQ6IG51bWJlcixcbiAgY2FudmFzSWQ/OiBzdHJpbmcsXG4gIGNvbmN1cnJlbmN5OiBudW1iZXIgPSAyXG4pOiB7XG4gIGNhbnZhczogYW55O1xuICBiYXRjaE1hbmFnZXI6IEJhdGNoRXhwb3J0TWFuYWdlcjtcbiAgcXVldWVFeHBvcnQ6IChjb25maWc6IFBhcnRpYWw8RXhwb3J0Q29uZmlnPikgPT4gUHJvbWlzZTxFeHBvcnRSZXN1bHQ+O1xuICBxdWV1ZU11bHRpcGxlOiAoY29uZmlnczogUGFydGlhbDxFeHBvcnRDb25maWc+W10pID0+IFByb21pc2U8RXhwb3J0UmVzdWx0W10+O1xuICBjbGVhclF1ZXVlOiAoKSA9PiB2b2lkO1xuICBxdWV1ZVN0YXR1czogeyBwZW5kaW5nOiBudW1iZXI7IHByb2Nlc3Npbmc6IGJvb2xlYW4gfTtcbiAgZXhwb3J0UHJlc2V0czogKHByZXNldHM6IFF1YWxpdHlQcmVzZXRbXSkgPT4gUHJvbWlzZTxFeHBvcnRSZXN1bHRbXT47XG59IHtcbiAgY29uc3QgY2FudmFzID0gdXNlTWFuYWdlZENhbnZhcyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LCBjYW52YXNJZCk7XG4gIGNvbnN0IGV4cG9ydGVyUmVmID0gdXNlUmVmPEltYWdlRXhwb3J0ZXI+KCk7XG4gIGNvbnN0IGJhdGNoTWFuYWdlclJlZiA9IHVzZVJlZjxCYXRjaEV4cG9ydE1hbmFnZXI+KCk7XG4gIGNvbnN0IFtxdWV1ZVN0YXR1cywgc2V0UXVldWVTdGF0dXNdID0gdXNlU3RhdGUoeyBwZW5kaW5nOiAwLCBwcm9jZXNzaW5nOiBmYWxzZSB9KTtcblxuICAvLyBJbml0aWFsaXplIGV4cG9ydGVyIGFuZCBiYXRjaCBtYW5hZ2VyXG4gIGlmICghZXhwb3J0ZXJSZWYuY3VycmVudCkge1xuICAgIGV4cG9ydGVyUmVmLmN1cnJlbnQgPSBjcmVhdGVJbWFnZUV4cG9ydGVyKGNhbnZhcyk7XG4gICAgYmF0Y2hNYW5hZ2VyUmVmLmN1cnJlbnQgPSBjcmVhdGVCYXRjaEV4cG9ydE1hbmFnZXIoZXhwb3J0ZXJSZWYuY3VycmVudCwgY29uY3VycmVuY3kpO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlUXVldWVTdGF0dXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGJhdGNoTWFuYWdlclJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRRdWV1ZVN0YXR1cyhiYXRjaE1hbmFnZXJSZWYuY3VycmVudC5nZXRRdWV1ZVN0YXR1cygpKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBxdWV1ZUV4cG9ydCA9IHVzZUNhbGxiYWNrKGFzeW5jIChjb25maWc6IFBhcnRpYWw8RXhwb3J0Q29uZmlnPik6IFByb21pc2U8RXhwb3J0UmVzdWx0PiA9PiB7XG4gICAgaWYgKCFiYXRjaE1hbmFnZXJSZWYuY3VycmVudCkgdGhyb3cgbmV3IEVycm9yKCdCYXRjaCBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIFxuICAgIHVwZGF0ZVF1ZXVlU3RhdHVzKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2hNYW5hZ2VyUmVmLmN1cnJlbnQucXVldWVFeHBvcnQoY29uZmlnKTtcbiAgICB1cGRhdGVRdWV1ZVN0YXR1cygpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFt1cGRhdGVRdWV1ZVN0YXR1c10pO1xuXG4gIGNvbnN0IHF1ZXVlTXVsdGlwbGUgPSB1c2VDYWxsYmFjayhhc3luYyAoY29uZmlnczogUGFydGlhbDxFeHBvcnRDb25maWc+W10pOiBQcm9taXNlPEV4cG9ydFJlc3VsdFtdPiA9PiB7XG4gICAgaWYgKCFiYXRjaE1hbmFnZXJSZWYuY3VycmVudCkgdGhyb3cgbmV3IEVycm9yKCdCYXRjaCBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIFxuICAgIGNvbnN0IHByb21pc2VzID0gY29uZmlncy5tYXAoY29uZmlnID0+IHF1ZXVlRXhwb3J0KGNvbmZpZykpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH0sIFtxdWV1ZUV4cG9ydF0pO1xuXG4gIGNvbnN0IGNsZWFyUXVldWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGJhdGNoTWFuYWdlclJlZi5jdXJyZW50KSB7XG4gICAgICBiYXRjaE1hbmFnZXJSZWYuY3VycmVudC5jbGVhclF1ZXVlKCk7XG4gICAgICB1cGRhdGVRdWV1ZVN0YXR1cygpO1xuICAgIH1cbiAgfSwgW3VwZGF0ZVF1ZXVlU3RhdHVzXSk7XG5cbiAgY29uc3QgZXhwb3J0UHJlc2V0cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChwcmVzZXRzOiBRdWFsaXR5UHJlc2V0W10pOiBQcm9taXNlPEV4cG9ydFJlc3VsdFtdPiA9PiB7XG4gICAgY29uc3QgY29uZmlncyA9IHByZXNldHMubWFwKHByZXNldCA9PiAoeyBwcmVzZXQgfSkpO1xuICAgIHJldHVybiBxdWV1ZU11bHRpcGxlKGNvbmZpZ3MpO1xuICB9LCBbcXVldWVNdWx0aXBsZV0pO1xuXG4gIHJldHVybiB7XG4gICAgY2FudmFzLFxuICAgIGJhdGNoTWFuYWdlcjogYmF0Y2hNYW5hZ2VyUmVmLmN1cnJlbnQhLFxuICAgIHF1ZXVlRXhwb3J0LFxuICAgIHF1ZXVlTXVsdGlwbGUsXG4gICAgY2xlYXJRdWV1ZSxcbiAgICBxdWV1ZVN0YXR1cyxcbiAgICBleHBvcnRQcmVzZXRzXG4gIH07XG59XG5cbi8qKlxuICogU2ltcGxlIGV4cG9ydCBob29rIHdpdGggY29tbW9uIHByZXNldHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNpbXBsZUltYWdlRXhwb3J0KFxuICBjYW52YXNXaWR0aDogbnVtYmVyLFxuICBjYW52YXNIZWlnaHQ6IG51bWJlcixcbiAgY2FudmFzSWQ/OiBzdHJpbmdcbik6IHtcbiAgY2FudmFzOiBhbnk7XG4gIGV4cG9ydEZvcldlYjogKCkgPT4gUHJvbWlzZTxFeHBvcnRSZXN1bHQ+O1xuICBleHBvcnRGb3JTb2NpYWw6ICgpID0+IFByb21pc2U8RXhwb3J0UmVzdWx0PjtcbiAgZXhwb3J0Rm9yUHJpbnQ6ICgpID0+IFByb21pc2U8RXhwb3J0UmVzdWx0PjtcbiAgZXhwb3J0UE5HOiAoKSA9PiBQcm9taXNlPEV4cG9ydFJlc3VsdD47XG4gIGV4cG9ydEpQRUc6IChxdWFsaXR5PzogbnVtYmVyKSA9PiBQcm9taXNlPEV4cG9ydFJlc3VsdD47XG4gIGlzRXhwb3J0aW5nOiBib29sZWFuO1xuICBsYXN0RXhwb3J0OiBFeHBvcnRSZXN1bHQgfCBudWxsO1xuICBkb3dubG9hZExhc3Q6ICgpID0+IHZvaWQ7XG59IHtcbiAgY29uc3Qge1xuICAgIGNhbnZhcyxcbiAgICBzdGF0ZSxcbiAgICBleHBvcnRJbWFnZSxcbiAgICBkb3dubG9hZExhc3RFeHBvcnQsXG4gICAgZ2V0T3B0aW1hbENvbmZpZ1xuICB9ID0gdXNlSW1hZ2VFeHBvcnQoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgY2FudmFzSWQsIHsgYXV0b0Rvd25sb2FkOiB0cnVlIH0pO1xuXG4gIGNvbnN0IGV4cG9ydEZvcldlYiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gZXhwb3J0SW1hZ2UoZ2V0T3B0aW1hbENvbmZpZygnd2ViJykpO1xuICB9LCBbZXhwb3J0SW1hZ2UsIGdldE9wdGltYWxDb25maWddKTtcblxuICBjb25zdCBleHBvcnRGb3JTb2NpYWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGV4cG9ydEltYWdlKGdldE9wdGltYWxDb25maWcoJ3NvY2lhbCcpKTtcbiAgfSwgW2V4cG9ydEltYWdlLCBnZXRPcHRpbWFsQ29uZmlnXSk7XG5cbiAgY29uc3QgZXhwb3J0Rm9yUHJpbnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGV4cG9ydEltYWdlKGdldE9wdGltYWxDb25maWcoJ3ByaW50JykpO1xuICB9LCBbZXhwb3J0SW1hZ2UsIGdldE9wdGltYWxDb25maWddKTtcblxuICBjb25zdCBleHBvcnRQTkcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGV4cG9ydEltYWdlKHsgZm9ybWF0OiBFeHBvcnRGb3JtYXQuUE5HLCBxdWFsaXR5OiAxLjAgfSk7XG4gIH0sIFtleHBvcnRJbWFnZV0pO1xuXG4gIGNvbnN0IGV4cG9ydEpQRUcgPSB1c2VDYWxsYmFjaygocXVhbGl0eTogbnVtYmVyID0gMC45KSA9PiB7XG4gICAgcmV0dXJuIGV4cG9ydEltYWdlKHsgZm9ybWF0OiBFeHBvcnRGb3JtYXQuSlBFRywgcXVhbGl0eSB9KTtcbiAgfSwgW2V4cG9ydEltYWdlXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjYW52YXMsXG4gICAgZXhwb3J0Rm9yV2ViLFxuICAgIGV4cG9ydEZvclNvY2lhbCxcbiAgICBleHBvcnRGb3JQcmludCxcbiAgICBleHBvcnRQTkcsXG4gICAgZXhwb3J0SlBFRyxcbiAgICBpc0V4cG9ydGluZzogc3RhdGUuaXNFeHBvcnRpbmcsXG4gICAgbGFzdEV4cG9ydDogc3RhdGUuY29tcGxldGVkRXhwb3J0c1tzdGF0ZS5jb21wbGV0ZWRFeHBvcnRzLmxlbmd0aCAtIDFdIHx8IG51bGwsXG4gICAgZG93bmxvYWRMYXN0OiBkb3dubG9hZExhc3RFeHBvcnRcbiAgfTtcbn0iXSwibmFtZXMiOlsidXNlQmF0Y2hJbWFnZUV4cG9ydCIsInVzZUltYWdlRXhwb3J0IiwidXNlU2ltcGxlSW1hZ2VFeHBvcnQiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImNhbnZhc0lkIiwib3B0aW9ucyIsImNhbnZhcyIsInVzZU1hbmFnZWRDYW52YXMiLCJleHBvcnRlclJlZiIsInVzZVJlZiIsInN0YXRlIiwic2V0U3RhdGUiLCJ1c2VTdGF0ZSIsImlzRXhwb3J0aW5nIiwicHJvZ3Jlc3MiLCJjdXJyZW50RXhwb3J0IiwiY29tcGxldGVkRXhwb3J0cyIsImZhaWxlZEV4cG9ydHMiLCJ0b3RhbEV4cG9ydHMiLCJjdXJyZW50IiwiY3JlYXRlSW1hZ2VFeHBvcnRlciIsInVwZGF0ZVByb2dyZXNzIiwidXNlQ2FsbGJhY2siLCJwcmV2Iiwib25Qcm9ncmVzcyIsImV4cG9ydEltYWdlIiwiY29uZmlnIiwiRXJyb3IiLCJmaW5hbENvbmZpZyIsImRlZmF1bHRDb25maWciLCJleHBvcnRJZCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJyZXN1bHQiLCJhdXRvRG93bmxvYWQiLCJkb3dubG9hZEltYWdlIiwib25FeHBvcnRDb21wbGV0ZSIsImVycm9yIiwiY2xhc3NpZmllZEVycm9yIiwiY2xhc3NpZnlUcnlvbkVycm9yIiwibG9nQW5kQ2xhc3NpZnlFcnJvciIsIm9wZXJhdGlvbiIsIm9uRXhwb3J0RXJyb3IiLCJleHBvcnRXaXRoUHJlc2V0IiwicHJlc2V0IiwiZXhwb3J0TXVsdGlwbGUiLCJjb25maWdzIiwibGVuZ3RoIiwicmVzdWx0cyIsInRvdGFsQ29uZmlncyIsImkiLCJwdXNoIiwiY29tcGxldGVkQ291bnQiLCJ0b3RhbENvdW50IiwiZG93bmxvYWRMYXN0RXhwb3J0IiwibGFzdEV4cG9ydCIsImNsZWFySGlzdG9yeSIsImdldE9wdGltYWxDb25maWciLCJ1c2VDYXNlIiwiYmFzZUNvbmZpZyIsIkRFRkFVTFRfRVhQT1JUX0NPTkZJRyIsImZvcm1hdCIsIkV4cG9ydEZvcm1hdCIsIldFQlAiLCJRdWFsaXR5UHJlc2V0IiwiV0VCIiwicXVhbGl0eSIsIkpQRUciLCJTT0NJQUwiLCJ3aWR0aCIsImhlaWdodCIsIlBORyIsIlBSSU5UIiwiZHBpIiwiTUFYSU1VTSIsImVzdGltYXRlU2l6ZSIsImVzdGltYXRlRmlsZVNpemUiLCJyZXF1aXJlIiwiZXhwb3J0ZXIiLCJjb25jdXJyZW5jeSIsImJhdGNoTWFuYWdlclJlZiIsInF1ZXVlU3RhdHVzIiwic2V0UXVldWVTdGF0dXMiLCJwZW5kaW5nIiwicHJvY2Vzc2luZyIsImNyZWF0ZUJhdGNoRXhwb3J0TWFuYWdlciIsInVwZGF0ZVF1ZXVlU3RhdHVzIiwiZ2V0UXVldWVTdGF0dXMiLCJxdWV1ZUV4cG9ydCIsInF1ZXVlTXVsdGlwbGUiLCJwcm9taXNlcyIsIm1hcCIsIlByb21pc2UiLCJhbGwiLCJjbGVhclF1ZXVlIiwiZXhwb3J0UHJlc2V0cyIsInByZXNldHMiLCJiYXRjaE1hbmFnZXIiLCJleHBvcnRGb3JXZWIiLCJleHBvcnRGb3JTb2NpYWwiLCJleHBvcnRGb3JQcmludCIsImV4cG9ydFBORyIsImV4cG9ydEpQRUciLCJkb3dubG9hZExhc3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7SUEyU2dCQSxtQkFBbUI7ZUFBbkJBOztJQW5QQUMsY0FBYztlQUFkQTs7SUE2VEFD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