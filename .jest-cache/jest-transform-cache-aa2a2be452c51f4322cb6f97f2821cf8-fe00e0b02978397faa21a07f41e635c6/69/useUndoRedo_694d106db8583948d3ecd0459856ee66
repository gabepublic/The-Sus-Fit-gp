14ca10b773b61728d68b12e8883e3175
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useHistoryPersistence: function() {
        return useHistoryPersistence;
    },
    useOperationBatching: function() {
        return useOperationBatching;
    },
    useSimpleUndoRedo: function() {
        return useSimpleUndoRedo;
    },
    useUndoRedo: function() {
        return useUndoRedo;
    }
});
const _react = require("react");
const _CanvasProvider = require("../providers/CanvasProvider");
const _undoRedoStack = require("../utils/undoRedoStack");
/**
 * Default keyboard shortcuts
 */ const DEFAULT_SHORTCUTS = {
    undo: [
        'ctrl+z',
        'cmd+z'
    ],
    redo: [
        'ctrl+y',
        'cmd+y',
        'ctrl+shift+z',
        'cmd+shift+z'
    ]
};
function useUndoRedo(canvasWidth, canvasHeight, canvasId, options = {}) {
    const canvas = (0, _CanvasProvider.useManagedCanvas)(canvasWidth, canvasHeight, canvasId);
    const managerRef = (0, _react.useRef)();
    const [state, setState] = (0, _react.useState)({
        currentIndex: -1,
        operations: [],
        canUndo: false,
        canRedo: false,
        memoryUsage: 0,
        stats: {
            totalOperations: 0,
            undoCount: 0,
            redoCount: 0,
            memoryPeakUsage: 0,
            lastCleanup: Date.now()
        }
    });
    // Initialize manager
    if (!managerRef.current) {
        managerRef.current = (0, _undoRedoStack.createUndoRedoManager)(canvas, options.config);
    }
    const updateState = (0, _react.useCallback)(()=>{
        if (managerRef.current) {
            setState(managerRef.current.getState());
        }
    }, []);
    const executeOperation = (0, _react.useCallback)(async (type, description, operationFn, operationData, metadata)=>{
        if (!managerRef.current) throw new Error('Manager not initialized');
        const operationId = await managerRef.current.executeOperation(type, description, operationFn, operationData, metadata);
        updateState();
        const operation = managerRef.current.getOperation(operationId);
        if (operation) {
            options.onOperationExecuted?.(operation);
        }
        return operationId;
    }, [
        updateState,
        options
    ]);
    const undo = (0, _react.useCallback)(()=>{
        if (!managerRef.current) return false;
        const currentOperation = state.currentIndex >= 0 ? managerRef.current.getHistory()[state.currentIndex] : null;
        const success = managerRef.current.undo();
        if (success) {
            updateState();
            if (currentOperation) {
                options.onUndo?.(currentOperation);
            }
        }
        return success;
    }, [
        state.currentIndex,
        updateState,
        options
    ]);
    const redo = (0, _react.useCallback)(()=>{
        if (!managerRef.current) return false;
        const nextOperation = state.currentIndex + 1 < state.operations.length ? state.operations[state.currentIndex + 1] : null;
        const success = managerRef.current.redo();
        if (success) {
            updateState();
            if (nextOperation) {
                options.onRedo?.(nextOperation);
            }
        }
        return success;
    }, [
        state.currentIndex,
        state.operations,
        updateState,
        options
    ]);
    const startComposite = (0, _react.useCallback)((description, metadata)=>{
        if (!managerRef.current) throw new Error('Manager not initialized');
        return managerRef.current.startCompositeOperation(description, metadata);
    }, []);
    const endComposite = (0, _react.useCallback)(()=>{
        if (!managerRef.current) return;
        managerRef.current.endCompositeOperation();
        updateState();
    }, [
        updateState
    ]);
    const jumpToOperation = (0, _react.useCallback)((index)=>{
        if (!managerRef.current) return false;
        const success = managerRef.current.jumpToOperation(index);
        if (success) {
            updateState();
        }
        return success;
    }, [
        updateState
    ]);
    const clearHistory = (0, _react.useCallback)(()=>{
        if (!managerRef.current) return;
        managerRef.current.clearHistory();
        updateState();
        options.onHistoryCleared?.();
    }, [
        updateState,
        options
    ]);
    const getHistory = (0, _react.useCallback)(()=>{
        return managerRef.current?.getHistory() || [];
    }, []);
    const getOperation = (0, _react.useCallback)((id)=>{
        return managerRef.current?.getOperation(id) || null;
    }, []);
    const cleanup = (0, _react.useCallback)((targetMemoryMB)=>{
        if (!managerRef.current) return;
        managerRef.current.cleanup(targetMemoryMB);
        updateState();
    }, [
        updateState
    ]);
    const exportHistory = (0, _react.useCallback)(()=>{
        return managerRef.current?.exportHistory() || '';
    }, []);
    const importHistory = (0, _react.useCallback)((historyData)=>{
        if (!managerRef.current) return false;
        const success = managerRef.current.importHistory(historyData);
        if (success) {
            updateState();
        }
        return success;
    }, [
        updateState
    ]);
    const updateConfig = (0, _react.useCallback)((newConfig)=>{
        if (!managerRef.current) return;
        managerRef.current.updateConfig(newConfig);
        updateState();
    }, [
        updateState
    ]);
    // Keyboard shortcuts
    (0, _react.useEffect)(()=>{
        if (!options.enableKeyboardShortcuts) return;
        const shortcuts = {
            ...DEFAULT_SHORTCUTS,
            ...options.keyboardShortcuts
        };
        const handleKeyDown = (event)=>{
            const key = `${event.ctrlKey || event.metaKey ? 'ctrl+' : ''}${event.shiftKey ? 'shift+' : ''}${event.key.toLowerCase()}`;
            const cmdKey = `${event.ctrlKey || event.metaKey ? 'cmd+' : ''}${event.shiftKey ? 'shift+' : ''}${event.key.toLowerCase()}`;
            if (shortcuts.undo.includes(key) || shortcuts.undo.includes(cmdKey)) {
                event.preventDefault();
                undo();
            } else if (shortcuts.redo.includes(key) || shortcuts.redo.includes(cmdKey)) {
                event.preventDefault();
                redo();
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        return ()=>document.removeEventListener('keydown', handleKeyDown);
    }, [
        options.enableKeyboardShortcuts,
        options.keyboardShortcuts,
        undo,
        redo
    ]);
    // Update state when operations change
    (0, _react.useEffect)(()=>{
        updateState();
    }, [
        updateState
    ]);
    return {
        canvas,
        manager: managerRef.current,
        state,
        canUndo: state.canUndo,
        canRedo: state.canRedo,
        undo,
        redo,
        executeOperation,
        startComposite,
        endComposite,
        jumpToOperation,
        clearHistory,
        getHistory,
        getOperation,
        cleanup,
        exportHistory,
        importHistory,
        updateConfig
    };
}
function useSimpleUndoRedo(initialState, maxHistorySize = 50) {
    const [history, setHistory] = (0, _react.useState)([
        initialState
    ]);
    const [currentIndex, setCurrentIndex] = (0, _react.useState)(0);
    const canUndo = currentIndex > 0;
    const canRedo = currentIndex < history.length - 1;
    const state = history[currentIndex];
    const undo = (0, _react.useCallback)(()=>{
        if (canUndo) {
            setCurrentIndex((prev)=>prev - 1);
        }
    }, [
        canUndo
    ]);
    const redo = (0, _react.useCallback)(()=>{
        if (canRedo) {
            setCurrentIndex((prev)=>prev + 1);
        }
    }, [
        canRedo
    ]);
    const pushState = (0, _react.useCallback)((newState)=>{
        setHistory((prev)=>{
            // Remove any states after current index
            const newHistory = prev.slice(0, currentIndex + 1);
            newHistory.push(newState);
            // Enforce max history size
            if (newHistory.length > maxHistorySize) {
                newHistory.splice(0, newHistory.length - maxHistorySize);
                setCurrentIndex(maxHistorySize - 1);
                return newHistory;
            }
            setCurrentIndex(newHistory.length - 1);
            return newHistory;
        });
    }, [
        currentIndex,
        maxHistorySize
    ]);
    const clearHistory = (0, _react.useCallback)(()=>{
        setHistory([
            state
        ]);
        setCurrentIndex(0);
    }, [
        state
    ]);
    const getHistory = (0, _react.useCallback)(()=>{
        return [
            ...history
        ];
    }, [
        history
    ]);
    return {
        state,
        canUndo,
        canRedo,
        undo,
        redo,
        pushState,
        clearHistory,
        getHistory
    };
}
function useOperationBatching(undoRedoManager, autoCommitDelay = 1000) {
    const [isBatching, setIsBatching] = (0, _react.useState)(false);
    const [batchOperationCount, setBatchOperationCount] = (0, _react.useState)(0);
    const batchTimeoutRef = (0, _react.useRef)();
    const currentBatchRef = (0, _react.useRef)(null);
    const startBatch = (0, _react.useCallback)((description)=>{
        if (currentBatchRef.current) {
            commitBatch();
        }
        const batchId = undoRedoManager.startCompositeOperation(description);
        currentBatchRef.current = batchId;
        setIsBatching(true);
        setBatchOperationCount(0);
        // Auto-commit after delay
        if (batchTimeoutRef.current) {
            clearTimeout(batchTimeoutRef.current);
        }
        batchTimeoutRef.current = setTimeout(()=>{
            commitBatch();
        }, autoCommitDelay);
        return batchId;
    }, [
        autoCommitDelay
    ]);
    const addOperation = (0, _react.useCallback)(async (type, description, operationFn, operationData)=>{
        const operationId = await undoRedoManager.executeOperation(type, description, operationFn, operationData);
        setBatchOperationCount((prev)=>prev + 1);
        return operationId;
    }, [
        undoRedoManager
    ]);
    const commitBatch = (0, _react.useCallback)(()=>{
        if (currentBatchRef.current) {
            undoRedoManager.endCompositeOperation();
            currentBatchRef.current = null;
            setIsBatching(false);
            setBatchOperationCount(0);
            if (batchTimeoutRef.current) {
                clearTimeout(batchTimeoutRef.current);
                batchTimeoutRef.current = undefined;
            }
        }
    }, [
        undoRedoManager
    ]);
    const discardBatch = (0, _react.useCallback)(()=>{
        if (currentBatchRef.current) {
            // Note: In a real implementation, you'd need to revert operations
            // For now, we just clear the batch state
            currentBatchRef.current = null;
            setIsBatching(false);
            setBatchOperationCount(0);
            if (batchTimeoutRef.current) {
                clearTimeout(batchTimeoutRef.current);
                batchTimeoutRef.current = undefined;
            }
        }
    }, []);
    // Cleanup on unmount
    (0, _react.useEffect)(()=>{
        return ()=>{
            if (batchTimeoutRef.current) {
                clearTimeout(batchTimeoutRef.current);
            }
        };
    }, []);
    return {
        startBatch,
        addOperation,
        commitBatch,
        discardBatch,
        isBatching,
        batchOperationCount
    };
}
function useHistoryPersistence(undoRedoManager, storageKey = 'canvas-history') {
    const [autoSave, setAutoSave] = (0, _react.useState)(false);
    const [lastSaved, setLastSaved] = (0, _react.useState)(null);
    const saveHistory = (0, _react.useCallback)(()=>{
        try {
            const historyData = undoRedoManager.exportHistory();
            localStorage.setItem(storageKey, historyData);
            setLastSaved(new Date());
            return true;
        } catch (error) {
            console.error('Failed to save history:', error);
            return false;
        }
    }, [
        undoRedoManager,
        storageKey
    ]);
    const loadHistory = (0, _react.useCallback)(()=>{
        try {
            const historyData = localStorage.getItem(storageKey);
            if (historyData) {
                const success = undoRedoManager.importHistory(historyData);
                if (success) {
                    setLastSaved(new Date());
                }
                return success;
            }
            return false;
        } catch (error) {
            console.error('Failed to load history:', error);
            return false;
        }
    }, [
        undoRedoManager,
        storageKey
    ]);
    // Auto-save functionality
    (0, _react.useEffect)(()=>{
        if (!autoSave) return;
        const handleBeforeUnload = ()=>{
            saveHistory();
        };
        const autoSaveInterval = setInterval(()=>{
            saveHistory();
        }, 30000); // Save every 30 seconds
        window.addEventListener('beforeunload', handleBeforeUnload);
        return ()=>{
            clearInterval(autoSaveInterval);
            window.removeEventListener('beforeunload', handleBeforeUnload);
        };
    }, [
        autoSave,
        saveHistory
    ]);
    // Load history on mount
    (0, _react.useEffect)(()=>{
        loadHistory();
    }, [
        loadHistory
    ]);
    return {
        saveHistory,
        loadHistory,
        autoSave,
        setAutoSave,
        lastSaved
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL2hvb2tzL3VzZVVuZG9SZWRvLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuLy8gVW5kby9SZWRvIFJlYWN0IEhvb2tzXG4vLyBSZWFjdCBob29rcyBmb3IgbWFuYWdpbmcgdW5kby9yZWRvIG9wZXJhdGlvbnMgd2l0aCBrZXlib2FyZCBzaG9ydGN1dHNcblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU1hbmFnZWRDYW52YXMsIHR5cGUgTWFuYWdlZENhbnZhcyB9IGZyb20gJy4uL3Byb3ZpZGVycy9DYW52YXNQcm92aWRlcic7XG5pbXBvcnQge1xuICBVbmRvUmVkb01hbmFnZXIsXG4gIGNyZWF0ZVVuZG9SZWRvTWFuYWdlcixcbiAgT3BlcmF0aW9uVHlwZSxcbiAgdHlwZSBVbmRvUmVkb0NvbmZpZyxcbiAgdHlwZSBVbmRvUmVkb1N0YXRlLFxuICB0eXBlIE9wZXJhdGlvbixcbiAgdHlwZSBDb21wb3NpdGVPcGVyYXRpb24sXG4gIERFRkFVTFRfVU5ET19SRURPX0NPTkZJR1xufSBmcm9tICcuLi91dGlscy91bmRvUmVkb1N0YWNrJztcblxuLyoqXG4gKiBVbmRvL1JlZG8gaG9vayBvcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVW5kb1JlZG9PcHRpb25zIHtcbiAgLyoqIFVuZG8vUmVkbyBjb25maWd1cmF0aW9uICovXG4gIGNvbmZpZz86IFBhcnRpYWw8VW5kb1JlZG9Db25maWc+O1xuICAvKiogRW5hYmxlIGtleWJvYXJkIHNob3J0Y3V0cyAoQ3RybCtaLCBDdHJsK1kpICovXG4gIGVuYWJsZUtleWJvYXJkU2hvcnRjdXRzPzogYm9vbGVhbjtcbiAgLyoqIEN1c3RvbSBrZXlib2FyZCBzaG9ydGN1dHMgKi9cbiAga2V5Ym9hcmRTaG9ydGN1dHM/OiB7XG4gICAgdW5kbz86IHN0cmluZ1tdO1xuICAgIHJlZG8/OiBzdHJpbmdbXTtcbiAgfTtcbiAgLyoqIENhbGxiYWNrIHdoZW4gb3BlcmF0aW9uIGlzIGV4ZWN1dGVkICovXG4gIG9uT3BlcmF0aW9uRXhlY3V0ZWQ/OiAob3BlcmF0aW9uOiBPcGVyYXRpb24gfCBDb21wb3NpdGVPcGVyYXRpb24pID0+IHZvaWQ7XG4gIC8qKiBDYWxsYmFjayB3aGVuIHVuZG8gaXMgcGVyZm9ybWVkICovXG4gIG9uVW5kbz86IChvcGVyYXRpb246IE9wZXJhdGlvbiB8IENvbXBvc2l0ZU9wZXJhdGlvbikgPT4gdm9pZDtcbiAgLyoqIENhbGxiYWNrIHdoZW4gcmVkbyBpcyBwZXJmb3JtZWQgKi9cbiAgb25SZWRvPzogKG9wZXJhdGlvbjogT3BlcmF0aW9uIHwgQ29tcG9zaXRlT3BlcmF0aW9uKSA9PiB2b2lkO1xuICAvKiogQ2FsbGJhY2sgd2hlbiBoaXN0b3J5IGlzIGNsZWFyZWQgKi9cbiAgb25IaXN0b3J5Q2xlYXJlZD86ICgpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogRGVmYXVsdCBrZXlib2FyZCBzaG9ydGN1dHNcbiAqL1xuY29uc3QgREVGQVVMVF9TSE9SVENVVFMgPSB7XG4gIHVuZG86IFsnY3RybCt6JywgJ2NtZCt6J10sXG4gIHJlZG86IFsnY3RybCt5JywgJ2NtZCt5JywgJ2N0cmwrc2hpZnQreicsICdjbWQrc2hpZnQreiddXG59O1xuXG4vKipcbiAqIE1haW4gdW5kby9yZWRvIGhvb2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVVuZG9SZWRvKFxuICBjYW52YXNXaWR0aDogbnVtYmVyLFxuICBjYW52YXNIZWlnaHQ6IG51bWJlcixcbiAgY2FudmFzSWQ/OiBzdHJpbmcsXG4gIG9wdGlvbnM6IFVzZVVuZG9SZWRvT3B0aW9ucyA9IHt9XG4pOiB7XG4gIGNhbnZhczogTWFuYWdlZENhbnZhcztcbiAgbWFuYWdlcjogVW5kb1JlZG9NYW5hZ2VyO1xuICBzdGF0ZTogVW5kb1JlZG9TdGF0ZTtcbiAgY2FuVW5kbzogYm9vbGVhbjtcbiAgY2FuUmVkbzogYm9vbGVhbjtcbiAgdW5kbzogKCkgPT4gYm9vbGVhbjtcbiAgcmVkbzogKCkgPT4gYm9vbGVhbjtcbiAgZXhlY3V0ZU9wZXJhdGlvbjogKFxuICAgIHR5cGU6IE9wZXJhdGlvblR5cGUsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICBvcGVyYXRpb25GbjogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gICAgb3BlcmF0aW9uRGF0YT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIHN0YXJ0Q29tcG9zaXRlOiAoZGVzY3JpcHRpb246IHN0cmluZywgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4gc3RyaW5nO1xuICBlbmRDb21wb3NpdGU6ICgpID0+IHZvaWQ7XG4gIGp1bXBUb09wZXJhdGlvbjogKGluZGV4OiBudW1iZXIpID0+IGJvb2xlYW47XG4gIGNsZWFySGlzdG9yeTogKCkgPT4gdm9pZDtcbiAgZ2V0SGlzdG9yeTogKCkgPT4gKE9wZXJhdGlvbiB8IENvbXBvc2l0ZU9wZXJhdGlvbilbXTtcbiAgZ2V0T3BlcmF0aW9uOiAoaWQ6IHN0cmluZykgPT4gT3BlcmF0aW9uIHwgQ29tcG9zaXRlT3BlcmF0aW9uIHwgbnVsbDtcbiAgY2xlYW51cDogKHRhcmdldE1lbW9yeU1CPzogbnVtYmVyKSA9PiB2b2lkO1xuICBleHBvcnRIaXN0b3J5OiAoKSA9PiBzdHJpbmc7XG4gIGltcG9ydEhpc3Rvcnk6IChoaXN0b3J5RGF0YTogc3RyaW5nKSA9PiBib29sZWFuO1xuICB1cGRhdGVDb25maWc6IChuZXdDb25maWc6IFBhcnRpYWw8VW5kb1JlZG9Db25maWc+KSA9PiB2b2lkO1xufSB7XG4gIGNvbnN0IGNhbnZhcyA9IHVzZU1hbmFnZWRDYW52YXMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgY2FudmFzSWQpO1xuICBjb25zdCBtYW5hZ2VyUmVmID0gdXNlUmVmPFVuZG9SZWRvTWFuYWdlcj4oKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxVbmRvUmVkb1N0YXRlPih7XG4gICAgY3VycmVudEluZGV4OiAtMSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgICBjYW5VbmRvOiBmYWxzZSxcbiAgICBjYW5SZWRvOiBmYWxzZSxcbiAgICBtZW1vcnlVc2FnZTogMCxcbiAgICBzdGF0czoge1xuICAgICAgdG90YWxPcGVyYXRpb25zOiAwLFxuICAgICAgdW5kb0NvdW50OiAwLFxuICAgICAgcmVkb0NvdW50OiAwLFxuICAgICAgbWVtb3J5UGVha1VzYWdlOiAwLFxuICAgICAgbGFzdENsZWFudXA6IERhdGUubm93KClcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEluaXRpYWxpemUgbWFuYWdlclxuICBpZiAoIW1hbmFnZXJSZWYuY3VycmVudCkge1xuICAgIG1hbmFnZXJSZWYuY3VycmVudCA9IGNyZWF0ZVVuZG9SZWRvTWFuYWdlcihjYW52YXMsIG9wdGlvbnMuY29uZmlnKTtcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChtYW5hZ2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHNldFN0YXRlKG1hbmFnZXJSZWYuY3VycmVudC5nZXRTdGF0ZSgpKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBleGVjdXRlT3BlcmF0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHR5cGU6IE9wZXJhdGlvblR5cGUsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICBvcGVyYXRpb25GbjogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gICAgb3BlcmF0aW9uRGF0YT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBpZiAoIW1hbmFnZXJSZWYuY3VycmVudCkgdGhyb3cgbmV3IEVycm9yKCdNYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIFxuICAgIGNvbnN0IG9wZXJhdGlvbklkID0gYXdhaXQgbWFuYWdlclJlZi5jdXJyZW50LmV4ZWN1dGVPcGVyYXRpb24oXG4gICAgICB0eXBlLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBvcGVyYXRpb25GbixcbiAgICAgIG9wZXJhdGlvbkRhdGEsXG4gICAgICBtZXRhZGF0YVxuICAgICk7XG4gICAgXG4gICAgdXBkYXRlU3RhdGUoKTtcbiAgICBcbiAgICBjb25zdCBvcGVyYXRpb24gPSBtYW5hZ2VyUmVmLmN1cnJlbnQuZ2V0T3BlcmF0aW9uKG9wZXJhdGlvbklkKTtcbiAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICBvcHRpb25zLm9uT3BlcmF0aW9uRXhlY3V0ZWQ/LihvcGVyYXRpb24pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3BlcmF0aW9uSWQ7XG4gIH0sIFt1cGRhdGVTdGF0ZSwgb3B0aW9uc10pO1xuXG4gIGNvbnN0IHVuZG8gPSB1c2VDYWxsYmFjaygoKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFtYW5hZ2VyUmVmLmN1cnJlbnQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBjb25zdCBjdXJyZW50T3BlcmF0aW9uID0gc3RhdGUuY3VycmVudEluZGV4ID49IDAgXG4gICAgICA/IG1hbmFnZXJSZWYuY3VycmVudC5nZXRIaXN0b3J5KClbc3RhdGUuY3VycmVudEluZGV4XSBcbiAgICAgIDogbnVsbDtcbiAgICBcbiAgICBjb25zdCBzdWNjZXNzID0gbWFuYWdlclJlZi5jdXJyZW50LnVuZG8oKTtcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIGlmIChjdXJyZW50T3BlcmF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMub25VbmRvPy4oY3VycmVudE9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LCBbc3RhdGUuY3VycmVudEluZGV4LCB1cGRhdGVTdGF0ZSwgb3B0aW9uc10pO1xuXG4gIGNvbnN0IHJlZG8gPSB1c2VDYWxsYmFjaygoKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFtYW5hZ2VyUmVmLmN1cnJlbnQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBjb25zdCBuZXh0T3BlcmF0aW9uID0gc3RhdGUuY3VycmVudEluZGV4ICsgMSA8IHN0YXRlLm9wZXJhdGlvbnMubGVuZ3RoXG4gICAgICA/IHN0YXRlLm9wZXJhdGlvbnNbc3RhdGUuY3VycmVudEluZGV4ICsgMV1cbiAgICAgIDogbnVsbDtcbiAgICBcbiAgICBjb25zdCBzdWNjZXNzID0gbWFuYWdlclJlZi5jdXJyZW50LnJlZG8oKTtcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIGlmIChuZXh0T3BlcmF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMub25SZWRvPy4obmV4dE9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LCBbc3RhdGUuY3VycmVudEluZGV4LCBzdGF0ZS5vcGVyYXRpb25zLCB1cGRhdGVTdGF0ZSwgb3B0aW9uc10pO1xuXG4gIGNvbnN0IHN0YXJ0Q29tcG9zaXRlID0gdXNlQ2FsbGJhY2soKGRlc2NyaXB0aW9uOiBzdHJpbmcsIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcgPT4ge1xuICAgIGlmICghbWFuYWdlclJlZi5jdXJyZW50KSB0aHJvdyBuZXcgRXJyb3IoJ01hbmFnZXIgbm90IGluaXRpYWxpemVkJyk7XG4gICAgcmV0dXJuIG1hbmFnZXJSZWYuY3VycmVudC5zdGFydENvbXBvc2l0ZU9wZXJhdGlvbihkZXNjcmlwdGlvbiwgbWV0YWRhdGEpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZW5kQ29tcG9zaXRlID0gdXNlQ2FsbGJhY2soKCk6IHZvaWQgPT4ge1xuICAgIGlmICghbWFuYWdlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbWFuYWdlclJlZi5jdXJyZW50LmVuZENvbXBvc2l0ZU9wZXJhdGlvbigpO1xuICAgIHVwZGF0ZVN0YXRlKCk7XG4gIH0sIFt1cGRhdGVTdGF0ZV0pO1xuXG4gIGNvbnN0IGp1bXBUb09wZXJhdGlvbiA9IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFtYW5hZ2VyUmVmLmN1cnJlbnQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzdWNjZXNzID0gbWFuYWdlclJlZi5jdXJyZW50Lmp1bXBUb09wZXJhdGlvbihpbmRleCk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LCBbdXBkYXRlU3RhdGVdKTtcblxuICBjb25zdCBjbGVhckhpc3RvcnkgPSB1c2VDYWxsYmFjaygoKTogdm9pZCA9PiB7XG4gICAgaWYgKCFtYW5hZ2VyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBtYW5hZ2VyUmVmLmN1cnJlbnQuY2xlYXJIaXN0b3J5KCk7XG4gICAgdXBkYXRlU3RhdGUoKTtcbiAgICBvcHRpb25zLm9uSGlzdG9yeUNsZWFyZWQ/LigpO1xuICB9LCBbdXBkYXRlU3RhdGUsIG9wdGlvbnNdKTtcblxuICBjb25zdCBnZXRIaXN0b3J5ID0gdXNlQ2FsbGJhY2soKCk6IChPcGVyYXRpb24gfCBDb21wb3NpdGVPcGVyYXRpb24pW10gPT4ge1xuICAgIHJldHVybiBtYW5hZ2VyUmVmLmN1cnJlbnQ/LmdldEhpc3RvcnkoKSB8fCBbXTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGdldE9wZXJhdGlvbiA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKTogT3BlcmF0aW9uIHwgQ29tcG9zaXRlT3BlcmF0aW9uIHwgbnVsbCA9PiB7XG4gICAgcmV0dXJuIG1hbmFnZXJSZWYuY3VycmVudD8uZ2V0T3BlcmF0aW9uKGlkKSB8fCBudWxsO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY2xlYW51cCA9IHVzZUNhbGxiYWNrKCh0YXJnZXRNZW1vcnlNQj86IG51bWJlcik6IHZvaWQgPT4ge1xuICAgIGlmICghbWFuYWdlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbWFuYWdlclJlZi5jdXJyZW50LmNsZWFudXAodGFyZ2V0TWVtb3J5TUIpO1xuICAgIHVwZGF0ZVN0YXRlKCk7XG4gIH0sIFt1cGRhdGVTdGF0ZV0pO1xuXG4gIGNvbnN0IGV4cG9ydEhpc3RvcnkgPSB1c2VDYWxsYmFjaygoKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gbWFuYWdlclJlZi5jdXJyZW50Py5leHBvcnRIaXN0b3J5KCkgfHwgJyc7XG4gIH0sIFtdKTtcblxuICBjb25zdCBpbXBvcnRIaXN0b3J5ID0gdXNlQ2FsbGJhY2soKGhpc3RvcnlEYXRhOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBpZiAoIW1hbmFnZXJSZWYuY3VycmVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBtYW5hZ2VyUmVmLmN1cnJlbnQuaW1wb3J0SGlzdG9yeShoaXN0b3J5RGF0YSk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LCBbdXBkYXRlU3RhdGVdKTtcblxuICBjb25zdCB1cGRhdGVDb25maWcgPSB1c2VDYWxsYmFjaygobmV3Q29uZmlnOiBQYXJ0aWFsPFVuZG9SZWRvQ29uZmlnPik6IHZvaWQgPT4ge1xuICAgIGlmICghbWFuYWdlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbWFuYWdlclJlZi5jdXJyZW50LnVwZGF0ZUNvbmZpZyhuZXdDb25maWcpO1xuICAgIHVwZGF0ZVN0YXRlKCk7XG4gIH0sIFt1cGRhdGVTdGF0ZV0pO1xuXG4gIC8vIEtleWJvYXJkIHNob3J0Y3V0c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVLZXlib2FyZFNob3J0Y3V0cykgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2hvcnRjdXRzID0geyAuLi5ERUZBVUxUX1NIT1JUQ1VUUywgLi4ub3B0aW9ucy5rZXlib2FyZFNob3J0Y3V0cyB9O1xuXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ID8gJ2N0cmwrJyA6ICcnfSR7ZXZlbnQuc2hpZnRLZXkgPyAnc2hpZnQrJyA6ICcnfSR7ZXZlbnQua2V5LnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgIGNvbnN0IGNtZEtleSA9IGAke2V2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSA/ICdjbWQrJyA6ICcnfSR7ZXZlbnQuc2hpZnRLZXkgPyAnc2hpZnQrJyA6ICcnfSR7ZXZlbnQua2V5LnRvTG93ZXJDYXNlKCl9YDtcblxuICAgICAgaWYgKHNob3J0Y3V0cy51bmRvLmluY2x1ZGVzKGtleSkgfHwgc2hvcnRjdXRzLnVuZG8uaW5jbHVkZXMoY21kS2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB1bmRvKCk7XG4gICAgICB9IGVsc2UgaWYgKHNob3J0Y3V0cy5yZWRvLmluY2x1ZGVzKGtleSkgfHwgc2hvcnRjdXRzLnJlZG8uaW5jbHVkZXMoY21kS2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZWRvKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICB9LCBbb3B0aW9ucy5lbmFibGVLZXlib2FyZFNob3J0Y3V0cywgb3B0aW9ucy5rZXlib2FyZFNob3J0Y3V0cywgdW5kbywgcmVkb10pO1xuXG4gIC8vIFVwZGF0ZSBzdGF0ZSB3aGVuIG9wZXJhdGlvbnMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXBkYXRlU3RhdGUoKTtcbiAgfSwgW3VwZGF0ZVN0YXRlXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjYW52YXMsXG4gICAgbWFuYWdlcjogbWFuYWdlclJlZi5jdXJyZW50LFxuICAgIHN0YXRlLFxuICAgIGNhblVuZG86IHN0YXRlLmNhblVuZG8sXG4gICAgY2FuUmVkbzogc3RhdGUuY2FuUmVkbyxcbiAgICB1bmRvLFxuICAgIHJlZG8sXG4gICAgZXhlY3V0ZU9wZXJhdGlvbixcbiAgICBzdGFydENvbXBvc2l0ZSxcbiAgICBlbmRDb21wb3NpdGUsXG4gICAganVtcFRvT3BlcmF0aW9uLFxuICAgIGNsZWFySGlzdG9yeSxcbiAgICBnZXRIaXN0b3J5LFxuICAgIGdldE9wZXJhdGlvbixcbiAgICBjbGVhbnVwLFxuICAgIGV4cG9ydEhpc3RvcnksXG4gICAgaW1wb3J0SGlzdG9yeSxcbiAgICB1cGRhdGVDb25maWdcbiAgfTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBzaW1wbGUgdW5kby9yZWRvIG9wZXJhdGlvbnMgd2l0aG91dCBmdWxsIHN0YXRlIG1hbmFnZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNpbXBsZVVuZG9SZWRvPFQ+KFxuICBpbml0aWFsU3RhdGU6IFQsXG4gIG1heEhpc3RvcnlTaXplOiBudW1iZXIgPSA1MFxuKToge1xuICBzdGF0ZTogVDtcbiAgY2FuVW5kbzogYm9vbGVhbjtcbiAgY2FuUmVkbzogYm9vbGVhbjtcbiAgdW5kbzogKCkgPT4gdm9pZDtcbiAgcmVkbzogKCkgPT4gdm9pZDtcbiAgcHVzaFN0YXRlOiAobmV3U3RhdGU6IFQpID0+IHZvaWQ7XG4gIGNsZWFySGlzdG9yeTogKCkgPT4gdm9pZDtcbiAgZ2V0SGlzdG9yeTogKCkgPT4gVFtdO1xufSB7XG4gIGNvbnN0IFtoaXN0b3J5LCBzZXRIaXN0b3J5XSA9IHVzZVN0YXRlPFRbXT4oW2luaXRpYWxTdGF0ZV0pO1xuICBjb25zdCBbY3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlU3RhdGUoMCk7XG5cbiAgY29uc3QgY2FuVW5kbyA9IGN1cnJlbnRJbmRleCA+IDA7XG4gIGNvbnN0IGNhblJlZG8gPSBjdXJyZW50SW5kZXggPCBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gIGNvbnN0IHN0YXRlID0gaGlzdG9yeVtjdXJyZW50SW5kZXhdO1xuXG4gIGNvbnN0IHVuZG8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGNhblVuZG8pIHtcbiAgICAgIHNldEN1cnJlbnRJbmRleChwcmV2ID0+IHByZXYgLSAxKTtcbiAgICB9XG4gIH0sIFtjYW5VbmRvXSk7XG5cbiAgY29uc3QgcmVkbyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoY2FuUmVkbykge1xuICAgICAgc2V0Q3VycmVudEluZGV4KHByZXYgPT4gcHJldiArIDEpO1xuICAgIH1cbiAgfSwgW2NhblJlZG9dKTtcblxuICBjb25zdCBwdXNoU3RhdGUgPSB1c2VDYWxsYmFjaygobmV3U3RhdGU6IFQpID0+IHtcbiAgICBzZXRIaXN0b3J5KHByZXYgPT4ge1xuICAgICAgLy8gUmVtb3ZlIGFueSBzdGF0ZXMgYWZ0ZXIgY3VycmVudCBpbmRleFxuICAgICAgY29uc3QgbmV3SGlzdG9yeSA9IHByZXYuc2xpY2UoMCwgY3VycmVudEluZGV4ICsgMSk7XG4gICAgICBuZXdIaXN0b3J5LnB1c2gobmV3U3RhdGUpO1xuICAgICAgXG4gICAgICAvLyBFbmZvcmNlIG1heCBoaXN0b3J5IHNpemVcbiAgICAgIGlmIChuZXdIaXN0b3J5Lmxlbmd0aCA+IG1heEhpc3RvcnlTaXplKSB7XG4gICAgICAgIG5ld0hpc3Rvcnkuc3BsaWNlKDAsIG5ld0hpc3RvcnkubGVuZ3RoIC0gbWF4SGlzdG9yeVNpemUpO1xuICAgICAgICBzZXRDdXJyZW50SW5kZXgobWF4SGlzdG9yeVNpemUgLSAxKTtcbiAgICAgICAgcmV0dXJuIG5ld0hpc3Rvcnk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldEN1cnJlbnRJbmRleChuZXdIaXN0b3J5Lmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIG5ld0hpc3Rvcnk7XG4gICAgfSk7XG4gIH0sIFtjdXJyZW50SW5kZXgsIG1heEhpc3RvcnlTaXplXSk7XG5cbiAgY29uc3QgY2xlYXJIaXN0b3J5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEhpc3RvcnkoW3N0YXRlXSk7XG4gICAgc2V0Q3VycmVudEluZGV4KDApO1xuICB9LCBbc3RhdGVdKTtcblxuICBjb25zdCBnZXRIaXN0b3J5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBbLi4uaGlzdG9yeV07XG4gIH0sIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZSxcbiAgICBjYW5VbmRvLFxuICAgIGNhblJlZG8sXG4gICAgdW5kbyxcbiAgICByZWRvLFxuICAgIHB1c2hTdGF0ZSxcbiAgICBjbGVhckhpc3RvcnksXG4gICAgZ2V0SGlzdG9yeVxuICB9O1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIG9wZXJhdGlvbiBiYXRjaGluZyBhbmQgYXRvbWljIGNvbW1pdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU9wZXJhdGlvbkJhdGNoaW5nKFxuICB1bmRvUmVkb01hbmFnZXI6IFVuZG9SZWRvTWFuYWdlcixcbiAgYXV0b0NvbW1pdERlbGF5OiBudW1iZXIgPSAxMDAwXG4pOiB7XG4gIHN0YXJ0QmF0Y2g6IChkZXNjcmlwdGlvbjogc3RyaW5nKSA9PiBzdHJpbmc7XG4gIGFkZE9wZXJhdGlvbjogKFxuICAgIHR5cGU6IE9wZXJhdGlvblR5cGUsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICBvcGVyYXRpb25GbjogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gICAgb3BlcmF0aW9uRGF0YT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICkgPT4gUHJvbWlzZTxzdHJpbmc+O1xuICBjb21taXRCYXRjaDogKCkgPT4gdm9pZDtcbiAgZGlzY2FyZEJhdGNoOiAoKSA9PiB2b2lkO1xuICBpc0JhdGNoaW5nOiBib29sZWFuO1xuICBiYXRjaE9wZXJhdGlvbkNvdW50OiBudW1iZXI7XG59IHtcbiAgY29uc3QgW2lzQmF0Y2hpbmcsIHNldElzQmF0Y2hpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYmF0Y2hPcGVyYXRpb25Db3VudCwgc2V0QmF0Y2hPcGVyYXRpb25Db3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgYmF0Y2hUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0PigpO1xuICBjb25zdCBjdXJyZW50QmF0Y2hSZWYgPSB1c2VSZWY8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3Qgc3RhcnRCYXRjaCA9IHVzZUNhbGxiYWNrKChkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBpZiAoY3VycmVudEJhdGNoUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbW1pdEJhdGNoKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYmF0Y2hJZCA9IHVuZG9SZWRvTWFuYWdlci5zdGFydENvbXBvc2l0ZU9wZXJhdGlvbihkZXNjcmlwdGlvbik7XG4gICAgY3VycmVudEJhdGNoUmVmLmN1cnJlbnQgPSBiYXRjaElkO1xuICAgIHNldElzQmF0Y2hpbmcodHJ1ZSk7XG4gICAgc2V0QmF0Y2hPcGVyYXRpb25Db3VudCgwKTtcblxuICAgIC8vIEF1dG8tY29tbWl0IGFmdGVyIGRlbGF5XG4gICAgaWYgKGJhdGNoVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQoYmF0Y2hUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgICBcbiAgICBiYXRjaFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29tbWl0QmF0Y2goKTtcbiAgICB9LCBhdXRvQ29tbWl0RGVsYXkpO1xuXG4gICAgcmV0dXJuIGJhdGNoSWQ7XG4gIH0sIFthdXRvQ29tbWl0RGVsYXldKTtcblxuICBjb25zdCBhZGRPcGVyYXRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgdHlwZTogT3BlcmF0aW9uVHlwZSxcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgIG9wZXJhdGlvbkZuOiAoKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPixcbiAgICBvcGVyYXRpb25EYXRhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBvcGVyYXRpb25JZCA9IGF3YWl0IHVuZG9SZWRvTWFuYWdlci5leGVjdXRlT3BlcmF0aW9uKFxuICAgICAgdHlwZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgb3BlcmF0aW9uRm4sXG4gICAgICBvcGVyYXRpb25EYXRhXG4gICAgKTtcblxuICAgIHNldEJhdGNoT3BlcmF0aW9uQ291bnQocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgcmV0dXJuIG9wZXJhdGlvbklkO1xuICB9LCBbdW5kb1JlZG9NYW5hZ2VyXSk7XG5cbiAgY29uc3QgY29tbWl0QmF0Y2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRCYXRjaFJlZi5jdXJyZW50KSB7XG4gICAgICB1bmRvUmVkb01hbmFnZXIuZW5kQ29tcG9zaXRlT3BlcmF0aW9uKCk7XG4gICAgICBjdXJyZW50QmF0Y2hSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzZXRJc0JhdGNoaW5nKGZhbHNlKTtcbiAgICAgIHNldEJhdGNoT3BlcmF0aW9uQ291bnQoMCk7XG5cbiAgICAgIGlmIChiYXRjaFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoYmF0Y2hUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBiYXRjaFRpbWVvdXRSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFt1bmRvUmVkb01hbmFnZXJdKTtcblxuICBjb25zdCBkaXNjYXJkQmF0Y2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRCYXRjaFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBOb3RlOiBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSdkIG5lZWQgdG8gcmV2ZXJ0IG9wZXJhdGlvbnNcbiAgICAgIC8vIEZvciBub3csIHdlIGp1c3QgY2xlYXIgdGhlIGJhdGNoIHN0YXRlXG4gICAgICBjdXJyZW50QmF0Y2hSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzZXRJc0JhdGNoaW5nKGZhbHNlKTtcbiAgICAgIHNldEJhdGNoT3BlcmF0aW9uQ291bnQoMCk7XG5cbiAgICAgIGlmIChiYXRjaFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoYmF0Y2hUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBiYXRjaFRpbWVvdXRSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBDbGVhbnVwIG9uIHVubW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGJhdGNoVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChiYXRjaFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnRCYXRjaCxcbiAgICBhZGRPcGVyYXRpb24sXG4gICAgY29tbWl0QmF0Y2gsXG4gICAgZGlzY2FyZEJhdGNoLFxuICAgIGlzQmF0Y2hpbmcsXG4gICAgYmF0Y2hPcGVyYXRpb25Db3VudFxuICB9O1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGhpc3RvcnkgcGVyc2lzdGVuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUhpc3RvcnlQZXJzaXN0ZW5jZShcbiAgdW5kb1JlZG9NYW5hZ2VyOiBVbmRvUmVkb01hbmFnZXIsXG4gIHN0b3JhZ2VLZXk6IHN0cmluZyA9ICdjYW52YXMtaGlzdG9yeSdcbik6IHtcbiAgc2F2ZUhpc3Rvcnk6ICgpID0+IGJvb2xlYW47XG4gIGxvYWRIaXN0b3J5OiAoKSA9PiBib29sZWFuO1xuICBhdXRvU2F2ZTogYm9vbGVhbjtcbiAgc2V0QXV0b1NhdmU6IChlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICBsYXN0U2F2ZWQ6IERhdGUgfCBudWxsO1xufSB7XG4gIGNvbnN0IFthdXRvU2F2ZSwgc2V0QXV0b1NhdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbbGFzdFNhdmVkLCBzZXRMYXN0U2F2ZWRdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IHNhdmVIaXN0b3J5ID0gdXNlQ2FsbGJhY2soKCk6IGJvb2xlYW4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoaXN0b3J5RGF0YSA9IHVuZG9SZWRvTWFuYWdlci5leHBvcnRIaXN0b3J5KCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBoaXN0b3J5RGF0YSk7XG4gICAgICBzZXRMYXN0U2F2ZWQobmV3IERhdGUoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBbdW5kb1JlZG9NYW5hZ2VyLCBzdG9yYWdlS2V5XSk7XG5cbiAgY29uc3QgbG9hZEhpc3RvcnkgPSB1c2VDYWxsYmFjaygoKTogYm9vbGVhbiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhpc3RvcnlEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICBpZiAoaGlzdG9yeURhdGEpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHVuZG9SZWRvTWFuYWdlci5pbXBvcnRIaXN0b3J5KGhpc3RvcnlEYXRhKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRMYXN0U2F2ZWQobmV3IERhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgW3VuZG9SZWRvTWFuYWdlciwgc3RvcmFnZUtleV0pO1xuXG4gIC8vIEF1dG8tc2F2ZSBmdW5jdGlvbmFsaXR5XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhdXRvU2F2ZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgaGFuZGxlQmVmb3JlVW5sb2FkID0gKCkgPT4ge1xuICAgICAgc2F2ZUhpc3RvcnkoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXV0b1NhdmVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNhdmVIaXN0b3J5KCk7XG4gICAgfSwgMzAwMDApOyAvLyBTYXZlIGV2ZXJ5IDMwIHNlY29uZHNcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBoYW5kbGVCZWZvcmVVbmxvYWQpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1NhdmVJbnRlcnZhbCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgaGFuZGxlQmVmb3JlVW5sb2FkKTtcbiAgICB9O1xuICB9LCBbYXV0b1NhdmUsIHNhdmVIaXN0b3J5XSk7XG5cbiAgLy8gTG9hZCBoaXN0b3J5IG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZEhpc3RvcnkoKTtcbiAgfSwgW2xvYWRIaXN0b3J5XSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzYXZlSGlzdG9yeSxcbiAgICBsb2FkSGlzdG9yeSxcbiAgICBhdXRvU2F2ZSxcbiAgICBzZXRBdXRvU2F2ZSxcbiAgICBsYXN0U2F2ZWRcbiAgfTtcbn0iXSwibmFtZXMiOlsidXNlSGlzdG9yeVBlcnNpc3RlbmNlIiwidXNlT3BlcmF0aW9uQmF0Y2hpbmciLCJ1c2VTaW1wbGVVbmRvUmVkbyIsInVzZVVuZG9SZWRvIiwiREVGQVVMVF9TSE9SVENVVFMiLCJ1bmRvIiwicmVkbyIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiY2FudmFzSWQiLCJvcHRpb25zIiwiY2FudmFzIiwidXNlTWFuYWdlZENhbnZhcyIsIm1hbmFnZXJSZWYiLCJ1c2VSZWYiLCJzdGF0ZSIsInNldFN0YXRlIiwidXNlU3RhdGUiLCJjdXJyZW50SW5kZXgiLCJvcGVyYXRpb25zIiwiY2FuVW5kbyIsImNhblJlZG8iLCJtZW1vcnlVc2FnZSIsInN0YXRzIiwidG90YWxPcGVyYXRpb25zIiwidW5kb0NvdW50IiwicmVkb0NvdW50IiwibWVtb3J5UGVha1VzYWdlIiwibGFzdENsZWFudXAiLCJEYXRlIiwibm93IiwiY3VycmVudCIsImNyZWF0ZVVuZG9SZWRvTWFuYWdlciIsImNvbmZpZyIsInVwZGF0ZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJnZXRTdGF0ZSIsImV4ZWN1dGVPcGVyYXRpb24iLCJ0eXBlIiwiZGVzY3JpcHRpb24iLCJvcGVyYXRpb25GbiIsIm9wZXJhdGlvbkRhdGEiLCJtZXRhZGF0YSIsIkVycm9yIiwib3BlcmF0aW9uSWQiLCJvcGVyYXRpb24iLCJnZXRPcGVyYXRpb24iLCJvbk9wZXJhdGlvbkV4ZWN1dGVkIiwiY3VycmVudE9wZXJhdGlvbiIsImdldEhpc3RvcnkiLCJzdWNjZXNzIiwib25VbmRvIiwibmV4dE9wZXJhdGlvbiIsImxlbmd0aCIsIm9uUmVkbyIsInN0YXJ0Q29tcG9zaXRlIiwic3RhcnRDb21wb3NpdGVPcGVyYXRpb24iLCJlbmRDb21wb3NpdGUiLCJlbmRDb21wb3NpdGVPcGVyYXRpb24iLCJqdW1wVG9PcGVyYXRpb24iLCJpbmRleCIsImNsZWFySGlzdG9yeSIsIm9uSGlzdG9yeUNsZWFyZWQiLCJpZCIsImNsZWFudXAiLCJ0YXJnZXRNZW1vcnlNQiIsImV4cG9ydEhpc3RvcnkiLCJpbXBvcnRIaXN0b3J5IiwiaGlzdG9yeURhdGEiLCJ1cGRhdGVDb25maWciLCJuZXdDb25maWciLCJ1c2VFZmZlY3QiLCJlbmFibGVLZXlib2FyZFNob3J0Y3V0cyIsInNob3J0Y3V0cyIsImtleWJvYXJkU2hvcnRjdXRzIiwiaGFuZGxlS2V5RG93biIsImV2ZW50Iiwia2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInRvTG93ZXJDYXNlIiwiY21kS2V5IiwiaW5jbHVkZXMiLCJwcmV2ZW50RGVmYXVsdCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtYW5hZ2VyIiwiaW5pdGlhbFN0YXRlIiwibWF4SGlzdG9yeVNpemUiLCJoaXN0b3J5Iiwic2V0SGlzdG9yeSIsInNldEN1cnJlbnRJbmRleCIsInByZXYiLCJwdXNoU3RhdGUiLCJuZXdTdGF0ZSIsIm5ld0hpc3RvcnkiLCJzbGljZSIsInB1c2giLCJzcGxpY2UiLCJ1bmRvUmVkb01hbmFnZXIiLCJhdXRvQ29tbWl0RGVsYXkiLCJpc0JhdGNoaW5nIiwic2V0SXNCYXRjaGluZyIsImJhdGNoT3BlcmF0aW9uQ291bnQiLCJzZXRCYXRjaE9wZXJhdGlvbkNvdW50IiwiYmF0Y2hUaW1lb3V0UmVmIiwiY3VycmVudEJhdGNoUmVmIiwic3RhcnRCYXRjaCIsImNvbW1pdEJhdGNoIiwiYmF0Y2hJZCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhZGRPcGVyYXRpb24iLCJ1bmRlZmluZWQiLCJkaXNjYXJkQmF0Y2giLCJzdG9yYWdlS2V5IiwiYXV0b1NhdmUiLCJzZXRBdXRvU2F2ZSIsImxhc3RTYXZlZCIsInNldExhc3RTYXZlZCIsInNhdmVIaXN0b3J5IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImVycm9yIiwiY29uc29sZSIsImxvYWRIaXN0b3J5IiwiZ2V0SXRlbSIsImhhbmRsZUJlZm9yZVVubG9hZCIsImF1dG9TYXZlSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsIndpbmRvdyIsImNsZWFySW50ZXJ2YWwiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7SUFzZGdCQSxxQkFBcUI7ZUFBckJBOztJQS9HQUMsb0JBQW9CO2VBQXBCQTs7SUExRUFDLGlCQUFpQjtlQUFqQkE7O0lBek9BQyxXQUFXO2VBQVhBOzs7dUJBL0N5QztnQ0FDSjsrQkFVOUM7QUF5QlA7O0NBRUMsR0FDRCxNQUFNQyxvQkFBb0I7SUFDeEJDLE1BQU07UUFBQztRQUFVO0tBQVE7SUFDekJDLE1BQU07UUFBQztRQUFVO1FBQVM7UUFBZ0I7S0FBYztBQUMxRDtBQUtPLFNBQVNILFlBQ2RJLFdBQW1CLEVBQ25CQyxZQUFvQixFQUNwQkMsUUFBaUIsRUFDakJDLFVBQThCLENBQUMsQ0FBQztJQTJCaEMsTUFBTUMsU0FBU0MsSUFBQUEsZ0NBQWdCLEVBQUNMLGFBQWFDLGNBQWNDO0lBQzNELE1BQU1JLGFBQWFDLElBQUFBLGFBQU07SUFDekIsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdDLElBQUFBLGVBQVEsRUFBZ0I7UUFDaERDLGNBQWMsQ0FBQztRQUNmQyxZQUFZLEVBQUU7UUFDZEMsU0FBUztRQUNUQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsT0FBTztZQUNMQyxpQkFBaUI7WUFDakJDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxpQkFBaUI7WUFDakJDLGFBQWFDLEtBQUtDLEdBQUc7UUFDdkI7SUFDRjtJQUVBLHFC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