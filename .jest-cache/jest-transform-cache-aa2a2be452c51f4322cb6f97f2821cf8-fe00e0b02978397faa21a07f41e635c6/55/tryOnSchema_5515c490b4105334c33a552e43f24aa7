8e1a72fa07c2f486d96a829f6f78c3c0
/**
 * Try-On Service Schema Definitions
 * 
 * Provides compile-time and runtime contracts for inputs and outputs of the OpenAI
 * Images Edit wrapper. These schemas ensure type safety and validate base64 image data.
 * 
 * @see https://platform.openai.com/docs/api-reference/images/edit
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Base64Str: function() {
        return Base64Str;
    },
    TryOnParamsSchema: function() {
        return TryOnParamsSchema;
    },
    TryOnResultSchema: function() {
        return TryOnResultSchema;
    },
    normalizeBase64: function() {
        return normalizeBase64;
    }
});
const _zod = require("zod");
/**
 * Base64 regex pattern for validating image data
 * Matches both data URLs (data:image/...;base64,...) and pure base64 strings
 * with optional padding
 */ const base64Regex = /^(?:data:image\/[a-zA-Z]+;base64,)?(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const normalizeBase64 = (base64String)=>{
    // If it's a data URL, extract the base64 part
    if (base64String.startsWith('data:image/')) {
        const commaIndex = base64String.indexOf(',');
        if (commaIndex !== -1) {
            return base64String.substring(commaIndex + 1);
        }
    }
    // If it's already pure base64, return as is
    return base64String;
};
const Base64Str = _zod.z.string().regex(base64Regex, 'Invalid base64 image data');
const TryOnParamsSchema = _zod.z.object({
    modelImage: Base64Str,
    apparelImages: _zod.z.array(Base64Str).min(1, 'At least one apparel image is required')
});
const TryOnResultSchema = _zod.z.object({
    imgGenerated: Base64Str
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2xpYi90cnlPblNjaGVtYS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyeS1PbiBTZXJ2aWNlIFNjaGVtYSBEZWZpbml0aW9uc1xuICogXG4gKiBQcm92aWRlcyBjb21waWxlLXRpbWUgYW5kIHJ1bnRpbWUgY29udHJhY3RzIGZvciBpbnB1dHMgYW5kIG91dHB1dHMgb2YgdGhlIE9wZW5BSVxuICogSW1hZ2VzIEVkaXQgd3JhcHBlci4gVGhlc2Ugc2NoZW1hcyBlbnN1cmUgdHlwZSBzYWZldHkgYW5kIHZhbGlkYXRlIGJhc2U2NCBpbWFnZSBkYXRhLlxuICogXG4gKiBAc2VlIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvaW1hZ2VzL2VkaXRcbiAqL1xuXG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcblxuLyoqXG4gKiBCYXNlNjQgcmVnZXggcGF0dGVybiBmb3IgdmFsaWRhdGluZyBpbWFnZSBkYXRhXG4gKiBNYXRjaGVzIGJvdGggZGF0YSBVUkxzIChkYXRhOmltYWdlLy4uLjtiYXNlNjQsLi4uKSBhbmQgcHVyZSBiYXNlNjQgc3RyaW5nc1xuICogd2l0aCBvcHRpb25hbCBwYWRkaW5nXG4gKi9cbmNvbnN0IGJhc2U2NFJlZ2V4ID0gL14oPzpkYXRhOmltYWdlXFwvW2EtekEtWl0rO2Jhc2U2NCwpPyg/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC87XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBub3JtYWxpemUgYmFzZTY0IHN0cmluZ3NcbiAqIFN0cmlwcyBkYXRhIFVSTCBwcmVmaXggaWYgcHJlc2VudCwgcmV0dXJucyBwdXJlIGJhc2U2NFxuICogXG4gKiBAcGFyYW0gYmFzZTY0U3RyaW5nIC0gVGhlIGJhc2U2NCBzdHJpbmcgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyBQdXJlIGJhc2U2NCBzdHJpbmcgd2l0aG91dCBkYXRhIFVSTCBwcmVmaXhcbiAqIFxuICogQGV4YW1wbGVcbiAqIC8vIElucHV0OiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFEVWxFUVZSNDJtTmtZUGhmRHdBQ2h3R0E2MGU2a2dBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuICogLy8gT3V0cHV0OiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlI0Mm1Oa1lQaGZEd0FDaHdHQTYwZTZrZ0FBQUFCSlJVNUVya0pnZ2c9PVwiXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVCYXNlNjQgPSAoYmFzZTY0U3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAvLyBJZiBpdCdzIGEgZGF0YSBVUkwsIGV4dHJhY3QgdGhlIGJhc2U2NCBwYXJ0XG4gIGlmIChiYXNlNjRTdHJpbmcuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS8nKSkge1xuICAgIGNvbnN0IGNvbW1hSW5kZXggPSBiYXNlNjRTdHJpbmcuaW5kZXhPZignLCcpO1xuICAgIGlmIChjb21tYUluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGJhc2U2NFN0cmluZy5zdWJzdHJpbmcoY29tbWFJbmRleCArIDEpO1xuICAgIH1cbiAgfVxuICAvLyBJZiBpdCdzIGFscmVhZHkgcHVyZSBiYXNlNjQsIHJldHVybiBhcyBpc1xuICByZXR1cm4gYmFzZTY0U3RyaW5nO1xufTtcblxuLyoqXG4gKiBab2Qgc2NoZW1hIGZvciB2YWxpZGF0aW5nIGJhc2U2NC1lbmNvZGVkIGltYWdlIHN0cmluZ3NcbiAqIEFjY2VwdHMgYm90aCBkYXRhIFVSTHMgYW5kIHB1cmUgYmFzZTY0IHN0cmluZ3NcbiAqIFxuICogQGV4YW1wbGVcbiAqIC8vIFZhbGlkIGRhdGEgVVJMOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFEVWxFUVZSNDJtTmtZUGhmRHdBQ2h3R0E2MGU2a2dBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuICogLy8gVmFsaWQgcHVyZSBiYXNlNjQ6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBRFVsRVFWUjQybU5rWVBoZkR3QUNod0dBNjBlNmtnQUFBQUJKUlU1RXJrSmdnZz09XCJcbiAqIC8vIEludmFsaWQ6IFwibm90LWJhc2U2NC1kYXRhXCJcbiAqL1xuZXhwb3J0IGNvbnN0IEJhc2U2NFN0ciA9IHouc3RyaW5nKCkucmVnZXgoYmFzZTY0UmVnZXgsICdJbnZhbGlkIGJhc2U2NCBpbWFnZSBkYXRhJyk7XG5cbi8qKlxuICogU2NoZW1hIGZvciB0cnktb24gc2VydmljZSBpbnB1dCBwYXJhbWV0ZXJzXG4gKiBcbiAqIEBleGFtcGxlXG4gKiB7XG4gKiAgIG1vZGVsSW1hZ2U6IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlI0Mm1Oa1lQaGZEd0FDaHdHQTYwZTZrZ0FBQUFCSlJVNUVya0pnZ2c9PVwiLFxuICogICBhcHBhcmVsSW1hZ2VzOiBbXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBRFVsRVFWUjQybU5rWVBoZkR3QUNod0dBNjBlNmtnQUFBQUJKUlU1RXJrSmdnZz09XCJdXG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCBUcnlPblBhcmFtc1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgbW9kZWxJbWFnZTogQmFzZTY0U3RyLFxuICBhcHBhcmVsSW1hZ2VzOiB6LmFycmF5KEJhc2U2NFN0cikubWluKDEsICdBdCBsZWFzdCBvbmUgYXBwYXJlbCBpbWFnZSBpcyByZXF1aXJlZCcpXG59KTtcblxuLyoqXG4gKiBTY2hlbWEgZm9yIHRyeS1vbiBzZXJ2aWNlIG91dHB1dCByZXN1bHRcbiAqIFxuICogQGV4YW1wbGVcbiAqIHtcbiAqICAgaW1nR2VuZXJhdGVkOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlI0Mm1Oa1lQaGZEd0FDaHdHQTYwZTZrZ0FBQUFCSlJVNUVya0pnZ2c9PVwiXG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCBUcnlPblJlc3VsdFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgaW1nR2VuZXJhdGVkOiBCYXNlNjRTdHJcbn0pO1xuXG4vKipcbiAqIFR5cGVTY3JpcHQgdHlwZSBmb3IgdHJ5LW9uIHNlcnZpY2UgaW5wdXQgcGFyYW1ldGVyc1xuICogSW5mZXJyZWQgZnJvbSBUcnlPblBhcmFtc1NjaGVtYSBmb3IgY29tcGlsZS10aW1lIHR5cGUgc2FmZXR5XG4gKi9cbmV4cG9ydCB0eXBlIFRyeU9uUGFyYW1zID0gei5pbmZlcjx0eXBlb2YgVHJ5T25QYXJhbXNTY2hlbWE+O1xuXG4vKipcbiAqIFR5cGVTY3JpcHQgdHlwZSBmb3IgdHJ5LW9uIHNlcnZpY2Ugb3V0cHV0IHJlc3VsdFxuICogSW5mZXJyZWQgZnJvbSBUcnlPblJlc3VsdFNjaGVtYSBmb3IgY29tcGlsZS10aW1lIHR5cGUgc2FmZXR5XG4gKi9cbmV4cG9ydCB0eXBlIFRyeU9uUmVzdWx0ID0gei5pbmZlcjx0eXBlb2YgVHJ5T25SZXN1bHRTY2hlbWE+OyAiXSwibmFtZXMiOlsiQmFzZTY0U3RyIiwiVHJ5T25QYXJhbXNTY2hlbWEiLCJUcnlPblJlc3VsdFNjaGVtYSIsIm5vcm1hbGl6ZUJhc2U2NCIsImJhc2U2NFJlZ2V4IiwiYmFzZTY0U3RyaW5nIiwic3RhcnRzV2l0aCIsImNvbW1hSW5kZXgiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwieiIsInN0cmluZyIsInJlZ2V4Iiwib2JqZWN0IiwibW9kZWxJbWFnZSIsImFwcGFyZWxJbWFnZXMiLCJhcnJheSIsIm1pbiIsImltZ0dlbmVyYXRlZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQzs7Ozs7Ozs7Ozs7SUEyQ1lBLFNBQVM7ZUFBVEE7O0lBV0FDLGlCQUFpQjtlQUFqQkE7O0lBYUFDLGlCQUFpQjtlQUFqQkE7O0lBN0NBQyxlQUFlO2VBQWZBOzs7cUJBcEJLO0FBRWxCOzs7O0NBSUMsR0FDRCxNQUFNQyxjQUFjO0FBYWIsTUFBTUQsa0JBQWtCLENBQUNFO0lBQzlCLDhDQUE4QztJQUM5QyxJQUFJQSxhQUFhQyxVQUFVLENBQUMsZ0JBQWdCO1FBQzFDLE1BQU1DLGFBQWFGLGFBQWFHLE9BQU8sQ0FBQztRQUN4QyxJQUFJRCxlQUFlLENBQUMsR0FBRztZQUNyQixPQUFPRixhQUFhSSxTQUFTLENBQUNGLGFBQWE7UUFDN0M7SUFDRjtJQUNBLDRDQUE0QztJQUM1QyxPQUFPRjtBQUNUO0FBV08sTUFBTUwsWUFBWVUsTUFBQyxDQUFDQyxNQUFNLEdBQUdDLEtBQUssQ0FBQ1IsYUFBYTtBQVdoRCxNQUFNSCxvQkFBb0JTLE1BQUMsQ0FBQ0csTUFBTSxDQUFDO0lBQ3hDQyxZQUFZZDtJQUNaZSxlQUFlTCxNQUFDLENBQUNNLEtBQUssQ0FBQ2hCLFdBQVdpQixHQUFHLENBQUMsR0FBRztBQUMzQztBQVVPLE1BQU1mLG9CQUFvQlEsTUFBQyxDQUFDRyxNQUFNLENBQUM7SUFDeENLLGNBQWNsQjtBQUNoQiJ9