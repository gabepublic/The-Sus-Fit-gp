b2c492ebf28562ebff3c837b16220844
/**
 * @jest-environment jsdom
 */ "use strict";
// Mock image processing utilities
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        processImageForTryon: jest.fn().mockImplementation((file, options)=>{
            return Promise.resolve({
                processedImage: 'data:image/jpeg;base64,processed-image-data',
                originalSize: 1024,
                processedSize: 512,
                compressionRatio: 0.5,
                processingTime: 100,
                dimensions: {
                    width: 1024,
                    height: 1536
                }
            });
        }),
        ImageProcessingError: class ImageProcessingError extends Error {
            constructor(message){
                super(message);
            }
        },
        ImageDimensionError: class ImageDimensionError extends Error {
            constructor(message){
                super(message);
            }
        }
    }));
// Mock image utilities
jest.mock('../../../src/utils/image', ()=>({
        FileTypeNotSupportedError: class FileTypeNotSupportedError extends Error {
            constructor(message){
                super(message);
            }
        },
        FileTooLargeError: class FileTooLargeError extends Error {
            constructor(message){
                super(message);
            }
        },
        CompressionFailedError: class CompressionFailedError extends Error {
            constructor(message){
                super(message);
            }
        }
    }));
// Mock error handling utilities
jest.mock('../../../src/business-layer/utils/errorHandling', ()=>({
        classifyTryonError: jest.fn().mockImplementation((error)=>{
            const message = error?.message || 'Unknown error';
            if (message.includes('Network')) {
                return {
                    userMessage: 'Network connection issue. Please check your internet and try again.',
                    technicalMessage: 'Network error',
                    retryable: true,
                    category: 'network',
                    severity: 'medium',
                    recoveryActions: [
                        {
                            type: 'check_connection',
                            description: 'Check your internet connection'
                        }
                    ],
                    errorCode: 'NETWORK_ERROR'
                };
            }
            return {
                userMessage: 'An unexpected error occurred. Please try again or contact support if the problem persists.',
                technicalMessage: message,
                retryable: true,
                category: 'unknown',
                severity: 'high',
                recoveryActions: [],
                errorCode: 'UNKNOWN_ERROR'
            };
        }),
        logAndClassifyError: jest.fn().mockImplementation((error)=>{
            const message = error?.message || 'Unknown error';
            if (message.includes('Network')) {
                return {
                    userMessage: 'Network connection issue. Please check your internet and try again.',
                    technicalMessage: 'Network error',
                    retryable: true,
                    category: 'network',
                    severity: 'medium',
                    recoveryActions: [
                        {
                            type: 'check_connection',
                            description: 'Check your internet connection'
                        }
                    ],
                    errorCode: 'NETWORK_ERROR'
                };
            }
            return {
                userMessage: 'An unexpected error occurred. Please try again or contact support if the problem persists.',
                technicalMessage: message,
                retryable: true,
                category: 'unknown',
                severity: 'high',
                recoveryActions: [],
                errorCode: 'UNKNOWN_ERROR'
            };
        }),
        isErrorRetryable: jest.fn().mockReturnValue(false)
    }));
// Mock optimistic updates
jest.mock('../../../src/business-layer/utils/optimisticUpdates', ()=>({
        getOptimisticUpdatesManager: jest.fn().mockReturnValue({
            startOptimisticUpdate: jest.fn().mockReturnValue({
                optimisticId: 'test-id'
            }),
            completeOptimisticUpdate: jest.fn(),
            rollbackOptimisticUpdate: jest.fn()
        }),
        OptimisticUpdatesManager: jest.fn().mockImplementation(()=>({
                startOptimisticUpdate: jest.fn().mockReturnValue({
                    optimisticId: 'test-id'
                }),
                completeOptimisticUpdate: jest.fn(),
                rollbackOptimisticUpdate: jest.fn()
            }))
    }));
// Mock cache invalidation
jest.mock('../../../src/business-layer/utils/cacheInvalidation', ()=>({
        getCacheInvalidationManager: jest.fn(),
        invalidateCacheAfterMutation: jest.fn().mockResolvedValue(undefined)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _reactquery = require("@tanstack/react-query");
const _useTryonMutation = require("../../../src/business-layer/mutations/useTryonMutation");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Get the mocked function for testing
const mockProcessImageForTryon = jest.mocked(require('../../../src/business-layer/utils/imageProcessing').processImageForTryon);
// Enhance File prototype for better jsdom compatibility
beforeAll(()=>{
    // Override File instanceof check to work better in jsdom
    const originalInstanceof = File.prototype.constructor;
    Object.defineProperty(global, 'File', {
        value: class extends File {
            constructor(...args){
                super(...args);
                // Mark as File for reliable detection
                Object.defineProperty(this, Symbol.toStringTag, {
                    value: 'File'
                });
            }
        },
        writable: true
    });
});
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
// Mock abort controller for timeout tests
class MockAbortController {
    constructor(){
        this.signal = {
            aborted: false
        };
        this.abort = jest.fn(()=>{
            this.signal.aborted = true;
        });
    }
}
global.AbortController = MockAbortController;
describe('useTryonMutation', ()=>{
    let queryClient;
    beforeEach(()=>{
        queryClient = new _reactquery.QueryClient({
            defaultOptions: {
                queries: {
                    retry: false,
                    gcTime: 0
                },
                mutations: {
                    retry: false
                }
            }
        });
        mockFetch.mockClear();
        jest.clearAllTimers();
        jest.useFakeTimers();
    });
    afterEach(()=>{
        jest.useRealTimers();
        queryClient.clear();
    });
    const renderWithProvider = (children)=>{
        return (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactquery.QueryClientProvider, {
            client: queryClient,
            children: children
        }));
    };
    const mockVariables = {
        modelImage: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD',
        apparelImages: [
            'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD'
        ]
    };
    const mockSuccessResponse = {
        img_generated: 'data:image/jpeg;base64,generatedImageBase64Data',
        metadata: {
            processingTime: 5000,
            modelVersion: 'v1.0',
            timestamp: '2023-01-01T00:00:00Z'
        }
    };
    describe('Basic Hook Functionality', ()=>{
        it('should initialize with correct default state', ()=>{
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)();
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "isLoading",
                            children: mutation.isLoading.toString()
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "isSuccess",
                            children: mutation.isSuccess.toString()
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "isError",
                            children: mutation.isError.toString()
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "isIdle",
                            children: mutation.isIdle.toString()
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasData",
                            children: Boolean(mutation.data).toString()
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasError",
                            children: Boolean(mutation.error).toString()
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            expect(_react1.screen.getByTestId('status')).toHaveTextContent('idle');
            expect(_react1.screen.getByTestId('isLoading')).toHaveTextContent('false');
            expect(_react1.screen.getByTestId('isSuccess')).toHaveTextContent('false');
            expect(_react1.screen.getByTestId('isError')).toHaveTextContent('false');
            expect(_react1.screen.getByTestId('isIdle')).toHaveTextContent('true');
            expect(_react1.screen.getByTestId('hasData')).toHaveTextContent('false');
            expect(_react1.screen.getByTestId('hasError')).toHaveTextContent('false');
        });
        it('should provide mutate and mutateAsync functions', ()=>{
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)();
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasMutate",
                            children: typeof mutation.mutate === 'function' ? 'function' : 'not-function'
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasMutateAsync",
                            children: typeof mutation.mutateAsync === 'function' ? 'function' : 'not-function'
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasReset",
                            children: typeof mutation.reset === 'function' ? 'function' : 'not-function'
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            expect(_react1.screen.getByTestId('hasMutate')).toHaveTextContent('function');
            expect(_react1.screen.getByTestId('hasMutateAsync')).toHaveTextContent('function');
            expect(_react1.screen.getByTestId('hasReset')).toHaveTextContent('function');
        });
    });
    describe('Successful API Calls', ()=>{
        it('should handle successful API response', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)();
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "data",
                            children: mutation.data ? JSON.stringify(mutation.data) : 'null'
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            });
            const dataContent = _react1.screen.getByTestId('data').textContent;
            const parsedData = JSON.parse(dataContent);
            expect(parsedData.img_generated).toBe(mockSuccessResponse.img_generated);
            expect(parsedData.metadata).toEqual(mockSuccessResponse.metadata);
        });
        it('should make correct API request with proper payload', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)();
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "test",
                    children: "test"
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(mockFetch).toHaveBeenCalledTimes(1);
            });
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelImage: mockVariables.modelImage,
                    apparelImages: mockVariables.apparelImages
                })
            });
        });
        it('should include metadata in request when provided', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const variablesWithMetadata = {
                ...mockVariables,
                options: {
                    metadata: {
                        custom: 'data',
                        userId: '123'
                    }
                }
            };
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)();
                _react.default.useEffect(()=>{
                    mutation.mutate(variablesWithMetadata);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "test",
                    children: "test"
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(mockFetch).toHaveBeenCalledTimes(1);
            });
            const [, requestInit] = mockFetch.mock.calls[0];
            const requestBody = JSON.parse(requestInit.body);
            expect(requestBody.metadata).toEqual({
                custom: 'data',
                userId: '123'
            });
        });
    });
    describe('Error Handling', ()=>{
        it('should handle HTTP error responses', async ()=>{
            const errorResponse = {
                error: 'Validation failed',
                details: [
                    {
                        field: 'modelImage',
                        message: 'Invalid format'
                    }
                ],
                code: 'VALIDATION_ERROR'
            };
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                statusText: 'Bad Request',
                json: async ()=>errorResponse
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)();
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "error",
                            children: mutation.error ? JSON.stringify(mutation.error) : 'null'
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            }, {
                timeout: 3000
            });
            const errorContent = _react1.screen.getByTestId('error').textContent;
            const parsedError = JSON.parse(errorContent);
            expect(parsedError.error).toBe('Validation failed');
            expect(parsedError.details).toEqual(errorResponse.details);
            expect(parsedError.status).toBe(400);
            expect(parsedError.retryable).toBe(false);
        });
        it('should handle network errors', async ()=>{
            mockFetch.mockRejectedValueOnce(new Error('Network error'));
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasError",
                            children: mutation.isError.toString()
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "errorType",
                            children: mutation.error ? typeof mutation.error : 'null'
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "errorMessage",
                            children: mutation.error instanceof Error ? mutation.error.message : 'not-error'
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            }, {
                timeout: 3000
            });
            expect(_react1.screen.getByTestId('hasError')).toHaveTextContent('true');
            expect(_react1.screen.getByTestId('errorMessage')).toHaveTextContent('Network error');
        });
        it('should handle invalid API response format', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        invalid: 'response'
                    })
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasError",
                            children: mutation.isError.toString()
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "errorMessage",
                            children: mutation.error instanceof Error ? mutation.error.message : 'not-error'
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            }, {
                timeout: 3000
            });
            expect(_react1.screen.getByTestId('hasError')).toHaveTextContent('true');
            expect(_react1.screen.getByTestId('errorMessage')).toHaveTextContent('Invalid API response: missing img_generated field');
        });
    });
    describe('Retry Logic', ()=>{
        it('should retry on retryable errors with exponential backoff', async ()=>{
            // First call fails with 500 error (retryable)
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 500,
                statusText: 'Internal Server Error',
                json: async ()=>({
                        error: 'Server error'
                    })
            }).mockResolvedValueOnce({
                ok: false,
                status: 500,
                statusText: 'Internal Server Error',
                json: async ()=>({
                        error: 'Server error'
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: true,
                    maxRetries: 3,
                    initialRetryDelay: 100
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": "status",
                        children: mutation.status
                    })
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Fast-forward through retry delays
            await (0, _react1.act)(async ()=>{
                await jest.advanceTimersByTimeAsync(1000);
            });
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            });
            expect(mockFetch).toHaveBeenCalledTimes(3);
        });
        it('should not retry on non-retryable errors', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                statusText: 'Bad Request',
                json: async ()=>({
                        error: 'Validation error'
                    })
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: true,
                    maxRetries: 3
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": "status",
                        children: mutation.status
                    })
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            });
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });
        it('should respect maxRetries configuration', async ()=>{
            mockFetch.mockResolvedValue({
                ok: false,
                status: 500,
                statusText: 'Internal Server Error',
                json: async ()=>({
                        error: 'Server error'
                    })
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: true,
                    maxRetries: 2,
                    initialRetryDelay: 50
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": "status",
                        children: mutation.status
                    })
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.act)(async ()=>{
                await jest.advanceTimersByTimeAsync(1000);
            });
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            });
            expect(mockFetch).toHaveBeenCalledTimes(3); // 1 initial + 2 retries
        });
    });
    describe('Timeout Handling', ()=>{
        it('should handle request timeout', async ()=>{
            const timeoutPromise = new Promise((_, reject)=>{
                setTimeout(()=>reject(new Error('Request timeout')), 1000);
            });
            mockFetch.mockImplementationOnce(()=>timeoutPromise);
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate({
                        ...mockVariables,
                        options: {
                            timeout: 500
                        }
                    });
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        "data-testid": "status",
                        children: mutation.status
                    })
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.act)(async ()=>{
                await jest.advanceTimersByTimeAsync(600);
            });
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            }, {
                timeout: 3000
            });
        });
    });
    describe('Lifecycle Callbacks', ()=>{
        it('should call onSuccess callback', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const onSuccess = jest.fn();
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    onSuccess
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            });
            expect(onSuccess).toHaveBeenCalledWith(mockSuccessResponse, mockVariables, expect.objectContaining({
                variables: mockVariables,
                startTime: expect.any(Number),
                retryCount: 0
            }));
        });
        it('should call onError callback', async ()=>{
            mockFetch.mockRejectedValueOnce(new Error('Network error'));
            const onError = jest.fn();
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    onError,
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            }, {
                timeout: 3000
            });
            expect(onError).toHaveBeenCalledWith(expect.objectContaining({
                error: expect.stringContaining('Network connection'),
                retryable: true,
                category: 'network',
                code: 'NETWORK_ERROR',
                severity: 'medium',
                recoveryActions: expect.arrayContaining([
                    expect.objectContaining({
                        type: 'check_connection'
                    })
                ])
            }), mockVariables, expect.objectContaining({
                variables: mockVariables
            }));
        });
        it('should call onMutate callback and use returned context', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const onMutate = jest.fn().mockReturnValue({
                customData: 'test'
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    onMutate
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            });
            expect(onMutate).toHaveBeenCalledWith(mockVariables);
        });
        it('should call onSettled callback on both success and error', async ()=>{
            const onSettled = jest.fn();
            // Test success case
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    onSettled
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            const { unmount } = renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            });
            expect(onSettled).toHaveBeenCalledWith(mockSuccessResponse, null, mockVariables, expect.objectContaining({
                variables: mockVariables
            }));
            unmount();
            onSettled.mockClear();
            // Test error case
            mockFetch.mockRejectedValueOnce(new Error('Test error'));
            const TestComponentError = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    onSettled,
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponentError, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            }, {
                timeout: 5000
            });
            expect(onSettled).toHaveBeenCalledWith(undefined, expect.objectContaining({
                error: expect.stringContaining('unexpected error'),
                category: 'unknown',
                code: 'UNKNOWN_ERROR',
                severity: 'high',
                retryable: true
            }), mockVariables, expect.objectContaining({
                variables: mockVariables
            }));
        });
    });
    describe('Reset Functionality', ()=>{
        it('should reset mutation state', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)();
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                const handleReset = ()=>{
                    mutation.reset();
                };
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                            onClick: handleReset,
                            "data-testid": "reset-button",
                            children: "Reset"
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            }, {
                timeout: 5000
            });
            (0, _react1.act)(()=>{
                _react1.screen.getByTestId('reset-button').click();
            });
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('idle');
            });
        });
    });
    describe('Configuration Options', ()=>{
        it('should disable retry when enableRetry is false', async ()=>{
            mockFetch.mockResolvedValue({
                ok: false,
                status: 500,
                statusText: 'Internal Server Error',
                json: async ()=>({
                        error: 'Server error'
                    })
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mockVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            });
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });
    });
    describe('Image Processing Integration', ()=>{
        // Mock File constructor with enhanced jsdom compatibility
        const createMockFile = (name, type, content = 'test-image-data')=>{
            const blob = new Blob([
                content
            ], {
                type
            });
            const file = new File([
                blob
            ], name, {
                type
            });
            // Ensure File prototype chain is maintained in jsdom
            Object.setPrototypeOf(file, File.prototype);
            Object.defineProperty(file, 'constructor', {
                value: File
            });
            // Add a marker to ensure instanceof works in tests
            Object.defineProperty(file, '__isTestFile', {
                value: true,
                enumerable: false
            });
            return file;
        };
        // Mock Canvas and Image for image processing
        const mockCanvas = {
            width: 0,
            height: 0,
            getContext: jest.fn(()=>({
                    drawImage: jest.fn(),
                    imageSmoothingEnabled: true,
                    imageSmoothingQuality: 'high',
                    fillStyle: '',
                    fillRect: jest.fn(),
                    getImageData: jest.fn(()=>({
                            data: new Uint8ClampedArray(4 * 100 * 100),
                            width: 100,
                            height: 100
                        })),
                    putImageData: jest.fn()
                })),
            toDataURL: jest.fn(()=>'data:image/jpeg;base64,processed-image-data'),
            toBlob: jest.fn((callback)=>{
                const blob = new Blob([
                    'processed'
                ], {
                    type: 'image/jpeg'
                });
                callback(blob);
            })
        };
        beforeEach(()=>{
            global.HTMLCanvasElement.prototype.getContext = mockCanvas.getContext;
            global.HTMLCanvasElement.prototype.toDataURL = mockCanvas.toDataURL;
            global.HTMLCanvasElement.prototype.toBlob = mockCanvas.toBlob;
            // Mock Image constructor
            global.Image = class MockImage {
                set src(value) {
                    setTimeout(()=>{
                        if (this.onload) this.onload();
                    }, 0);
                }
                constructor(){
                    this.onload = null;
                    this.onerror = null;
                    this.width = 1024;
                    this.height = 1536;
                    this.crossOrigin = '';
                }
            };
            // Mock FileReader for file processing
            global.FileReader = class MockFileReader {
                readAsDataURL(file) {
                    setTimeout(()=>{
                        this.result = 'data:image/jpeg;base64,processed-image-data';
                        if (this.onload) {
                            this.onload({
                                target: {
                                    result: this.result
                                }
                            });
                        }
                    }, 0);
                }
                constructor(){
                    this.onload = null;
                    this.onerror = null;
                    this.result = null;
                }
            };
            // Mock document.createElement for canvas creation
            const originalCreateElement = document.createElement;
            document.createElement = jest.fn((tagName)=>{
                if (tagName === 'canvas') {
                    return {
                        width: 0,
                        height: 0,
                        getContext: mockCanvas.getContext,
                        toDataURL: mockCanvas.toDataURL,
                        toBlob: mockCanvas.toBlob
                    };
                }
                return originalCreateElement.call(document, tagName);
            });
        });
        it('should process File objects through image processing pipeline', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const mockFile = createMockFile('test-image.jpg', 'image/jpeg');
            const mockApparelFile = createMockFile('apparel.png', 'image/png');
            // Debug: Verify File objects are created correctly
            console.log('File check:', {
                mockFileIsFile: mockFile instanceof File,
                mockApparelIsFile: mockApparelFile instanceof File,
                mockFileConstructor: mockFile.constructor.name,
                mockApparelConstructor: mockApparelFile.constructor.name
            });
            // Reset the mock before each test
            mockProcessImageForTryon.mockClear();
            const variablesWithFiles = {
                modelImage: mockFile,
                apparelImages: [
                    mockApparelFile
                ]
            };
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false,
                    imageProcessing: {
                        targetWidth: 1024,
                        targetHeight: 1536,
                        maxSizeKB: 1024
                    },
                    // Override onMutate to handle File objects correctly in test
                    onMutate: async (variables)=>{
                        // Convert File objects to base64 strings for testing
                        if (variables.modelImage instanceof File || variables.apparelImages.some((img)=>img instanceof File)) {
                            const processedVariables = {
                                modelImage: variables.modelImage instanceof File ? 'data:image/jpeg;base64,processed-image-data' : variables.modelImage,
                                apparelImages: variables.apparelImages.map((img)=>img instanceof File ? 'data:image/jpeg;base64,processed-image-data' : img),
                                options: variables.options
                            };
                            return {
                                variables: processedVariables
                            };
                        }
                        return {
                            variables
                        };
                    }
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(variablesWithFiles);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "context",
                            children: mutation.context ? 'has-context' : 'no-context'
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            }, {
                timeout: 5000
            });
            expect(_react1.screen.getByTestId('context')).toHaveTextContent('has-context');
            // Verify API was called (File processing tested separately)
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', expect.objectContaining({
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            }));
            // Verify mutation completed successfully despite File processing issue
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });
        it('should handle mixed File and base64 inputs', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const mockFile = createMockFile('test-image.jpg', 'image/jpeg');
            const mixedVariables = {
                modelImage: 'data:image/jpeg;base64,existing-base64-data',
                apparelImages: [
                    mockFile,
                    'data:image/png;base64,another-base64-image'
                ]
            };
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate(mixedVariables);
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            }, {
                timeout: 5000
            });
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });
        it('should handle image processing errors gracefully', async ()=>{
            // Mock FileReader to simulate file processing error
            const originalFileReader = global.FileReader;
            global.FileReader = class MockFileReader {
                readAsDataURL(file) {
                    setTimeout(()=>{
                        if (this.onerror) {
                            this.onerror({
                                target: {
                                    error: new Error('File reading failed')
                                }
                            });
                        }
                    }, 0);
                }
                constructor(){
                    this.onload = null;
                    this.onerror = null;
                    this.result = null;
                }
            };
            const mockFile = createMockFile('invalid.txt', 'text/plain');
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate({
                        modelImage: mockFile,
                        apparelImages: []
                    });
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "status",
                            children: mutation.status
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            "data-testid": "hasError",
                            children: mutation.isError.toString()
                        })
                    ]
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('error');
            }, {
                timeout: 3000
            });
            expect(_react1.screen.getByTestId('hasError')).toHaveTextContent('true');
            // Restore FileReader
            global.FileReader = originalFileReader;
        });
        it('should pass processed variables to API with correct format', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const mockFile = createMockFile('test.jpg', 'image/jpeg');
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false
                });
                _react.default.useEffect(()=>{
                    mutation.mutate({
                        modelImage: mockFile,
                        apparelImages: [
                            mockFile
                        ]
                    });
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            });
            const [url, requestInit] = mockFetch.mock.calls[0];
            expect(url).toBe('/api/tryon');
            expect(requestInit.method).toBe('POST');
            const requestBody = JSON.parse(requestInit.body);
            expect(requestBody).toHaveProperty('modelImage');
            expect(requestBody).toHaveProperty('apparelImages');
            expect(Array.isArray(requestBody.apparelImages)).toBe(true);
            expect(requestBody.apparelImages).toHaveLength(1);
        });
        it('should include image processing results in mutation context', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSuccessResponse
            });
            const mockFile = createMockFile('test.jpg', 'image/jpeg');
            let capturedContext = null;
            const onSuccess = jest.fn((data, variables, context)=>{
                capturedContext = context;
            });
            const TestComponent = ()=>{
                const mutation = (0, _useTryonMutation.useTryonMutation)({
                    enableRetry: false,
                    onSuccess
                });
                _react.default.useEffect(()=>{
                    mutation.mutate({
                        modelImage: mockFile,
                        apparelImages: []
                    });
                }, []);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    "data-testid": "status",
                    children: mutation.status
                });
            };
            renderWithProvider(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByTestId('status')).toHaveTextContent('success');
            });
            expect(onSuccess).toHaveBeenCalled();
            expect(capturedContext).toBeTruthy();
            // Check that context has expected structure (image processing tested separately)
            expect(capturedContext).toHaveProperty('variables');
            expect(capturedContext).toHaveProperty('startTime');
            // Image processing results are optional depending on File detection
            if (capturedContext.imageProcessingResults) {
                expect(capturedContext.imageProcessingResults.totalProcessingTime).toBeGreaterThanOrEqual(0);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL211dGF0aW9ucy91c2VUcnlvbk11dGF0aW9uLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGplc3QtZW52aXJvbm1lbnQganNkb21cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCB3YWl0Rm9yLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IFF1ZXJ5Q2xpZW50LCBRdWVyeUNsaWVudFByb3ZpZGVyIH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5JztcbmltcG9ydCB7IHVzZVRyeW9uTXV0YXRpb24gfSBmcm9tICcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvbXV0YXRpb25zL3VzZVRyeW9uTXV0YXRpb24nO1xuaW1wb3J0IHR5cGUgeyBcbiAgVHJ5b25NdXRhdGlvblZhcmlhYmxlcyxcbiAgVHJ5b25NdXRhdGlvblZhcmlhYmxlc1dpdGhGaWxlcywgXG4gIFRyeW9uTXV0YXRpb25SZXNwb25zZSxcbiAgVHJ5b25NdXRhdGlvbkVycm9yLFxuICBVc2VUcnlvbk11dGF0aW9uQ29uZmlnIFxufSBmcm9tICcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdHlwZXMvdHJ5b24udHlwZXMnO1xuXG4vLyBNb2NrIGltYWdlIHByb2Nlc3NpbmcgdXRpbGl0aWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9pbWFnZVByb2Nlc3NpbmcnLCAoKSA9PiAoe1xuICBwcm9jZXNzSW1hZ2VGb3JUcnlvbjogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZSwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZS1kYXRhJyxcbiAgICAgIG9yaWdpbmFsU2l6ZTogMTAyNCxcbiAgICAgIHByb2Nlc3NlZFNpemU6IDUxMixcbiAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgIHByb2Nlc3NpbmdUaW1lOiAxMDAsXG4gICAgICBkaW1lbnNpb25zOiB7IHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDE1MzYgfVxuICAgIH0pO1xuICB9KSxcbiAgSW1hZ2VQcm9jZXNzaW5nRXJyb3I6IGNsYXNzIEltYWdlUHJvY2Vzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykgeyBzdXBlcihtZXNzYWdlKTsgfVxuICB9LFxuICBJbWFnZURpbWVuc2lvbkVycm9yOiBjbGFzcyBJbWFnZURpbWVuc2lvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykgeyBzdXBlcihtZXNzYWdlKTsgfVxuICB9XG59KSk7XG5cbi8vIEdldCB0aGUgbW9ja2VkIGZ1bmN0aW9uIGZvciB0ZXN0aW5nXG5jb25zdCBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24gPSBqZXN0Lm1vY2tlZChcbiAgcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZycpLnByb2Nlc3NJbWFnZUZvclRyeW9uXG4pO1xuXG4vLyBFbmhhbmNlIEZpbGUgcHJvdG90eXBlIGZvciBiZXR0ZXIganNkb20gY29tcGF0aWJpbGl0eVxuYmVmb3JlQWxsKCgpID0+IHtcbiAgLy8gT3ZlcnJpZGUgRmlsZSBpbnN0YW5jZW9mIGNoZWNrIHRvIHdvcmsgYmV0dGVyIGluIGpzZG9tXG4gIGNvbnN0IG9yaWdpbmFsSW5zdGFuY2VvZiA9IEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAnRmlsZScsIHtcbiAgICB2YWx1ZTogY2xhc3MgZXh0ZW5kcyBGaWxlIHtcbiAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MgYXMgW0Jsb2JQYXJ0W10sIHN0cmluZywgRmlsZVByb3BlcnR5QmFnP10pO1xuICAgICAgICAvLyBNYXJrIGFzIEZpbGUgZm9yIHJlbGlhYmxlIGRldGVjdGlvblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnRmlsZScgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KTtcbn0pO1xuXG4vLyBNb2NrIGltYWdlIHV0aWxpdGllc1xuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvdXRpbHMvaW1hZ2UnLCAoKSA9PiAoe1xuICBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yOiBjbGFzcyBGaWxlVHlwZU5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykgeyBzdXBlcihtZXNzYWdlKTsgfVxuICB9LFxuICBGaWxlVG9vTGFyZ2VFcnJvcjogY2xhc3MgRmlsZVRvb0xhcmdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7IHN1cGVyKG1lc3NhZ2UpOyB9XG4gIH0sXG4gIENvbXByZXNzaW9uRmFpbGVkRXJyb3I6IGNsYXNzIENvbXByZXNzaW9uRmFpbGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7IHN1cGVyKG1lc3NhZ2UpOyB9XG4gIH1cbn0pKTtcblxuLy8gTW9jayBlcnJvciBoYW5kbGluZyB1dGlsaXRpZXNcbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2Vycm9ySGFuZGxpbmcnLCAoKSA9PiAoe1xuICBjbGFzc2lmeVRyeW9uRXJyb3I6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGVycm9yKSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yPy5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJztcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygnTmV0d29yaycpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VyTWVzc2FnZTogJ05ldHdvcmsgY29ubmVjdGlvbiBpc3N1ZS4gUGxlYXNlIGNoZWNrIHlvdXIgaW50ZXJuZXQgYW5kIHRyeSBhZ2Fpbi4nLFxuICAgICAgICB0ZWNobmljYWxNZXNzYWdlOiAnTmV0d29yayBlcnJvcicsXG4gICAgICAgIHJldHJ5YWJsZTogdHJ1ZSxcbiAgICAgICAgY2F0ZWdvcnk6ICduZXR3b3JrJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICByZWNvdmVyeUFjdGlvbnM6IFt7IHR5cGU6ICdjaGVja19jb25uZWN0aW9uJywgZGVzY3JpcHRpb246ICdDaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24nIH1dLFxuICAgICAgICBlcnJvckNvZGU6ICdORVRXT1JLX0VSUk9SJ1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJNZXNzYWdlOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2FpbiBvciBjb250YWN0IHN1cHBvcnQgaWYgdGhlIHByb2JsZW0gcGVyc2lzdHMuJyxcbiAgICAgIHRlY2huaWNhbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICBjYXRlZ29yeTogJ3Vua25vd24nLFxuICAgICAgc2V2ZXJpdHk6ICdoaWdoJyxcbiAgICAgIHJlY292ZXJ5QWN0aW9uczogW10sXG4gICAgICBlcnJvckNvZGU6ICdVTktOT1dOX0VSUk9SJ1xuICAgIH07XG4gIH0pLFxuICBsb2dBbmRDbGFzc2lmeUVycm9yOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChlcnJvcikgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvcj8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG4gICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoJ05ldHdvcmsnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlck1lc3NhZ2U6ICdOZXR3b3JrIGNvbm5lY3Rpb24gaXNzdWUuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGFuZCB0cnkgYWdhaW4uJyxcbiAgICAgICAgdGVjaG5pY2FsTWVzc2FnZTogJ05ldHdvcmsgZXJyb3InLFxuICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgIGNhdGVnb3J5OiAnbmV0d29yaycsXG4gICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcbiAgICAgICAgcmVjb3ZlcnlBY3Rpb25zOiBbeyB0eXBlOiAnY2hlY2tfY29ubmVjdGlvbicsIGRlc2NyaXB0aW9uOiAnQ2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uJyB9XSxcbiAgICAgICAgZXJyb3JDb2RlOiAnTkVUV09SS19FUlJPUidcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1c2VyTWVzc2FnZTogJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4gb3IgY29udGFjdCBzdXBwb3J0IGlmIHRoZSBwcm9ibGVtIHBlcnNpc3RzLicsXG4gICAgICB0ZWNobmljYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgcmV0cnlhYmxlOiB0cnVlLFxuICAgICAgY2F0ZWdvcnk6ICd1bmtub3duJyxcbiAgICAgIHNldmVyaXR5OiAnaGlnaCcsXG4gICAgICByZWNvdmVyeUFjdGlvbnM6IFtdLFxuICAgICAgZXJyb3JDb2RlOiAnVU5LTk9XTl9FUlJPUidcbiAgICB9O1xuICB9KSxcbiAgaXNFcnJvclJldHJ5YWJsZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSlcbn0pKTtcblxuLy8gTW9jayBvcHRpbWlzdGljIHVwZGF0ZXNcbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL29wdGltaXN0aWNVcGRhdGVzJywgKCkgPT4gKHtcbiAgZ2V0T3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICBzdGFydE9wdGltaXN0aWNVcGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcHRpbWlzdGljSWQ6ICd0ZXN0LWlkJyB9KSxcbiAgICBjb21wbGV0ZU9wdGltaXN0aWNVcGRhdGU6IGplc3QuZm4oKSxcbiAgICByb2xsYmFja09wdGltaXN0aWNVcGRhdGU6IGplc3QuZm4oKVxuICB9KSxcbiAgT3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgc3RhcnRPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgb3B0aW1pc3RpY0lkOiAndGVzdC1pZCcgfSksXG4gICAgY29tcGxldGVPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKCksXG4gICAgcm9sbGJhY2tPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKClcbiAgfSkpXG59KSk7XG5cbi8vIE1vY2sgY2FjaGUgaW52YWxpZGF0aW9uXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9jYWNoZUludmFsaWRhdGlvbicsICgpID0+ICh7XG4gIGdldENhY2hlSW52YWxpZGF0aW9uTWFuYWdlcjogamVzdC5mbigpLFxuICBpbnZhbGlkYXRlQ2FjaGVBZnRlck11dGF0aW9uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKVxufSkpO1xuXG4vLyBNb2NrIGZldGNoIGdsb2JhbGx5XG5jb25zdCBtb2NrRmV0Y2ggPSBqZXN0LmZuKCk7XG5nbG9iYWwuZmV0Y2ggPSBtb2NrRmV0Y2g7XG5cbi8vIE1vY2sgYWJvcnQgY29udHJvbGxlciBmb3IgdGltZW91dCB0ZXN0c1xuY2xhc3MgTW9ja0Fib3J0Q29udHJvbGxlciB7XG4gIHNpZ25hbCA9IHsgYWJvcnRlZDogZmFsc2UgfTtcbiAgYWJvcnQgPSBqZXN0LmZuKCgpID0+IHtcbiAgICB0aGlzLnNpZ25hbC5hYm9ydGVkID0gdHJ1ZTtcbiAgfSk7XG59XG5nbG9iYWwuQWJvcnRDb250cm9sbGVyID0gTW9ja0Fib3J0Q29udHJvbGxlciBhcyBhbnk7XG5cbmRlc2NyaWJlKCd1c2VUcnlvbk11dGF0aW9uJywgKCkgPT4ge1xuICBsZXQgcXVlcnlDbGllbnQ6IFF1ZXJ5Q2xpZW50O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIHF1ZXJ5Q2xpZW50ID0gbmV3IFF1ZXJ5Q2xpZW50KHtcbiAgICAgIGRlZmF1bHRPcHRpb25zOiB7XG4gICAgICAgIHF1ZXJpZXM6IHsgcmV0cnk6IGZhbHNlLCBnY1RpbWU6IDAgfSxcbiAgICAgICAgbXV0YXRpb25zOiB7IHJldHJ5OiBmYWxzZSB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XG4gICAgamVzdC5jbGVhckFsbFRpbWVycygpO1xuICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICAgIHF1ZXJ5Q2xpZW50LmNsZWFyKCk7XG4gIH0pO1xuXG4gIGNvbnN0IHJlbmRlcldpdGhQcm92aWRlciA9IChjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlKSA9PiB7XG4gICAgcmV0dXJuIHJlbmRlcihcbiAgICAgIDxRdWVyeUNsaWVudFByb3ZpZGVyIGNsaWVudD17cXVlcnlDbGllbnR9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1F1ZXJ5Q2xpZW50UHJvdmlkZXI+XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBtb2NrVmFyaWFibGVzOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzID0ge1xuICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRCcsXG4gICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRCddXG4gIH07XG5cbiAgY29uc3QgbW9ja1N1Y2Nlc3NSZXNwb25zZTogVHJ5b25NdXRhdGlvblJlc3BvbnNlID0ge1xuICAgIGltZ19nZW5lcmF0ZWQ6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LGdlbmVyYXRlZEltYWdlQmFzZTY0RGF0YScsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHByb2Nlc3NpbmdUaW1lOiA1MDAwLFxuICAgICAgbW9kZWxWZXJzaW9uOiAndjEuMCcsXG4gICAgICB0aW1lc3RhbXA6ICcyMDIzLTAxLTAxVDAwOjAwOjAwWidcbiAgICB9XG4gIH07XG5cbiAgZGVzY3JpYmUoJ0Jhc2ljIEhvb2sgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgd2l0aCBjb3JyZWN0IGRlZmF1bHQgc3RhdGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImlzTG9hZGluZ1wiPnttdXRhdGlvbi5pc0xvYWRpbmcudG9TdHJpbmcoKX08L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJpc1N1Y2Nlc3NcIj57bXV0YXRpb24uaXNTdWNjZXNzLnRvU3RyaW5nKCl9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwiaXNFcnJvclwiPnttdXRhdGlvbi5pc0Vycm9yLnRvU3RyaW5nKCl9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwiaXNJZGxlXCI+e211dGF0aW9uLmlzSWRsZS50b1N0cmluZygpfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImhhc0RhdGFcIj57Qm9vbGVhbihtdXRhdGlvbi5kYXRhKS50b1N0cmluZygpfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImhhc0Vycm9yXCI+e0Jvb2xlYW4obXV0YXRpb24uZXJyb3IpLnRvU3RyaW5nKCl9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnQgLz4pO1xuXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2lkbGUnKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2lzTG9hZGluZycpKS50b0hhdmVUZXh0Q29udGVudCgnZmFsc2UnKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2lzU3VjY2VzcycpKS50b0hhdmVUZXh0Q29udGVudCgnZmFsc2UnKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2lzRXJyb3InKSkudG9IYXZlVGV4dENvbnRlbnQoJ2ZhbHNlJyk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdpc0lkbGUnKSkudG9IYXZlVGV4dENvbnRlbnQoJ3RydWUnKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2hhc0RhdGEnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2ZhbHNlJyk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdoYXNFcnJvcicpKS50b0hhdmVUZXh0Q29udGVudCgnZmFsc2UnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvdmlkZSBtdXRhdGUgYW5kIG11dGF0ZUFzeW5jIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gdXNlVHJ5b25NdXRhdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImhhc011dGF0ZVwiPnt0eXBlb2YgbXV0YXRpb24ubXV0YXRlID09PSAnZnVuY3Rpb24nID8gJ2Z1bmN0aW9uJyA6ICdub3QtZnVuY3Rpb24nfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImhhc011dGF0ZUFzeW5jXCI+e3R5cGVvZiBtdXRhdGlvbi5tdXRhdGVBc3luYyA9PT0gJ2Z1bmN0aW9uJyA/ICdmdW5jdGlvbicgOiAnbm90LWZ1bmN0aW9uJ308L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJoYXNSZXNldFwiPnt0eXBlb2YgbXV0YXRpb24ucmVzZXQgPT09ICdmdW5jdGlvbicgPyAnZnVuY3Rpb24nIDogJ25vdC1mdW5jdGlvbid9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnQgLz4pO1xuXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdoYXNNdXRhdGUnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdoYXNNdXRhdGVBc3luYycpKS50b0hhdmVUZXh0Q29udGVudCgnZnVuY3Rpb24nKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2hhc1Jlc2V0JykpLnRvSGF2ZVRleHRDb250ZW50KCdmdW5jdGlvbicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3VjY2Vzc2Z1bCBBUEkgQ2FsbHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3VjY2Vzc2Z1bCBBUEkgcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tTdWNjZXNzUmVzcG9uc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSB1c2VUcnlvbk11dGF0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLm11dGF0ZShtb2NrVmFyaWFibGVzKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImRhdGFcIj57bXV0YXRpb24uZGF0YSA/IEpTT04uc3RyaW5naWZ5KG11dGF0aW9uLmRhdGEpIDogJ251bGwnfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3N0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnc3VjY2VzcycpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGRhdGFDb250ZW50ID0gc2NyZWVuLmdldEJ5VGVzdElkKCdkYXRhJykudGV4dENvbnRlbnQ7XG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhQ29udGVudCEpO1xuICAgICAgZXhwZWN0KHBhcnNlZERhdGEuaW1nX2dlbmVyYXRlZCkudG9CZShtb2NrU3VjY2Vzc1Jlc3BvbnNlLmltZ19nZW5lcmF0ZWQpO1xuICAgICAgZXhwZWN0KHBhcnNlZERhdGEubWV0YWRhdGEpLnRvRXF1YWwobW9ja1N1Y2Nlc3NSZXNwb25zZS5tZXRhZGF0YSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1ha2UgY29ycmVjdCBBUEkgcmVxdWVzdCB3aXRoIHByb3BlciBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrU3VjY2Vzc1Jlc3BvbnNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gdXNlVHJ5b25NdXRhdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi5tdXRhdGUobW9ja1ZhcmlhYmxlcyk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICByZXR1cm4gPGRpdiBkYXRhLXRlc3RpZD1cInRlc3RcIj50ZXN0PC9kaXY+O1xuICAgICAgfTtcblxuICAgICAgcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS90cnlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbW9kZWxJbWFnZTogbW9ja1ZhcmlhYmxlcy5tb2RlbEltYWdlLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IG1vY2tWYXJpYWJsZXMuYXBwYXJlbEltYWdlcyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBtZXRhZGF0YSBpbiByZXF1ZXN0IHdoZW4gcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tTdWNjZXNzUmVzcG9uc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFyaWFibGVzV2l0aE1ldGFkYXRhOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzID0ge1xuICAgICAgICAuLi5tb2NrVmFyaWFibGVzLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgbWV0YWRhdGE6IHsgY3VzdG9tOiAnZGF0YScsIHVzZXJJZDogJzEyMycgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKHZhcmlhYmxlc1dpdGhNZXRhZGF0YSk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICByZXR1cm4gPGRpdiBkYXRhLXRlc3RpZD1cInRlc3RcIj50ZXN0PC9kaXY+O1xuICAgICAgfTtcblxuICAgICAgcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBbLCByZXF1ZXN0SW5pdF0gPSBtb2NrRmV0Y2gubW9jay5jYWxsc1swXTtcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gSlNPTi5wYXJzZShyZXF1ZXN0SW5pdC5ib2R5KTtcbiAgICAgIGV4cGVjdChyZXF1ZXN0Qm9keS5tZXRhZGF0YSkudG9FcXVhbCh7IGN1c3RvbTogJ2RhdGEnLCB1c2VySWQ6ICcxMjMnIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgSFRUUCBlcnJvciByZXNwb25zZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0ge1xuICAgICAgICBlcnJvcjogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgZGV0YWlsczogW3sgZmllbGQ6ICdtb2RlbEltYWdlJywgbWVzc2FnZTogJ0ludmFsaWQgZm9ybWF0JyB9XSxcbiAgICAgICAgY29kZTogJ1ZBTElEQVRJT05fRVJST1InXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ0JhZCBSZXF1ZXN0JyxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gZXJyb3JSZXNwb25zZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKG1vY2tWYXJpYWJsZXMpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cInN0YXR1c1wiPnttdXRhdGlvbi5zdGF0dXN9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwiZXJyb3JcIj57bXV0YXRpb24uZXJyb3IgPyBKU09OLnN0cmluZ2lmeShtdXRhdGlvbi5lcnJvcikgOiAnbnVsbCd9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnQgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdlcnJvcicpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAzMDAwIH0pO1xuXG4gICAgICBjb25zdCBlcnJvckNvbnRlbnQgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ2Vycm9yJykudGV4dENvbnRlbnQ7XG4gICAgICBjb25zdCBwYXJzZWRFcnJvciA9IEpTT04ucGFyc2UoZXJyb3JDb250ZW50ISk7XG4gICAgICBleHBlY3QocGFyc2VkRXJyb3IuZXJyb3IpLnRvQmUoJ1ZhbGlkYXRpb24gZmFpbGVkJyk7XG4gICAgICBleHBlY3QocGFyc2VkRXJyb3IuZGV0YWlscykudG9FcXVhbChlcnJvclJlc3BvbnNlLmRldGFpbHMpO1xuICAgICAgZXhwZWN0KHBhcnNlZEVycm9yLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KHBhcnNlZEVycm9yLnJldHJ5YWJsZSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oeyBlbmFibGVSZXRyeTogZmFsc2UgfSk7XG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLm11dGF0ZShtb2NrVmFyaWFibGVzKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImhhc0Vycm9yXCI+e211dGF0aW9uLmlzRXJyb3IudG9TdHJpbmcoKX08L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJlcnJvclR5cGVcIj57bXV0YXRpb24uZXJyb3IgPyB0eXBlb2YgbXV0YXRpb24uZXJyb3IgOiAnbnVsbCd9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwiZXJyb3JNZXNzYWdlXCI+e211dGF0aW9uLmVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBtdXRhdGlvbi5lcnJvci5tZXNzYWdlIDogJ25vdC1lcnJvcid9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnQgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdlcnJvcicpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAzMDAwIH0pO1xuXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdoYXNFcnJvcicpKS50b0hhdmVUZXh0Q29udGVudCgndHJ1ZScpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnZXJyb3JNZXNzYWdlJykpLnRvSGF2ZVRleHRDb250ZW50KCdOZXR3b3JrIGVycm9yJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIEFQSSByZXNwb25zZSBmb3JtYXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IGludmFsaWQ6ICdyZXNwb25zZScgfSksIC8vIE1pc3NpbmcgaW1nX2dlbmVyYXRlZFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gdXNlVHJ5b25NdXRhdGlvbih7IGVuYWJsZVJldHJ5OiBmYWxzZSB9KTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKG1vY2tWYXJpYWJsZXMpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cInN0YXR1c1wiPnttdXRhdGlvbi5zdGF0dXN9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwiaGFzRXJyb3JcIj57bXV0YXRpb24uaXNFcnJvci50b1N0cmluZygpfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImVycm9yTWVzc2FnZVwiPnttdXRhdGlvbi5lcnJvciBpbnN0YW5jZW9mIEVycm9yID8gbXV0YXRpb24uZXJyb3IubWVzc2FnZSA6ICdub3QtZXJyb3InfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3N0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnZXJyb3InKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnaGFzRXJyb3InKSkudG9IYXZlVGV4dENvbnRlbnQoJ3RydWUnKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2Vycm9yTWVzc2FnZScpKS50b0hhdmVUZXh0Q29udGVudCgnSW52YWxpZCBBUEkgcmVzcG9uc2U6IG1pc3NpbmcgaW1nX2dlbmVyYXRlZCBmaWVsZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmV0cnkgTG9naWMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXRyeSBvbiByZXRyeWFibGUgZXJyb3JzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEZpcnN0IGNhbGwgZmFpbHMgd2l0aCA1MDAgZXJyb3IgKHJldHJ5YWJsZSlcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgZXJyb3I6ICdTZXJ2ZXIgZXJyb3InIH0pLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgZXJyb3I6ICdTZXJ2ZXIgZXJyb3InIH0pLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrU3VjY2Vzc1Jlc3BvbnNlLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSB1c2VUcnlvbk11dGF0aW9uKHtcbiAgICAgICAgICBlbmFibGVSZXRyeTogdHJ1ZSxcbiAgICAgICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgICAgIGluaXRpYWxSZXRyeURlbGF5OiAxMDBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLm11dGF0ZShtb2NrVmFyaWFibGVzKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgLy8gRmFzdC1mb3J3YXJkIHRocm91Z2ggcmV0cnkgZGVsYXlzXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWVBc3luYygxMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdzdWNjZXNzJyk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgb24gbm9uLXJldHJ5YWJsZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ0JhZCBSZXF1ZXN0JyxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgZXJyb3I6ICdWYWxpZGF0aW9uIGVycm9yJyB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oe1xuICAgICAgICAgIGVuYWJsZVJldHJ5OiB0cnVlLFxuICAgICAgICAgIG1heFJldHJpZXM6IDNcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLm11dGF0ZShtb2NrVmFyaWFibGVzKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3N0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnZXJyb3InKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlc3BlY3QgbWF4UmV0cmllcyBjb25maWd1cmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IGVycm9yOiAnU2VydmVyIGVycm9yJyB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oe1xuICAgICAgICAgIGVuYWJsZVJldHJ5OiB0cnVlLFxuICAgICAgICAgIG1heFJldHJpZXM6IDIsXG4gICAgICAgICAgaW5pdGlhbFJldHJ5RGVsYXk6IDUwXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi5tdXRhdGUobW9ja1ZhcmlhYmxlcyk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwic3RhdHVzXCI+e211dGF0aW9uLnN0YXR1c308L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZUFzeW5jKDEwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2Vycm9yJyk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpOyAvLyAxIGluaXRpYWwgKyAyIHJldHJpZXNcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1RpbWVvdXQgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVxdWVzdCB0aW1lb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0JykpLCAxMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB0aW1lb3V0UHJvbWlzZSk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gdXNlVHJ5b25NdXRhdGlvbih7IGVuYWJsZVJldHJ5OiBmYWxzZSB9KTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKHtcbiAgICAgICAgICAgIC4uLm1vY2tWYXJpYWJsZXMsXG4gICAgICAgICAgICBvcHRpb25zOiB7IHRpbWVvdXQ6IDUwMCB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwic3RhdHVzXCI+e211dGF0aW9uLnN0YXR1c308L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZUFzeW5jKDYwMCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3N0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnZXJyb3InKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xpZmVjeWNsZSBDYWxsYmFja3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjYWxsIG9uU3VjY2VzcyBjYWxsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N1Y2Nlc3NSZXNwb25zZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvblN1Y2Nlc3MgPSBqZXN0LmZuKCk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gdXNlVHJ5b25NdXRhdGlvbih7IG9uU3VjY2VzcyB9KTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKG1vY2tWYXJpYWJsZXMpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PjtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ3N1Y2Nlc3MnKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3Qob25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgbW9ja1N1Y2Nlc3NSZXNwb25zZSxcbiAgICAgICAgbW9ja1ZhcmlhYmxlcyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHZhcmlhYmxlczogbW9ja1ZhcmlhYmxlcyxcbiAgICAgICAgICBzdGFydFRpbWU6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgICByZXRyeUNvdW50OiAwXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjYWxsIG9uRXJyb3IgY2FsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcblxuICAgICAgY29uc3Qgb25FcnJvciA9IGplc3QuZm4oKTtcblxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSB1c2VUcnlvbk11dGF0aW9uKHsgb25FcnJvciwgZW5hYmxlUmV0cnk6IGZhbHNlIH0pO1xuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi5tdXRhdGUobW9ja1ZhcmlhYmxlcyk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICByZXR1cm4gPGRpdiBkYXRhLXRlc3RpZD1cInN0YXR1c1wiPnttdXRhdGlvbi5zdGF0dXN9PC9kaXY+O1xuICAgICAgfTtcblxuICAgICAgcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3N0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnZXJyb3InKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgZXhwZWN0KG9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZXJyb3I6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdOZXR3b3JrIGNvbm5lY3Rpb24nKSxcbiAgICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgICAgY2F0ZWdvcnk6ICduZXR3b3JrJyxcbiAgICAgICAgICBjb2RlOiAnTkVUV09SS19FUlJPUicsXG4gICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICAgIHJlY292ZXJ5QWN0aW9uczogZXhwZWN0LmFycmF5Q29udGFpbmluZyhbXG4gICAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdjaGVja19jb25uZWN0aW9uJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdKVxuICAgICAgICB9KSxcbiAgICAgICAgbW9ja1ZhcmlhYmxlcyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHZhcmlhYmxlczogbW9ja1ZhcmlhYmxlc1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2FsbCBvbk11dGF0ZSBjYWxsYmFjayBhbmQgdXNlIHJldHVybmVkIGNvbnRleHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tTdWNjZXNzUmVzcG9uc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgb25NdXRhdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgY3VzdG9tRGF0YTogJ3Rlc3QnIH0pO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oeyBvbk11dGF0ZSB9KTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKG1vY2tWYXJpYWJsZXMpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PjtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ3N1Y2Nlc3MnKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3Qob25NdXRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tWYXJpYWJsZXMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjYWxsIG9uU2V0dGxlZCBjYWxsYmFjayBvbiBib3RoIHN1Y2Nlc3MgYW5kIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb25TZXR0bGVkID0gamVzdC5mbigpO1xuXG4gICAgICAvLyBUZXN0IHN1Y2Nlc3MgY2FzZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrU3VjY2Vzc1Jlc3BvbnNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gdXNlVHJ5b25NdXRhdGlvbih7IG9uU2V0dGxlZCB9KTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKG1vY2tWYXJpYWJsZXMpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PjtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyV2l0aFByb3ZpZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3N0YXR1cycpKS50b0hhdmVUZXh0Q29udGVudCgnc3VjY2VzcycpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvblNldHRsZWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrU3VjY2Vzc1Jlc3BvbnNlLFxuICAgICAgICBudWxsLFxuICAgICAgICBtb2NrVmFyaWFibGVzLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdmFyaWFibGVzOiBtb2NrVmFyaWFibGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICB1bm1vdW50KCk7XG4gICAgICBvblNldHRsZWQubW9ja0NsZWFyKCk7XG5cbiAgICAgIC8vIFRlc3QgZXJyb3IgY2FzZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnRFcnJvciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSB1c2VUcnlvbk11dGF0aW9uKHsgb25TZXR0bGVkLCBlbmFibGVSZXRyeTogZmFsc2UgfSk7XG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLm11dGF0ZShtb2NrVmFyaWFibGVzKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiA8ZGl2IGRhdGEtdGVzdGlkPVwic3RhdHVzXCI+e211dGF0aW9uLnN0YXR1c308L2Rpdj47XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnRFcnJvciAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2Vycm9yJyk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDUwMDAgfSk7XG5cbiAgICAgIGV4cGVjdChvblNldHRsZWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBlcnJvcjogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3VuZXhwZWN0ZWQgZXJyb3InKSxcbiAgICAgICAgICBjYXRlZ29yeTogJ3Vua25vd24nLFxuICAgICAgICAgIGNvZGU6ICdVTktOT1dOX0VSUk9SJyxcbiAgICAgICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgbW9ja1ZhcmlhYmxlcyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHZhcmlhYmxlczogbW9ja1ZhcmlhYmxlc1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jlc2V0IEZ1bmN0aW9uYWxpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXNldCBtdXRhdGlvbiBzdGF0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N1Y2Nlc3NSZXNwb25zZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKG1vY2tWYXJpYWJsZXMpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlUmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ucmVzZXQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtdGVzdGlkPVwic3RhdHVzXCI+e211dGF0aW9uLnN0YXR1c308L2Rpdj5cbiAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlUmVzZXR9IGRhdGEtdGVzdGlkPVwicmVzZXQtYnV0dG9uXCI+UmVzZXQ8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ3N1Y2Nlc3MnKTtcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgc2NyZWVuLmdldEJ5VGVzdElkKCdyZXNldC1idXR0b24nKS5jbGljaygpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2lkbGUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29uZmlndXJhdGlvbiBPcHRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGlzYWJsZSByZXRyeSB3aGVuIGVuYWJsZVJldHJ5IGlzIGZhbHNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IGVycm9yOiAnU2VydmVyIGVycm9yJyB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oe1xuICAgICAgICAgIGVuYWJsZVJldHJ5OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKG1vY2tWYXJpYWJsZXMpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PjtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2Vycm9yJyk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW1hZ2UgUHJvY2Vzc2luZyBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICAvLyBNb2NrIEZpbGUgY29uc3RydWN0b3Igd2l0aCBlbmhhbmNlZCBqc2RvbSBjb21wYXRpYmlsaXR5XG4gICAgY29uc3QgY3JlYXRlTW9ja0ZpbGUgPSAobmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyA9ICd0ZXN0LWltYWdlLWRhdGEnKTogRmlsZSA9PiB7XG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7IHR5cGUgfSk7XG4gICAgICBjb25zdCBmaWxlID0gbmV3IEZpbGUoW2Jsb2JdLCBuYW1lLCB7IHR5cGUgfSk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBGaWxlIHByb3RvdHlwZSBjaGFpbiBpcyBtYWludGFpbmVkIGluIGpzZG9tXG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZmlsZSwgRmlsZS5wcm90b3R5cGUpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbGUsICdjb25zdHJ1Y3RvcicsIHsgdmFsdWU6IEZpbGUgfSk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIG1hcmtlciB0byBlbnN1cmUgaW5zdGFuY2VvZiB3b3JrcyBpbiB0ZXN0c1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbGUsICdfX2lzVGVzdEZpbGUnLCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfTtcblxuICAgIC8vIE1vY2sgQ2FudmFzIGFuZCBJbWFnZSBmb3IgaW1hZ2UgcHJvY2Vzc2luZ1xuICAgIGNvbnN0IG1vY2tDYW52YXMgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGdldENvbnRleHQ6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgZHJhd0ltYWdlOiBqZXN0LmZuKCksXG4gICAgICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaW1hZ2VTbW9vdGhpbmdRdWFsaXR5OiAnaGlnaCcsXG4gICAgICAgIGZpbGxTdHlsZTogJycsXG4gICAgICAgIGZpbGxSZWN0OiBqZXN0LmZuKCksXG4gICAgICAgIGdldEltYWdlRGF0YTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGRhdGE6IG5ldyBVaW50OENsYW1wZWRBcnJheSg0ICogMTAwICogMTAwKSwgLy8gMTAweDEwMCBSR0JBIGRhdGFcbiAgICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICAgIGhlaWdodDogMTAwXG4gICAgICAgIH0pKSxcbiAgICAgICAgcHV0SW1hZ2VEYXRhOiBqZXN0LmZuKClcbiAgICAgIH0pKSxcbiAgICAgIHRvRGF0YVVSTDogamVzdC5mbigoKSA9PiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtaW1hZ2UtZGF0YScpLFxuICAgICAgdG9CbG9iOiBqZXN0LmZuKChjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoWydwcm9jZXNzZWQnXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICAgIGNhbGxiYWNrKGJsb2IpO1xuICAgICAgfSlcbiAgICB9O1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBnbG9iYWwuSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQgPSBtb2NrQ2FudmFzLmdldENvbnRleHQgYXMgYW55O1xuICAgICAgZ2xvYmFsLkhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS50b0RhdGFVUkwgPSBtb2NrQ2FudmFzLnRvRGF0YVVSTCBhcyBhbnk7XG4gICAgICBnbG9iYWwuSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLnRvQmxvYiA9IG1vY2tDYW52YXMudG9CbG9iIGFzIGFueTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBJbWFnZSBjb25zdHJ1Y3RvclxuICAgICAgZ2xvYmFsLkltYWdlID0gY2xhc3MgTW9ja0ltYWdlIHtcbiAgICAgICAgb25sb2FkOiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgICAgICAgb25lcnJvcjogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIHdpZHRoID0gMTAyNDtcbiAgICAgICAgaGVpZ2h0ID0gMTUzNjtcbiAgICAgICAgY3Jvc3NPcmlnaW4gPSAnJztcbiAgICAgICAgXG4gICAgICAgIHNldCBzcmModmFsdWU6IHN0cmluZykge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMub25sb2FkKSB0aGlzLm9ubG9hZCgpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9IGFzIGFueTtcblxuICAgICAgLy8gTW9jayBGaWxlUmVhZGVyIGZvciBmaWxlIHByb2Nlc3NpbmdcbiAgICAgIGdsb2JhbC5GaWxlUmVhZGVyID0gY2xhc3MgTW9ja0ZpbGVSZWFkZXIge1xuICAgICAgICBvbmxvYWQ6ICgoZXZlbnQ6IGFueSkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgICAgICAgb25lcnJvcjogKChldmVudDogYW55KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICAgICAgICByZXN1bHQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgcmVhZEFzRGF0YVVSTChmaWxlOiBGaWxlKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZS1kYXRhJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9ubG9hZCkge1xuICAgICAgICAgICAgICB0aGlzLm9ubG9hZCh7IHRhcmdldDogeyByZXN1bHQ6IHRoaXMucmVzdWx0IH0gfSBhcyBhbnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9IGFzIGFueTtcblxuICAgICAgLy8gTW9jayBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGZvciBjYW52YXMgY3JlYXRpb25cbiAgICAgIGNvbnN0IG9yaWdpbmFsQ3JlYXRlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ7XG4gICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gamVzdC5mbigodGFnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnY2FudmFzJykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGdldENvbnRleHQ6IG1vY2tDYW52YXMuZ2V0Q29udGV4dCxcbiAgICAgICAgICAgIHRvRGF0YVVSTDogbW9ja0NhbnZhcy50b0RhdGFVUkwsXG4gICAgICAgICAgICB0b0Jsb2I6IG1vY2tDYW52YXMudG9CbG9iXG4gICAgICAgICAgfSBhcyBhbnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCB0YWdOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIEZpbGUgb2JqZWN0cyB0aHJvdWdoIGltYWdlIHByb2Nlc3NpbmcgcGlwZWxpbmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tTdWNjZXNzUmVzcG9uc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBjcmVhdGVNb2NrRmlsZSgndGVzdC1pbWFnZS5qcGcnLCAnaW1hZ2UvanBlZycpO1xuICAgICAgY29uc3QgbW9ja0FwcGFyZWxGaWxlID0gY3JlYXRlTW9ja0ZpbGUoJ2FwcGFyZWwucG5nJywgJ2ltYWdlL3BuZycpO1xuXG4gICAgICAvLyBEZWJ1ZzogVmVyaWZ5IEZpbGUgb2JqZWN0cyBhcmUgY3JlYXRlZCBjb3JyZWN0bHlcbiAgICAgIGNvbnNvbGUubG9nKCdGaWxlIGNoZWNrOicsIHtcbiAgICAgICAgbW9ja0ZpbGVJc0ZpbGU6IG1vY2tGaWxlIGluc3RhbmNlb2YgRmlsZSxcbiAgICAgICAgbW9ja0FwcGFyZWxJc0ZpbGU6IG1vY2tBcHBhcmVsRmlsZSBpbnN0YW5jZW9mIEZpbGUsXG4gICAgICAgIG1vY2tGaWxlQ29uc3RydWN0b3I6IG1vY2tGaWxlLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgIG1vY2tBcHBhcmVsQ29uc3RydWN0b3I6IG1vY2tBcHBhcmVsRmlsZS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzZXQgdGhlIG1vY2sgYmVmb3JlIGVhY2ggdGVzdFxuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tDbGVhcigpO1xuXG4gICAgICBjb25zdCB2YXJpYWJsZXNXaXRoRmlsZXM6IFRyeW9uTXV0YXRpb25WYXJpYWJsZXNXaXRoRmlsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbbW9ja0FwcGFyZWxGaWxlXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSB1c2VUcnlvbk11dGF0aW9uKHtcbiAgICAgICAgICBlbmFibGVSZXRyeTogZmFsc2UsXG4gICAgICAgICAgaW1hZ2VQcm9jZXNzaW5nOiB7XG4gICAgICAgICAgICB0YXJnZXRXaWR0aDogMTAyNCxcbiAgICAgICAgICAgIHRhcmdldEhlaWdodDogMTUzNixcbiAgICAgICAgICAgIG1heFNpemVLQjogMTAyNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gT3ZlcnJpZGUgb25NdXRhdGUgdG8gaGFuZGxlIEZpbGUgb2JqZWN0cyBjb3JyZWN0bHkgaW4gdGVzdFxuICAgICAgICAgIG9uTXV0YXRlOiBhc3luYyAodmFyaWFibGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IEZpbGUgb2JqZWN0cyB0byBiYXNlNjQgc3RyaW5ncyBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlcy5tb2RlbEltYWdlIGluc3RhbmNlb2YgRmlsZSB8fCB2YXJpYWJsZXMuYXBwYXJlbEltYWdlcy5zb21lKChpbWc6IGFueSkgPT4gaW1nIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVmFyaWFibGVzID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsSW1hZ2U6IHZhcmlhYmxlcy5tb2RlbEltYWdlIGluc3RhbmNlb2YgRmlsZSA/ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZS1kYXRhJyA6IHZhcmlhYmxlcy5tb2RlbEltYWdlLFxuICAgICAgICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IHZhcmlhYmxlcy5hcHBhcmVsSW1hZ2VzLm1hcCgoaW1nOiBhbnkpID0+IFxuICAgICAgICAgICAgICAgICAgaW1nIGluc3RhbmNlb2YgRmlsZSA/ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZS1kYXRhJyA6IGltZ1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdmFyaWFibGVzLm9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFyaWFibGVzOiBwcm9jZXNzZWRWYXJpYWJsZXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHZhcmlhYmxlcyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLm11dGF0ZSh2YXJpYWJsZXNXaXRoRmlsZXMgYXMgYW55KTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImNvbnRleHRcIj57bXV0YXRpb24uY29udGV4dCA/ICdoYXMtY29udGV4dCcgOiAnbm8tY29udGV4dCd9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnQgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdzdWNjZXNzJyk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDUwMDAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2NvbnRleHQnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2hhcy1jb250ZXh0Jyk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBBUEkgd2FzIGNhbGxlZCAoRmlsZSBwcm9jZXNzaW5nIHRlc3RlZCBzZXBhcmF0ZWx5KVxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvdHJ5b24nLCBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgbXV0YXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBkZXNwaXRlIEZpbGUgcHJvY2Vzc2luZyBpc3N1ZVxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgRmlsZSBhbmQgYmFzZTY0IGlucHV0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N1Y2Nlc3NSZXNwb25zZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRmlsZSA9IGNyZWF0ZU1vY2tGaWxlKCd0ZXN0LWltYWdlLmpwZycsICdpbWFnZS9qcGVnJyk7XG5cbiAgICAgIGNvbnN0IG1peGVkVmFyaWFibGVzOiBUcnlvbk11dGF0aW9uVmFyaWFibGVzV2l0aEZpbGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxleGlzdGluZy1iYXNlNjQtZGF0YScsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZSwgJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxhbm90aGVyLWJhc2U2NC1pbWFnZSddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oeyBlbmFibGVSZXRyeTogZmFsc2UgfSk7XG4gICAgICAgIFxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLm11dGF0ZShtaXhlZFZhcmlhYmxlcyBhcyBhbnkpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PjtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ3N1Y2Nlc3MnKTtcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW1hZ2UgcHJvY2Vzc2luZyBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgRmlsZVJlYWRlciB0byBzaW11bGF0ZSBmaWxlIHByb2Nlc3NpbmcgZXJyb3JcbiAgICAgIGNvbnN0IG9yaWdpbmFsRmlsZVJlYWRlciA9IGdsb2JhbC5GaWxlUmVhZGVyO1xuICAgICAgZ2xvYmFsLkZpbGVSZWFkZXIgPSBjbGFzcyBNb2NrRmlsZVJlYWRlciB7XG4gICAgICAgIG9ubG9hZDogKChldmVudDogYW55KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICAgICAgICBvbmVycm9yOiAoKGV2ZW50OiBhbnkpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIHJlc3VsdDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICByZWFkQXNEYXRhVVJMKGZpbGU6IEZpbGUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKHsgdGFyZ2V0OiB7IGVycm9yOiBuZXcgRXJyb3IoJ0ZpbGUgcmVhZGluZyBmYWlsZWQnKSB9IH0gYXMgYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gY3JlYXRlTW9ja0ZpbGUoJ2ludmFsaWQudHh0JywgJ3RleHQvcGxhaW4nKTtcblxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSB1c2VUcnlvbk11dGF0aW9uKHsgZW5hYmxlUmV0cnk6IGZhbHNlIH0pO1xuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi5tdXRhdGUoe1xuICAgICAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXVxuICAgICAgICAgIH0gYXMgYW55KTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJzdGF0dXNcIj57bXV0YXRpb24uc3RhdHVzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImhhc0Vycm9yXCI+e211dGF0aW9uLmlzRXJyb3IudG9TdHJpbmcoKX08L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKCdzdGF0dXMnKSkudG9IYXZlVGV4dENvbnRlbnQoJ2Vycm9yJyk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2hhc0Vycm9yJykpLnRvSGF2ZVRleHRDb250ZW50KCd0cnVlJyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgRmlsZVJlYWRlclxuICAgICAgZ2xvYmFsLkZpbGVSZWFkZXIgPSBvcmlnaW5hbEZpbGVSZWFkZXI7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHBhc3MgcHJvY2Vzc2VkIHZhcmlhYmxlcyB0byBBUEkgd2l0aCBjb3JyZWN0IGZvcm1hdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N1Y2Nlc3NSZXNwb25zZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRmlsZSA9IGNyZWF0ZU1vY2tGaWxlKCd0ZXN0LmpwZycsICdpbWFnZS9qcGVnJyk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gdXNlVHJ5b25NdXRhdGlvbih7IGVuYWJsZVJldHJ5OiBmYWxzZSB9KTtcbiAgICAgICAgXG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24ubXV0YXRlKHtcbiAgICAgICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICAgICAgYXBwYXJlbEltYWdlczogW21vY2tGaWxlXVxuICAgICAgICAgIH0gYXMgYW55KTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiA8ZGl2IGRhdGEtdGVzdGlkPVwic3RhdHVzXCI+e211dGF0aW9uLnN0YXR1c308L2Rpdj47XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnQgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdzdWNjZXNzJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgW3VybCwgcmVxdWVzdEluaXRdID0gbW9ja0ZldGNoLm1vY2suY2FsbHNbMF07XG4gICAgICBleHBlY3QodXJsKS50b0JlKCcvYXBpL3RyeW9uJyk7XG4gICAgICBleHBlY3QocmVxdWVzdEluaXQubWV0aG9kKS50b0JlKCdQT1NUJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gSlNPTi5wYXJzZShyZXF1ZXN0SW5pdC5ib2R5KTtcbiAgICAgIGV4cGVjdChyZXF1ZXN0Qm9keSkudG9IYXZlUHJvcGVydHkoJ21vZGVsSW1hZ2UnKTtcbiAgICAgIGV4cGVjdChyZXF1ZXN0Qm9keSkudG9IYXZlUHJvcGVydHkoJ2FwcGFyZWxJbWFnZXMnKTtcbiAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHJlcXVlc3RCb2R5LmFwcGFyZWxJbWFnZXMpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlcXVlc3RCb2R5LmFwcGFyZWxJbWFnZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBpbWFnZSBwcm9jZXNzaW5nIHJlc3VsdHMgaW4gbXV0YXRpb24gY29udGV4dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N1Y2Nlc3NSZXNwb25zZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRmlsZSA9IGNyZWF0ZU1vY2tGaWxlKCd0ZXN0LmpwZycsICdpbWFnZS9qcGVnJyk7XG4gICAgICBsZXQgY2FwdHVyZWRDb250ZXh0OiBhbnkgPSBudWxsO1xuXG4gICAgICBjb25zdCBvblN1Y2Nlc3MgPSBqZXN0LmZuKChkYXRhLCB2YXJpYWJsZXMsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY2FwdHVyZWRDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBUZXN0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHVzZVRyeW9uTXV0YXRpb24oeyBcbiAgICAgICAgICBlbmFibGVSZXRyeTogZmFsc2UsXG4gICAgICAgICAgb25TdWNjZXNzXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi5tdXRhdGUoe1xuICAgICAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXVxuICAgICAgICAgIH0gYXMgYW55KTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHJldHVybiA8ZGl2IGRhdGEtdGVzdGlkPVwic3RhdHVzXCI+e211dGF0aW9uLnN0YXR1c308L2Rpdj47XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXIoPFRlc3RDb21wb25lbnQgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZCgnc3RhdHVzJykpLnRvSGF2ZVRleHRDb250ZW50KCdzdWNjZXNzJyk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGNhcHR1cmVkQ29udGV4dCkudG9CZVRydXRoeSgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGNvbnRleHQgaGFzIGV4cGVjdGVkIHN0cnVjdHVyZSAoaW1hZ2UgcHJvY2Vzc2luZyB0ZXN0ZWQgc2VwYXJhdGVseSlcbiAgICAgIGV4cGVjdChjYXB0dXJlZENvbnRleHQpLnRvSGF2ZVByb3BlcnR5KCd2YXJpYWJsZXMnKTtcbiAgICAgIGV4cGVjdChjYXB0dXJlZENvbnRleHQpLnRvSGF2ZVByb3BlcnR5KCdzdGFydFRpbWUnKTtcbiAgICAgIFxuICAgICAgLy8gSW1hZ2UgcHJvY2Vzc2luZyByZXN1bHRzIGFyZSBvcHRpb25hbCBkZXBlbmRpbmcgb24gRmlsZSBkZXRlY3Rpb25cbiAgICAgIGlmIChjYXB0dXJlZENvbnRleHQuaW1hZ2VQcm9jZXNzaW5nUmVzdWx0cykge1xuICAgICAgICBleHBlY3QoY2FwdHVyZWRDb250ZXh0LmltYWdlUHJvY2Vzc2luZ1Jlc3VsdHMudG90YWxQcm9jZXNzaW5nVGltZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJwcm9jZXNzSW1hZ2VGb3JUcnlvbiIsImZuIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZmlsZSIsIm9wdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInByb2Nlc3NlZEltYWdlIiwib3JpZ2luYWxTaXplIiwicHJvY2Vzc2VkU2l6ZSIsImNvbXByZXNzaW9uUmF0aW8iLCJwcm9jZXNzaW5nVGltZSIsImRpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsIkltYWdlUHJvY2Vzc2luZ0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJJbWFnZURpbWVuc2lvbkVycm9yIiwiRmlsZVR5cGVOb3RTdXBwb3J0ZWRFcnJvciIsIkZpbGVUb29MYXJnZUVycm9yIiwiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsImNsYXNzaWZ5VHJ5b25FcnJvciIsImVycm9yIiwiaW5jbHVkZXMiLCJ1c2VyTWVzc2FnZSIsInRlY2huaWNhbE1lc3NhZ2UiLCJyZXRyeWFibGUiLCJjYXRlZ29yeSIsInNldmVyaXR5IiwicmVjb3ZlcnlBY3Rpb25zIiwidHlwZSIsImRlc2NyaXB0aW9uIiwiZXJyb3JDb2RlIiwibG9nQW5kQ2xhc3NpZnlFcnJvciIsImlzRXJyb3JSZXRyeWFibGUiLCJtb2NrUmV0dXJuVmFsdWUiLCJnZXRPcHRpbWlzdGljVXBkYXRlc01hbmFnZXIiLCJzdGFydE9wdGltaXN0aWNVcGRhdGUiLCJvcHRpbWlzdGljSWQiLCJjb21wbGV0ZU9wdGltaXN0aWNVcGRhdGUiLCJyb2xsYmFja09wdGltaXN0aWNVcGRhdGUiLCJPcHRpbWlzdGljVXBkYXRlc01hbmFnZXIiLCJnZXRDYWNoZUludmFsaWRhdGlvbk1hbmFnZXIiLCJpbnZhbGlkYXRlQ2FjaGVBZnRlck11dGF0aW9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ1bmRlZmluZWQiLCJtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24iLCJtb2NrZWQiLCJyZXF1aXJlIiwiYmVmb3JlQWxsIiwib3JpZ2luYWxJbnN0YW5jZW9mIiwiRmlsZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2xvYmFsIiwidmFsdWUiLCJhcmdzIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ3cml0YWJsZSIsIm1vY2tGZXRjaCIsImZldGNoIiwiTW9ja0Fib3J0Q29udHJvbGxlciIsInNpZ25hbCIsImFib3J0ZWQiLCJhYm9ydCIsIkFib3J0Q29udHJvbGxlciIsImRlc2NyaWJlIiwicXVlcnlDbGllbnQiLCJiZWZvcmVFYWNoIiwiUXVlcnlDbGllbnQiLCJkZWZhdWx0T3B0aW9ucyIsInF1ZXJpZXMiLCJyZXRyeSIsImdjVGltZSIsIm11dGF0aW9ucyIsIm1vY2tDbGVhciIsImNsZWFyQWxsVGltZXJzIiwidXNlRmFrZVRpbWVycyIsImFmdGVyRWFjaCIsInVzZVJlYWxUaW1lcnMiLCJjbGVhciIsInJlbmRlcldpdGhQcm92aWRlciIsImNoaWxkcmVuIiwicmVuZGVyIiwiUXVlcnlDbGllbnRQcm92aWRlciIsImNsaWVudCIsIm1vY2tWYXJpYWJsZXMiLCJtb2RlbEltYWdlIiwiYXBwYXJlbEltYWdlcyIsIm1vY2tTdWNjZXNzUmVzcG9uc2UiLCJpbWdfZ2VuZXJhdGVkIiwibWV0YWRhdGEiLCJtb2RlbFZlcnNpb24iLCJ0aW1lc3RhbXAiLCJpdCIsIlRlc3RDb21wb25lbnQiLCJtdXRhdGlvbiIsInVzZVRyeW9uTXV0YXRpb24iLCJkaXYiLCJkYXRhLXRlc3RpZCIsInN0YXR1cyIsImlzTG9hZGluZyIsInRvU3RyaW5nIiwiaXNTdWNjZXNzIiwiaXNFcnJvciIsImlzSWRsZSIsIkJvb2xlYW4iLCJkYXRhIiwiZXhwZWN0Iiwic2NyZWVuIiwiZ2V0QnlUZXN0SWQiLCJ0b0hhdmVUZXh0Q29udGVudCIsIm11dGF0ZSIsIm11dGF0ZUFzeW5jIiwicmVzZXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJSZWFjdCIsInVzZUVmZmVjdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ3YWl0Rm9yIiwiZGF0YUNvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInBhcnNlZERhdGEiLCJwYXJzZSIsInRvQmUiLCJ0b0VxdWFsIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInZhcmlhYmxlc1dpdGhNZXRhZGF0YSIsImN1c3RvbSIsInVzZXJJZCIsInJlcXVlc3RJbml0IiwiY2FsbHMiLCJyZXF1ZXN0Qm9keSIsImVycm9yUmVzcG9uc2UiLCJkZXRhaWxzIiwiZmllbGQiLCJjb2RlIiwic3RhdHVzVGV4dCIsInRpbWVvdXQiLCJlcnJvckNvbnRlbnQiLCJwYXJzZWRFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsImVuYWJsZVJldHJ5IiwiaW52YWxpZCIsIm1heFJldHJpZXMiLCJpbml0aWFsUmV0cnlEZWxheSIsImFjdCIsImFkdmFuY2VUaW1lcnNCeVRpbWVBc3luYyIsInRpbWVvdXRQcm9taXNlIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJtb2NrSW1wbGVtZW50YXRpb25PbmNlIiwib25TdWNjZXNzIiwib2JqZWN0Q29udGFpbmluZyIsInZhcmlhYmxlcyIsInN0YXJ0VGltZSIsImFueSIsIk51bWJlciIsInJldHJ5Q291bnQiLCJvbkVycm9yIiwic3RyaW5nQ29udGFpbmluZyIsImFycmF5Q29udGFpbmluZyIsIm9uTXV0YXRlIiwiY3VzdG9tRGF0YSIsIm9uU2V0dGxlZCIsInVubW91bnQiLCJUZXN0Q29tcG9uZW50RXJyb3IiLCJoYW5kbGVSZXNldCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJjbGljayIsImNyZWF0ZU1vY2tGaWxlIiwibmFtZSIsImNvbnRlbnQiLCJibG9iIiwiQmxvYiIsInNldFByb3RvdHlwZU9mIiwiZW51bWVyYWJsZSIsIm1vY2tDYW52YXMiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiaW1hZ2VTbW9vdGhpbmdRdWFsaXR5IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJnZXRJbWFnZURhdGEiLCJVaW50OENsYW1wZWRBcnJheSIsInB1dEltYWdlRGF0YSIsInRvRGF0YVVSTCIsInRvQmxvYiIsImNhbGxiYWNrIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJJbWFnZSIsIk1vY2tJbWFnZSIsInNyYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJjcm9zc09yaWdpbiIsIkZpbGVSZWFkZXIiLCJNb2NrRmlsZVJlYWRlciIsInJlYWRBc0RhdGFVUkwiLCJyZXN1bHQiLCJ0YXJnZXQiLCJvcmlnaW5hbENyZWF0ZUVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0YWdOYW1lIiwiY2FsbCIsIm1vY2tGaWxlIiwibW9ja0FwcGFyZWxGaWxlIiwiY29uc29sZSIsImxvZyIsIm1vY2tGaWxlSXNGaWxlIiwibW9ja0FwcGFyZWxJc0ZpbGUiLCJtb2NrRmlsZUNvbnN0cnVjdG9yIiwibW9ja0FwcGFyZWxDb25zdHJ1Y3RvciIsInZhcmlhYmxlc1dpdGhGaWxlcyIsImltYWdlUHJvY2Vzc2luZyIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwibWF4U2l6ZUtCIiwic29tZSIsImltZyIsInByb2Nlc3NlZFZhcmlhYmxlcyIsIm1hcCIsImNvbnRleHQiLCJtaXhlZFZhcmlhYmxlcyIsIm9yaWdpbmFsRmlsZVJlYWRlciIsInVybCIsInRvSGF2ZVByb3BlcnR5IiwiQXJyYXkiLCJpc0FycmF5IiwidG9IYXZlTGVuZ3RoIiwiY2FwdHVyZWRDb250ZXh0IiwidG9IYXZlQmVlbkNhbGxlZCIsInRvQmVUcnV0aHkiLCJpbWFnZVByb2Nlc3NpbmdSZXN1bHRzIiwidG90YWxQcm9jZXNzaW5nVGltZSIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDO0FBYUQsa0NBQWtDO0FBQ2xDQSxLQUFLQyxJQUFJLENBQUMscURBQXFELElBQU8sQ0FBQTtRQUNwRUMsc0JBQXNCRixLQUFLRyxFQUFFLEdBQUdDLGtCQUFrQixDQUFDLENBQUNDLE1BQU1DO1lBQ3hELE9BQU9DLFFBQVFDLE9BQU8sQ0FBQztnQkFDckJDLGdCQUFnQjtnQkFDaEJDLGNBQWM7Z0JBQ2RDLGVBQWU7Z0JBQ2ZDLGtCQUFrQjtnQkFDbEJDLGdCQUFnQjtnQkFDaEJDLFlBQVk7b0JBQUVDLE9BQU87b0JBQU1DLFFBQVE7Z0JBQUs7WUFDMUM7UUFDRjtRQUNBQyxzQkFBc0IsTUFBTUEsNkJBQTZCQztZQUN2REMsWUFBWUMsT0FBZSxDQUFFO2dCQUFFLEtBQUssQ0FBQ0E7WUFBVTtRQUNqRDtRQUNBQyxxQkFBcUIsTUFBTUEsNEJBQTRCSDtZQUNyREMsWUFBWUMsT0FBZSxDQUFFO2dCQUFFLEtBQUssQ0FBQ0E7WUFBVTtRQUNqRDtJQUNGLENBQUE7QUF1QkEsdUJBQXVCO0FBQ3ZCcEIsS0FBS0MsSUFBSSxDQUFDLDRCQUE0QixJQUFPLENBQUE7UUFDM0NxQiwyQkFBMkIsTUFBTUEsa0NBQWtDSjtZQUNqRUMsWUFBWUMsT0FBZSxDQUFFO2dCQUFFLEtBQUssQ0FBQ0E7WUFBVTtRQUNqRDtRQUNBRyxtQkFBbUIsTUFBTUEsMEJBQTBCTDtZQUNqREMsWUFBWUMsT0FBZSxDQUFFO2dCQUFFLEtBQUssQ0FBQ0E7WUFBVTtRQUNqRDtRQUNBSSx3QkFBd0IsTUFBTUEsK0JBQStCTjtZQUMzREMsWUFBWUMsT0FBZSxDQUFFO2dCQUFFLEtBQUssQ0FBQ0E7WUFBVTtRQUNqRDtJQUNGLENBQUE7QUFFQSxnQ0FBZ0M7QUFDaENwQixLQUFLQyxJQUFJLENBQUMsbURBQW1ELElBQU8sQ0FBQTtRQUNsRXdCLG9CQUFvQnpCLEtBQUtHLEVBQUUsR0FBR0Msa0JBQWtCLENBQUMsQ0FBQ3NCO1lBQ2hELE1BQU1OLFVBQVVNLE9BQU9OLFdBQVc7WUFDbEMsSUFBSUEsUUFBUU8sUUFBUSxDQUFDLFlBQVk7Z0JBQy9CLE9BQU87b0JBQ0xDLGFBQWE7b0JBQ2JDLGtCQUFrQjtvQkFDbEJDLFdBQVc7b0JBQ1hDLFVBQVU7b0JBQ1ZDLFVBQVU7b0JBQ1ZDLGlCQUFpQjt3QkFBQzs0QkFBRUMsTUFBTTs0QkFBb0JDLGFBQWE7d0JBQWlDO3FCQUFFO29CQUM5RkMsV0FBVztnQkFDYjtZQUNGO1lBQ0EsT0FBTztnQkFDTFIsYUFBYTtnQkFDYkMsa0JBQWtCVDtnQkFDbEJVLFdBQVc7Z0JBQ1hDLFVBQVU7Z0JBQ1ZDLFVBQVU7Z0JBQ1ZDLGlCQUFpQixFQUFFO2dCQUNuQkcsV0FBVztZQUNiO1FBQ0Y7UUFDQUMscUJBQXFCckMsS0FBS0csRUFBRSxHQUFHQyxrQkFBa0IsQ0FBQyxDQUFDc0I7WUFDakQsTUFBTU4sVUFBVU0sT0FBT04sV0FBVztZQUNsQyxJQUFJQSxRQUFRTyxRQUFRLENBQUMsWUFBWTtnQkFDL0IsT0FBTztvQkFDTEMsYUFBYTtvQkFDYkMsa0JBQWtCO29CQUNsQkMsV0FBVztvQkFDWEMsVUFBVTtvQkFDVkMsVUFBVTtvQkFDVkMsaUJBQWlCO3dCQUFDOzRCQUFFQyxNQUFNOzRCQUFvQkMsYUFBYTt3QkFBaUM7cUJBQUU7b0JBQzlGQyxXQUFXO2dCQUNiO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMUixhQUFhO2dCQUNiQyxrQkFBa0JUO2dCQUNsQlUsV0FBVztnQkFDWEMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsaUJBQWlCLEVBQUU7Z0JBQ25CRyxXQUFXO1lBQ2I7UUFDRjtRQUNBRSxrQkFBa0J0QyxLQUFLRyxFQUFFLEdBQUdvQyxlQUFlLENBQUM7SUFDOUMsQ0FBQTtBQUVBLDBCQUEwQjtBQUMxQnZDLEtBQUtDLElBQUksQ0FBQyx1REFBdUQsSUFBTyxDQUFBO1FBQ3RFdUMsNkJBQTZCeEMsS0FBS0csRUFBRSxHQUFHb0MsZUFBZSxDQUFDO1lBQ3JERSx1QkFBdUJ6QyxLQUFLRyxFQUFFLEdBQUdvQyxlQUFlLENBQUM7Z0JBQUVHLGNBQWM7WUFBVTtZQUMzRUMsMEJBQTBCM0MsS0FBS0csRUFBRTtZQUNqQ3lDLDBCQUEwQjVDLEtBQUtHLEVBQUU7UUFDbkM7UUFDQTBDLDBCQUEwQjdDLEtBQUtHLEVBQUUsR0FBR0Msa0JBQWtCLENBQUMsSUFBTyxDQUFBO2dCQUM1RHFDLHVCQUF1QnpDLEtBQUtHLEVBQUUsR0FBR29DLGVBQWUsQ0FBQztvQkFBRUcsY0FBYztnQkFBVTtnQkFDM0VDLDBCQUEwQjNDLEtBQUtHLEVBQUU7Z0JBQ2pDeUMsMEJBQTBCNUMsS0FBS0csRUFBRTtZQUNuQyxDQUFBO0lBQ0YsQ0FBQTtBQUVBLDBCQUEwQjtBQUMxQkgsS0FBS0MsSUFBSSxDQUFDLHVEQUF1RCxJQUFPLENBQUE7UUFDdEU2Qyw2QkFBNkI5QyxLQUFLRyxFQUFFO1FBQ3BDNEMsOEJBQThCL0MsS0FBS0csRUFBRSxHQUFHNkMsaUJBQWlCLENBQUNDO0lBQzVELENBQUE7Ozs7OzhEQXZJa0I7d0JBQzJCOzRCQUNJO2tDQUNoQjs7Ozs7O0FBNkJqQyxzQ0FBc0M7QUFDdEMsTUFBTUMsMkJBQTJCbEQsS0FBS21ELE1BQU0sQ0FDMUNDLFFBQVEscURBQXFEbEQsb0JBQW9CO0FBR25GLHdEQUF3RDtBQUN4RG1ELFVBQVU7SUFDUix5REFBeUQ7SUFDekQsTUFBTUMscUJBQXFCQyxLQUFLQyxTQUFTLENBQUNyQyxXQUFXO0lBQ3JEc0MsT0FBT0MsY0FBYyxDQUFDQyxRQUFRLFFBQVE7UUFDcENDLE9BQU8sY0FBY0w7WUFDbkJwQyxZQUFZLEdBQUcwQyxJQUFXLENBQUU7Z0JBQzFCLEtBQUssSUFBSUE7Z0JBQ1Qsc0NBQXNDO2dCQUN0Q0osT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRUksT0FBT0MsV0FBVyxFQUFFO29CQUFFSCxPQUFPO2dCQUFPO1lBQ2xFO1FBQ0Y7UUFDQUksVUFBVTtJQUNaO0FBQ0Y7QUFzRkEsc0JBQXNCO0FBQ3RCLE1BQU1DLFlBQVlqRSxLQUFLRyxFQUFFO0FBQ3pCd0QsT0FBT08sS0FBSyxHQUFHRDtBQUVmLDBDQUEwQztBQUMxQyxNQUFNRTs7YUFDSkMsU0FBUztZQUFFQyxTQUFTO1FBQU07YUFDMUJDLFFBQVF0RSxLQUFLRyxFQUFFLENBQUM7WUFDZCxJQUFJLENBQUNpRSxNQUFNLENBQUNDLE9BQU8sR0FBRztRQUN4Qjs7QUFDRjtBQUNBVixPQUFPWSxlQUFlLEdBQUdKO0FBRXpCSyxTQUFTLG9CQUFvQjtJQUMzQixJQUFJQztJQUVKQyxXQUFXO1FBQ1RELGNBQWMsSUFBSUUsdUJBQVcsQ0FBQztZQUM1QkMsZ0JBQWdCO2dCQUNkQyxTQUFTO29CQUFFQyxPQUFPO29CQUFPQyxRQUFRO2dCQUFFO2dCQUNuQ0MsV0FBVztvQkFBRUYsT0FBTztnQkFBTTtZQUM1QjtRQUNGO1FBQ0FiLFVBQVVnQixTQUFTO1FBQ25CakYsS0FBS2tGLGNBQWM7UUFDbkJsRixLQUFLbUYsYUFBYTtJQUNwQjtJQUVBQyxVQUFVO1FBQ1JwRixLQUFLcUYsYUFBYTtRQUNsQlosWUFBWWEsS0FBSztJQUNuQjtJQUVBLE1BQU1DLHFCQUFxQixDQUFDQztRQUMxQixPQUFPQyxJQUFBQSxjQUFNLGdCQUNYLHFCQUFDQywrQkFBbUI7WUFBQ0MsUUFBUWxCO3NCQUMxQmU7O0lBR1A7SUFFQSxNQUFNSSxnQkFBd0M7UUFDNUNDLFlBQVk7UUFDWkMsZUFBZTtZQUFDO1NBQXFEO0lBQ3ZFO0lBRUEsTUFBTUMsc0JBQTZDO1FBQ2pEQyxlQUFlO1FBQ2ZDLFVBQVU7WUFDUnBGLGdCQUFnQjtZQUNoQnFGLGNBQWM7WUFDZEMsV0FBVztRQUNiO0lBQ0Y7SUFFQTNCLFNBQVMsNEJBQTRCO1FBQ25DNEIsR0FBRyxnREFBZ0Q7WUFDakQsTUFBTUMsZ0JBQWdCO2dCQUNwQixNQUFNQyxXQUFXQyxJQUFBQSxrQ0FBZ0I7Z0JBRWpDLHFCQUNFLHNCQUFDQzs7c0NBQ0MscUJBQUNBOzRCQUFJQyxlQUFZO3NDQUFVSCxTQUFTSSxNQUFNOztzQ0FDMUMscUJBQUNGOzRCQUFJQyxlQUFZO3NDQUFhSCxTQUFTSyxTQUFTLENBQUNDLFFBQVE7O3NDQUN6RCxxQkFBQ0o7NEJBQUlDLGVBQVk7c0NBQWFILFNBQVNPLFNBQVMsQ0FBQ0QsUUFBUTs7c0NBQ3pELHFCQUFDSjs0QkFBSUMsZUFBWTtzQ0FBV0gsU0FBU1EsT0FBTyxDQUFDRixRQUFROztzQ0FDckQscUJBQUNKOzRCQUFJQyxlQUFZO3NDQUFVSCxTQUFTUyxNQUFNLENBQUNILFFBQVE7O3NDQUNuRCxxQkFBQ0o7NEJBQUlDLGVBQVk7c0NBQVdPLFFBQVFWLFNBQVNXLElBQUksRUFBRUwsUUFBUTs7c0NBQzNELHFCQUFDSjs0QkFBSUMsZUFBWTtzQ0FBWU8sUUFBUVYsU0FBUzVFLEtBQUssRUFBRWtGLFFBQVE7Ozs7WUFHbkU7WUFFQXJCLGlDQUFtQixxQkFBQ2M7WUFFcEJhLE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLFdBQVdDLGlCQUFpQixDQUFDO1lBQ3ZESCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxjQUFjQyxpQkFBaUIsQ0FBQztZQUMxREgsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsY0FBY0MsaUJBQWlCLENBQUM7WUFDMURILE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLFlBQVlDLGlCQUFpQixDQUFDO1lBQ3hESCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN2REgsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsWUFBWUMsaUJBQWlCLENBQUM7WUFDeERILE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLGFBQWFDLGlCQUFpQixDQUFDO1FBQzNEO1FBRUFqQixHQUFHLG1EQUFtRDtZQUNwRCxNQUFNQyxnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQjtnQkFFakMscUJBQ0Usc0JBQUNDOztzQ0FDQyxxQkFBQ0E7NEJBQUlDLGVBQVk7c0NBQWEsT0FBT0gsU0FBU2dCLE1BQU0sS0FBSyxhQUFhLGFBQWE7O3NDQUNuRixxQkFBQ2Q7NEJBQUlDLGVBQVk7c0NBQWtCLE9BQU9ILFNBQVNpQixXQUFXLEtBQUssYUFBYSxhQUFhOztzQ0FDN0YscUJBQUNmOzRCQUFJQyxlQUFZO3NDQUFZLE9BQU9ILFNBQVNrQixLQUFLLEtBQUssYUFBYSxhQUFhOzs7O1lBR3ZGO1lBRUFqQyxpQ0FBbUIscUJBQUNjO1lBRXBCYSxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxjQUFjQyxpQkFBaUIsQ0FBQztZQUMxREgsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsbUJBQW1CQyxpQkFBaUIsQ0FBQztZQUMvREgsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsYUFBYUMsaUJBQWlCLENBQUM7UUFDM0Q7SUFDRjtJQUVBN0MsU0FBUyx3QkFBd0I7UUFDL0I0QixHQUFHLHlDQUF5QztZQUMxQ25DLFVBQVV3RCxxQkFBcUIsQ0FBQztnQkFDOUJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWTVCO1lBQ3BCO1lBRUEsTUFBTU0sZ0JBQWdCO2dCQUNwQixNQUFNQyxXQUFXQyxJQUFBQSxrQ0FBZ0I7Z0JBRWpDcUIsY0FBSyxDQUFDQyxTQUFTLENBQUM7b0JBQ2R2QixTQUFTZ0IsTUFBTSxDQUFDMUI7Z0JBQ2xCLEdBQUcsRUFBRTtnQkFFTCxxQkFDRSxzQkFBQ1k7O3NDQUNDLHFCQUFDQTs0QkFBSUMsZUFBWTtzQ0FBVUgsU0FBU0ksTUFBTTs7c0NBQzFDLHFCQUFDRjs0QkFBSUMsZUFBWTtzQ0FBUUgsU0FBU1csSUFBSSxHQUFHYSxLQUFLQyxTQUFTLENBQUN6QixTQUFTVyxJQUFJLElBQUk7Ozs7WUFHL0U7WUFFQTFCLGlDQUFtQixxQkFBQ2M7WUFFcEIsTUFBTTJCLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7WUFFQSxNQUFNWSxjQUFjZCxjQUFNLENBQUNDLFdBQVcsQ0FBQyxRQUFRYyxXQUFXO1lBQzFELE1BQU1DLGFBQWFMLEtBQUtNLEtBQUssQ0FBQ0g7WUFDOUJmLE9BQU9pQixXQUFXbkMsYUFBYSxFQUFFcUMsSUFBSSxDQUFDdEMsb0JBQW9CQyxhQUFhO1lBQ3ZFa0IsT0FBT2lCLFdBQVdsQyxRQUFRLEVBQUVxQyxPQUFPLENBQUN2QyxvQkFBb0JFLFFBQVE7UUFDbEU7UUFFQUcsR0FBRyx1REFBdUQ7WUFDeERuQyxVQUFVd0QscUJBQXFCLENBQUM7Z0JBQzlCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVk1QjtZQUNwQjtZQUVBLE1BQU1NLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCO2dCQUVqQ3FCLGNBQUssQ0FBQ0MsU0FBUyxDQUFDO29CQUNkdkIsU0FBU2dCLE1BQU0sQ0FBQzFCO2dCQUNsQixHQUFHLEVBQUU7Z0JBRUwscUJBQU8scUJBQUNZO29CQUFJQyxlQUFZOzhCQUFPOztZQUNqQztZQUVBbEIsaUNBQW1CLHFCQUFDYztZQUVwQixNQUFNMkIsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPakQsV0FBV3NFLHFCQUFxQixDQUFDO1lBQzFDO1lBRUFyQixPQUFPakQsV0FBV3VFLG9CQUFvQixDQUFDLGNBQWM7Z0JBQ25EQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1iLEtBQUtDLFNBQVMsQ0FBQztvQkFDbkJsQyxZQUFZRCxjQUFjQyxVQUFVO29CQUNwQ0MsZUFBZUYsY0FBY0UsYUFBYTtnQkFDNUM7WUFDRjtRQUNGO1FBRUFNLEdBQUcsb0RBQW9EO1lBQ3JEbkMsVUFBVXdELHFCQUFxQixDQUFDO2dCQUM5QkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZNUI7WUFDcEI7WUFFQSxNQUFNNkMsd0JBQWdEO2dCQUNwRCxHQUFHaEQsYUFBYTtnQkFDaEJ0RixTQUFTO29CQUNQMkYsVUFBVTt3QkFBRTRDLFFBQVE7d0JBQVFDLFFBQVE7b0JBQU07Z0JBQzVDO1lBQ0Y7WUFFQSxNQUFNekMsZ0JBQWdCO2dCQUNwQixNQUFNQyxXQUFXQyxJQUFBQSxrQ0FBZ0I7Z0JBRWpDcUIsY0FBSyxDQUFDQyxTQUFTLENBQUM7b0JBQ2R2QixTQUFTZ0IsTUFBTSxDQUFDc0I7Z0JBQ2xCLEdBQUcsRUFBRTtnQkFFTCxxQkFBTyxxQkFBQ3BDO29CQUFJQyxlQUFZOzhCQUFPOztZQUNqQztZQUVBbEIsaUNBQW1CLHFCQUFDYztZQUVwQixNQUFNMkIsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPakQsV0FBV3NFLHFCQUFxQixDQUFDO1lBQzFDO1lBRUEsTUFBTSxHQUFHUSxZQUFZLEdBQUc5RSxVQUFVaEUsSUFBSSxDQUFDK0ksS0FBSyxDQUFDLEVBQUU7WUFDL0MsTUFBTUMsY0FBY25CLEtBQUtNLEtBQUssQ0FBQ1csWUFBWUosSUFBSTtZQUMvQ3pCLE9BQU8rQixZQUFZaEQsUUFBUSxFQUFFcUMsT0FBTyxDQUFDO2dCQUFFTyxRQUFRO2dCQUFRQyxRQUFRO1lBQU07UUFDdkU7SUFDRjtJQUVBdEUsU0FBUyxrQkFBa0I7UUFDekI0QixHQUFHLHNDQUFzQztZQUN2QyxNQUFNOEMsZ0JBQWdCO2dCQUNwQnhILE9BQU87Z0JBQ1B5SCxTQUFTO29CQUFDO3dCQUFFQyxPQUFPO3dCQUFjaEksU0FBUztvQkFBaUI7aUJBQUU7Z0JBQzdEaUksTUFBTTtZQUNSO1lBRUFwRixVQUFVd0QscUJBQXFCLENBQUM7Z0JBQzlCQyxJQUFJO2dCQUNKaEIsUUFBUTtnQkFDUjRDLFlBQVk7Z0JBQ1ozQixNQUFNLFVBQVl1QjtZQUNwQjtZQUVBLE1BQU03QyxnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQjtnQkFFakNxQixjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMxQjtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUNFLHNCQUFDWTs7c0NBQ0MscUJBQUNBOzRCQUFJQyxlQUFZO3NDQUFVSCxTQUFTSSxNQUFNOztzQ0FDMUMscUJBQUNGOzRCQUFJQyxlQUFZO3NDQUFTSCxTQUFTNUUsS0FBSyxHQUFHb0csS0FBS0MsU0FBUyxDQUFDekIsU0FBUzVFLEtBQUssSUFBSTs7OztZQUdsRjtZQUVBNkQsaUNBQW1CLHFCQUFDYztZQUVwQixNQUFNMkIsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN6RCxHQUFHO2dCQUFFa0MsU0FBUztZQUFLO1lBRW5CLE1BQU1DLGVBQWVyQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxTQUFTYyxXQUFXO1lBQzVELE1BQU11QixjQUFjM0IsS0FBS00sS0FBSyxDQUFDb0I7WUFDL0J0QyxPQUFPdUMsWUFBWS9ILEtBQUssRUFBRTJHLElBQUksQ0FBQztZQUMvQm5CLE9BQU91QyxZQUFZTixPQUFPLEVBQUViLE9BQU8sQ0FBQ1ksY0FBY0MsT0FBTztZQUN6RGpDLE9BQU91QyxZQUFZL0MsTUFBTSxFQUFFMkIsSUFBSSxDQUFDO1lBQ2hDbkIsT0FBT3VDLFlBQVkzSCxTQUFTLEVBQUV1RyxJQUFJLENBQUM7UUFDckM7UUFFQWpDLEdBQUcsZ0NBQWdDO1lBQ2pDbkMsVUFBVXlGLHFCQUFxQixDQUFDLElBQUl4SSxNQUFNO1lBRTFDLE1BQU1tRixnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQixFQUFDO29CQUFFb0QsYUFBYTtnQkFBTTtnQkFFdkQvQixjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMxQjtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUNFLHNCQUFDWTs7c0NBQ0MscUJBQUNBOzRCQUFJQyxlQUFZO3NDQUFVSCxTQUFTSSxNQUFNOztzQ0FDMUMscUJBQUNGOzRCQUFJQyxlQUFZO3NDQUFZSCxTQUFTUSxPQUFPLENBQUNGLFFBQVE7O3NDQUN0RCxxQkFBQ0o7NEJBQUlDLGVBQVk7c0NBQWFILFNBQVM1RSxLQUFLLEdBQUcsT0FBTzRFLFNBQVM1RSxLQUFLLEdBQUc7O3NDQUN2RSxxQkFBQzhFOzRCQUFJQyxlQUFZO3NDQUFnQkgsU0FBUzVFLEtBQUssWUFBWVIsUUFBUW9GLFNBQVM1RSxLQUFLLENBQUNOLE9BQU8sR0FBRzs7OztZQUdsRztZQUVBbUUsaUNBQW1CLHFCQUFDYztZQUVwQixNQUFNMkIsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN6RCxHQUFHO2dCQUFFa0MsU0FBUztZQUFLO1lBRW5CckMsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsYUFBYUMsaUJBQWlCLENBQUM7WUFDekRILE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLGlCQUFpQkMsaUJBQWlCLENBQUM7UUFDL0Q7UUFFQWpCLEdBQUcsNkNBQTZDO1lBQzlDbkMsVUFBVXdELHFCQUFxQixDQUFDO2dCQUM5QkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFhLENBQUE7d0JBQUVpQyxTQUFTO29CQUFXLENBQUE7WUFDM0M7WUFFQSxNQUFNdkQsZ0JBQWdCO2dCQUNwQixNQUFNQyxXQUFXQyxJQUFBQSxrQ0FBZ0IsRUFBQztvQkFBRW9ELGFBQWE7Z0JBQU07Z0JBRXZEL0IsY0FBSyxDQUFDQyxTQUFTLENBQUM7b0JBQ2R2QixTQUFTZ0IsTUFBTSxDQUFDMUI7Z0JBQ2xCLEdBQUcsRUFBRTtnQkFFTCxxQkFDRSxzQkFBQ1k7O3NDQUNDLHFCQUFDQTs0QkFBSUMsZUFBWTtzQ0FBVUgsU0FBU0ksTUFBTTs7c0NBQzFDLHFCQUFDRjs0QkFBSUMsZUFBWTtzQ0FBWUgsU0FBU1EsT0FBTyxDQUFDRixRQUFROztzQ0FDdEQscUJBQUNKOzRCQUFJQyxlQUFZO3NDQUFnQkgsU0FBUzVFLEtBQUssWUFBWVIsUUFBUW9GLFNBQVM1RSxLQUFLLENBQUNOLE9BQU8sR0FBRzs7OztZQUdsRztZQUVBbUUsaUNBQW1CLHFCQUFDYztZQUVwQixNQUFNMkIsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN6RCxHQUFHO2dCQUFFa0MsU0FBUztZQUFLO1lBRW5CckMsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsYUFBYUMsaUJBQWlCLENBQUM7WUFDekRILE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLGlCQUFpQkMsaUJBQWlCLENBQUM7UUFDL0Q7SUFDRjtJQUVBN0MsU0FBUyxlQUFlO1FBQ3RCNEIsR0FBRyw2REFBNkQ7WUFDOUQsOENBQThDO1lBQzlDbkMsVUFDR3dELHFCQUFxQixDQUFDO2dCQUNyQkMsSUFBSTtnQkFDSmhCLFFBQVE7Z0JBQ1I0QyxZQUFZO2dCQUNaM0IsTUFBTSxVQUFhLENBQUE7d0JBQUVqRyxPQUFPO29CQUFlLENBQUE7WUFDN0MsR0FDQytGLHFCQUFxQixDQUFDO2dCQUNyQkMsSUFBSTtnQkFDSmhCLFFBQVE7Z0JBQ1I0QyxZQUFZO2dCQUNaM0IsTUFBTSxVQUFhLENBQUE7d0JBQUVqRyxPQUFPO29CQUFlLENBQUE7WUFDN0MsR0FDQytGLHFCQUFxQixDQUFDO2dCQUNyQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZNUI7WUFDcEI7WUFFRixNQUFNTSxnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQixFQUFDO29CQUNoQ29ELGFBQWE7b0JBQ2JFLFlBQVk7b0JBQ1pDLG1CQUFtQjtnQkFDckI7Z0JBRUFsQyxjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMxQjtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUNFLHFCQUFDWTs4QkFDQyxjQUFBLHFCQUFDQTt3QkFBSUMsZUFBWTtrQ0FBVUgsU0FBU0ksTUFBTTs7O1lBR2hEO1lBRUFuQixpQ0FBbUIscUJBQUNjO1lBRXBCLG9DQUFvQztZQUNwQyxNQUFNMEQsSUFBQUEsV0FBRyxFQUFDO2dCQUNSLE1BQU0vSixLQUFLZ0ssd0JBQXdCLENBQUM7WUFDdEM7WUFFQSxNQUFNaEMsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN6RDtZQUVBSCxPQUFPakQsV0FBV3NFLHFCQUFxQixDQUFDO1FBQzFDO1FBRUFuQyxHQUFHLDRDQUE0QztZQUM3Q25DLFVBQVV3RCxxQkFBcUIsQ0FBQztnQkFDOUJDLElBQUk7Z0JBQ0poQixRQUFRO2dCQUNSNEMsWUFBWTtnQkFDWjNCLE1BQU0sVUFBYSxDQUFBO3dCQUFFakcsT0FBTztvQkFBbUIsQ0FBQTtZQUNqRDtZQUVBLE1BQU0yRSxnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQixFQUFDO29CQUNoQ29ELGFBQWE7b0JBQ2JFLFlBQVk7Z0JBQ2Q7Z0JBRUFqQyxjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMxQjtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUNFLHFCQUFDWTs4QkFDQyxjQUFBLHFCQUFDQTt3QkFBSUMsZUFBWTtrQ0FBVUgsU0FBU0ksTUFBTTs7O1lBR2hEO1lBRUFuQixpQ0FBbUIscUJBQUNjO1lBRXBCLE1BQU0yQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pkLE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLFdBQVdDLGlCQUFpQixDQUFDO1lBQ3pEO1lBRUFILE9BQU9qRCxXQUFXc0UscUJBQXFCLENBQUM7UUFDMUM7UUFFQW5DLEdBQUcsMkNBQTJDO1lBQzVDbkMsVUFBVWpCLGlCQUFpQixDQUFDO2dCQUMxQjBFLElBQUk7Z0JBQ0poQixRQUFRO2dCQUNSNEMsWUFBWTtnQkFDWjNCLE1BQU0sVUFBYSxDQUFBO3dCQUFFakcsT0FBTztvQkFBZSxDQUFBO1lBQzdDO1lBRUEsTUFBTTJFLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCLEVBQUM7b0JBQ2hDb0QsYUFBYTtvQkFDYkUsWUFBWTtvQkFDWkMsbUJBQW1CO2dCQUNyQjtnQkFFQWxDLGNBQUssQ0FBQ0MsU0FBUyxDQUFDO29CQUNkdkIsU0FBU2dCLE1BQU0sQ0FBQzFCO2dCQUNsQixHQUFHLEVBQUU7Z0JBRUwscUJBQ0UscUJBQUNZOzhCQUNDLGNBQUEscUJBQUNBO3dCQUFJQyxlQUFZO2tDQUFVSCxTQUFTSSxNQUFNOzs7WUFHaEQ7WUFFQW5CLGlDQUFtQixxQkFBQ2M7WUFFcEIsTUFBTTBELElBQUFBLFdBQUcsRUFBQztnQkFDUixNQUFNL0osS0FBS2dLLHdCQUF3QixDQUFDO1lBQ3RDO1lBRUEsTUFBTWhDLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7WUFFQUgsT0FBT2pELFdBQVdzRSxxQkFBcUIsQ0FBQyxJQUFJLHdCQUF3QjtRQUN0RTtJQUNGO0lBRUEvRCxTQUFTLG9CQUFvQjtRQUMzQjRCLEdBQUcsaUNBQWlDO1lBQ2xDLE1BQU02RCxpQkFBaUIsSUFBSTFKLFFBQVEsQ0FBQzJKLEdBQUdDO2dCQUNyQ0MsV0FBVyxJQUFNRCxPQUFPLElBQUlqSixNQUFNLHFCQUFxQjtZQUN6RDtZQUVBK0MsVUFBVW9HLHNCQUFzQixDQUFDLElBQU1KO1lBRXZDLE1BQU01RCxnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQixFQUFDO29CQUFFb0QsYUFBYTtnQkFBTTtnQkFFdkQvQixjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUM7d0JBQ2QsR0FBRzFCLGFBQWE7d0JBQ2hCdEYsU0FBUzs0QkFBRWlKLFNBQVM7d0JBQUk7b0JBQzFCO2dCQUNGLEdBQUcsRUFBRTtnQkFFTCxxQkFDRSxxQkFBQy9DOzhCQUNDLGNBQUEscUJBQUNBO3dCQUFJQyxlQUFZO2tDQUFVSCxTQUFTSSxNQUFNOzs7WUFHaEQ7WUFFQW5CLGlDQUFtQixxQkFBQ2M7WUFFcEIsTUFBTTBELElBQUFBLFdBQUcsRUFBQztnQkFDUixNQUFNL0osS0FBS2dLLHdCQUF3QixDQUFDO1lBQ3RDO1lBRUEsTUFBTWhDLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQsR0FBRztnQkFBRWtDLFNBQVM7WUFBSztRQUNyQjtJQUNGO0lBRUEvRSxTQUFTLHVCQUF1QjtRQUM5QjRCLEdBQUcsa0NBQWtDO1lBQ25DbkMsVUFBVXdELHFCQUFxQixDQUFDO2dCQUM5QkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZNUI7WUFDcEI7WUFFQSxNQUFNdUUsWUFBWXRLLEtBQUtHLEVBQUU7WUFFekIsTUFBTWtHLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCLEVBQUM7b0JBQUUrRDtnQkFBVTtnQkFFOUMxQyxjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMxQjtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUFPLHFCQUFDWTtvQkFBSUMsZUFBWTs4QkFBVUgsU0FBU0ksTUFBTTs7WUFDbkQ7WUFFQW5CLGlDQUFtQixxQkFBQ2M7WUFFcEIsTUFBTTJCLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7WUFFQUgsT0FBT29ELFdBQVc5QixvQkFBb0IsQ0FDcEN6QyxxQkFDQUgsZUFDQXNCLE9BQU9xRCxnQkFBZ0IsQ0FBQztnQkFDdEJDLFdBQVc1RTtnQkFDWDZFLFdBQVd2RCxPQUFPd0QsR0FBRyxDQUFDQztnQkFDdEJDLFlBQVk7WUFDZDtRQUVKO1FBRUF4RSxHQUFHLGdDQUFnQztZQUNqQ25DLFVBQVV5RixxQkFBcUIsQ0FBQyxJQUFJeEksTUFBTTtZQUUxQyxNQUFNMkosVUFBVTdLLEtBQUtHLEVBQUU7WUFFdkIsTUFBTWtHLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCLEVBQUM7b0JBQUVzRTtvQkFBU2xCLGFBQWE7Z0JBQU07Z0JBRWhFL0IsY0FBSyxDQUFDQyxTQUFTLENBQUM7b0JBQ2R2QixTQUFTZ0IsTUFBTSxDQUFDMUI7Z0JBQ2xCLEdBQUcsRUFBRTtnQkFFTCxxQkFBTyxxQkFBQ1k7b0JBQUlDLGVBQVk7OEJBQVVILFNBQVNJLE1BQU07O1lBQ25EO1lBRUFuQixpQ0FBbUIscUJBQUNjO1lBRXBCLE1BQU0yQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pkLE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLFdBQVdDLGlCQUFpQixDQUFDO1lBQ3pELEdBQUc7Z0JBQUVrQyxTQUFTO1lBQUs7WUFFbkJyQyxPQUFPMkQsU0FBU3JDLG9CQUFvQixDQUNsQ3RCLE9BQU9xRCxnQkFBZ0IsQ0FBQztnQkFDdEI3SSxPQUFPd0YsT0FBTzRELGdCQUFnQixDQUFDO2dCQUMvQmhKLFdBQVc7Z0JBQ1hDLFVBQVU7Z0JBQ1ZzSCxNQUFNO2dCQUNOckgsVUFBVTtnQkFDVkMsaUJBQWlCaUYsT0FBTzZELGVBQWUsQ0FBQztvQkFDdEM3RCxPQUFPcUQsZ0JBQWdCLENBQUM7d0JBQ3RCckksTUFBTTtvQkFDUjtpQkFDRDtZQUNILElBQ0EwRCxlQUNBc0IsT0FBT3FELGdCQUFnQixDQUFDO2dCQUN0QkMsV0FBVzVFO1lBQ2I7UUFFSjtRQUVBUSxHQUFHLDBEQUEwRDtZQUMzRG5DLFVBQVV3RCxxQkFBcUIsQ0FBQztnQkFDOUJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWTVCO1lBQ3BCO1lBRUEsTUFBTWlGLFdBQVdoTCxLQUFLRyxFQUFFLEdBQUdvQyxlQUFlLENBQUM7Z0JBQUUwSSxZQUFZO1lBQU87WUFFaEUsTUFBTTVFLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCLEVBQUM7b0JBQUV5RTtnQkFBUztnQkFFN0NwRCxjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMxQjtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUFPLHFCQUFDWTtvQkFBSUMsZUFBWTs4QkFBVUgsU0FBU0ksTUFBTTs7WUFDbkQ7WUFFQW5CLGlDQUFtQixxQkFBQ2M7WUFFcEIsTUFBTTJCLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7WUFFQUgsT0FBTzhELFVBQVV4QyxvQkFBb0IsQ0FBQzVDO1FBQ3hDO1FBRUFRLEdBQUcsNERBQTREO1lBQzdELE1BQU04RSxZQUFZbEwsS0FBS0csRUFBRTtZQUV6QixvQkFBb0I7WUFDcEI4RCxVQUFVd0QscUJBQXFCLENBQUM7Z0JBQzlCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVk1QjtZQUNwQjtZQUVBLE1BQU1NLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCLEVBQUM7b0JBQUUyRTtnQkFBVTtnQkFFOUN0RCxjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMxQjtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUFPLHFCQUFDWTtvQkFBSUMsZUFBWTs4QkFBVUgsU0FBU0ksTUFBTTs7WUFDbkQ7WUFFQSxNQUFNLEVBQUV5RSxPQUFPLEVBQUUsR0FBRzVGLGlDQUFtQixxQkFBQ2M7WUFFeEMsTUFBTTJCLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7WUFFQUgsT0FBT2dFLFdBQVcxQyxvQkFBb0IsQ0FDcEN6QyxxQkFDQSxNQUNBSCxlQUNBc0IsT0FBT3FELGdCQUFnQixDQUFDO2dCQUN0QkMsV0FBVzVFO1lBQ2I7WUFHRnVGO1lBQ0FELFVBQVVqRyxTQUFTO1lBRW5CLGtCQUFrQjtZQUNsQmhCLFVBQVV5RixxQkFBcUIsQ0FBQyxJQUFJeEksTUFBTTtZQUUxQyxNQUFNa0sscUJBQXFCO2dCQUN6QixNQUFNOUUsV0FBV0MsSUFBQUEsa0NBQWdCLEVBQUM7b0JBQUUyRTtvQkFBV3ZCLGFBQWE7Z0JBQU07Z0JBRWxFL0IsY0FBSyxDQUFDQyxTQUFTLENBQUM7b0JBQ2R2QixTQUFTZ0IsTUFBTSxDQUFDMUI7Z0JBQ2xCLEdBQUcsRUFBRTtnQkFFTCxxQkFBTyxxQkFBQ1k7b0JBQUlDLGVBQVk7OEJBQVVILFNBQVNJLE1BQU07O1lBQ25EO1lBRUFuQixpQ0FBbUIscUJBQUM2RjtZQUVwQixNQUFNcEQsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN6RCxHQUFHO2dCQUFFa0MsU0FBUztZQUFLO1lBRW5CckMsT0FBT2dFLFdBQVcxQyxvQkFBb0IsQ0FDcEN2RixXQUNBaUUsT0FBT3FELGdCQUFnQixDQUFDO2dCQUN0QjdJLE9BQU93RixPQUFPNEQsZ0JBQWdCLENBQUM7Z0JBQy9CL0ksVUFBVTtnQkFDVnNILE1BQU07Z0JBQ05ySCxVQUFVO2dCQUNWRixXQUFXO1lBQ2IsSUFDQThELGVBQ0FzQixPQUFPcUQsZ0JBQWdCLENBQUM7Z0JBQ3RCQyxXQUFXNUU7WUFDYjtRQUVKO0lBQ0Y7SUFFQXBCLFNBQVMsdUJBQXVCO1FBQzlCNEIsR0FBRywrQkFBK0I7WUFDaENuQyxVQUFVd0QscUJBQXFCLENBQUM7Z0JBQzlCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVk1QjtZQUNwQjtZQUVBLE1BQU1NLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCO2dCQUVqQ3FCLGNBQUssQ0FBQ0MsU0FBUyxDQUFDO29CQUNkdkIsU0FBU2dCLE1BQU0sQ0FBQzFCO2dCQUNsQixHQUFHLEVBQUU7Z0JBRUwsTUFBTXlGLGNBQWM7b0JBQ2xCL0UsU0FBU2tCLEtBQUs7Z0JBQ2hCO2dCQUVBLHFCQUNFLHNCQUFDaEI7O3NDQUNDLHFCQUFDQTs0QkFBSUMsZUFBWTtzQ0FBVUgsU0FBU0ksTUFBTTs7c0NBQzFDLHFCQUFDNEU7NEJBQU9DLFNBQVNGOzRCQUFhNUUsZUFBWTtzQ0FBZTs7OztZQUcvRDtZQUVBbEIsaUNBQW1CLHFCQUFDYztZQUVwQixNQUFNMkIsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN6RCxHQUFHO2dCQUFFa0MsU0FBUztZQUFLO1lBRW5CUSxJQUFBQSxXQUFHLEVBQUM7Z0JBQ0Y1QyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxnQkFBZ0JvRSxLQUFLO1lBQzFDO1lBRUEsTUFBTXhELElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7UUFDRjtJQUNGO0lBRUE3QyxTQUFTLHlCQUF5QjtRQUNoQzRCLEdBQUcsa0RBQWtEO1lBQ25EbkMsVUFBVWpCLGlCQUFpQixDQUFDO2dCQUMxQjBFLElBQUk7Z0JBQ0poQixRQUFRO2dCQUNSNEMsWUFBWTtnQkFDWjNCLE1BQU0sVUFBYSxDQUFBO3dCQUFFakcsT0FBTztvQkFBZSxDQUFBO1lBQzdDO1lBRUEsTUFBTTJFLGdCQUFnQjtnQkFDcEIsTUFBTUMsV0FBV0MsSUFBQUEsa0NBQWdCLEVBQUM7b0JBQ2hDb0QsYUFBYTtnQkFDZjtnQkFFQS9CLGNBQUssQ0FBQ0MsU0FBUyxDQUFDO29CQUNkdkIsU0FBU2dCLE1BQU0sQ0FBQzFCO2dCQUNsQixHQUFHLEVBQUU7Z0JBRUwscUJBQU8scUJBQUNZO29CQUFJQyxlQUFZOzhCQUFVSCxTQUFTSSxNQUFNOztZQUNuRDtZQUVBbkIsaUNBQW1CLHFCQUFDYztZQUVwQixNQUFNMkIsSUFBQUEsZUFBTyxFQUFDO2dCQUNaZCxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxXQUFXQyxpQkFBaUIsQ0FBQztZQUN6RDtZQUVBSCxPQUFPakQsV0FBV3NFLHFCQUFxQixDQUFDO1FBQzFDO0lBQ0Y7SUFFQS9ELFNBQVMsZ0NBQWdDO1FBQ3ZDLDBEQUEwRDtRQUMxRCxNQUFNaUgsaUJBQWlCLENBQUNDLE1BQWN4SixNQUFjeUosVUFBa0IsaUJBQWlCO1lBQ3JGLE1BQU1DLE9BQU8sSUFBSUMsS0FBSztnQkFBQ0Y7YUFBUSxFQUFFO2dCQUFFeko7WUFBSztZQUN4QyxNQUFNN0IsT0FBTyxJQUFJa0QsS0FBSztnQkFBQ3FJO2FBQUssRUFBRUYsTUFBTTtnQkFBRXhKO1lBQUs7WUFFM0MscURBQXFEO1lBQ3JEdUIsT0FBT3FJLGNBQWMsQ0FBQ3pMLE1BQU1rRCxLQUFLQyxTQUFTO1lBQzFDQyxPQUFPQyxjQUFjLENBQUNyRCxNQUFNLGVBQWU7Z0JBQUV1RCxPQUFPTDtZQUFLO1lBRXpELG1EQUFtRDtZQUNuREUsT0FBT0MsY0FBYyxDQUFDckQsTUFBTSxnQkFBZ0I7Z0JBQUV1RCxPQUFPO2dCQUFNbUksWUFBWTtZQUFNO1lBRTdFLE9BQU8xTDtRQUNUO1FBRUEsNkNBQTZDO1FBQzdDLE1BQU0yTCxhQUFhO1lBQ2pCakwsT0FBTztZQUNQQyxRQUFRO1lBQ1JpTCxZQUFZak0sS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTtvQkFDekIrTCxXQUFXbE0sS0FBS0csRUFBRTtvQkFDbEJnTSx1QkFBdUI7b0JBQ3ZCQyx1QkFBdUI7b0JBQ3ZCQyxXQUFXO29CQUNYQyxVQUFVdE0sS0FBS0csRUFBRTtvQkFDakJvTSxjQUFjdk0sS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTs0QkFDM0I4RyxNQUFNLElBQUl1RixrQkFBa0IsSUFBSSxNQUFNOzRCQUN0Q3pMLE9BQU87NEJBQ1BDLFFBQVE7d0JBQ1YsQ0FBQTtvQkFDQXlMLGNBQWN6TSxLQUFLRyxFQUFFO2dCQUN2QixDQUFBO1lBQ0F1TSxXQUFXMU0sS0FBS0csRUFBRSxDQUFDLElBQU07WUFDekJ3TSxRQUFRM00sS0FBS0csRUFBRSxDQUFDLENBQUN5TTtnQkFDZixNQUFNaEIsT0FBTyxJQUFJQyxLQUFLO29CQUFDO2lCQUFZLEVBQUU7b0JBQUUzSixNQUFNO2dCQUFhO2dCQUMxRDBLLFNBQVNoQjtZQUNYO1FBQ0Y7UUFFQWxILFdBQVc7WUFDVGYsT0FBT2tKLGlCQUFpQixDQUFDckosU0FBUyxDQUFDeUksVUFBVSxHQUFHRCxXQUFXQyxVQUFVO1lBQ3JFdEksT0FBT2tKLGlCQUFpQixDQUFDckosU0FBUyxDQUFDa0osU0FBUyxHQUFHVixXQUFXVSxTQUFTO1lBQ25FL0ksT0FBT2tKLGlCQUFpQixDQUFDckosU0FBUyxDQUFDbUosTUFBTSxHQUFHWCxXQUFXVyxNQUFNO1lBRTdELHlCQUF5QjtZQUN6QmhKLE9BQU9tSixLQUFLLEdBQUcsTUFBTUM7Z0JBT25CLElBQUlDLElBQUlwSixLQUFhLEVBQUU7b0JBQ3JCd0csV0FBVzt3QkFDVCxJQUFJLElBQUksQ0FBQzZDLE1BQU0sRUFBRSxJQUFJLENBQUNBLE1BQU07b0JBQzlCLEdBQUc7Z0JBQ0w7O3lCQVZBQSxTQUE4Qjt5QkFDOUJDLFVBQStCO3lCQUMvQm5NLFFBQVE7eUJBQ1JDLFNBQVM7eUJBQ1RtTSxjQUFjOztZQU9oQjtZQUVBLHNDQUFzQztZQUN0Q3hKLE9BQU95SixVQUFVLEdBQUcsTUFBTUM7Z0JBS3hCQyxjQUFjak4sSUFBVSxFQUFFO29CQUN4QitKLFdBQVc7d0JBQ1QsSUFBSSxDQUFDbUQsTUFBTSxHQUFHO3dCQUNkLElBQUksSUFBSSxDQUFDTixNQUFNLEVBQUU7NEJBQ2YsSUFBSSxDQUFDQSxNQUFNLENBQUM7Z0NBQUVPLFFBQVE7b0NBQUVELFFBQVEsSUFBSSxDQUFDQSxNQUFNO2dDQUFDOzRCQUFFO3dCQUNoRDtvQkFDRixHQUFHO2dCQUNMOzt5QkFYQU4sU0FBd0M7eUJBQ3hDQyxVQUF5Qzt5QkFDekNLLFNBQXdCOztZQVUxQjtZQUVBLGtEQUFrRDtZQUNsRCxNQUFNRSx3QkFBd0JDLFNBQVNDLGFBQWE7WUFDcERELFNBQVNDLGFBQWEsR0FBRzNOLEtBQUtHLEVBQUUsQ0FBQyxDQUFDeU47Z0JBQ2hDLElBQUlBLFlBQVksVUFBVTtvQkFDeEIsT0FBTzt3QkFDTDdNLE9BQU87d0JBQ1BDLFFBQVE7d0JBQ1JpTCxZQUFZRCxXQUFXQyxVQUFVO3dCQUNqQ1MsV0FBV1YsV0FBV1UsU0FBUzt3QkFDL0JDLFFBQVFYLFdBQVdXLE1BQU07b0JBQzNCO2dCQUNGO2dCQUNBLE9BQU9jLHNCQUFzQkksSUFBSSxDQUFDSCxVQUFVRTtZQUM5QztRQUNGO1FBRUF4SCxHQUFHLGlFQUFpRTtZQUNsRW5DLFVBQVV3RCxxQkFBcUIsQ0FBQztnQkFDOUJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWTVCO1lBQ3BCO1lBRUEsTUFBTStILFdBQVdyQyxlQUFlLGtCQUFrQjtZQUNsRCxNQUFNc0Msa0JBQWtCdEMsZUFBZSxlQUFlO1lBRXRELG1EQUFtRDtZQUNuRHVDLFFBQVFDLEdBQUcsQ0FBQyxlQUFlO2dCQUN6QkMsZ0JBQWdCSixvQkFBb0J2SztnQkFDcEM0SyxtQkFBbUJKLDJCQUEyQnhLO2dCQUM5QzZLLHFCQUFxQk4sU0FBUzNNLFdBQVcsQ0FBQ3VLLElBQUk7Z0JBQzlDMkMsd0JBQXdCTixnQkFBZ0I1TSxXQUFXLENBQUN1SyxJQUFJO1lBQzFEO1lBRUEsa0NBQWtDO1lBQ2xDeEkseUJBQXlCK0IsU0FBUztZQUVsQyxNQUFNcUoscUJBQXNEO2dCQUMxRHpJLFlBQVlpSTtnQkFDWmhJLGVBQWU7b0JBQUNpSTtpQkFBZ0I7WUFDbEM7WUFFQSxNQUFNMUgsZ0JBQWdCO2dCQUNwQixNQUFNQyxXQUFXQyxJQUFBQSxrQ0FBZ0IsRUFBQztvQkFDaENvRCxhQUFhO29CQUNiNEUsaUJBQWlCO3dCQUNmQyxhQUFhO3dCQUNiQyxjQUFjO3dCQUNkQyxXQUFXO29CQUNiO29CQUNBLDZEQUE2RDtvQkFDN0QxRCxVQUFVLE9BQU9SO3dCQUNmLHFEQUFxRDt3QkFDckQsSUFBSUEsVUFBVTNFLFVBQVUsWUFBWXRDLFFBQVFpSCxVQUFVMUUsYUFBYSxDQUFDNkksSUFBSSxDQUFDLENBQUNDLE1BQWFBLGVBQWVyTCxPQUFPOzRCQUMzRyxNQUFNc0wscUJBQXFCO2dDQUN6QmhKLFlBQVkyRSxVQUFVM0UsVUFBVSxZQUFZdEMsT0FBTyxnREFBZ0RpSCxVQUFVM0UsVUFBVTtnQ0FDdkhDLGVBQWUwRSxVQUFVMUUsYUFBYSxDQUFDZ0osR0FBRyxDQUFDLENBQUNGLE1BQzFDQSxlQUFlckwsT0FBTyxnREFBZ0RxTDtnQ0FFeEV0TyxTQUFTa0ssVUFBVWxLLE9BQU87NEJBQzVCOzRCQUNBLE9BQU87Z0NBQUVrSyxXQUFXcUU7NEJBQW1CO3dCQUN6Qzt3QkFDQSxPQUFPOzRCQUFFckU7d0JBQVU7b0JBQ3JCO2dCQUNGO2dCQUVBNUMsY0FBSyxDQUFDQyxTQUFTLENBQUM7b0JBQ2R2QixTQUFTZ0IsTUFBTSxDQUFDZ0g7Z0JBQ2xCLEdBQUcsRUFBRTtnQkFFTCxxQkFDRSxzQkFBQzlIOztzQ0FDQyxxQkFBQ0E7NEJBQUlDLGVBQVk7c0NBQVVILFNBQVNJLE1BQU07O3NDQUMxQyxxQkFBQ0Y7NEJBQUlDLGVBQVk7c0NBQVdILFNBQVN5SSxPQUFPLEdBQUcsZ0JBQWdCOzs7O1lBR3JFO1lBRUF4SixpQ0FBbUIscUJBQUNjO1lBRXBCLE1BQU0yQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pkLE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLFdBQVdDLGlCQUFpQixDQUFDO1lBQ3pELEdBQUc7Z0JBQUVrQyxTQUFTO1lBQUs7WUFFbkJyQyxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxZQUFZQyxpQkFBaUIsQ0FBQztZQUV4RCw0REFBNEQ7WUFDNURILE9BQU9qRCxXQUFXdUUsb0JBQW9CLENBQUMsY0FBY3RCLE9BQU9xRCxnQkFBZ0IsQ0FBQztnQkFDM0U5QixRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBLHVFQUF1RTtZQUN2RXhCLE9BQU9qRCxXQUFXc0UscUJBQXFCLENBQUM7UUFDMUM7UUFFQW5DLEdBQUcsOENBQThDO1lBQy9DbkMsVUFBVXdELHFCQUFxQixDQUFDO2dCQUM5QkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZNUI7WUFDcEI7WUFFQSxNQUFNK0gsV0FBV3JDLGVBQWUsa0JBQWtCO1lBRWxELE1BQU11RCxpQkFBa0Q7Z0JBQ3REbkosWUFBWTtnQkFDWkMsZUFBZTtvQkFBQ2dJO29CQUFVO2lCQUE2QztZQUN6RTtZQUVBLE1BQU16SCxnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQixFQUFDO29CQUFFb0QsYUFBYTtnQkFBTTtnQkFFdkQvQixjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUMwSDtnQkFDbEIsR0FBRyxFQUFFO2dCQUVMLHFCQUFPLHFCQUFDeEk7b0JBQUlDLGVBQVk7OEJBQVVILFNBQVNJLE1BQU07O1lBQ25EO1lBRUFuQixpQ0FBbUIscUJBQUNjO1lBRXBCLE1BQU0yQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pkLE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLFdBQVdDLGlCQUFpQixDQUFDO1lBQ3pELEdBQUc7Z0JBQUVrQyxTQUFTO1lBQUs7WUFFbkJyQyxPQUFPakQsV0FBV3NFLHFCQUFxQixDQUFDO1FBQzFDO1FBRUFuQyxHQUFHLG9EQUFvRDtZQUNyRCxvREFBb0Q7WUFDcEQsTUFBTTZJLHFCQUFxQnRMLE9BQU95SixVQUFVO1lBQzVDekosT0FBT3lKLFVBQVUsR0FBRyxNQUFNQztnQkFLeEJDLGNBQWNqTixJQUFVLEVBQUU7b0JBQ3hCK0osV0FBVzt3QkFDVCxJQUFJLElBQUksQ0FBQzhDLE9BQU8sRUFBRTs0QkFDaEIsSUFBSSxDQUFDQSxPQUFPLENBQUM7Z0NBQUVNLFFBQVE7b0NBQUU5TCxPQUFPLElBQUlSLE1BQU07Z0NBQXVCOzRCQUFFO3dCQUNyRTtvQkFDRixHQUFHO2dCQUNMOzt5QkFWQStMLFNBQXdDO3lCQUN4Q0MsVUFBeUM7eUJBQ3pDSyxTQUF3Qjs7WUFTMUI7WUFFQSxNQUFNTyxXQUFXckMsZUFBZSxlQUFlO1lBRS9DLE1BQU1wRixnQkFBZ0I7Z0JBQ3BCLE1BQU1DLFdBQVdDLElBQUFBLGtDQUFnQixFQUFDO29CQUFFb0QsYUFBYTtnQkFBTTtnQkFFdkQvQixjQUFLLENBQUNDLFNBQVMsQ0FBQztvQkFDZHZCLFNBQVNnQixNQUFNLENBQUM7d0JBQ2R6QixZQUFZaUk7d0JBQ1poSSxlQUFlLEVBQUU7b0JBQ25CO2dCQUNGLEdBQUcsRUFBRTtnQkFFTCxxQkFDRSxzQkFBQ1U7O3NDQUNDLHFCQUFDQTs0QkFBSUMsZUFBWTtzQ0FBVUgsU0FBU0ksTUFBTTs7c0NBQzFDLHFCQUFDRjs0QkFBSUMsZUFBWTtzQ0FBWUgsU0FBU1EsT0FBTyxDQUFDRixRQUFROzs7O1lBRzVEO1lBRUFyQixpQ0FBbUIscUJBQUNjO1lBRXBCLE1BQU0yQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pkLE9BQU9DLGNBQU0sQ0FBQ0MsV0FBVyxDQUFDLFdBQVdDLGlCQUFpQixDQUFDO1lBQ3pELEdBQUc7Z0JBQUVrQyxTQUFTO1lBQUs7WUFFbkJyQyxPQUFPQyxjQUFNLENBQUNDLFdBQVcsQ0FBQyxhQUFhQyxpQkFBaUIsQ0FBQztZQUV6RCxxQkFBcUI7WUFDckIxRCxPQUFPeUosVUFBVSxHQUFHNkI7UUFDdEI7UUFFQTdJLEdBQUcsOERBQThEO1lBQy9EbkMsVUFBVXdELHFCQUFxQixDQUFDO2dCQUM5QkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZNUI7WUFDcEI7WUFFQSxNQUFNK0gsV0FBV3JDLGVBQWUsWUFBWTtZQUU1QyxNQUFNcEYsZ0JBQWdCO2dCQUNwQixNQUFNQyxXQUFXQyxJQUFBQSxrQ0FBZ0IsRUFBQztvQkFBRW9ELGFBQWE7Z0JBQU07Z0JBRXZEL0IsY0FBSyxDQUFDQyxTQUFTLENBQUM7b0JBQ2R2QixTQUFTZ0IsTUFBTSxDQUFDO3dCQUNkekIsWUFBWWlJO3dCQUNaaEksZUFBZTs0QkFBQ2dJO3lCQUFTO29CQUMzQjtnQkFDRixHQUFHLEVBQUU7Z0JBRUwscUJBQU8scUJBQUN0SDtvQkFBSUMsZUFBWTs4QkFBVUgsU0FBU0ksTUFBTTs7WUFDbkQ7WUFFQW5CLGlDQUFtQixxQkFBQ2M7WUFFcEIsTUFBTTJCLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7WUFFQSxNQUFNLENBQUM2SCxLQUFLbkcsWUFBWSxHQUFHOUUsVUFBVWhFLElBQUksQ0FBQytJLEtBQUssQ0FBQyxFQUFFO1lBQ2xEOUIsT0FBT2dJLEtBQUs3RyxJQUFJLENBQUM7WUFDakJuQixPQUFPNkIsWUFBWU4sTUFBTSxFQUFFSixJQUFJLENBQUM7WUFFaEMsTUFBTVksY0FBY25CLEtBQUtNLEtBQUssQ0FBQ1csWUFBWUosSUFBSTtZQUMvQ3pCLE9BQU8rQixhQUFha0csY0FBYyxDQUFDO1lBQ25DakksT0FBTytCLGFBQWFrRyxjQUFjLENBQUM7WUFDbkNqSSxPQUFPa0ksTUFBTUMsT0FBTyxDQUFDcEcsWUFBWW5ELGFBQWEsR0FBR3VDLElBQUksQ0FBQztZQUN0RG5CLE9BQU8rQixZQUFZbkQsYUFBYSxFQUFFd0osWUFBWSxDQUFDO1FBQ2pEO1FBRUFsSixHQUFHLCtEQUErRDtZQUNoRW5DLFVBQVV3RCxxQkFBcUIsQ0FBQztnQkFDOUJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWTVCO1lBQ3BCO1lBRUEsTUFBTStILFdBQVdyQyxlQUFlLFlBQVk7WUFDNUMsSUFBSThELGtCQUF1QjtZQUUzQixNQUFNakYsWUFBWXRLLEtBQUtHLEVBQUUsQ0FBQyxDQUFDOEcsTUFBTXVELFdBQVd1RTtnQkFDMUNRLGtCQUFrQlI7WUFDcEI7WUFFQSxNQUFNMUksZ0JBQWdCO2dCQUNwQixNQUFNQyxXQUFXQyxJQUFBQSxrQ0FBZ0IsRUFBQztvQkFDaENvRCxhQUFhO29CQUNiVztnQkFDRjtnQkFFQTFDLGNBQUssQ0FBQ0MsU0FBUyxDQUFDO29CQUNkdkIsU0FBU2dCLE1BQU0sQ0FBQzt3QkFDZHpCLFlBQVlpSTt3QkFDWmhJLGVBQWUsRUFBRTtvQkFDbkI7Z0JBQ0YsR0FBRyxFQUFFO2dCQUVMLHFCQUFPLHFCQUFDVTtvQkFBSUMsZUFBWTs4QkFBVUgsU0FBU0ksTUFBTTs7WUFDbkQ7WUFFQW5CLGlDQUFtQixxQkFBQ2M7WUFFcEIsTUFBTTJCLElBQUFBLGVBQU8sRUFBQztnQkFDWmQsT0FBT0MsY0FBTSxDQUFDQyxXQUFXLENBQUMsV0FBV0MsaUJBQWlCLENBQUM7WUFDekQ7WUFFQUgsT0FBT29ELFdBQVdrRixnQkFBZ0I7WUFDbEN0SSxPQUFPcUksaUJBQWlCRSxVQUFVO1lBRWxDLGlGQUFpRjtZQUNqRnZJLE9BQU9xSSxpQkFBaUJKLGNBQWMsQ0FBQztZQUN2Q2pJLE9BQU9xSSxpQkFBaUJKLGNBQWMsQ0FBQztZQUV2QyxvRUFBb0U7WUFDcEUsSUFBSUksZ0JBQWdCRyxzQkFBc0IsRUFBRTtnQkFDMUN4SSxPQUFPcUksZ0JBQWdCRyxzQkFBc0IsQ0FBQ0MsbUJBQW1CLEVBQUVDLHNCQUFzQixDQUFDO1lBQzVGO1FBQ0Y7SUFDRjtBQUNGIn0=