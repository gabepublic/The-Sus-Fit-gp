{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/queries/useImageProcessing.ts"],"sourcesContent":["'use client';\n\n// Image Processing React Query Hooks\n// React Query integration for image processing operations with progress tracking\n\nimport { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useCallback, useRef, useState } from 'react';\nimport {\n  processImageForTryon,\n  processImageAdvanced,\n  processImagesInBatch,\n  createImageThumbnail,\n  extractImageMetadata,\n  convertImageFormat,\n  validateImageDimensions,\n  ImageFormat,\n  type ImageProcessingResult,\n  type AdvancedImageProcessingResult,\n  type AdvancedImageProcessingOptions,\n  type ImageMetadata\n} from '../utils/imageProcessing';\nimport {\n  classifyTryonError,\n  logAndClassifyError,\n  type ClassifiedError\n} from '../utils/errorHandling';\n\n/**\n * Image processing operation types\n */\nexport enum ImageProcessingOperation {\n  BASIC_PROCESSING = 'basic_processing',\n  ADVANCED_PROCESSING = 'advanced_processing',\n  BATCH_PROCESSING = 'batch_processing',\n  THUMBNAIL_GENERATION = 'thumbnail_generation',\n  METADATA_EXTRACTION = 'metadata_extraction',\n  FORMAT_CONVERSION = 'format_conversion',\n  VALIDATION = 'validation'\n}\n\n/**\n * Processing queue item\n */\nexport interface ProcessingQueueItem {\n  id: string;\n  operation: ImageProcessingOperation;\n  file: File;\n  options?: any;\n  priority: 'low' | 'normal' | 'high';\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  progress: number;\n  result?: any;\n  error?: ClassifiedError;\n  startTime?: number;\n  endTime?: number;\n  estimatedTime?: number;\n}\n\n/**\n * Batch processing configuration\n */\nexport interface BatchProcessingConfig {\n  maxConcurrent: number;\n  retryAttempts: number;\n  retryDelay: number;\n  progressCallback?: (completed: number, total: number, currentItem: ProcessingQueueItem) => void;\n  itemCompleteCallback?: (item: ProcessingQueueItem) => void;\n  errorCallback?: (item: ProcessingQueueItem, error: ClassifiedError) => void;\n}\n\n/**\n * Image processing stats\n */\nexport interface ProcessingStats {\n  totalProcessed: number;\n  totalFailed: number;\n  averageProcessingTime: number;\n  totalProcessingTime: number;\n  peakMemoryUsage: number;\n  cacheHitRate: number;\n}\n\n/**\n * Processing queue state\n */\nexport interface ProcessingQueueState {\n  queue: ProcessingQueueItem[];\n  activeItems: ProcessingQueueItem[];\n  completedItems: ProcessingQueueItem[];\n  failedItems: ProcessingQueueItem[];\n  isProcessing: boolean;\n  totalProgress: number;\n}\n\n/**\n * Default batch processing configuration\n */\nconst DEFAULT_BATCH_CONFIG: BatchProcessingConfig = {\n  maxConcurrent: 3,\n  retryAttempts: 2,\n  retryDelay: 1000\n};\n\n/**\n * Query keys for React Query\n */\nexport const imageProcessingKeys = {\n  all: ['imageProcessing'] as const,\n  metadata: (fileId: string) => [...imageProcessingKeys.all, 'metadata', fileId] as const,\n  thumbnail: (fileId: string, size: number) => [...imageProcessingKeys.all, 'thumbnail', fileId, size] as const,\n  validation: (fileId: string) => [...imageProcessingKeys.all, 'validation', fileId] as const,\n  processing: (operationId: string) => [...imageProcessingKeys.all, 'processing', operationId] as const,\n  stats: () => [...imageProcessingKeys.all, 'stats'] as const\n};\n\n/**\n * Basic image processing hook for try-on operations\n */\nexport function useImageProcessing() {\n  const queryClient = useQueryClient();\n\n  const basicProcessingMutation = useMutation({\n    mutationFn: async (file: File): Promise<ImageProcessingResult> => {\n      try {\n        return await processImageForTryon(file);\n      } catch (error) {\n        const classifiedError = classifyTryonError(error);\n        logAndClassifyError(error, { operation: 'basic_processing', fileName: file.name });\n        throw classifiedError;\n      }\n    },\n    onSuccess: (result, file) => {\n      // Cache the result\n      queryClient.setQueryData(\n        imageProcessingKeys.processing(`basic_${file.name}_${file.lastModified}`),\n        result\n      );\n    },\n    onError: (error: ClassifiedError, file) => {\n      console.error(`Failed to process image ${file.name}:`, error);\n    }\n  });\n\n  const advancedProcessingMutation = useMutation({\n    mutationFn: async ({\n      file,\n      options\n    }: {\n      file: File;\n      options?: Partial<AdvancedImageProcessingOptions>;\n    }): Promise<AdvancedImageProcessingResult> => {\n      try {\n        return await processImageAdvanced(file, options);\n      } catch (error) {\n        const classifiedError = classifyTryonError(error);\n        logAndClassifyError(error, { \n          operation: 'advanced_processing', \n          fileName: file.name,\n          options \n        });\n        throw classifiedError;\n      }\n    },\n    onSuccess: (result, { file }) => {\n      // Cache the result\n      queryClient.setQueryData(\n        imageProcessingKeys.processing(`advanced_${file.name}_${file.lastModified}`),\n        result\n      );\n    }\n  });\n\n  return {\n    processBasic: basicProcessingMutation.mutateAsync,\n    processAdvanced: advancedProcessingMutation.mutateAsync,\n    isProcessingBasic: basicProcessingMutation.isPending,\n    isProcessingAdvanced: advancedProcessingMutation.isPending,\n    basicError: basicProcessingMutation.error,\n    advancedError: advancedProcessingMutation.error,\n    reset: () => {\n      basicProcessingMutation.reset();\n      advancedProcessingMutation.reset();\n    }\n  };\n}\n\n/**\n * Image metadata extraction hook\n */\nexport function useImageMetadata(file: File | null, enabled: boolean = true) {\n  return useQuery({\n    queryKey: file ? imageProcessingKeys.metadata(`${file.name}_${file.lastModified}`) : [],\n    queryFn: async (): Promise<ImageMetadata> => {\n      if (!file) throw new Error('No file provided');\n      try {\n        return await extractImageMetadata(file);\n      } catch (error) {\n        const classifiedError = classifyTryonError(error);\n        logAndClassifyError(error, { operation: 'metadata_extraction', fileName: file.name });\n        throw classifiedError;\n      }\n    },\n    enabled: enabled && !!file,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    gcTime: 10 * 60 * 1000 // 10 minutes\n  });\n}\n\n/**\n * Image thumbnail generation hook\n */\nexport function useImageThumbnail(file: File | null, size: number = 150, enabled: boolean = true) {\n  return useQuery({\n    queryKey: file ? imageProcessingKeys.thumbnail(`${file.name}_${file.lastModified}`, size) : [],\n    queryFn: async (): Promise<string> => {\n      if (!file) throw new Error('No file provided');\n      try {\n        return await createImageThumbnail(file, size);\n      } catch (error) {\n        const classifiedError = classifyTryonError(error);\n        logAndClassifyError(error, { \n          operation: 'thumbnail_generation', \n          fileName: file.name,\n          size \n        });\n        throw classifiedError;\n      }\n    },\n    enabled: enabled && !!file,\n    staleTime: 10 * 60 * 1000, // 10 minutes\n    gcTime: 30 * 60 * 1000 // 30 minutes\n  });\n}\n\n/**\n * Image validation hook\n */\nexport function useImageValidation(file: File | null, enabled: boolean = true) {\n  return useQuery({\n    queryKey: file ? imageProcessingKeys.validation(`${file.name}_${file.lastModified}`) : [],\n    queryFn: async (): Promise<{ isValid: boolean; errors: string[] }> => {\n      if (!file) throw new Error('No file provided');\n      \n      const errors: string[] = [];\n      \n      try {\n        // Basic file type validation\n        if (!file.type.startsWith('image/')) {\n          errors.push('File is not an image');\n        }\n        \n        // File size validation (10MB max)\n        if (file.size > 10 * 1024 * 1024) {\n          errors.push('File size too large (max 10MB)');\n        }\n        \n        // Dimension validation\n        try {\n          const metadata = await extractImageMetadata(file);\n          if (metadata.dimensions.width < 256 || metadata.dimensions.height < 256) {\n            errors.push('Image dimensions too small (minimum 256x256)');\n          }\n          if (metadata.dimensions.width > 4096 || metadata.dimensions.height > 4096) {\n            errors.push('Image dimensions too large (maximum 4096x4096)');\n          }\n        } catch (error) {\n          errors.push('Failed to validate image dimensions');\n        }\n        \n        return {\n          isValid: errors.length === 0,\n          errors\n        };\n      } catch (error) {\n        const classifiedError = classifyTryonError(error);\n        logAndClassifyError(error, { operation: 'validation', fileName: file.name });\n        throw classifiedError;\n      }\n    },\n    enabled: enabled && !!file,\n    staleTime: 2 * 60 * 1000, // 2 minutes\n    gcTime: 5 * 60 * 1000 // 5 minutes\n  });\n}\n\n/**\n * Format conversion hook\n */\nexport function useFormatConversion() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      file,\n      targetFormat,\n      quality = 0.9\n    }: {\n      file: File;\n      targetFormat: ImageFormat;\n      quality?: number;\n    }): Promise<string> => {\n      try {\n        const imageUrl = URL.createObjectURL(file);\n        const { convertImageFormat } = await import('../utils/imageProcessing');\n        const result = await convertImageFormat(imageUrl, targetFormat, quality);\n        URL.revokeObjectURL(imageUrl);\n        return result;\n      } catch (error) {\n        const classifiedError = classifyTryonError(error);\n        logAndClassifyError(error, { \n          operation: 'format_conversion', \n          fileName: file.name,\n          targetFormat,\n          quality \n        });\n        throw classifiedError;\n      }\n    },\n    onSuccess: (result, { file, targetFormat }) => {\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: imageProcessingKeys.metadata(`${file.name}_${file.lastModified}`)\n      });\n    }\n  });\n}\n\n/**\n * Batch processing hook with queue management\n */\nexport function useBatchImageProcessing(config: Partial<BatchProcessingConfig> = {}) {\n  const processingConfig = { ...DEFAULT_BATCH_CONFIG, ...config };\n  const [queueState, setQueueState] = useState<ProcessingQueueState>({\n    queue: [],\n    activeItems: [],\n    completedItems: [],\n    failedItems: [],\n    isProcessing: false,\n    totalProgress: 0\n  });\n  \n  const queueRef = useRef<ProcessingQueueItem[]>([]);\n  const activeRef = useRef<Map<string, ProcessingQueueItem>>(new Map());\n  const statsRef = useRef<ProcessingStats>({\n    totalProcessed: 0,\n    totalFailed: 0,\n    averageProcessingTime: 0,\n    totalProcessingTime: 0,\n    peakMemoryUsage: 0,\n    cacheHitRate: 0\n  });\n\n  const generateId = useCallback(() => {\n    return `proc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }, []);\n\n  const updateQueueState = useCallback(() => {\n    const activeItems = Array.from(activeRef.current.values());\n    const completedItems = queueRef.current.filter(item => item.status === 'completed');\n    const failedItems = queueRef.current.filter(item => item.status === 'failed');\n    const totalItems = queueRef.current.length;\n    const totalProgress = totalItems > 0 \n      ? (completedItems.length + failedItems.length) / totalItems * 100 \n      : 0;\n\n    setQueueState({\n      queue: [...queueRef.current],\n      activeItems,\n      completedItems,\n      failedItems,\n      isProcessing: activeItems.length > 0,\n      totalProgress\n    });\n  }, []);\n\n  const processQueueItem = useCallback(async (item: ProcessingQueueItem): Promise<void> => {\n    item.status = 'processing';\n    item.startTime = Date.now();\n    activeRef.current.set(item.id, item);\n    updateQueueState();\n\n    try {\n      let result: any;\n      \n      switch (item.operation) {\n        case ImageProcessingOperation.BASIC_PROCESSING:\n          result = await processImageForTryon(item.file, item.options);\n          break;\n        case ImageProcessingOperation.ADVANCED_PROCESSING:\n          result = await processImageAdvanced(item.file, item.options);\n          break;\n        case ImageProcessingOperation.THUMBNAIL_GENERATION:\n          result = await createImageThumbnail(item.file, item.options?.size || 150);\n          break;\n        case ImageProcessingOperation.METADATA_EXTRACTION:\n          result = await extractImageMetadata(item.file);\n          break;\n        case ImageProcessingOperation.FORMAT_CONVERSION:\n          const imageUrl = URL.createObjectURL(item.file);\n          result = await convertImageFormat(imageUrl, item.options.targetFormat, item.options.quality);\n          URL.revokeObjectURL(imageUrl);\n          break;\n        default:\n          throw new Error(`Unsupported operation: ${item.operation}`);\n      }\n\n      item.status = 'completed';\n      item.result = result;\n      item.endTime = Date.now();\n      item.progress = 100;\n      \n      // Update stats\n      const processingTime = item.endTime - (item.startTime || 0);\n      statsRef.current.totalProcessed++;\n      statsRef.current.totalProcessingTime += processingTime;\n      statsRef.current.averageProcessingTime = \n        statsRef.current.totalProcessingTime / statsRef.current.totalProcessed;\n\n      processingConfig.itemCompleteCallback?.(item);\n    } catch (error) {\n      item.status = 'failed';\n      item.endTime = Date.now();\n      item.error = classifyTryonError(error);\n      \n      statsRef.current.totalFailed++;\n      \n      logAndClassifyError(error, {\n        operation: item.operation,\n        fileName: item.file.name,\n        itemId: item.id\n      });\n\n      processingConfig.errorCallback?.(item, item.error);\n    } finally {\n      activeRef.current.delete(item.id);\n      updateQueueState();\n      \n      // Process next items in queue\n      processNextInQueue();\n    }\n  }, [processingConfig, updateQueueState]);\n\n  const processNextInQueue = useCallback(() => {\n    const pendingItems = queueRef.current\n      .filter(item => item.status === 'pending')\n      .sort((a, b) => {\n        const priorityOrder = { high: 3, normal: 2, low: 1 };\n        return priorityOrder[b.priority] - priorityOrder[a.priority];\n      });\n\n    const availableSlots = processingConfig.maxConcurrent - activeRef.current.size;\n    \n    for (let i = 0; i < Math.min(availableSlots, pendingItems.length); i++) {\n      processQueueItem(pendingItems[i]);\n    }\n  }, [processingConfig.maxConcurrent, processQueueItem]);\n\n  const addToQueue = useCallback((\n    operation: ImageProcessingOperation,\n    file: File,\n    options?: any,\n    priority: 'low' | 'normal' | 'high' = 'normal'\n  ): string => {\n    const item: ProcessingQueueItem = {\n      id: generateId(),\n      operation,\n      file,\n      options,\n      priority,\n      status: 'pending',\n      progress: 0\n    };\n\n    queueRef.current.push(item);\n    updateQueueState();\n    \n    // Start processing if under capacity\n    if (activeRef.current.size < processingConfig.maxConcurrent) {\n      processNextInQueue();\n    }\n\n    return item.id;\n  }, [generateId, processingConfig.maxConcurrent, updateQueueState, processNextInQueue]);\n\n  const removeFromQueue = useCallback((itemId: string): boolean => {\n    const index = queueRef.current.findIndex(item => item.id === itemId);\n    if (index === -1) return false;\n\n    const item = queueRef.current[index];\n    if (item.status === 'processing') {\n      // Cannot remove active items\n      return false;\n    }\n\n    queueRef.current.splice(index, 1);\n    updateQueueState();\n    return true;\n  }, [updateQueueState]);\n\n  const clearQueue = useCallback((includeActive: boolean = false) => {\n    if (includeActive) {\n      queueRef.current = [];\n      activeRef.current.clear();\n    } else {\n      queueRef.current = queueRef.current.filter(item => item.status === 'processing');\n    }\n    updateQueueState();\n  }, [updateQueueState]);\n\n  const pauseQueue = useCallback(() => {\n    // Implementation would pause processing new items\n    // For now, just stop processing new items\n  }, []);\n\n  const resumeQueue = useCallback(() => {\n    processNextInQueue();\n  }, [processNextInQueue]);\n\n  const getStats = useCallback((): ProcessingStats => {\n    return { ...statsRef.current };\n  }, []);\n\n  return {\n    queueState,\n    addToQueue,\n    removeFromQueue,\n    clearQueue,\n    pauseQueue,\n    resumeQueue,\n    getStats,\n    processingConfig\n  };\n}\n\n/**\n * Processing statistics hook\n */\nexport function useProcessingStats() {\n  return useQuery({\n    queryKey: imageProcessingKeys.stats(),\n    queryFn: async (): Promise<ProcessingStats> => {\n      // This would typically fetch from a backend or local storage\n      return {\n        totalProcessed: 0,\n        totalFailed: 0,\n        averageProcessingTime: 0,\n        totalProcessingTime: 0,\n        peakMemoryUsage: 0,\n        cacheHitRate: 0\n      };\n    },\n    staleTime: 30 * 1000, // 30 seconds\n    gcTime: 2 * 60 * 1000 // 2 minutes\n  });\n}\n\n/**\n * Cache management for image processing\n */\nexport function useImageProcessingCache() {\n  const queryClient = useQueryClient();\n\n  const clearCache = useCallback((pattern?: string) => {\n    if (pattern) {\n      queryClient.invalidateQueries({\n        predicate: (query) => query.queryKey.toString().includes(pattern)\n      });\n    } else {\n      queryClient.invalidateQueries({\n        queryKey: imageProcessingKeys.all\n      });\n    }\n  }, [queryClient]);\n\n  const getCacheStats = useCallback(() => {\n    const cache = queryClient.getQueryCache();\n    const queries = cache.findAll({ queryKey: imageProcessingKeys.all });\n    \n    return {\n      totalQueries: queries.length,\n      activeQueries: queries.filter(q => q.isActive()).length,\n      stalequeries: queries.filter(q => q.isStale()).length,\n      invalidQueries: queries.filter(q => q.isStale() && q.getObserversCount() === 0).length\n    };\n  }, [queryClient]);\n\n  const preloadMetadata = useCallback(async (files: File[]) => {\n    const promises = files.map(file => \n      queryClient.prefetchQuery({\n        queryKey: imageProcessingKeys.metadata(`${file.name}_${file.lastModified}`),\n        queryFn: () => extractImageMetadata(file)\n      })\n    );\n    \n    await Promise.allSettled(promises);\n  }, [queryClient]);\n\n  return {\n    clearCache,\n    getCacheStats,\n    preloadMetadata\n  };\n}"],"names":["ImageProcessingOperation","imageProcessingKeys","useBatchImageProcessing","useFormatConversion","useImageMetadata","useImageProcessing","useImageProcessingCache","useImageThumbnail","useImageValidation","useProcessingStats","DEFAULT_BATCH_CONFIG","maxConcurrent","retryAttempts","retryDelay","all","metadata","fileId","thumbnail","size","validation","processing","operationId","stats","queryClient","useQueryClient","basicProcessingMutation","useMutation","mutationFn","file","processImageForTryon","error","classifiedError","classifyTryonError","logAndClassifyError","operation","fileName","name","onSuccess","result","setQueryData","lastModified","onError","console","advancedProcessingMutation","options","processImageAdvanced","processBasic","mutateAsync","processAdvanced","isProcessingBasic","isPending","isProcessingAdvanced","basicError","advancedError","reset","enabled","useQuery","queryKey","queryFn","Error","extractImageMetadata","staleTime","gcTime","createImageThumbnail","errors","type","startsWith","push","dimensions","width","height","isValid","length","targetFormat","quality","imageUrl","URL","createObjectURL","convertImageFormat","revokeObjectURL","invalidateQueries","config","processingConfig","queueState","setQueueState","useState","queue","activeItems","completedItems","failedItems","isProcessing","totalProgress","queueRef","useRef","activeRef","Map","statsRef","totalProcessed","totalFailed","averageProcessingTime","totalProcessingTime","peakMemoryUsage","cacheHitRate","generateId","useCallback","Date","now","Math","random","toString","substr","updateQueueState","Array","from","current","values","filter","item","status","totalItems","processQueueItem","startTime","set","id","endTime","progress","processingTime","itemCompleteCallback","itemId","errorCallback","delete","processNextInQueue","pendingItems","sort","a","b","priorityOrder","high","normal","low","priority","availableSlots","i","min","addToQueue","removeFromQueue","index","findIndex","splice","clearQueue","includeActive","clear","pauseQueue","resumeQueue","getStats","clearCache","pattern","predicate","query","includes","getCacheStats","cache","getQueryCache","queries","findAll","totalQueries","activeQueries","q","isActive","stalequeries","isStale","invalidQueries","getObserversCount","preloadMetadata","files","promises","map","prefetchQuery","Promise","allSettled"],"mappings":"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"}