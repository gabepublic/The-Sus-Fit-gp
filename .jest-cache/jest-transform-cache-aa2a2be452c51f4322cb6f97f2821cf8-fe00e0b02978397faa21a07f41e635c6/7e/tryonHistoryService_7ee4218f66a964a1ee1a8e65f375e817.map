{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/services/tryonHistoryService.ts"],"sourcesContent":["// Try-On History Storage Service\n// Implements persistent storage for try-on history using localStorage with compression\n\nimport { \n  compressBase64, \n  getBase64Size, \n  CompressionFailedError \n} from '../utils/imageProcessing';\nimport type {\n  TryonHistoryEntry,\n  TryonHistoryCollection,\n  TryonHistoryQueryOptions,\n  CreateTryonHistoryEntryOptions,\n  TryonHistoryService,\n  TryonHistoryStorageConfig\n} from '../types/history.types';\n\n/**\n * Default configuration for history storage\n */\nconst DEFAULT_CONFIG: Required<TryonHistoryStorageConfig> = {\n  storageType: 'localStorage',\n  maxEntries: 50,\n  maxEntrySizeKB: 2048, // 2MB per entry\n  compressImages: true,\n  compressionQuality: 0.8,\n  autoCleanup: true,\n  encryptionKey: ''\n};\n\n/**\n * Storage keys for localStorage\n */\nconst STORAGE_KEYS = {\n  ENTRIES: 'susfit_tryon_history_entries',\n  CONFIG: 'susfit_tryon_history_config',\n  METADATA: 'susfit_tryon_history_metadata'\n} as const;\n\n/**\n * Generate a unique ID for history entries\n */\nfunction generateHistoryId(): string {\n  return `tryon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Calculate the size of a history entry in KB\n */\nfunction calculateEntrySize(entry: TryonHistoryEntry): number {\n  const json = JSON.stringify(entry);\n  return new Blob([json]).size / 1024;\n}\n\n/**\n * Compress images in a history entry\n */\nasync function compressHistoryEntry(\n  entry: TryonHistoryEntry, \n  config: TryonHistoryStorageConfig\n): Promise<TryonHistoryEntry> {\n  if (!config.compressImages) {\n    return entry;\n  }\n\n  try {\n    const maxSizeKB = config.maxEntrySizeKB! / (2 + entry.apparelImages.length);\n    const quality = config.compressionQuality!;\n\n    // Compress generated image\n    const compressedGenerated = await compressBase64(\n      entry.generatedImage, \n      maxSizeKB, \n      quality\n    );\n\n    // Compress model image\n    const compressedModel = await compressBase64(\n      entry.modelImage, \n      maxSizeKB, \n      quality\n    );\n\n    // Compress apparel images\n    const compressedApparel = await Promise.all(\n      entry.apparelImages.map(img => compressBase64(img, maxSizeKB, quality))\n    );\n\n    return {\n      ...entry,\n      generatedImage: compressedGenerated,\n      modelImage: compressedModel,\n      apparelImages: compressedApparel,\n      metadata: {\n        ...entry.metadata,\n        imageProcessingResults: {\n          ...entry.metadata?.imageProcessingResults,\n          finalImageSizes: {\n            modelImageSize: getBase64Size(compressedModel),\n            apparelImageSizes: compressedApparel.map(img => getBase64Size(img))\n          }\n        }\n      }\n    };\n  } catch (error) {\n    if (error instanceof CompressionFailedError) {\n      console.warn('Failed to compress history entry images, using original', error);\n      return entry;\n    }\n    throw error;\n  }\n}\n\n/**\n * localStorage-based Try-On History Service implementation\n */\nexport class LocalStorageTryonHistoryService implements TryonHistoryService {\n  private config: Required<TryonHistoryStorageConfig>;\n  private isInitialized = false;\n\n  constructor(config: Partial<TryonHistoryStorageConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    // Don't initialize immediately - defer until first use\n  }\n\n  /**\n   * Initialize localStorage storage (called lazily on first use)\n   */\n  private initializeStorage(): void {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Check if localStorage is available (client-side only)\n      if (typeof window === 'undefined' || !window.localStorage) {\n        throw new Error('localStorage is not available');\n      }\n\n      // Initialize config if not exists\n      if (!localStorage.getItem(STORAGE_KEYS.CONFIG)) {\n        localStorage.setItem(STORAGE_KEYS.CONFIG, JSON.stringify(this.config));\n      }\n\n      // Initialize entries array if not exists\n      if (!localStorage.getItem(STORAGE_KEYS.ENTRIES)) {\n        localStorage.setItem(STORAGE_KEYS.ENTRIES, JSON.stringify([]));\n      }\n\n      // Initialize metadata if not exists\n      if (!localStorage.getItem(STORAGE_KEYS.METADATA)) {\n        const metadata = {\n          version: '1.0.0',\n          createdAt: new Date().toISOString(),\n          lastUpdated: new Date().toISOString()\n        };\n        localStorage.setItem(STORAGE_KEYS.METADATA, JSON.stringify(metadata));\n      }\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize history storage:', error);\n      throw new Error('History storage initialization failed');\n    }\n  }\n\n  /**\n   * Ensure storage is initialized before use\n   */\n  private ensureInitialized(): void {\n    if (!this.isInitialized) {\n      this.initializeStorage();\n    }\n  }\n\n  /**\n   * Get all stored entries from localStorage\n   */\n  private getStoredEntries(): TryonHistoryEntry[] {\n    this.ensureInitialized();\n    try {\n      const entriesJson = localStorage.getItem(STORAGE_KEYS.ENTRIES);\n      return entriesJson ? JSON.parse(entriesJson) : [];\n    } catch (error) {\n      console.error('Failed to parse stored entries:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Save entries to localStorage\n   */\n  private saveEntries(entries: TryonHistoryEntry[]): void {\n    this.ensureInitialized();\n    try {\n      localStorage.setItem(STORAGE_KEYS.ENTRIES, JSON.stringify(entries));\n      \n      // Update metadata\n      const metadata = JSON.parse(localStorage.getItem(STORAGE_KEYS.METADATA) || '{}');\n      metadata.lastUpdated = new Date().toISOString();\n      localStorage.setItem(STORAGE_KEYS.METADATA, JSON.stringify(metadata));\n    } catch (error) {\n      console.error('Failed to save entries to localStorage:', error);\n      throw new Error('Failed to save history entries');\n    }\n  }\n\n  /**\n   * Perform cleanup if needed\n   */\n  private performCleanupIfNeeded(entries: TryonHistoryEntry[]): TryonHistoryEntry[] {\n    if (!this.config.autoCleanup || entries.length <= this.config.maxEntries) {\n      return entries;\n    }\n\n    // Sort by timestamp and keep only the most recent entries\n    const sorted = [...entries].sort((a, b) => \n      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n    );\n    \n    return sorted.slice(0, this.config.maxEntries);\n  }\n\n  /**\n   * Filter and sort entries based on query options\n   */\n  private filterAndSortEntries(\n    entries: TryonHistoryEntry[], \n    options: TryonHistoryQueryOptions = {}\n  ): TryonHistoryEntry[] {\n    let filtered = [...entries];\n\n    // Apply favorites filter\n    if (options.favoritesOnly) {\n      filtered = filtered.filter(entry => entry.isFavorite);\n    }\n\n    // Apply date range filter\n    if (options.dateRange) {\n      const startDate = new Date(options.dateRange.startDate);\n      const endDate = new Date(options.dateRange.endDate);\n      filtered = filtered.filter(entry => {\n        const entryDate = new Date(entry.timestamp);\n        return entryDate >= startDate && entryDate <= endDate;\n      });\n    }\n\n    // Apply search term filter\n    if (options.searchTerm) {\n      const searchTerm = options.searchTerm.toLowerCase();\n      filtered = filtered.filter(entry => \n        entry.tags?.some(tag => tag.toLowerCase().includes(searchTerm)) ||\n        entry.notes?.toLowerCase().includes(searchTerm)\n      );\n    }\n\n    // Apply sorting\n    const sortBy = options.sortBy || 'timestamp';\n    const sortDirection = options.sortDirection || 'desc';\n    \n    filtered.sort((a, b) => {\n      let aValue: Date | number, bValue: Date | number;\n      \n      switch (sortBy) {\n        case 'timestamp':\n          aValue = new Date(a.timestamp);\n          bValue = new Date(b.timestamp);\n          break;\n        case 'processingTime':\n          aValue = a.processingTime || 0;\n          bValue = b.processingTime || 0;\n          break;\n        case 'isFavorite':\n          aValue = a.isFavorite ? 1 : 0;\n          bValue = b.isFavorite ? 1 : 0;\n          break;\n        default:\n          aValue = a.timestamp;\n          bValue = b.timestamp;\n      }\n      \n      if (sortDirection === 'asc') {\n        return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;\n      } else {\n        return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;\n      }\n    });\n\n    return filtered;\n  }\n\n  /**\n   * Add a new history entry\n   */\n  async addEntry(options: CreateTryonHistoryEntryOptions): Promise<TryonHistoryEntry> {\n    const entry: TryonHistoryEntry = {\n      id: generateHistoryId(),\n      timestamp: new Date().toISOString(),\n      generatedImage: options.generatedImage,\n      modelImage: options.modelImage,\n      apparelImages: options.apparelImages,\n      processingTime: options.processingTime,\n      metadata: options.metadata,\n      tags: options.tags || [],\n      isFavorite: options.isFavorite || false,\n      notes: options.notes || ''\n    };\n\n    // Compress entry if enabled\n    const compressedEntry = await compressHistoryEntry(entry, this.config);\n\n    // Check entry size\n    const entrySize = calculateEntrySize(compressedEntry);\n    if (entrySize > this.config.maxEntrySizeKB) {\n      throw new Error(\n        `History entry too large: ${entrySize.toFixed(2)}KB exceeds limit of ${this.config.maxEntrySizeKB}KB`\n      );\n    }\n\n    // Get current entries and add the new one\n    let entries = this.getStoredEntries();\n    entries.push(compressedEntry);\n\n    // Perform cleanup if needed\n    entries = this.performCleanupIfNeeded(entries);\n\n    // Save updated entries\n    this.saveEntries(entries);\n\n    return compressedEntry;\n  }\n\n  /**\n   * Get history entries with filtering and pagination\n   */\n  async getEntries(options: TryonHistoryQueryOptions = {}): Promise<TryonHistoryCollection> {\n    const allEntries = this.getStoredEntries();\n    const filteredEntries = this.filterAndSortEntries(allEntries, options);\n\n    // Apply pagination\n    const page = options.page || 0;\n    const pageSize = options.pageSize || 20;\n    const startIndex = page * pageSize;\n    const endIndex = startIndex + pageSize;\n    const paginatedEntries = filteredEntries.slice(startIndex, endIndex);\n\n    return {\n      entries: paginatedEntries,\n      totalCount: filteredEntries.length,\n      currentPage: page,\n      pageSize,\n      hasMore: endIndex < filteredEntries.length,\n      lastUpdated: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Get a specific history entry by ID\n   */\n  async getEntry(id: string): Promise<TryonHistoryEntry | null> {\n    const entries = this.getStoredEntries();\n    return entries.find(entry => entry.id === id) || null;\n  }\n\n  /**\n   * Update an existing history entry\n   */\n  async updateEntry(id: string, updates: Partial<TryonHistoryEntry>): Promise<TryonHistoryEntry> {\n    const entries = this.getStoredEntries();\n    const entryIndex = entries.findIndex(entry => entry.id === id);\n    \n    if (entryIndex === -1) {\n      throw new Error(`History entry with ID ${id} not found`);\n    }\n\n    // Apply updates\n    const updatedEntry = { \n      ...entries[entryIndex], \n      ...updates,\n      // Preserve ID and timestamp, update only if explicitly provided\n      id: entries[entryIndex].id,\n      timestamp: updates.timestamp || entries[entryIndex].timestamp\n    };\n\n    entries[entryIndex] = updatedEntry;\n    this.saveEntries(entries);\n\n    return updatedEntry;\n  }\n\n  /**\n   * Delete a history entry\n   */\n  async deleteEntry(id: string): Promise<boolean> {\n    const entries = this.getStoredEntries();\n    const filteredEntries = entries.filter(entry => entry.id !== id);\n    \n    if (filteredEntries.length === entries.length) {\n      return false; // Entry not found\n    }\n\n    this.saveEntries(filteredEntries);\n    return true;\n  }\n\n  /**\n   * Clear all history entries\n   */\n  async clearAll(): Promise<boolean> {\n    this.ensureInitialized();\n    try {\n      localStorage.setItem(STORAGE_KEYS.ENTRIES, JSON.stringify([]));\n      return true;\n    } catch (error) {\n      console.error('Failed to clear history:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStorageStats(): Promise<{\n    totalEntries: number;\n    totalSizeKB: number;\n    oldestEntry?: string;\n    newestEntry?: string;\n  }> {\n    const entries = this.getStoredEntries();\n    \n    let totalSizeKB = 0;\n    entries.forEach(entry => {\n      totalSizeKB += calculateEntrySize(entry);\n    });\n\n    const timestamps = entries.map(entry => entry.timestamp).sort();\n    \n    return {\n      totalEntries: entries.length,\n      totalSizeKB,\n      oldestEntry: timestamps[0],\n      newestEntry: timestamps[timestamps.length - 1]\n    };\n  }\n\n  /**\n   * Export history data\n   */\n  async exportHistory(): Promise<TryonHistoryEntry[]> {\n    return this.getStoredEntries();\n  }\n\n  /**\n   * Import history data\n   */\n  async importHistory(entries: TryonHistoryEntry[]): Promise<number> {\n    try {\n      // Validate entries\n      const validEntries = entries.filter(entry => \n        entry.id && entry.generatedImage && entry.modelImage && entry.apparelImages\n      );\n\n      // Get existing entries and merge with imports\n      const existingEntries = this.getStoredEntries();\n      const existingIds = new Set(existingEntries.map(entry => entry.id));\n      \n      // Only import entries that don't already exist\n      const newEntries = validEntries.filter(entry => !existingIds.has(entry.id));\n      \n      if (newEntries.length === 0) {\n        return 0;\n      }\n\n      // Merge and save\n      const mergedEntries = [...existingEntries, ...newEntries];\n      const cleanedEntries = this.performCleanupIfNeeded(mergedEntries);\n      \n      this.saveEntries(cleanedEntries);\n      return newEntries.length;\n    } catch (error) {\n      console.error('Failed to import history:', error);\n      throw new Error('History import failed');\n    }\n  }\n\n  /**\n   * Update service configuration\n   */\n  updateConfig(newConfig: Partial<TryonHistoryStorageConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    \n    this.ensureInitialized();\n    try {\n      localStorage.setItem(STORAGE_KEYS.CONFIG, JSON.stringify(this.config));\n    } catch (error) {\n      console.error('Failed to save config:', error);\n    }\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): TryonHistoryStorageConfig {\n    return { ...this.config };\n  }\n}\n\n/**\n * Default history service instance\n */\nexport const defaultHistoryService = new LocalStorageTryonHistoryService();"],"names":["LocalStorageTryonHistoryService","defaultHistoryService","DEFAULT_CONFIG","storageType","maxEntries","maxEntrySizeKB","compressImages","compressionQuality","autoCleanup","encryptionKey","STORAGE_KEYS","ENTRIES","CONFIG","METADATA","generateHistoryId","Date","now","Math","random","toString","substr","calculateEntrySize","entry","json","JSON","stringify","Blob","size","compressHistoryEntry","config","maxSizeKB","apparelImages","length","quality","compressedGenerated","compressBase64","generatedImage","compressedModel","modelImage","compressedApparel","Promise","all","map","img","metadata","imageProcessingResults","finalImageSizes","modelImageSize","getBase64Size","apparelImageSizes","error","CompressionFailedError","console","warn","constructor","isInitialized","initializeStorage","window","localStorage","Error","getItem","setItem","version","createdAt","toISOString","lastUpdated","ensureInitialized","getStoredEntries","entriesJson","parse","saveEntries","entries","performCleanupIfNeeded","sorted","sort","a","b","timestamp","getTime","slice","filterAndSortEntries","options","filtered","favoritesOnly","filter","isFavorite","dateRange","startDate","endDate","entryDate","searchTerm","toLowerCase","tags","some","tag","includes","notes","sortBy","sortDirection","aValue","bValue","processingTime","addEntry","id","compressedEntry","entrySize","toFixed","push","getEntries","allEntries","filteredEntries","page","pageSize","startIndex","endIndex","paginatedEntries","totalCount","currentPage","hasMore","getEntry","find","updateEntry","updates","entryIndex","findIndex","updatedEntry","deleteEntry","clearAll","getStorageStats","totalSizeKB","forEach","timestamps","totalEntries","oldestEntry","newestEntry","exportHistory","importHistory","validEntries","existingEntries","existingIds","Set","newEntries","has","mergedEntries","cleanedEntries","updateConfig","newConfig","getConfig"],"mappings":"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"}