5e442368796bb8d00a46c24300de87f1
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ImageProcessingOperation: function() {
        return ImageProcessingOperation;
    },
    imageProcessingKeys: function() {
        return imageProcessingKeys;
    },
    useBatchImageProcessing: function() {
        return useBatchImageProcessing;
    },
    useFormatConversion: function() {
        return useFormatConversion;
    },
    useImageMetadata: function() {
        return useImageMetadata;
    },
    useImageProcessing: function() {
        return useImageProcessing;
    },
    useImageProcessingCache: function() {
        return useImageProcessingCache;
    },
    useImageThumbnail: function() {
        return useImageThumbnail;
    },
    useImageValidation: function() {
        return useImageValidation;
    },
    useProcessingStats: function() {
        return useProcessingStats;
    }
});
const _reactquery = require("@tanstack/react-query");
const _react = require("react");
const _imageProcessing = require("../utils/imageProcessing");
const _errorHandling = require("../utils/errorHandling");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
var ImageProcessingOperation = /*#__PURE__*/ function(ImageProcessingOperation) {
    ImageProcessingOperation["BASIC_PROCESSING"] = "basic_processing";
    ImageProcessingOperation["ADVANCED_PROCESSING"] = "advanced_processing";
    ImageProcessingOperation["BATCH_PROCESSING"] = "batch_processing";
    ImageProcessingOperation["THUMBNAIL_GENERATION"] = "thumbnail_generation";
    ImageProcessingOperation["METADATA_EXTRACTION"] = "metadata_extraction";
    ImageProcessingOperation["FORMAT_CONVERSION"] = "format_conversion";
    ImageProcessingOperation["VALIDATION"] = "validation";
    return ImageProcessingOperation;
}({});
/**
 * Default batch processing configuration
 */ const DEFAULT_BATCH_CONFIG = {
    maxConcurrent: 3,
    retryAttempts: 2,
    retryDelay: 1000
};
const imageProcessingKeys = {
    all: [
        'imageProcessing'
    ],
    metadata: (fileId)=>[
            ...imageProcessingKeys.all,
            'metadata',
            fileId
        ],
    thumbnail: (fileId, size)=>[
            ...imageProcessingKeys.all,
            'thumbnail',
            fileId,
            size
        ],
    validation: (fileId)=>[
            ...imageProcessingKeys.all,
            'validation',
            fileId
        ],
    processing: (operationId)=>[
            ...imageProcessingKeys.all,
            'processing',
            operationId
        ],
    stats: ()=>[
            ...imageProcessingKeys.all,
            'stats'
        ]
};
function useImageProcessing() {
    const queryClient = (0, _reactquery.useQueryClient)();
    const basicProcessingMutation = (0, _reactquery.useMutation)({
        mutationFn: async (file)=>{
            try {
                return await (0, _imageProcessing.processImageForTryon)(file);
            } catch (error) {
                const classifiedError = (0, _errorHandling.classifyTryonError)(error);
                (0, _errorHandling.logAndClassifyError)(error, {
                    operation: 'basic_processing',
                    fileName: file.name
                });
                throw classifiedError;
            }
        },
        onSuccess: (result, file)=>{
            // Cache the result
            queryClient.setQueryData(imageProcessingKeys.processing(`basic_${file.name}_${file.lastModified}`), result);
        },
        onError: (error, file)=>{
            console.error(`Failed to process image ${file.name}:`, error);
        }
    });
    const advancedProcessingMutation = (0, _reactquery.useMutation)({
        mutationFn: async ({ file, options })=>{
            try {
                return await (0, _imageProcessing.processImageAdvanced)(file, options);
            } catch (error) {
                const classifiedError = (0, _errorHandling.classifyTryonError)(error);
                (0, _errorHandling.logAndClassifyError)(error, {
                    operation: 'advanced_processing',
                    fileName: file.name,
                    options
                });
                throw classifiedError;
            }
        },
        onSuccess: (result, { file })=>{
            // Cache the result
            queryClient.setQueryData(imageProcessingKeys.processing(`advanced_${file.name}_${file.lastModified}`), result);
        }
    });
    return {
        processBasic: basicProcessingMutation.mutateAsync,
        processAdvanced: advancedProcessingMutation.mutateAsync,
        isProcessingBasic: basicProcessingMutation.isPending,
        isProcessingAdvanced: advancedProcessingMutation.isPending,
        basicError: basicProcessingMutation.error,
        advancedError: advancedProcessingMutation.error,
        reset: ()=>{
            basicProcessingMutation.reset();
            advancedProcessingMutation.reset();
        }
    };
}
function useImageMetadata(file, enabled = true) {
    return (0, _reactquery.useQuery)({
        queryKey: file ? imageProcessingKeys.metadata(`${file.name}_${file.lastModified}`) : [],
        queryFn: async ()=>{
            if (!file) throw new Error('No file provided');
            try {
                return await (0, _imageProcessing.extractImageMetadata)(file);
            } catch (error) {
                const classifiedError = (0, _errorHandling.classifyTryonError)(error);
                (0, _errorHandling.logAndClassifyError)(error, {
                    operation: 'metadata_extraction',
                    fileName: file.name
                });
                throw classifiedError;
            }
        },
        enabled: enabled && !!file,
        staleTime: 5 * 60 * 1000,
        gcTime: 10 * 60 * 1000 // 10 minutes
    });
}
function useImageThumbnail(file, size = 150, enabled = true) {
    return (0, _reactquery.useQuery)({
        queryKey: file ? imageProcessingKeys.thumbnail(`${file.name}_${file.lastModified}`, size) : [],
        queryFn: async ()=>{
            if (!file) throw new Error('No file provided');
            try {
                return await (0, _imageProcessing.createImageThumbnail)(file, size);
            } catch (error) {
                const classifiedError = (0, _errorHandling.classifyTryonError)(error);
                (0, _errorHandling.logAndClassifyError)(error, {
                    operation: 'thumbnail_generation',
                    fileName: file.name,
                    size
                });
                throw classifiedError;
            }
        },
        enabled: enabled && !!file,
        staleTime: 10 * 60 * 1000,
        gcTime: 30 * 60 * 1000 // 30 minutes
    });
}
function useImageValidation(file, enabled = true) {
    return (0, _reactquery.useQuery)({
        queryKey: file ? imageProcessingKeys.validation(`${file.name}_${file.lastModified}`) : [],
        queryFn: async ()=>{
            if (!file) throw new Error('No file provided');
            const errors = [];
            try {
                // Basic file type validation
                if (!file.type.startsWith('image/')) {
                    errors.push('File is not an image');
                }
                // File size validation (10MB max)
                if (file.size > 10 * 1024 * 1024) {
                    errors.push('File size too large (max 10MB)');
                }
                // Dimension validation
                try {
                    const metadata = await (0, _imageProcessing.extractImageMetadata)(file);
                    if (metadata.dimensions.width < 256 || metadata.dimensions.height < 256) {
                        errors.push('Image dimensions too small (minimum 256x256)');
                    }
                    if (metadata.dimensions.width > 4096 || metadata.dimensions.height > 4096) {
                        errors.push('Image dimensions too large (maximum 4096x4096)');
                    }
                } catch (error) {
                    errors.push('Failed to validate image dimensions');
                }
                return {
                    isValid: errors.length === 0,
                    errors
                };
            } catch (error) {
                const classifiedError = (0, _errorHandling.classifyTryonError)(error);
                (0, _errorHandling.logAndClassifyError)(error, {
                    operation: 'validation',
                    fileName: file.name
                });
                throw classifiedError;
            }
        },
        enabled: enabled && !!file,
        staleTime: 2 * 60 * 1000,
        gcTime: 5 * 60 * 1000 // 5 minutes
    });
}
function useFormatConversion() {
    const queryClient = (0, _reactquery.useQueryClient)();
    return (0, _reactquery.useMutation)({
        mutationFn: async ({ file, targetFormat, quality = 0.9 })=>{
            try {
                const imageUrl = URL.createObjectURL(file);
                const { convertImageFormat } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../utils/imageProcessing")));
                const result = await convertImageFormat(imageUrl, targetFormat, quality);
                URL.revokeObjectURL(imageUrl);
                return result;
            } catch (error) {
                const classifiedError = (0, _errorHandling.classifyTryonError)(error);
                (0, _errorHandling.logAndClassifyError)(error, {
                    operation: 'format_conversion',
                    fileName: file.name,
                    targetFormat,
                    quality
                });
                throw classifiedError;
            }
        },
        onSuccess: (result, { file, targetFormat })=>{
            // Invalidate related queries
            queryClient.invalidateQueries({
                queryKey: imageProcessingKeys.metadata(`${file.name}_${file.lastModified}`)
            });
        }
    });
}
function useBatchImageProcessing(config = {}) {
    const processingConfig = {
        ...DEFAULT_BATCH_CONFIG,
        ...config
    };
    const [queueState, setQueueState] = (0, _react.useState)({
        queue: [],
        activeItems: [],
        completedItems: [],
        failedItems: [],
        isProcessing: false,
        totalProgress: 0
    });
    const queueRef = (0, _react.useRef)([]);
    const activeRef = (0, _react.useRef)(new Map());
    const statsRef = (0, _react.useRef)({
        totalProcessed: 0,
        totalFailed: 0,
        averageProcessingTime: 0,
        totalProcessingTime: 0,
        peakMemoryUsage: 0,
        cacheHitRate: 0
    });
    const generateId = (0, _react.useCallback)(()=>{
        return `proc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }, []);
    const updateQueueState = (0, _react.useCallback)(()=>{
        const activeItems = Array.from(activeRef.current.values());
        const completedItems = queueRef.current.filter((item)=>item.status === 'completed');
        const failedItems = queueRef.current.filter((item)=>item.status === 'failed');
        const totalItems = queueRef.current.length;
        const totalProgress = totalItems > 0 ? (completedItems.length + failedItems.length) / totalItems * 100 : 0;
        setQueueState({
            queue: [
                ...queueRef.current
            ],
            activeItems,
            completedItems,
            failedItems,
            isProcessing: activeItems.length > 0,
            totalProgress
        });
    }, []);
    const processQueueItem = (0, _react.useCallback)(async (item)=>{
        item.status = 'processing';
        item.startTime = Date.now();
        activeRef.current.set(item.id, item);
        updateQueueState();
        try {
            let result;
            switch(item.operation){
                case "basic_processing":
                    result = await (0, _imageProcessing.processImageForTryon)(item.file, item.options);
                    break;
                case "advanced_processing":
                    result = await (0, _imageProcessing.processImageAdvanced)(item.file, item.options);
                    break;
                case "thumbnail_generation":
                    result = await (0, _imageProcessing.createImageThumbnail)(item.file, item.options?.size || 150);
                    break;
                case "metadata_extraction":
                    result = await (0, _imageProcessing.extractImageMetadata)(item.file);
                    break;
                case "format_conversion":
                    const imageUrl = URL.createObjectURL(item.file);
                    result = await (0, _imageProcessing.convertImageFormat)(imageUrl, item.options.targetFormat, item.options.quality);
                    URL.revokeObjectURL(imageUrl);
                    break;
                default:
                    throw new Error(`Unsupported operation: ${item.operation}`);
            }
            item.status = 'completed';
            item.result = result;
            item.endTime = Date.now();
            item.progress = 100;
            // Update stats
            const processingTime = item.endTime - (item.startTime || 0);
            statsRef.current.totalProcessed++;
            statsRef.current.totalProcessingTime += processingTime;
            statsRef.current.averageProcessingTime = statsRef.current.totalProcessingTime / statsRef.current.totalProcessed;
            processingConfig.itemCompleteCallback?.(item);
        } catch (error) {
            item.status = 'failed';
            item.endTime = Date.now();
            item.error = (0, _errorHandling.classifyTryonError)(error);
            statsRef.current.totalFailed++;
            (0, _errorHandling.logAndClassifyError)(error, {
                operation: item.operation,
                fileName: item.file.name,
                itemId: item.id
            });
            processingConfig.errorCallback?.(item, item.error);
        } finally{
            activeRef.current.delete(item.id);
            updateQueueState();
            // Process next items in queue
            processNextInQueue();
        }
    }, [
        processingConfig,
        updateQueueState
    ]);
    const processNextInQueue = (0, _react.useCallback)(()=>{
        const pendingItems = queueRef.current.filter((item)=>item.status === 'pending').sort((a, b)=>{
            const priorityOrder = {
                high: 3,
                normal: 2,
                low: 1
            };
            return priorityOrder[b.priority] - priorityOrder[a.priority];
        });
        const availableSlots = processingConfig.maxConcurrent - activeRef.current.size;
        for(let i = 0; i < Math.min(availableSlots, pendingItems.length); i++){
            processQueueItem(pendingItems[i]);
        }
    }, [
        processingConfig.maxConcurrent,
        processQueueItem
    ]);
    const addToQueue = (0, _react.useCallback)((operation, file, options, priority = 'normal')=>{
        const item = {
            id: generateId(),
            operation,
            file,
            options,
            priority,
            status: 'pending',
            progress: 0
        };
        queueRef.current.push(item);
        updateQueueState();
        // Start processing if under capacity
        if (activeRef.current.size < processingConfig.maxConcurrent) {
            processNextInQueue();
        }
        return item.id;
    }, [
        generateId,
        processingConfig.maxConcurrent,
        updateQueueState,
        processNextInQueue
    ]);
    const removeFromQueue = (0, _react.useCallback)((itemId)=>{
        const index = queueRef.current.findIndex((item)=>item.id === itemId);
        if (index === -1) return false;
        const item = queueRef.current[index];
        if (item.status === 'processing') {
            // Cannot remove active items
            return false;
        }
        queueRef.current.splice(index, 1);
        updateQueueState();
        return true;
    }, [
        updateQueueState
    ]);
    const clearQueue = (0, _react.useCallback)((includeActive = false)=>{
        if (includeActive) {
            queueRef.current = [];
            activeRef.current.clear();
        } else {
            queueRef.current = queueRef.current.filter((item)=>item.status === 'processing');
        }
        updateQueueState();
    }, [
        updateQueueState
    ]);
    const pauseQueue = (0, _react.useCallback)(()=>{
    // Implementation would pause processing new items
    // For now, just stop processing new items
    }, []);
    const resumeQueue = (0, _react.useCallback)(()=>{
        processNextInQueue();
    }, [
        processNextInQueue
    ]);
    const getStats = (0, _react.useCallback)(()=>{
        return {
            ...statsRef.current
        };
    }, []);
    return {
        queueState,
        addToQueue,
        removeFromQueue,
        clearQueue,
        pauseQueue,
        resumeQueue,
        getStats,
        processingConfig
    };
}
function useProcessingStats() {
    return (0, _reactquery.useQuery)({
        queryKey: imageProcessingKeys.stats(),
        queryFn: async ()=>{
            // This would typically fetch from a backend or local storage
            return {
                totalProcessed: 0,
                totalFailed: 0,
                averageProcessingTime: 0,
                totalProcessingTime: 0,
                peakMemoryUsage: 0,
                cacheHitRate: 0
            };
        },
        staleTime: 30 * 1000,
        gcTime: 2 * 60 * 1000 // 2 minutes
    });
}
function useImageProcessingCache() {
    const queryClient = (0, _reactquery.useQueryClient)();
    const clearCache = (0, _react.useCallback)((pattern)=>{
        if (pattern) {
            queryClient.invalidateQueries({
                predicate: (query)=>query.queryKey.toString().includes(pattern)
            });
        } else {
            queryClient.invalidateQueries({
                queryKey: imageProcessingKeys.all
            });
        }
    }, [
        queryClient
    ]);
    const getCacheStats = (0, _react.useCallback)(()=>{
        const cache = queryClient.getQueryCache();
        const queries = cache.findAll({
            queryKey: imageProcessingKeys.all
        });
        return {
            totalQueries: queries.length,
            activeQueries: queries.filter((q)=>q.isActive()).length,
            stalequeries: queries.filter((q)=>q.isStale()).length,
            invalidQueries: queries.filter((q)=>q.isInvalid()).length
        };
    }, [
        queryClient
    ]);
    const preloadMetadata = (0, _react.useCallback)(async (files)=>{
        const promises = files.map((file)=>queryClient.prefetchQuery({
                queryKey: imageProcessingKeys.metadata(`${file.name}_${file.lastModified}`),
                queryFn: ()=>(0, _imageProcessing.extractImageMetadata)(file)
            }));
        await Promise.allSettled(promises);
    }, [
        queryClient
    ]);
    return {
        clearCache,
        getCacheStats,
        preloadMetadata
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL3F1ZXJpZXMvdXNlSW1hZ2VQcm9jZXNzaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuLy8gSW1hZ2UgUHJvY2Vzc2luZyBSZWFjdCBRdWVyeSBIb29rc1xuLy8gUmVhY3QgUXVlcnkgaW50ZWdyYXRpb24gZm9yIGltYWdlIHByb2Nlc3Npbmcgb3BlcmF0aW9ucyB3aXRoIHByb2dyZXNzIHRyYWNraW5nXG5cbmltcG9ydCB7IHVzZU11dGF0aW9uLCB1c2VRdWVyeSwgdXNlUXVlcnlDbGllbnQgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICBwcm9jZXNzSW1hZ2VGb3JUcnlvbixcbiAgcHJvY2Vzc0ltYWdlQWR2YW5jZWQsXG4gIHByb2Nlc3NJbWFnZXNJbkJhdGNoLFxuICBjcmVhdGVJbWFnZVRodW1ibmFpbCxcbiAgZXh0cmFjdEltYWdlTWV0YWRhdGEsXG4gIGNvbnZlcnRJbWFnZUZvcm1hdCxcbiAgdmFsaWRhdGVJbWFnZURpbWVuc2lvbnMsXG4gIEltYWdlRm9ybWF0LFxuICB0eXBlIEltYWdlUHJvY2Vzc2luZ1Jlc3VsdCxcbiAgdHlwZSBBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ1Jlc3VsdCxcbiAgdHlwZSBBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ09wdGlvbnMsXG4gIHR5cGUgSW1hZ2VNZXRhZGF0YVxufSBmcm9tICcuLi91dGlscy9pbWFnZVByb2Nlc3NpbmcnO1xuaW1wb3J0IHtcbiAgY2xhc3NpZnlUcnlvbkVycm9yLFxuICBsb2dBbmRDbGFzc2lmeUVycm9yLFxuICB0eXBlIENsYXNzaWZpZWRFcnJvclxufSBmcm9tICcuLi91dGlscy9lcnJvckhhbmRsaW5nJztcblxuLyoqXG4gKiBJbWFnZSBwcm9jZXNzaW5nIG9wZXJhdGlvbiB0eXBlc1xuICovXG5leHBvcnQgZW51bSBJbWFnZVByb2Nlc3NpbmdPcGVyYXRpb24ge1xuICBCQVNJQ19QUk9DRVNTSU5HID0gJ2Jhc2ljX3Byb2Nlc3NpbmcnLFxuICBBRFZBTkNFRF9QUk9DRVNTSU5HID0gJ2FkdmFuY2VkX3Byb2Nlc3NpbmcnLFxuICBCQVRDSF9QUk9DRVNTSU5HID0gJ2JhdGNoX3Byb2Nlc3NpbmcnLFxuICBUSFVNQk5BSUxfR0VORVJBVElPTiA9ICd0aHVtYm5haWxfZ2VuZXJhdGlvbicsXG4gIE1FVEFEQVRBX0VYVFJBQ1RJT04gPSAnbWV0YWRhdGFfZXh0cmFjdGlvbicsXG4gIEZPUk1BVF9DT05WRVJTSU9OID0gJ2Zvcm1hdF9jb252ZXJzaW9uJyxcbiAgVkFMSURBVElPTiA9ICd2YWxpZGF0aW9uJ1xufVxuXG4vKipcbiAqIFByb2Nlc3NpbmcgcXVldWUgaXRlbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NpbmdRdWV1ZUl0ZW0ge1xuICBpZDogc3RyaW5nO1xuICBvcGVyYXRpb246IEltYWdlUHJvY2Vzc2luZ09wZXJhdGlvbjtcbiAgZmlsZTogRmlsZTtcbiAgb3B0aW9ucz86IGFueTtcbiAgcHJpb3JpdHk6ICdsb3cnIHwgJ25vcm1hbCcgfCAnaGlnaCc7XG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJztcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgcmVzdWx0PzogYW55O1xuICBlcnJvcj86IENsYXNzaWZpZWRFcnJvcjtcbiAgc3RhcnRUaW1lPzogbnVtYmVyO1xuICBlbmRUaW1lPzogbnVtYmVyO1xuICBlc3RpbWF0ZWRUaW1lPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEJhdGNoIHByb2Nlc3NpbmcgY29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoUHJvY2Vzc2luZ0NvbmZpZyB7XG4gIG1heENvbmN1cnJlbnQ6IG51bWJlcjtcbiAgcmV0cnlBdHRlbXB0czogbnVtYmVyO1xuICByZXRyeURlbGF5OiBudW1iZXI7XG4gIHByb2dyZXNzQ2FsbGJhY2s/OiAoY29tcGxldGVkOiBudW1iZXIsIHRvdGFsOiBudW1iZXIsIGN1cnJlbnRJdGVtOiBQcm9jZXNzaW5nUXVldWVJdGVtKSA9PiB2b2lkO1xuICBpdGVtQ29tcGxldGVDYWxsYmFjaz86IChpdGVtOiBQcm9jZXNzaW5nUXVldWVJdGVtKSA9PiB2b2lkO1xuICBlcnJvckNhbGxiYWNrPzogKGl0ZW06IFByb2Nlc3NpbmdRdWV1ZUl0ZW0sIGVycm9yOiBDbGFzc2lmaWVkRXJyb3IpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogSW1hZ2UgcHJvY2Vzc2luZyBzdGF0c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NpbmdTdGF0cyB7XG4gIHRvdGFsUHJvY2Vzc2VkOiBudW1iZXI7XG4gIHRvdGFsRmFpbGVkOiBudW1iZXI7XG4gIGF2ZXJhZ2VQcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuICB0b3RhbFByb2Nlc3NpbmdUaW1lOiBudW1iZXI7XG4gIHBlYWtNZW1vcnlVc2FnZTogbnVtYmVyO1xuICBjYWNoZUhpdFJhdGU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBQcm9jZXNzaW5nIHF1ZXVlIHN0YXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2luZ1F1ZXVlU3RhdGUge1xuICBxdWV1ZTogUHJvY2Vzc2luZ1F1ZXVlSXRlbVtdO1xuICBhY3RpdmVJdGVtczogUHJvY2Vzc2luZ1F1ZXVlSXRlbVtdO1xuICBjb21wbGV0ZWRJdGVtczogUHJvY2Vzc2luZ1F1ZXVlSXRlbVtdO1xuICBmYWlsZWRJdGVtczogUHJvY2Vzc2luZ1F1ZXVlSXRlbVtdO1xuICBpc1Byb2Nlc3Npbmc6IGJvb2xlYW47XG4gIHRvdGFsUHJvZ3Jlc3M6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGJhdGNoIHByb2Nlc3NpbmcgY29uZmlndXJhdGlvblxuICovXG5jb25zdCBERUZBVUxUX0JBVENIX0NPTkZJRzogQmF0Y2hQcm9jZXNzaW5nQ29uZmlnID0ge1xuICBtYXhDb25jdXJyZW50OiAzLFxuICByZXRyeUF0dGVtcHRzOiAyLFxuICByZXRyeURlbGF5OiAxMDAwXG59O1xuXG4vKipcbiAqIFF1ZXJ5IGtleXMgZm9yIFJlYWN0IFF1ZXJ5XG4gKi9cbmV4cG9ydCBjb25zdCBpbWFnZVByb2Nlc3NpbmdLZXlzID0ge1xuICBhbGw6IFsnaW1hZ2VQcm9jZXNzaW5nJ10gYXMgY29uc3QsXG4gIG1ldGFkYXRhOiAoZmlsZUlkOiBzdHJpbmcpID0+IFsuLi5pbWFnZVByb2Nlc3NpbmdLZXlzLmFsbCwgJ21ldGFkYXRhJywgZmlsZUlkXSBhcyBjb25zdCxcbiAgdGh1bWJuYWlsOiAoZmlsZUlkOiBzdHJpbmcsIHNpemU6IG51bWJlcikgPT4gWy4uLmltYWdlUHJvY2Vzc2luZ0tleXMuYWxsLCAndGh1bWJuYWlsJywgZmlsZUlkLCBzaXplXSBhcyBjb25zdCxcbiAgdmFsaWRhdGlvbjogKGZpbGVJZDogc3RyaW5nKSA9PiBbLi4uaW1hZ2VQcm9jZXNzaW5nS2V5cy5hbGwsICd2YWxpZGF0aW9uJywgZmlsZUlkXSBhcyBjb25zdCxcbiAgcHJvY2Vzc2luZzogKG9wZXJhdGlvbklkOiBzdHJpbmcpID0+IFsuLi5pbWFnZVByb2Nlc3NpbmdLZXlzLmFsbCwgJ3Byb2Nlc3NpbmcnLCBvcGVyYXRpb25JZF0gYXMgY29uc3QsXG4gIHN0YXRzOiAoKSA9PiBbLi4uaW1hZ2VQcm9jZXNzaW5nS2V5cy5hbGwsICdzdGF0cyddIGFzIGNvbnN0XG59O1xuXG4vKipcbiAqIEJhc2ljIGltYWdlIHByb2Nlc3NpbmcgaG9vayBmb3IgdHJ5LW9uIG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltYWdlUHJvY2Vzc2luZygpIHtcbiAgY29uc3QgcXVlcnlDbGllbnQgPSB1c2VRdWVyeUNsaWVudCgpO1xuXG4gIGNvbnN0IGJhc2ljUHJvY2Vzc2luZ011dGF0aW9uID0gdXNlTXV0YXRpb24oe1xuICAgIG11dGF0aW9uRm46IGFzeW5jIChmaWxlOiBGaWxlKTogUHJvbWlzZTxJbWFnZVByb2Nlc3NpbmdSZXN1bHQ+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzSW1hZ2VGb3JUcnlvbihmaWxlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzaWZpZWRFcnJvciA9IGNsYXNzaWZ5VHJ5b25FcnJvcihlcnJvcik7XG4gICAgICAgIGxvZ0FuZENsYXNzaWZ5RXJyb3IoZXJyb3IsIHsgb3BlcmF0aW9uOiAnYmFzaWNfcHJvY2Vzc2luZycsIGZpbGVOYW1lOiBmaWxlLm5hbWUgfSk7XG4gICAgICAgIHRocm93IGNsYXNzaWZpZWRFcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uU3VjY2VzczogKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKFxuICAgICAgICBpbWFnZVByb2Nlc3NpbmdLZXlzLnByb2Nlc3NpbmcoYGJhc2ljXyR7ZmlsZS5uYW1lfV8ke2ZpbGUubGFzdE1vZGlmaWVkfWApLFxuICAgICAgICByZXN1bHRcbiAgICAgICk7XG4gICAgfSxcbiAgICBvbkVycm9yOiAoZXJyb3I6IENsYXNzaWZpZWRFcnJvciwgZmlsZSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHByb2Nlc3MgaW1hZ2UgJHtmaWxlLm5hbWV9OmAsIGVycm9yKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGFkdmFuY2VkUHJvY2Vzc2luZ011dGF0aW9uID0gdXNlTXV0YXRpb24oe1xuICAgIG11dGF0aW9uRm46IGFzeW5jICh7XG4gICAgICBmaWxlLFxuICAgICAgb3B0aW9uc1xuICAgIH06IHtcbiAgICAgIGZpbGU6IEZpbGU7XG4gICAgICBvcHRpb25zPzogUGFydGlhbDxBZHZhbmNlZEltYWdlUHJvY2Vzc2luZ09wdGlvbnM+O1xuICAgIH0pOiBQcm9taXNlPEFkdmFuY2VkSW1hZ2VQcm9jZXNzaW5nUmVzdWx0PiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc0ltYWdlQWR2YW5jZWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBjbGFzc2lmaWVkRXJyb3IgPSBjbGFzc2lmeVRyeW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBsb2dBbmRDbGFzc2lmeUVycm9yKGVycm9yLCB7IFxuICAgICAgICAgIG9wZXJhdGlvbjogJ2FkdmFuY2VkX3Byb2Nlc3NpbmcnLCBcbiAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgIG9wdGlvbnMgXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBjbGFzc2lmaWVkRXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICBvblN1Y2Nlc3M6IChyZXN1bHQsIHsgZmlsZSB9KSA9PiB7XG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoXG4gICAgICAgIGltYWdlUHJvY2Vzc2luZ0tleXMucHJvY2Vzc2luZyhgYWR2YW5jZWRfJHtmaWxlLm5hbWV9XyR7ZmlsZS5sYXN0TW9kaWZpZWR9YCksXG4gICAgICAgIHJlc3VsdFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc0Jhc2ljOiBiYXNpY1Byb2Nlc3NpbmdNdXRhdGlvbi5tdXRhdGVBc3luYyxcbiAgICBwcm9jZXNzQWR2YW5jZWQ6IGFkdmFuY2VkUHJvY2Vzc2luZ011dGF0aW9uLm11dGF0ZUFzeW5jLFxuICAgIGlzUHJvY2Vzc2luZ0Jhc2ljOiBiYXNpY1Byb2Nlc3NpbmdNdXRhdGlvbi5pc1BlbmRpbmcsXG4gICAgaXNQcm9jZXNzaW5nQWR2YW5jZWQ6IGFkdmFuY2VkUHJvY2Vzc2luZ011dGF0aW9uLmlzUGVuZGluZyxcbiAgICBiYXNpY0Vycm9yOiBiYXNpY1Byb2Nlc3NpbmdNdXRhdGlvbi5lcnJvcixcbiAgICBhZHZhbmNlZEVycm9yOiBhZHZhbmNlZFByb2Nlc3NpbmdNdXRhdGlvbi5lcnJvcixcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgYmFzaWNQcm9jZXNzaW5nTXV0YXRpb24ucmVzZXQoKTtcbiAgICAgIGFkdmFuY2VkUHJvY2Vzc2luZ011dGF0aW9uLnJlc2V0KCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEltYWdlIG1ldGFkYXRhIGV4dHJhY3Rpb24gaG9va1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1hZ2VNZXRhZGF0YShmaWxlOiBGaWxlIHwgbnVsbCwgZW5hYmxlZDogYm9vbGVhbiA9IHRydWUpIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogZmlsZSA/IGltYWdlUHJvY2Vzc2luZ0tleXMubWV0YWRhdGEoYCR7ZmlsZS5uYW1lfV8ke2ZpbGUubGFzdE1vZGlmaWVkfWApIDogW10sXG4gICAgcXVlcnlGbjogYXN5bmMgKCk6IFByb21pc2U8SW1hZ2VNZXRhZGF0YT4gPT4ge1xuICAgICAgaWYgKCFmaWxlKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGZpbGUgcHJvdmlkZWQnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBleHRyYWN0SW1hZ2VNZXRhZGF0YShmaWxlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzaWZpZWRFcnJvciA9IGNsYXNzaWZ5VHJ5b25FcnJvcihlcnJvcik7XG4gICAgICAgIGxvZ0FuZENsYXNzaWZ5RXJyb3IoZXJyb3IsIHsgb3BlcmF0aW9uOiAnbWV0YWRhdGFfZXh0cmFjdGlvbicsIGZpbGVOYW1lOiBmaWxlLm5hbWUgfSk7XG4gICAgICAgIHRocm93IGNsYXNzaWZpZWRFcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuYWJsZWQ6IGVuYWJsZWQgJiYgISFmaWxlLFxuICAgIHN0YWxlVGltZTogNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzXG4gICAgZ2NUaW1lOiAxMCAqIDYwICogMTAwMCAvLyAxMCBtaW51dGVzXG4gIH0pO1xufVxuXG4vKipcbiAqIEltYWdlIHRodW1ibmFpbCBnZW5lcmF0aW9uIGhvb2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltYWdlVGh1bWJuYWlsKGZpbGU6IEZpbGUgfCBudWxsLCBzaXplOiBudW1iZXIgPSAxNTAsIGVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlKSB7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IGZpbGUgPyBpbWFnZVByb2Nlc3NpbmdLZXlzLnRodW1ibmFpbChgJHtmaWxlLm5hbWV9XyR7ZmlsZS5sYXN0TW9kaWZpZWR9YCwgc2l6ZSkgOiBbXSxcbiAgICBxdWVyeUZuOiBhc3luYyAoKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAgIGlmICghZmlsZSkgdGhyb3cgbmV3IEVycm9yKCdObyBmaWxlIHByb3ZpZGVkJyk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgY3JlYXRlSW1hZ2VUaHVtYm5haWwoZmlsZSwgc2l6ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBjbGFzc2lmaWVkRXJyb3IgPSBjbGFzc2lmeVRyeW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBsb2dBbmRDbGFzc2lmeUVycm9yKGVycm9yLCB7IFxuICAgICAgICAgIG9wZXJhdGlvbjogJ3RodW1ibmFpbF9nZW5lcmF0aW9uJywgXG4gICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICBzaXplIFxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgY2xhc3NpZmllZEVycm9yO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5hYmxlZDogZW5hYmxlZCAmJiAhIWZpbGUsXG4gICAgc3RhbGVUaW1lOiAxMCAqIDYwICogMTAwMCwgLy8gMTAgbWludXRlc1xuICAgIGdjVGltZTogMzAgKiA2MCAqIDEwMDAgLy8gMzAgbWludXRlc1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbWFnZSB2YWxpZGF0aW9uIGhvb2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltYWdlVmFsaWRhdGlvbihmaWxlOiBGaWxlIHwgbnVsbCwgZW5hYmxlZDogYm9vbGVhbiA9IHRydWUpIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogZmlsZSA/IGltYWdlUHJvY2Vzc2luZ0tleXMudmFsaWRhdGlvbihgJHtmaWxlLm5hbWV9XyR7ZmlsZS5sYXN0TW9kaWZpZWR9YCkgOiBbXSxcbiAgICBxdWVyeUZuOiBhc3luYyAoKTogUHJvbWlzZTx7IGlzVmFsaWQ6IGJvb2xlYW47IGVycm9yczogc3RyaW5nW10gfT4gPT4ge1xuICAgICAgaWYgKCFmaWxlKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGZpbGUgcHJvdmlkZWQnKTtcbiAgICAgIFxuICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBCYXNpYyBmaWxlIHR5cGUgdmFsaWRhdGlvblxuICAgICAgICBpZiAoIWZpbGUudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKCdGaWxlIGlzIG5vdCBhbiBpbWFnZScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGaWxlIHNpemUgdmFsaWRhdGlvbiAoMTBNQiBtYXgpXG4gICAgICAgIGlmIChmaWxlLnNpemUgPiAxMCAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ0ZpbGUgc2l6ZSB0b28gbGFyZ2UgKG1heCAxME1CKScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEaW1lbnNpb24gdmFsaWRhdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgZXh0cmFjdEltYWdlTWV0YWRhdGEoZmlsZSk7XG4gICAgICAgICAgaWYgKG1ldGFkYXRhLmRpbWVuc2lvbnMud2lkdGggPCAyNTYgfHwgbWV0YWRhdGEuZGltZW5zaW9ucy5oZWlnaHQgPCAyNTYpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKCdJbWFnZSBkaW1lbnNpb25zIHRvbyBzbWFsbCAobWluaW11bSAyNTZ4MjU2KScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWV0YWRhdGEuZGltZW5zaW9ucy53aWR0aCA+IDQwOTYgfHwgbWV0YWRhdGEuZGltZW5zaW9ucy5oZWlnaHQgPiA0MDk2KSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnSW1hZ2UgZGltZW5zaW9ucyB0b28gbGFyZ2UgKG1heGltdW0gNDA5Nng0MDk2KScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCgnRmFpbGVkIHRvIHZhbGlkYXRlIGltYWdlIGRpbWVuc2lvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgY2xhc3NpZmllZEVycm9yID0gY2xhc3NpZnlUcnlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgbG9nQW5kQ2xhc3NpZnlFcnJvcihlcnJvciwgeyBvcGVyYXRpb246ICd2YWxpZGF0aW9uJywgZmlsZU5hbWU6IGZpbGUubmFtZSB9KTtcbiAgICAgICAgdGhyb3cgY2xhc3NpZmllZEVycm9yO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5hYmxlZDogZW5hYmxlZCAmJiAhIWZpbGUsXG4gICAgc3RhbGVUaW1lOiAyICogNjAgKiAxMDAwLCAvLyAyIG1pbnV0ZXNcbiAgICBnY1RpbWU6IDUgKiA2MCAqIDEwMDAgLy8gNSBtaW51dGVzXG4gIH0pO1xufVxuXG4vKipcbiAqIEZvcm1hdCBjb252ZXJzaW9uIGhvb2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcm1hdENvbnZlcnNpb24oKSB7XG4gIGNvbnN0IHF1ZXJ5Q2xpZW50ID0gdXNlUXVlcnlDbGllbnQoKTtcblxuICByZXR1cm4gdXNlTXV0YXRpb24oe1xuICAgIG11dGF0aW9uRm46IGFzeW5jICh7XG4gICAgICBmaWxlLFxuICAgICAgdGFyZ2V0Rm9ybWF0LFxuICAgICAgcXVhbGl0eSA9IDAuOVxuICAgIH06IHtcbiAgICAgIGZpbGU6IEZpbGU7XG4gICAgICB0YXJnZXRGb3JtYXQ6IEltYWdlRm9ybWF0O1xuICAgICAgcXVhbGl0eT86IG51bWJlcjtcbiAgICB9KTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGltYWdlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgY29uc3QgeyBjb252ZXJ0SW1hZ2VGb3JtYXQgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnZlcnRJbWFnZUZvcm1hdChpbWFnZVVybCwgdGFyZ2V0Rm9ybWF0LCBxdWFsaXR5KTtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpbWFnZVVybCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBjbGFzc2lmaWVkRXJyb3IgPSBjbGFzc2lmeVRyeW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBsb2dBbmRDbGFzc2lmeUVycm9yKGVycm9yLCB7IFxuICAgICAgICAgIG9wZXJhdGlvbjogJ2Zvcm1hdF9jb252ZXJzaW9uJywgXG4gICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICB0YXJnZXRGb3JtYXQsXG4gICAgICAgICAgcXVhbGl0eSBcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IGNsYXNzaWZpZWRFcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uU3VjY2VzczogKHJlc3VsdCwgeyBmaWxlLCB0YXJnZXRGb3JtYXQgfSkgPT4ge1xuICAgICAgLy8gSW52YWxpZGF0ZSByZWxhdGVkIHF1ZXJpZXNcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHtcbiAgICAgICAgcXVlcnlLZXk6IGltYWdlUHJvY2Vzc2luZ0tleXMubWV0YWRhdGEoYCR7ZmlsZS5uYW1lfV8ke2ZpbGUubGFzdE1vZGlmaWVkfWApXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEJhdGNoIHByb2Nlc3NpbmcgaG9vayB3aXRoIHF1ZXVlIG1hbmFnZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhdGNoSW1hZ2VQcm9jZXNzaW5nKGNvbmZpZzogUGFydGlhbDxCYXRjaFByb2Nlc3NpbmdDb25maWc+ID0ge30pIHtcbiAgY29uc3QgcHJvY2Vzc2luZ0NvbmZpZyA9IHsgLi4uREVGQVVMVF9CQVRDSF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuICBjb25zdCBbcXVldWVTdGF0ZSwgc2V0UXVldWVTdGF0ZV0gPSB1c2VTdGF0ZTxQcm9jZXNzaW5nUXVldWVTdGF0ZT4oe1xuICAgIHF1ZXVlOiBbXSxcbiAgICBhY3RpdmVJdGVtczogW10sXG4gICAgY29tcGxldGVkSXRlbXM6IFtdLFxuICAgIGZhaWxlZEl0ZW1zOiBbXSxcbiAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgIHRvdGFsUHJvZ3Jlc3M6IDBcbiAgfSk7XG4gIFxuICBjb25zdCBxdWV1ZVJlZiA9IHVzZVJlZjxQcm9jZXNzaW5nUXVldWVJdGVtW10+KFtdKTtcbiAgY29uc3QgYWN0aXZlUmVmID0gdXNlUmVmPE1hcDxzdHJpbmcsIFByb2Nlc3NpbmdRdWV1ZUl0ZW0+PihuZXcgTWFwKCkpO1xuICBjb25zdCBzdGF0c1JlZiA9IHVzZVJlZjxQcm9jZXNzaW5nU3RhdHM+KHtcbiAgICB0b3RhbFByb2Nlc3NlZDogMCxcbiAgICB0b3RhbEZhaWxlZDogMCxcbiAgICBhdmVyYWdlUHJvY2Vzc2luZ1RpbWU6IDAsXG4gICAgdG90YWxQcm9jZXNzaW5nVGltZTogMCxcbiAgICBwZWFrTWVtb3J5VXNhZ2U6IDAsXG4gICAgY2FjaGVIaXRSYXRlOiAwXG4gIH0pO1xuXG4gIGNvbnN0IGdlbmVyYXRlSWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGBwcm9jXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHVwZGF0ZVF1ZXVlU3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlSXRlbXMgPSBBcnJheS5mcm9tKGFjdGl2ZVJlZi5jdXJyZW50LnZhbHVlcygpKTtcbiAgICBjb25zdCBjb21wbGV0ZWRJdGVtcyA9IHF1ZXVlUmVmLmN1cnJlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKTtcbiAgICBjb25zdCBmYWlsZWRJdGVtcyA9IHF1ZXVlUmVmLmN1cnJlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zdGF0dXMgPT09ICdmYWlsZWQnKTtcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gcXVldWVSZWYuY3VycmVudC5sZW5ndGg7XG4gICAgY29uc3QgdG90YWxQcm9ncmVzcyA9IHRvdGFsSXRlbXMgPiAwIFxuICAgICAgPyAoY29tcGxldGVkSXRlbXMubGVuZ3RoICsgZmFpbGVkSXRlbXMubGVuZ3RoKSAvIHRvdGFsSXRlbXMgKiAxMDAgXG4gICAgICA6IDA7XG5cbiAgICBzZXRRdWV1ZVN0YXRlKHtcbiAgICAgIHF1ZXVlOiBbLi4ucXVldWVSZWYuY3VycmVudF0sXG4gICAgICBhY3RpdmVJdGVtcyxcbiAgICAgIGNvbXBsZXRlZEl0ZW1zLFxuICAgICAgZmFpbGVkSXRlbXMsXG4gICAgICBpc1Byb2Nlc3Npbmc6IGFjdGl2ZUl0ZW1zLmxlbmd0aCA+IDAsXG4gICAgICB0b3RhbFByb2dyZXNzXG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBwcm9jZXNzUXVldWVJdGVtID0gdXNlQ2FsbGJhY2soYXN5bmMgKGl0ZW06IFByb2Nlc3NpbmdRdWV1ZUl0ZW0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpdGVtLnN0YXR1cyA9ICdwcm9jZXNzaW5nJztcbiAgICBpdGVtLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQuc2V0KGl0ZW0uaWQsIGl0ZW0pO1xuICAgIHVwZGF0ZVF1ZXVlU3RhdGUoKTtcblxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzdWx0OiBhbnk7XG4gICAgICBcbiAgICAgIHN3aXRjaCAoaXRlbS5vcGVyYXRpb24pIHtcbiAgICAgICAgY2FzZSBJbWFnZVByb2Nlc3NpbmdPcGVyYXRpb24uQkFTSUNfUFJPQ0VTU0lORzpcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBwcm9jZXNzSW1hZ2VGb3JUcnlvbihpdGVtLmZpbGUsIGl0ZW0ub3B0aW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW1hZ2VQcm9jZXNzaW5nT3BlcmF0aW9uLkFEVkFOQ0VEX1BST0NFU1NJTkc6XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0ltYWdlQWR2YW5jZWQoaXRlbS5maWxlLCBpdGVtLm9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEltYWdlUHJvY2Vzc2luZ09wZXJhdGlvbi5USFVNQk5BSUxfR0VORVJBVElPTjpcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBjcmVhdGVJbWFnZVRodW1ibmFpbChpdGVtLmZpbGUsIGl0ZW0ub3B0aW9ucz8uc2l6ZSB8fCAxNTApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEltYWdlUHJvY2Vzc2luZ09wZXJhdGlvbi5NRVRBREFUQV9FWFRSQUNUSU9OOlxuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGV4dHJhY3RJbWFnZU1ldGFkYXRhKGl0ZW0uZmlsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW1hZ2VQcm9jZXNzaW5nT3BlcmF0aW9uLkZPUk1BVF9DT05WRVJTSU9OOlxuICAgICAgICAgIGNvbnN0IGltYWdlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpdGVtLmZpbGUpO1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGNvbnZlcnRJbWFnZUZvcm1hdChpbWFnZVVybCwgaXRlbS5vcHRpb25zLnRhcmdldEZvcm1hdCwgaXRlbS5vcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1hZ2VVcmwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3BlcmF0aW9uOiAke2l0ZW0ub3BlcmF0aW9ufWApO1xuICAgICAgfVxuXG4gICAgICBpdGVtLnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xuICAgICAgaXRlbS5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICBpdGVtLmVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgaXRlbS5wcm9ncmVzcyA9IDEwMDtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXRzXG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IGl0ZW0uZW5kVGltZSAtIChpdGVtLnN0YXJ0VGltZSB8fCAwKTtcbiAgICAgIHN0YXRzUmVmLmN1cnJlbnQudG90YWxQcm9jZXNzZWQrKztcbiAgICAgIHN0YXRzUmVmLmN1cnJlbnQudG90YWxQcm9jZXNzaW5nVGltZSArPSBwcm9jZXNzaW5nVGltZTtcbiAgICAgIHN0YXRzUmVmLmN1cnJlbnQuYXZlcmFnZVByb2Nlc3NpbmdUaW1lID0gXG4gICAgICAgIHN0YXRzUmVmLmN1cnJlbnQudG90YWxQcm9jZXNzaW5nVGltZSAvIHN0YXRzUmVmLmN1cnJlbnQudG90YWxQcm9jZXNzZWQ7XG5cbiAgICAgIHByb2Nlc3NpbmdDb25maWcuaXRlbUNvbXBsZXRlQ2FsbGJhY2s/LihpdGVtKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlbS5zdGF0dXMgPSAnZmFpbGVkJztcbiAgICAgIGl0ZW0uZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICBpdGVtLmVycm9yID0gY2xhc3NpZnlUcnlvbkVycm9yKGVycm9yKTtcbiAgICAgIFxuICAgICAgc3RhdHNSZWYuY3VycmVudC50b3RhbEZhaWxlZCsrO1xuICAgICAgXG4gICAgICBsb2dBbmRDbGFzc2lmeUVycm9yKGVycm9yLCB7XG4gICAgICAgIG9wZXJhdGlvbjogaXRlbS5vcGVyYXRpb24sXG4gICAgICAgIGZpbGVOYW1lOiBpdGVtLmZpbGUubmFtZSxcbiAgICAgICAgaXRlbUlkOiBpdGVtLmlkXG4gICAgICB9KTtcblxuICAgICAgcHJvY2Vzc2luZ0NvbmZpZy5lcnJvckNhbGxiYWNrPy4oaXRlbSwgaXRlbS5lcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGFjdGl2ZVJlZi5jdXJyZW50LmRlbGV0ZShpdGVtLmlkKTtcbiAgICAgIHVwZGF0ZVF1ZXVlU3RhdGUoKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBuZXh0IGl0ZW1zIGluIHF1ZXVlXG4gICAgICBwcm9jZXNzTmV4dEluUXVldWUoKTtcbiAgICB9XG4gIH0sIFtwcm9jZXNzaW5nQ29uZmlnLCB1cGRhdGVRdWV1ZVN0YXRlXSk7XG5cbiAgY29uc3QgcHJvY2Vzc05leHRJblF1ZXVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHF1ZXVlUmVmLmN1cnJlbnRcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgcHJpb3JpdHlPcmRlciA9IHsgaGlnaDogMywgbm9ybWFsOiAyLCBsb3c6IDEgfTtcbiAgICAgICAgcmV0dXJuIHByaW9yaXR5T3JkZXJbYi5wcmlvcml0eV0gLSBwcmlvcml0eU9yZGVyW2EucHJpb3JpdHldO1xuICAgICAgfSk7XG5cbiAgICBjb25zdCBhdmFpbGFibGVTbG90cyA9IHByb2Nlc3NpbmdDb25maWcubWF4Q29uY3VycmVudCAtIGFjdGl2ZVJlZi5jdXJyZW50LnNpemU7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihhdmFpbGFibGVTbG90cywgcGVuZGluZ0l0ZW1zLmxlbmd0aCk7IGkrKykge1xuICAgICAgcHJvY2Vzc1F1ZXVlSXRlbShwZW5kaW5nSXRlbXNbaV0pO1xuICAgIH1cbiAgfSwgW3Byb2Nlc3NpbmdDb25maWcubWF4Q29uY3VycmVudCwgcHJvY2Vzc1F1ZXVlSXRlbV0pO1xuXG4gIGNvbnN0IGFkZFRvUXVldWUgPSB1c2VDYWxsYmFjaygoXG4gICAgb3BlcmF0aW9uOiBJbWFnZVByb2Nlc3NpbmdPcGVyYXRpb24sXG4gICAgZmlsZTogRmlsZSxcbiAgICBvcHRpb25zPzogYW55LFxuICAgIHByaW9yaXR5OiAnbG93JyB8ICdub3JtYWwnIHwgJ2hpZ2gnID0gJ25vcm1hbCdcbiAgKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBpdGVtOiBQcm9jZXNzaW5nUXVldWVJdGVtID0ge1xuICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgIG9wZXJhdGlvbixcbiAgICAgIGZpbGUsXG4gICAgICBvcHRpb25zLFxuICAgICAgcHJpb3JpdHksXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIHByb2dyZXNzOiAwXG4gICAgfTtcblxuICAgIHF1ZXVlUmVmLmN1cnJlbnQucHVzaChpdGVtKTtcbiAgICB1cGRhdGVRdWV1ZVN0YXRlKCk7XG4gICAgXG4gICAgLy8gU3RhcnQgcHJvY2Vzc2luZyBpZiB1bmRlciBjYXBhY2l0eVxuICAgIGlmIChhY3RpdmVSZWYuY3VycmVudC5zaXplIDwgcHJvY2Vzc2luZ0NvbmZpZy5tYXhDb25jdXJyZW50KSB7XG4gICAgICBwcm9jZXNzTmV4dEluUXVldWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbS5pZDtcbiAgfSwgW2dlbmVyYXRlSWQsIHByb2Nlc3NpbmdDb25maWcubWF4Q29uY3VycmVudCwgdXBkYXRlUXVldWVTdGF0ZSwgcHJvY2Vzc05leHRJblF1ZXVlXSk7XG5cbiAgY29uc3QgcmVtb3ZlRnJvbVF1ZXVlID0gdXNlQ2FsbGJhY2soKGl0ZW1JZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBxdWV1ZVJlZi5jdXJyZW50LmZpbmRJbmRleChpdGVtID0+IGl0ZW0uaWQgPT09IGl0ZW1JZCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaXRlbSA9IHF1ZXVlUmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gJ3Byb2Nlc3NpbmcnKSB7XG4gICAgICAvLyBDYW5ub3QgcmVtb3ZlIGFjdGl2ZSBpdGVtc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHF1ZXVlUmVmLmN1cnJlbnQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB1cGRhdGVRdWV1ZVN0YXRlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIFt1cGRhdGVRdWV1ZVN0YXRlXSk7XG5cbiAgY29uc3QgY2xlYXJRdWV1ZSA9IHVzZUNhbGxiYWNrKChpbmNsdWRlQWN0aXZlOiBib29sZWFuID0gZmFsc2UpID0+IHtcbiAgICBpZiAoaW5jbHVkZUFjdGl2ZSkge1xuICAgICAgcXVldWVSZWYuY3VycmVudCA9IFtdO1xuICAgICAgYWN0aXZlUmVmLmN1cnJlbnQuY2xlYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVSZWYuY3VycmVudCA9IHF1ZXVlUmVmLmN1cnJlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zdGF0dXMgPT09ICdwcm9jZXNzaW5nJyk7XG4gICAgfVxuICAgIHVwZGF0ZVF1ZXVlU3RhdGUoKTtcbiAgfSwgW3VwZGF0ZVF1ZXVlU3RhdGVdKTtcblxuICBjb25zdCBwYXVzZVF1ZXVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHdvdWxkIHBhdXNlIHByb2Nlc3NpbmcgbmV3IGl0ZW1zXG4gICAgLy8gRm9yIG5vdywganVzdCBzdG9wIHByb2Nlc3NpbmcgbmV3IGl0ZW1zXG4gIH0sIFtdKTtcblxuICBjb25zdCByZXN1bWVRdWV1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBwcm9jZXNzTmV4dEluUXVldWUoKTtcbiAgfSwgW3Byb2Nlc3NOZXh0SW5RdWV1ZV0pO1xuXG4gIGNvbnN0IGdldFN0YXRzID0gdXNlQ2FsbGJhY2soKCk6IFByb2Nlc3NpbmdTdGF0cyA9PiB7XG4gICAgcmV0dXJuIHsgLi4uc3RhdHNSZWYuY3VycmVudCB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBxdWV1ZVN0YXRlLFxuICAgIGFkZFRvUXVldWUsXG4gICAgcmVtb3ZlRnJvbVF1ZXVlLFxuICAgIGNsZWFyUXVldWUsXG4gICAgcGF1c2VRdWV1ZSxcbiAgICByZXN1bWVRdWV1ZSxcbiAgICBnZXRTdGF0cyxcbiAgICBwcm9jZXNzaW5nQ29uZmlnXG4gIH07XG59XG5cbi8qKlxuICogUHJvY2Vzc2luZyBzdGF0aXN0aWNzIGhvb2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVByb2Nlc3NpbmdTdGF0cygpIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogaW1hZ2VQcm9jZXNzaW5nS2V5cy5zdGF0cygpLFxuICAgIHF1ZXJ5Rm46IGFzeW5jICgpOiBQcm9taXNlPFByb2Nlc3NpbmdTdGF0cz4gPT4ge1xuICAgICAgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgZmV0Y2ggZnJvbSBhIGJhY2tlbmQgb3IgbG9jYWwgc3RvcmFnZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG90YWxQcm9jZXNzZWQ6IDAsXG4gICAgICAgIHRvdGFsRmFpbGVkOiAwLFxuICAgICAgICBhdmVyYWdlUHJvY2Vzc2luZ1RpbWU6IDAsXG4gICAgICAgIHRvdGFsUHJvY2Vzc2luZ1RpbWU6IDAsXG4gICAgICAgIHBlYWtNZW1vcnlVc2FnZTogMCxcbiAgICAgICAgY2FjaGVIaXRSYXRlOiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhbGVUaW1lOiAzMCAqIDEwMDAsIC8vIDMwIHNlY29uZHNcbiAgICBnY1RpbWU6IDIgKiA2MCAqIDEwMDAgLy8gMiBtaW51dGVzXG4gIH0pO1xufVxuXG4vKipcbiAqIENhY2hlIG1hbmFnZW1lbnQgZm9yIGltYWdlIHByb2Nlc3NpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltYWdlUHJvY2Vzc2luZ0NhY2hlKCkge1xuICBjb25zdCBxdWVyeUNsaWVudCA9IHVzZVF1ZXJ5Q2xpZW50KCk7XG5cbiAgY29uc3QgY2xlYXJDYWNoZSA9IHVzZUNhbGxiYWNrKChwYXR0ZXJuPzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHBhdHRlcm4pIHtcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHtcbiAgICAgICAgcHJlZGljYXRlOiAocXVlcnkpID0+IHF1ZXJ5LnF1ZXJ5S2V5LnRvU3RyaW5nKCkuaW5jbHVkZXMocGF0dGVybilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeUNsaWVudC5pbnZhbGlkYXRlUXVlcmllcyh7XG4gICAgICAgIHF1ZXJ5S2V5OiBpbWFnZVByb2Nlc3NpbmdLZXlzLmFsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbcXVlcnlDbGllbnRdKTtcblxuICBjb25zdCBnZXRDYWNoZVN0YXRzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gcXVlcnlDbGllbnQuZ2V0UXVlcnlDYWNoZSgpO1xuICAgIGNvbnN0IHF1ZXJpZXMgPSBjYWNoZS5maW5kQWxsKHsgcXVlcnlLZXk6IGltYWdlUHJvY2Vzc2luZ0tleXMuYWxsIH0pO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFF1ZXJpZXM6IHF1ZXJpZXMubGVuZ3RoLFxuICAgICAgYWN0aXZlUXVlcmllczogcXVlcmllcy5maWx0ZXIocSA9PiBxLmlzQWN0aXZlKCkpLmxlbmd0aCxcbiAgICAgIHN0YWxlcXVlcmllczogcXVlcmllcy5maWx0ZXIocSA9PiBxLmlzU3RhbGUoKSkubGVuZ3RoLFxuICAgICAgaW52YWxpZFF1ZXJpZXM6IHF1ZXJpZXMuZmlsdGVyKHEgPT4gcS5pc0ludmFsaWQoKSkubGVuZ3RoXG4gICAgfTtcbiAgfSwgW3F1ZXJ5Q2xpZW50XSk7XG5cbiAgY29uc3QgcHJlbG9hZE1ldGFkYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKGZpbGVzOiBGaWxlW10pID0+IHtcbiAgICBjb25zdCBwcm9taXNlcyA9IGZpbGVzLm1hcChmaWxlID0+IFxuICAgICAgcXVlcnlDbGllbnQucHJlZmV0Y2hRdWVyeSh7XG4gICAgICAgIHF1ZXJ5S2V5OiBpbWFnZVByb2Nlc3NpbmdLZXlzLm1ldGFkYXRhKGAke2ZpbGUubmFtZX1fJHtmaWxlLmxhc3RNb2RpZmllZH1gKSxcbiAgICAgICAgcXVlcnlGbjogKCkgPT4gZXh0cmFjdEltYWdlTWV0YWRhdGEoZmlsZSlcbiAgICAgIH0pXG4gICAgKTtcbiAgICBcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICB9LCBbcXVlcnlDbGllbnRdKTtcblxuICByZXR1cm4ge1xuICAgIGNsZWFyQ2FjaGUsXG4gICAgZ2V0Q2FjaGVTdGF0cyxcbiAgICBwcmVsb2FkTWV0YWRhdGFcbiAgfTtcbn0iXSwibmFtZXMiOlsiSW1hZ2VQcm9jZXNzaW5nT3BlcmF0aW9uIiwiaW1hZ2VQcm9jZXNzaW5nS2V5cyIsInVzZUJhdGNoSW1hZ2VQcm9jZXNzaW5nIiwidXNlRm9ybWF0Q29udmVyc2lvbiIsInVzZUltYWdlTWV0YWRhdGEiLCJ1c2VJbWFnZVByb2Nlc3NpbmciLCJ1c2VJbWFnZVByb2Nlc3NpbmdDYWNoZSIsInVzZUltYWdlVGh1bWJuYWlsIiwidXNlSW1hZ2VWYWxpZGF0aW9uIiwidXNlUHJvY2Vzc2luZ1N0YXRzIiwiREVGQVVMVF9CQVRDSF9DT05GSUciLCJtYXhDb25jdXJyZW50IiwicmV0cnlBdHRlbXB0cyIsInJldHJ5RGVsYXkiLCJhbGwiLCJtZXRhZGF0YSIsImZpbGVJZCIsInRodW1ibmFpbCIsInNpemUiLCJ2YWxpZGF0aW9uIiwicHJvY2Vzc2luZyIsIm9wZXJhdGlvbklkIiwic3RhdHMiLCJxdWVyeUNsaWVudCIsInVzZVF1ZXJ5Q2xpZW50IiwiYmFzaWNQcm9jZXNzaW5nTXV0YXRpb24iLCJ1c2VNdXRhdGlvbiIsIm11dGF0aW9uRm4iLCJmaWxlIiwicHJvY2Vzc0ltYWdlRm9yVHJ5b24iLCJlcnJvciIsImNsYXNzaWZpZWRFcnJvciIsImNsYXNzaWZ5VHJ5b25FcnJvciIsImxvZ0FuZENsYXNzaWZ5RXJyb3IiLCJvcGVyYXRpb24iLCJmaWxlTmFtZSIsIm5hbWUiLCJvblN1Y2Nlc3MiLCJyZXN1bHQiLCJzZXRRdWVyeURhdGEiLCJsYXN0TW9kaWZpZWQiLCJvbkVycm9yIiwiY29uc29sZSIsImFkdmFuY2VkUHJvY2Vzc2luZ011dGF0aW9uIiwib3B0aW9ucyIsInByb2Nlc3NJbWFnZUFkdmFuY2VkIiwicHJvY2Vzc0Jhc2ljIiwibXV0YXRlQXN5bmMiLCJwcm9jZXNzQWR2YW5jZWQiLCJpc1Byb2Nlc3NpbmdCYXNpYyIsImlzUGVuZGluZyIsImlzUHJvY2Vzc2luZ0FkdmFuY2VkIiwiYmFzaWNFcnJvciIsImFkdmFuY2VkRXJyb3IiLCJyZXNldCIsImVuYWJsZWQiLCJ1c2VRdWVyeSIsInF1ZXJ5S2V5IiwicXVlcnlGbiIsIkVycm9yIiwiZXh0cmFjdEltYWdlTWV0YWRhdGEiLCJzdGFsZVRpbWUiLCJnY1RpbWUiLCJjcmVhdGVJbWFnZVRodW1ibmFpbCIsImVycm9ycyIsInR5cGUiLCJzdGFydHNXaXRoIiwicHVzaCIsImRpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsImlzVmFsaWQiLCJsZW5ndGgiLCJ0YXJnZXRGb3JtYXQiLCJxdWFsaXR5IiwiaW1hZ2VVcmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJjb252ZXJ0SW1hZ2VGb3JtYXQiLCJyZXZva2VPYmplY3RVUkwiLCJpbnZhbGlkYXRlUXVlcmllcyIsImNvbmZpZyIsInByb2Nlc3NpbmdDb25maWciLCJxdWV1ZVN0YXRlIiwic2V0UXVldWVTdGF0ZSIsInVzZVN0YXRlIiwicXVldWUiLCJhY3RpdmVJdGVtcyIsImNvbXBsZXRlZEl0ZW1zIiwiZmFpbGVkSXRlbXMiLCJpc1Byb2Nlc3NpbmciLCJ0b3RhbFByb2dyZXNzIiwicXVldWVSZWYiLCJ1c2VSZWYiLCJhY3RpdmVSZWYiLCJNYXAiLCJzdGF0c1JlZiIsInRvdGFsUHJvY2Vzc2VkIiwidG90YWxGYWlsZWQiLCJhdmVyYWdlUHJvY2Vzc2luZ1RpbWUiLCJ0b3RhbFByb2Nlc3NpbmdUaW1lIiwicGVha01lbW9yeVVzYWdlIiwiY2FjaGVIaXRSYXRlIiwiZ2VuZXJhdGVJZCIsInVzZUNhbGxiYWNrIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInVwZGF0ZVF1ZXVlU3RhdGUiLCJBcnJheSIsImZyb20iLCJjdXJyZW50IiwidmFsdWVzIiwiZmlsdGVyIiwiaXRlbSIsInN0YXR1cyIsInRvdGFsSXRlbXMiLCJwcm9jZXNzUXVldWVJdGVtIiwic3RhcnRUaW1lIiwic2V0IiwiaWQiLCJlbmRUaW1lIiwicHJvZ3Jlc3MiLCJwcm9jZXNzaW5nVGltZSIsIml0ZW1Db21wbGV0ZUNhbGxiYWNrIiwiaXRlbUlkIiwiZXJyb3JDYWxsYmFjayIsImRlbGV0ZSIsInByb2Nlc3NOZXh0SW5RdWV1ZSIsInBlbmRpbmdJdGVtcyIsInNvcnQiLCJhIiwiYiIsInByaW9yaXR5T3JkZXIiLCJoaWdoIiwibm9ybWFsIiwibG93IiwicHJpb3JpdHkiLCJhdmFpbGFibGVTbG90cyIsImkiLCJtaW4iLCJhZGRUb1F1ZXVlIiwicmVtb3ZlRnJvbVF1ZXVlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJjbGVhclF1ZXVlIiwiaW5jbHVkZUFjdGl2ZSIsImNsZWFyIiwicGF1c2VRdWV1ZSIsInJlc3VtZVF1ZXVlIiwiZ2V0U3RhdHMiLCJjbGVhckNhY2hlIiwicGF0dGVybiIsInByZWRpY2F0ZSIsInF1ZXJ5IiwiaW5jbHVkZXMiLCJnZXRDYWNoZVN0YXRzIiwiY2FjaGUiLCJnZXRRdWVyeUNhY2hlIiwicXVlcmllcyIsImZpbmRBbGwiLCJ0b3RhbFF1ZXJpZXMiLCJhY3RpdmVRdWVyaWVzIiwicSIsImlzQWN0aXZlIiwic3RhbGVxdWVyaWVzIiwiaXNTdGFsZSIsImludmFsaWRRdWVyaWVzIiwiaXNJbnZhbGlkIiwicHJlbG9hZE1ldGFkYXRhIiwiZmlsZXMiLCJwcm9taXNlcyIsIm1hcCIsInByZWZldGNoUXVlcnkiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztJQThCWUEsd0JBQXdCO2VBQXhCQTs7SUE0RUNDLG1CQUFtQjtlQUFuQkE7O0lBZ09HQyx1QkFBdUI7ZUFBdkJBOztJQTFDQUMsbUJBQW1CO2VBQW5CQTs7SUFuR0FDLGdCQUFnQjtlQUFoQkE7O0lBdkVBQyxrQkFBa0I7ZUFBbEJBOztJQXliQUMsdUJBQXVCO2VBQXZCQTs7SUE1VkFDLGlCQUFpQjtlQUFqQkE7O0lBMEJBQyxrQkFBa0I7ZUFBbEJBOztJQTRTQUMsa0JBQWtCO2VBQWxCQTs7OzRCQXBoQnNDO3VCQUNSO2lDQWN2QzsrQkFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsSUFBQSxBQUFLVCxrREFBQUE7Ozs7Ozs7O1dBQUFBOztBQWdFWjs7Q0FFQyxHQUNELE1BQU1VLHVCQUE4QztJQUNsREMsZUFBZTtJQUNmQyxlQUFlO0lBQ2ZDLFlBQVk7QUFDZDtBQUtPLE1BQU1a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