{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/utils/image.ts"],"sourcesContent":["/**\n * Image utility constants and helper functions for file processing\n * \n * @example\n * ```typescript\n * import { fileToBase64, compressBase64, isImageFile } from './utils/image';\n * \n * // Convert file to base64\n * try {\n *   const base64 = await fileToBase64(imageFile);\n *   const compressed = await compressBase64(base64, 512); // 512KB limit\n * } catch (error) {\n *   if (error instanceof FileTypeNotSupportedError) {\n *     console.log('Please select an image file');\n *   } else if (error instanceof FileTooLargeError) {\n *     console.log('File is too large');\n *   } else if (error instanceof CompressionFailedError) {\n *     console.log('Compression failed');\n *   }\n * }\n * ```\n */\n\n/**\n * Type alias for base64 image strings (data URL format)\n */\nexport type ImageBase64 = string;\n\n/**\n * Maximum allowed image file size in bytes (5 MB)\n */\nexport const IMG_SIZE_LIMIT_BYTES = 5 * 1024 * 1024; // 5 MB\n\n/**\n * Custom error for unsupported file types\n */\nexport class FileTypeNotSupportedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FileTypeNotSupportedError';\n  }\n}\n\n/**\n * Custom error for files that exceed size limits\n */\nexport class FileTooLargeError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FileTooLargeError';\n  }\n}\n\n/**\n * Custom error for image compression failures\n */\nexport class CompressionFailedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CompressionFailedError';\n  }\n}\n\n/**\n * Checks if a file is an image based on its MIME type\n * @param file - The file to check\n * @returns true if the file is an image, false otherwise\n */\nexport const isImageFile = (file: File): boolean => file.type.startsWith('image/');\n\n/**\n * Converts a File object to a base64 string (data URL format)\n * \n * @param file - The file to convert to base64\n * @returns Promise that resolves to the base64 string representation (data URL format)\n * @throws {FileTypeNotSupportedError} When file type is not supported (non-image files)\n * @throws {FileTooLargeError} When file size exceeds 5 MB limit\n * \n * @example\n * ```typescript\n * const imageFile = event.target.files[0];\n * try {\n *   const base64 = await fileToBase64(imageFile);\n *   // base64 will be: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...\"\n * } catch (error) {\n *   if (error instanceof FileTypeNotSupportedError) {\n *     alert('Please select an image file');\n *   } else if (error instanceof FileTooLargeError) {\n *     alert('Image must be under 5 MB');\n *   }\n * }\n * ```\n */\nexport async function fileToBase64(file: File): Promise<string> {\n  if (!isImageFile(file)) throw new FileTypeNotSupportedError('Only image files are allowed.');\n  if (file.size > IMG_SIZE_LIMIT_BYTES) throw new FileTooLargeError('Image exceeds 5 MB limit.');\n  \n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const result = reader.result as string;\n      resolve(result);\n    };\n    reader.onerror = () => reject(reader.error);\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * Helper function to convert a Blob to base64 string\n * @param blob - The blob to convert\n * @returns Promise that resolves to the base64 string\n */\nasync function blobToBase64(blob: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const result = reader.result as string;\n      resolve(result);\n    };\n    reader.onerror = () => reject(reader.error);\n    reader.readAsDataURL(blob);\n  });\n}\n\n/**\n * Compresses a base64 image string to reduce file size using canvas-based compression\n * \n * @param b64 - The base64 string to compress (data URL format)\n * @param maxSizeKB - Maximum size in KB (default: 1024)\n * @returns Promise that resolves to the compressed base64 string (data URL format)\n * @throws {CompressionFailedError} When compression fails (canvas errors, image loading failures, or unable to meet size target)\n * \n * @example\n * ```typescript\n * try {\n *   const originalBase64 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...\";\n *   const compressed = await compressBase64(originalBase64, 512); // 512KB limit\n *   // compressed will be a smaller base64 string\n * } catch (error) {\n *   if (error instanceof CompressionFailedError) {\n *     console.log('Failed to compress image:', error.message);\n *   }\n * }\n * ```\n * \n * @note This function preserves transparency for PNG images and uses JPEG for other formats\n */\nexport async function compressBase64(b64: string, maxSizeKB = 1024): Promise<string> {\n  const byteLimit = maxSizeKB * 1024;\n  \n  // Early return if already under limit\n  const base64Data = b64.split(',')[1];\n  if (atob(base64Data).length <= byteLimit) {\n    return b64;\n  }\n  \n  // Create canvas and image for compression\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new CompressionFailedError('Failed to get canvas context');\n  }\n  \n  const img = new Image();\n  \n  return new Promise((resolve, reject) => {\n    img.onload = async () => {\n      try {\n        // Set canvas dimensions\n        canvas.width = img.width;\n        canvas.height = img.height;\n        \n        // Draw image to canvas\n        ctx.drawImage(img, 0, 0);\n        \n        // Determine format (preserve alpha for PNG, use JPEG otherwise)\n        const hasTransparency = b64.includes('image/png');\n        const format = hasTransparency ? 'image/png' : 'image/jpeg';\n        \n        // Compression loop - more aggressive quality reduction\n        let quality = 0.9;\n        let compressed = b64;\n        let attempts = 0;\n        const maxAttempts = 15; // More attempts for better compression\n        \n        while (quality > 0.1 && attempts < maxAttempts) {\n          try {\n            const blob = await new Promise<Blob>((resolveBlob, rejectBlob) => {\n              canvas.toBlob(\n                (blob) => {\n                  if (blob) resolveBlob(blob);\n                  else rejectBlob(new Error('Failed to create blob'));\n                },\n                format,\n                quality\n              );\n            });\n            \n            compressed = await blobToBase64(blob);\n            \n            // Check if compressed size is under limit\n            const compressedData = compressed.split(',')[1];\n            if (atob(compressedData).length <= byteLimit) {\n              break;\n            }\n            \n            quality -= 0.05; // Smaller steps for finer control\n            attempts++;\n          } catch {\n            quality -= 0.05;\n            attempts++;\n            continue;\n          }\n        }\n        \n        // If still too large, try reducing dimensions as last resort\n        if (atob(compressed.split(',')[1]).length > byteLimit) {\n          // Calculate scale factor to reduce dimensions\n          const currentSize = atob(compressed.split(',')[1]).length;\n          const scaleFactor = Math.sqrt(byteLimit / currentSize) * 0.9; // 10% safety margin\n          \n          if (scaleFactor < 0.5) { // Don't scale below 50% of original size\n            throw new CompressionFailedError('Unable to compress image below limit');\n          }\n          \n          // Resize canvas and try again\n          const newWidth = Math.floor(img.width * scaleFactor);\n          const newHeight = Math.floor(img.height * scaleFactor);\n          \n          canvas.width = newWidth;\n          canvas.height = newHeight;\n          ctx.drawImage(img, 0, 0, newWidth, newHeight);\n          \n          const resizedBlob = await new Promise<Blob>((resolveBlob, rejectBlob) => {\n            canvas.toBlob(\n              (blob) => {\n                if (blob) resolveBlob(blob);\n                else rejectBlob(new Error('Failed to create resized blob'));\n              },\n              format,\n              0.8 // Use 80% quality for resized image\n            );\n          });\n          \n          compressed = await blobToBase64(resizedBlob);\n          \n          // Final check after resizing\n          const finalData = compressed.split(',')[1];\n          if (atob(finalData).length > byteLimit) {\n            throw new CompressionFailedError('Unable to compress image below limit even after resizing');\n          }\n        }\n        \n        resolve(compressed);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    \n    img.onerror = () => {\n      reject(new CompressionFailedError('Failed to load image for compression'));\n    };\n    \n    img.src = b64;\n  });\n}\n\n// Note: All functions and types are already exported above\n// This module provides a complete API for image processing utilities "],"names":["CompressionFailedError","FileTooLargeError","FileTypeNotSupportedError","IMG_SIZE_LIMIT_BYTES","compressBase64","fileToBase64","isImageFile","Error","constructor","message","name","file","type","startsWith","size","Promise","resolve","reject","reader","FileReader","onload","result","onerror","error","readAsDataURL","blobToBase64","blob","b64","maxSizeKB","byteLimit","base64Data","split","atob","length","canvas","document","createElement","ctx","getContext","img","Image","width","height","drawImage","hasTransparency","includes","format","quality","compressed","attempts","maxAttempts","resolveBlob","rejectBlob","toBlob","compressedData","currentSize","scaleFactor","Math","sqrt","newWidth","floor","newHeight","resizedBlob","finalData","src"],"mappings":"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"}