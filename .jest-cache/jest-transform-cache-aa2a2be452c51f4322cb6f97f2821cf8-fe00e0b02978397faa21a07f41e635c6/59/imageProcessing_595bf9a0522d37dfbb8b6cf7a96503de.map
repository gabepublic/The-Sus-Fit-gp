{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/src/business-layer/utils/imageProcessing.ts"],"sourcesContent":["// Image Processing Utilities for Try-On Mutations\n// Comprehensive image processing functions for the business layer\n\nimport { \n  fileToBase64, \n  compressBase64, \n  isImageFile,\n  FileTypeNotSupportedError,\n  FileTooLargeError,\n  CompressionFailedError,\n  type ImageBase64\n} from '@/utils/image';\nimport { \n  AdvancedCanvasOperations, \n  createAdvancedCanvasOperations,\n  type ManagedCanvas \n} from '../providers/CanvasProvider';\n\n/**\n * Custom error for image processing failures\n */\nexport class ImageProcessingError extends Error {\n  constructor(message: string, public readonly originalError?: Error) {\n    super(message);\n    this.name = 'ImageProcessingError';\n  }\n}\n\n/**\n * Custom error for image dimension validation failures\n */\nexport class ImageDimensionError extends Error {\n  constructor(message: string, public readonly width?: number, public readonly height?: number) {\n    super(message);\n    this.name = 'ImageDimensionError';\n  }\n}\n\n/**\n * Configuration options for image processing\n */\nexport interface ImageProcessingOptions {\n  /** Target width for resizing (default: 1024) */\n  targetWidth?: number;\n  /** Target height for resizing (default: 1536) */\n  targetHeight?: number;\n  /** Maximum file size in KB after compression (default: 1024) */\n  maxSizeKB?: number;\n  /** JPEG quality for compression (0.1-1.0, default: 0.9) */\n  quality?: number;\n  /** Whether to preserve aspect ratio during resize (default: false) */\n  preserveAspectRatio?: boolean;\n}\n\n/**\n * Default processing options for try-on images\n */\nexport const DEFAULT_PROCESSING_OPTIONS: Required<ImageProcessingOptions> = {\n  targetWidth: 1024,\n  targetHeight: 1536,\n  maxSizeKB: 1024,\n  quality: 0.9,\n  preserveAspectRatio: false\n};\n\n/**\n * Supported image formats for conversion\n */\nexport enum ImageFormat {\n  JPEG = 'image/jpeg',\n  PNG = 'image/png',\n  WEBP = 'image/webp',\n  GIF = 'image/gif'\n}\n\n/**\n * Image metadata extracted from file\n */\nexport interface ImageMetadata {\n  /** Image format/MIME type */\n  format: string;\n  /** Image dimensions */\n  dimensions: { width: number; height: number };\n  /** File size in bytes */\n  size: number;\n  /** Color depth information */\n  colorDepth?: number;\n  /** Whether image has transparency */\n  hasAlpha?: boolean;\n  /** Estimated quality (for JPEG) */\n  estimatedQuality?: number;\n  /** Creation timestamp if available */\n  dateCreated?: Date;\n  /** Device orientation (EXIF) */\n  orientation?: number;\n  /** DPI/resolution information */\n  resolution?: { x: number; y: number };\n}\n\n/**\n * Advanced image processing options\n */\nexport interface AdvancedImageProcessingOptions extends ImageProcessingOptions {\n  /** Output format */\n  outputFormat?: ImageFormat;\n  /** Enable sharpening after resize */\n  enableSharpening?: boolean;\n  /** Noise reduction strength (0-1) */\n  noiseReduction?: number;\n  /** Enable automatic color correction */\n  autoColorCorrection?: boolean;\n  /** Preserve EXIF data */\n  preserveExif?: boolean;\n  /** Custom canvas for processing */\n  canvas?: ManagedCanvas;\n}\n\n/**\n * Enhanced result of image processing operations\n */\nexport interface AdvancedImageProcessingResult {\n  /** Processed image as base64 data URL */\n  processedImage: ImageBase64;\n  /** Original image metadata */\n  originalMetadata: ImageMetadata;\n  /** Final image metadata */\n  finalMetadata: ImageMetadata;\n  /** Processing metadata */\n  processingMetadata: {\n    wasResized: boolean;\n    wasCompressed: boolean;\n    wasFormatConverted: boolean;\n    wasSharpened: boolean;\n    hadNoiseReduction: boolean;\n    compressionRatio: number;\n    processingTime: number;\n    operationsApplied: string[];\n  };\n}\n\n/**\n * Result of image processing operations (legacy compatibility)\n */\nexport interface ImageProcessingResult {\n  /** Processed image as base64 data URL */\n  processedImage: ImageBase64;\n  /** Original image dimensions */\n  originalDimensions: { width: number; height: number };\n  /** Final image dimensions */\n  finalDimensions: { width: number; height: number };\n  /** Original file size in bytes */\n  originalSize: number;\n  /** Final file size in bytes */\n  finalSize: number;\n  /** Processing metadata */\n  metadata: {\n    wasResized: boolean;\n    wasCompressed: boolean;\n    compressionRatio: number;\n    processingTime: number;\n  };\n}\n\n/**\n * Get image dimensions from a data URL or image element\n */\nexport function getImageDimensions(imageUrl: string): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      resolve({ width: img.width, height: img.height });\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for dimension analysis'));\n    };\n    \n    img.src = imageUrl;\n  });\n}\n\n/**\n * Resize image to specific dimensions\n * \n * @param imageUrl - Source image data URL\n * @param options - Resize options\n * @returns Promise resolving to resized image data URL\n */\nexport function resizeImageTo1024x1536(\n  imageUrl: string, \n  options: Partial<ImageProcessingOptions> = {}\n): Promise<string> {\n  const config = { ...DEFAULT_PROCESSING_OPTIONS, ...options };\n  \n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      try {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        if (!ctx) {\n          reject(new ImageProcessingError('Could not get canvas context'));\n          return;\n        }\n        \n        let { targetWidth, targetHeight } = config;\n        \n        // Calculate dimensions preserving aspect ratio if requested\n        if (config.preserveAspectRatio) {\n          const aspectRatio = img.width / img.height;\n          const targetAspectRatio = targetWidth / targetHeight;\n          \n          if (aspectRatio > targetAspectRatio) {\n            // Image is wider, fit to width\n            targetHeight = Math.round(targetWidth / aspectRatio);\n          } else {\n            // Image is taller, fit to height\n            targetWidth = Math.round(targetHeight * aspectRatio);\n          }\n        }\n        \n        // Set canvas dimensions\n        canvas.width = targetWidth;\n        canvas.height = targetHeight;\n        \n        // Apply high-quality scaling\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n        \n        // Draw the image resized to fit the canvas\n        ctx.drawImage(img, 0, 0, targetWidth, targetHeight);\n        \n        // Convert to data URL with specified quality\n        const resizedImageUrl = canvas.toDataURL('image/jpeg', config.quality);\n        resolve(resizedImageUrl);\n      } catch (error) {\n        reject(new ImageProcessingError(\n          'Failed to resize image',\n          error instanceof Error ? error : new Error(String(error))\n        ));\n      }\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for resizing'));\n    };\n    \n    img.src = imageUrl;\n  });\n}\n\n/**\n * Validate image dimensions against requirements\n */\nexport async function validateImageDimensions(\n  imageUrl: string,\n  minWidth = 512,\n  minHeight = 512,\n  maxWidth = 4096,\n  maxHeight = 4096\n): Promise<void> {\n  const dimensions = await getImageDimensions(imageUrl);\n  \n  if (dimensions.width < minWidth || dimensions.height < minHeight) {\n    throw new ImageDimensionError(\n      `Image dimensions too small. Minimum: ${minWidth}x${minHeight}, got: ${dimensions.width}x${dimensions.height}`,\n      dimensions.width,\n      dimensions.height\n    );\n  }\n  \n  if (dimensions.width > maxWidth || dimensions.height > maxHeight) {\n    throw new ImageDimensionError(\n      `Image dimensions too large. Maximum: ${maxWidth}x${maxHeight}, got: ${dimensions.width}x${dimensions.height}`,\n      dimensions.width,\n      dimensions.height\n    );\n  }\n}\n\n/**\n * Calculate file size from base64 data URL\n */\nexport function getBase64Size(base64: string): number {\n  const base64Data = base64.split(',')[1];\n  return atob(base64Data).length;\n}\n\n/**\n * Process a file through the complete try-on image pipeline\n * \n * @param file - Input image file\n * @param options - Processing options\n * @returns Promise resolving to processing result\n */\nexport async function processImageForTryon(\n  file: File,\n  options: Partial<ImageProcessingOptions> = {}\n): Promise<ImageProcessingResult> {\n  const startTime = Date.now();\n  const config = { ...DEFAULT_PROCESSING_OPTIONS, ...options };\n  \n  try {\n    // Step 1: Validate file type and convert to base64\n    if (!isImageFile(file)) {\n      throw new FileTypeNotSupportedError('Only image files are allowed');\n    }\n    \n    const originalBase64 = await fileToBase64(file);\n    const originalSize = file.size;\n    const originalDimensions = await getImageDimensions(originalBase64);\n    \n    // Step 2: Validate dimensions\n    await validateImageDimensions(originalBase64);\n    \n    // Step 3: Resize image to target dimensions\n    const resizedImage = await resizeImageTo1024x1536(originalBase64, config);\n    const finalDimensions = await getImageDimensions(resizedImage);\n    \n    // Step 4: Compress if needed\n    let processedImage = resizedImage;\n    let wasCompressed = false;\n    \n    const resizedSize = getBase64Size(resizedImage);\n    const targetSizeBytes = config.maxSizeKB * 1024;\n    \n    if (resizedSize > targetSizeBytes) {\n      processedImage = await compressBase64(resizedImage, config.maxSizeKB);\n      wasCompressed = true;\n    }\n    \n    const finalSize = getBase64Size(processedImage);\n    const processingTime = Date.now() - startTime;\n    \n    return {\n      processedImage,\n      originalDimensions,\n      finalDimensions,\n      originalSize,\n      finalSize,\n      metadata: {\n        wasResized: originalDimensions.width !== finalDimensions.width || \n                   originalDimensions.height !== finalDimensions.height,\n        wasCompressed,\n        compressionRatio: originalSize / finalSize,\n        processingTime\n      }\n    };\n  } catch (error) {\n    if (error instanceof FileTypeNotSupportedError ||\n        error instanceof FileTooLargeError ||\n        error instanceof CompressionFailedError ||\n        error instanceof ImageDimensionError ||\n        error instanceof ImageProcessingError) {\n      throw error;\n    }\n    \n    throw new ImageProcessingError(\n      'Unexpected error during image processing',\n      error instanceof Error ? error : new Error(String(error))\n    );\n  }\n}\n\n/**\n * Process multiple images for try-on (model + apparel images)\n */\nexport async function processTryonImages(\n  modelImage: File,\n  apparelImages: File[],\n  options: Partial<ImageProcessingOptions> = {}\n): Promise<{\n  modelImageResult: ImageProcessingResult;\n  apparelImageResults: ImageProcessingResult[];\n}> {\n  // Process model image\n  const modelImageResult = await processImageForTryon(modelImage, options);\n  \n  // Process all apparel images in parallel\n  const apparelImageResults = await Promise.all(\n    apparelImages.map(file => processImageForTryon(file, options))\n  );\n  \n  return {\n    modelImageResult,\n    apparelImageResults\n  };\n}\n\n/**\n * Extract comprehensive metadata from image\n */\nexport async function extractImageMetadata(file: File): Promise<ImageMetadata> {\n  const imageUrl = await fileToBase64(file);\n  const dimensions = await getImageDimensions(imageUrl);\n  \n  return {\n    format: file.type,\n    dimensions,\n    size: file.size,\n    dateCreated: file.lastModified ? new Date(file.lastModified) : undefined,\n    // Additional metadata would require EXIF parsing library\n    // For now, we'll provide basic metadata\n  };\n}\n\n/**\n * Convert image to different format\n */\nexport async function convertImageFormat(\n  imageUrl: string,\n  targetFormat: ImageFormat,\n  quality: number = 0.9\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      try {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        if (!ctx) {\n          reject(new ImageProcessingError('Could not get canvas context'));\n          return;\n        }\n        \n        canvas.width = img.width;\n        canvas.height = img.height;\n        \n        // For PNG with transparency, fill with white background for JPEG\n        if (targetFormat === ImageFormat.JPEG) {\n          ctx.fillStyle = 'white';\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n        \n        ctx.drawImage(img, 0, 0);\n        \n        const convertedImageUrl = canvas.toDataURL(targetFormat, quality);\n        resolve(convertedImageUrl);\n      } catch (error) {\n        reject(new ImageProcessingError(\n          'Failed to convert image format',\n          error instanceof Error ? error : new Error(String(error))\n        ));\n      }\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for format conversion'));\n    };\n    \n    img.src = imageUrl;\n  });\n}\n\n/**\n * Apply sharpening filter to image\n */\nexport function applySharpeningFilter(canvas: HTMLCanvasElement, strength: number = 0.5): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  const width = canvas.width;\n  const height = canvas.height;\n  \n  // Simple unsharp mask implementation\n  const sharpenKernel = [\n    0, -strength, 0,\n    -strength, 1 + 4 * strength, -strength,\n    0, -strength, 0\n  ];\n  \n  const newData = new Uint8ClampedArray(data);\n  \n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      for (let c = 0; c < 3; c++) { // RGB channels only\n        let sum = 0;\n        for (let ky = -1; ky <= 1; ky++) {\n          for (let kx = -1; kx <= 1; kx++) {\n            const pixelIndex = ((y + ky) * width + (x + kx)) * 4 + c;\n            const kernelIndex = (ky + 1) * 3 + (kx + 1);\n            sum += data[pixelIndex] * sharpenKernel[kernelIndex];\n          }\n        }\n        newData[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));\n      }\n    }\n  }\n  \n  // Copy the new data back\n  for (let i = 0; i < data.length; i++) {\n    data[i] = newData[i];\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Apply noise reduction filter\n */\nexport function applyNoiseReduction(canvas: HTMLCanvasElement, strength: number = 0.3): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  const width = canvas.width;\n  const height = canvas.height;\n  \n  // Simple blur for noise reduction\n  const radius = Math.ceil(strength * 3);\n  const newData = new Uint8ClampedArray(data);\n  \n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      for (let c = 0; c < 3; c++) { // RGB channels only\n        let sum = 0;\n        let count = 0;\n        \n        for (let dy = -radius; dy <= radius; dy++) {\n          for (let dx = -radius; dx <= radius; dx++) {\n            const nx = x + dx;\n            const ny = y + dy;\n            \n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n              sum += data[(ny * width + nx) * 4 + c];\n              count++;\n            }\n          }\n        }\n        \n        newData[(y * width + x) * 4 + c] = sum / count;\n      }\n    }\n  }\n  \n  // Copy the new data back\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = newData[i];     // R\n    data[i + 1] = newData[i + 1]; // G\n    data[i + 2] = newData[i + 2]; // B\n    // Keep original alpha\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Apply automatic color correction\n */\nexport function applyAutoColorCorrection(canvas: HTMLCanvasElement): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  \n  // Calculate histogram\n  const histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0)\n  };\n  \n  for (let i = 0; i < data.length; i += 4) {\n    histogram.r[data[i]]++;\n    histogram.g[data[i + 1]]++;\n    histogram.b[data[i + 2]]++;\n  }\n  \n  // Find min/max values for each channel\n  const getMinMax = (hist: number[]) => {\n    let min = 0, max = 255;\n    for (let i = 0; i < 256; i++) {\n      if (hist[i] > 0) { min = i; break; }\n    }\n    for (let i = 255; i >= 0; i--) {\n      if (hist[i] > 0) { max = i; break; }\n    }\n    return { min, max };\n  };\n  \n  const rMinMax = getMinMax(histogram.r);\n  const gMinMax = getMinMax(histogram.g);\n  const bMinMax = getMinMax(histogram.b);\n  \n  // Apply histogram stretching\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = Math.max(0, Math.min(255, \n      ((data[i] - rMinMax.min) / (rMinMax.max - rMinMax.min)) * 255));\n    data[i + 1] = Math.max(0, Math.min(255, \n      ((data[i + 1] - gMinMax.min) / (gMinMax.max - gMinMax.min)) * 255));\n    data[i + 2] = Math.max(0, Math.min(255, \n      ((data[i + 2] - bMinMax.min) / (bMinMax.max - bMinMax.min)) * 255));\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Advanced image processing with comprehensive options\n */\nexport async function processImageAdvanced(\n  file: File,\n  options: Partial<AdvancedImageProcessingOptions> = {}\n): Promise<AdvancedImageProcessingResult> {\n  const startTime = Date.now();\n  const config = { ...DEFAULT_PROCESSING_OPTIONS, ...options };\n  const operationsApplied: string[] = [];\n  \n  try {\n    // Step 1: Extract original metadata\n    const originalMetadata = await extractImageMetadata(file);\n    operationsApplied.push('metadata-extraction');\n    \n    // Step 2: Validate file type and convert to base64\n    if (!isImageFile(file)) {\n      throw new FileTypeNotSupportedError('Only image files are allowed');\n    }\n    \n    let currentImage = await fileToBase64(file);\n    operationsApplied.push('base64-conversion');\n    \n    // Step 3: Validate dimensions\n    await validateImageDimensions(currentImage);\n    operationsApplied.push('dimension-validation');\n    \n    // Step 4: Format conversion (if needed)\n    let wasFormatConverted = false;\n    if (options.outputFormat && options.outputFormat !== file.type) {\n      currentImage = await convertImageFormat(currentImage, options.outputFormat, config.quality);\n      wasFormatConverted = true;\n      operationsApplied.push('format-conversion');\n    }\n    \n    // Step 5: Create canvas for advanced processing\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new ImageProcessingError('Could not get canvas context');\n    \n    // Load image onto canvas\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    await new Promise<void>((resolve, reject) => {\n      img.onload = () => resolve();\n      img.onerror = () => reject(new ImageProcessingError('Failed to load image'));\n      img.src = currentImage;\n    });\n    \n    // Set canvas dimensions based on resize requirements\n    const finalWidth = config.targetWidth || img.width;\n    const finalHeight = config.targetHeight || img.height;\n    \n    canvas.width = finalWidth;\n    canvas.height = finalHeight;\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high';\n    \n    // Draw resized image\n    ctx.drawImage(img, 0, 0, finalWidth, finalHeight);\n    \n    const wasResized = img.width !== finalWidth || img.height !== finalHeight;\n    if (wasResized) {\n      operationsApplied.push('resize');\n    }\n    \n    // Step 6: Apply advanced processing\n    let wasSharpened = false;\n    if (options.enableSharpening && wasResized) {\n      applySharpeningFilter(canvas, 0.3);\n      wasSharpened = true;\n      operationsApplied.push('sharpening');\n    }\n    \n    let hadNoiseReduction = false;\n    if (options.noiseReduction && options.noiseReduction > 0) {\n      applyNoiseReduction(canvas, options.noiseReduction);\n      hadNoiseReduction = true;\n      operationsApplied.push('noise-reduction');\n    }\n    \n    if (options.autoColorCorrection) {\n      applyAutoColorCorrection(canvas);\n      operationsApplied.push('color-correction');\n    }\n    \n    // Step 7: Convert back to data URL\n    const outputFormat = options.outputFormat || ImageFormat.JPEG;\n    let processedImage = canvas.toDataURL(outputFormat, config.quality);\n    \n    // Step 8: Compress if needed\n    let wasCompressed = false;\n    const processedSize = getBase64Size(processedImage);\n    const targetSizeBytes = config.maxSizeKB * 1024;\n    \n    if (processedSize > targetSizeBytes) {\n      processedImage = await compressBase64(processedImage, config.maxSizeKB);\n      wasCompressed = true;\n      operationsApplied.push('compression');\n    }\n    \n    // Step 9: Generate final metadata\n    const finalDimensions = await getImageDimensions(processedImage);\n    const finalSize = getBase64Size(processedImage);\n    const processingTime = Date.now() - startTime;\n    \n    const finalMetadata: ImageMetadata = {\n      format: outputFormat,\n      dimensions: finalDimensions,\n      size: finalSize\n    };\n    \n    return {\n      processedImage,\n      originalMetadata,\n      finalMetadata,\n      processingMetadata: {\n        wasResized,\n        wasCompressed,\n        wasFormatConverted,\n        wasSharpened,\n        hadNoiseReduction,\n        compressionRatio: originalMetadata.size / finalSize,\n        processingTime,\n        operationsApplied\n      }\n    };\n    \n  } catch (error) {\n    if (error instanceof FileTypeNotSupportedError ||\n        error instanceof FileTooLargeError ||\n        error instanceof CompressionFailedError ||\n        error instanceof ImageDimensionError ||\n        error instanceof ImageProcessingError) {\n      throw error;\n    }\n    \n    throw new ImageProcessingError(\n      'Unexpected error during advanced image processing',\n      error instanceof Error ? error : new Error(String(error))\n    );\n  }\n}\n\n/**\n * Batch process multiple images with progress tracking\n */\nexport async function processImagesInBatch(\n  files: File[],\n  options: Partial<AdvancedImageProcessingOptions> = {},\n  onProgress?: (completed: number, total: number, currentFile: string) => void\n): Promise<AdvancedImageProcessingResult[]> {\n  const results: AdvancedImageProcessingResult[] = [];\n  \n  for (let i = 0; i < files.length; i++) {\n    const file = files[i];\n    onProgress?.(i, files.length, file.name);\n    \n    try {\n      const result = await processImageAdvanced(file, options);\n      results.push(result);\n    } catch (error) {\n      // For batch processing, we might want to continue with other files\n      console.error(`Failed to process ${file.name}:`, error);\n      // You could push a failed result or skip, depending on requirements\n    }\n  }\n  \n  onProgress?.(files.length, files.length, 'Complete');\n  return results;\n}\n\n/**\n * Create image thumbnail with consistent dimensions\n */\nexport async function createImageThumbnail(\n  file: File,\n  size: number = 150,\n  quality: number = 0.8\n): Promise<string> {\n  const imageUrl = await fileToBase64(file);\n  \n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    \n    img.onload = () => {\n      try {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        if (!ctx) {\n          reject(new ImageProcessingError('Could not get canvas context'));\n          return;\n        }\n        \n        // Calculate dimensions to maintain aspect ratio\n        const aspectRatio = img.width / img.height;\n        let width = size;\n        let height = size;\n        \n        if (aspectRatio > 1) {\n          height = size / aspectRatio;\n        } else {\n          width = size * aspectRatio;\n        }\n        \n        canvas.width = width;\n        canvas.height = height;\n        \n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n        ctx.drawImage(img, 0, 0, width, height);\n        \n        const thumbnailUrl = canvas.toDataURL('image/jpeg', quality);\n        resolve(thumbnailUrl);\n      } catch (error) {\n        reject(new ImageProcessingError(\n          'Failed to create thumbnail',\n          error instanceof Error ? error : new Error(String(error))\n        ));\n      }\n    };\n    \n    img.onerror = () => {\n      reject(new ImageProcessingError('Failed to load image for thumbnail creation'));\n    };\n    \n    img.src = imageUrl;\n  });\n}"],"names":["DEFAULT_PROCESSING_OPTIONS","ImageDimensionError","ImageFormat","ImageProcessingError","applyAutoColorCorrection","applyNoiseReduction","applySharpeningFilter","convertImageFormat","createImageThumbnail","extractImageMetadata","getBase64Size","getImageDimensions","processImageAdvanced","processImageForTryon","processImagesInBatch","processTryonImages","resizeImageTo1024x1536","validateImageDimensions","Error","constructor","message","originalError","name","width","height","targetWidth","targetHeight","maxSizeKB","quality","preserveAspectRatio","imageUrl","Promise","resolve","reject","img","Image","crossOrigin","onload","onerror","src","options","config","canvas","document","createElement","ctx","getContext","aspectRatio","targetAspectRatio","Math","round","imageSmoothingEnabled","imageSmoothingQuality","drawImage","resizedImageUrl","toDataURL","error","String","minWidth","minHeight","maxWidth","maxHeight","dimensions","base64","base64Data","split","atob","length","file","startTime","Date","now","isImageFile","FileTypeNotSupportedError","originalBase64","fileToBase64","originalSize","size","originalDimensions","resizedImage","finalDimensions","processedImage","wasCompressed","resizedSize","targetSizeBytes","compressBase64","finalSize","processingTime","metadata","wasResized","compressionRatio","FileTooLargeError","CompressionFailedError","modelImage","apparelImages","modelImageResult","apparelImageResults","all","map","format","type","dateCreated","lastModified","undefined","targetFormat","fillStyle","fillRect","convertedImageUrl","strength","imageData","getImageData","data","sharpenKernel","newData","Uint8ClampedArray","y","x","c","sum","ky","kx","pixelIndex","kernelIndex","max","min","i","putImageData","radius","ceil","count","dy","dx","nx","ny","histogram","r","Array","fill","g","b","getMinMax","hist","rMinMax","gMinMax","bMinMax","operationsApplied","originalMetadata","push","currentImage","wasFormatConverted","outputFormat","finalWidth","finalHeight","wasSharpened","enableSharpening","hadNoiseReduction","noiseReduction","autoColorCorrection","processedSize","finalMetadata","processingMetadata","files","onProgress","results","result","console","thumbnailUrl"],"mappings":"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"}