{"version":3,"sources":["/Users/willstreeter/WebstormProjects/vibe-coding/those-people/The-Sus-Fit-gp/__tests__/business-layer/services/tryonHistoryService.test.ts"],"sourcesContent":["/**\n * @jest-environment jsdom\n */\n\nimport { LocalStorageTryonHistoryService } from '../../../src/business-layer/services/tryonHistoryService';\nimport type {\n  CreateTryonHistoryEntryOptions,\n  TryonHistoryQueryOptions,\n  TryonHistoryStorageConfig\n} from '../../../src/business-layer/types/history.types';\n\n// Mock localStorage\nconst mockLocalStorage = (() => {\n  let store: Record<string, string> = {};\n  \n  return {\n    getItem: jest.fn((key: string) => store[key] || null),\n    setItem: jest.fn((key: string, value: string) => {\n      store[key] = value;\n    }),\n    removeItem: jest.fn((key: string) => {\n      delete store[key];\n    }),\n    clear: jest.fn(() => {\n      store = {};\n    })\n  };\n})();\n\nObject.defineProperty(window, 'localStorage', {\n  value: mockLocalStorage\n});\n\n// Mock compression utilities\njest.mock('../../../src/utils/image', () => ({\n  compressBase64: jest.fn((base64: string) => Promise.resolve(base64)),\n  getBase64Size: jest.fn(() => 1024),\n  CompressionFailedError: class extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'CompressionFailedError';\n    }\n  }\n}));\n\ndescribe('LocalStorageTryonHistoryService', () => {\n  let historyService: LocalStorageTryonHistoryService;\n\n  const sampleHistoryEntry: CreateTryonHistoryEntryOptions = {\n    generatedImage: 'data:image/jpeg;base64,generated-image-data',\n    modelImage: 'data:image/jpeg;base64,model-image-data',\n    apparelImages: ['data:image/jpeg;base64,apparel-image-data'],\n    processingTime: 5000,\n    metadata: {\n      modelVersion: '1.0.0',\n      appliedQuality: 'high'\n    },\n    tags: ['test', 'sample'],\n    notes: 'Test history entry'\n  };\n\n  beforeEach(() => {\n    // Clear localStorage\n    mockLocalStorage.clear();\n    jest.clearAllMocks();\n    \n    // Create new service instance\n    historyService = new LocalStorageTryonHistoryService();\n  });\n\n  describe('Initialization', () => {\n    it('should initialize localStorage with default values', () => {\n      expect(mockLocalStorage.setItem).toHaveBeenCalledWith(\n        'susfit_tryon_history_config',\n        expect.stringContaining('localStorage')\n      );\n      expect(mockLocalStorage.setItem).toHaveBeenCalledWith(\n        'susfit_tryon_history_entries',\n        '[]'\n      );\n      expect(mockLocalStorage.setItem).toHaveBeenCalledWith(\n        'susfit_tryon_history_metadata',\n        expect.stringContaining('version')\n      );\n    });\n\n    it('should use custom configuration when provided', () => {\n      const customConfig: Partial<TryonHistoryStorageConfig> = {\n        maxEntries: 100,\n        compressImages: false\n      };\n      \n      const customService = new LocalStorageTryonHistoryService(customConfig);\n      expect(customService.getConfig().maxEntries).toBe(100);\n      expect(customService.getConfig().compressImages).toBe(false);\n    });\n\n    it('should handle localStorage unavailability gracefully', () => {\n      // Mock localStorage as undefined\n      Object.defineProperty(window, 'localStorage', {\n        value: undefined,\n        configurable: true\n      });\n\n      expect(() => {\n        new LocalStorageTryonHistoryService();\n      }).toThrow('History storage initialization failed');\n\n      // Restore localStorage\n      Object.defineProperty(window, 'localStorage', {\n        value: mockLocalStorage,\n        configurable: true\n      });\n    });\n  });\n\n  describe('Adding History Entries', () => {\n    it('should add a new history entry successfully', async () => {\n      const entry = await historyService.addEntry(sampleHistoryEntry);\n\n      expect(entry.id).toBeDefined();\n      expect(entry.timestamp).toBeDefined();\n      expect(entry.generatedImage).toBe(sampleHistoryEntry.generatedImage);\n      expect(entry.modelImage).toBe(sampleHistoryEntry.modelImage);\n      expect(entry.apparelImages).toEqual(sampleHistoryEntry.apparelImages);\n      expect(entry.processingTime).toBe(sampleHistoryEntry.processingTime);\n      expect(entry.tags).toEqual(sampleHistoryEntry.tags);\n      expect(entry.notes).toBe(sampleHistoryEntry.notes);\n\n      // Verify localStorage was updated\n      expect(mockLocalStorage.setItem).toHaveBeenCalledWith(\n        'susfit_tryon_history_entries',\n        expect.stringContaining(entry.id)\n      );\n    });\n\n    it('should generate unique IDs for entries', async () => {\n      const entry1 = await historyService.addEntry(sampleHistoryEntry);\n      const entry2 = await historyService.addEntry(sampleHistoryEntry);\n\n      expect(entry1.id).not.toBe(entry2.id);\n    });\n\n    it('should apply default values for optional fields', async () => {\n      const minimalEntry: CreateTryonHistoryEntryOptions = {\n        generatedImage: 'generated',\n        modelImage: 'model',\n        apparelImages: ['apparel']\n      };\n\n      const entry = await historyService.addEntry(minimalEntry);\n\n      expect(entry.tags).toEqual([]);\n      expect(entry.isFavorite).toBe(false);\n      expect(entry.notes).toBe('');\n    });\n\n    it('should handle compression when enabled', async () => {\n      const compressEnabledService = new LocalStorageTryonHistoryService({\n        compressImages: true,\n        compressionQuality: 0.8\n      });\n\n      const entry = await compressEnabledService.addEntry(sampleHistoryEntry);\n\n      expect(entry.id).toBeDefined();\n      // Compression mock should have been called\n      const { compressBase64 } = require('../../../src/utils/image');\n      expect(compressBase64).toHaveBeenCalled();\n    });\n  });\n\n  describe('Retrieving History Entries', () => {\n    beforeEach(async () => {\n      // Add some test entries\n      await historyService.addEntry({\n        ...sampleHistoryEntry,\n        tags: ['tag1'],\n        notes: 'First entry'\n      });\n      await historyService.addEntry({\n        ...sampleHistoryEntry,\n        tags: ['tag2'],\n        notes: 'Second entry',\n        isFavorite: true\n      });\n      await historyService.addEntry({\n        ...sampleHistoryEntry,\n        tags: ['tag1', 'tag2'],\n        notes: 'Third entry'\n      });\n    });\n\n    it('should retrieve all entries without options', async () => {\n      const result = await historyService.getEntries();\n\n      expect(result.entries).toHaveLength(3);\n      expect(result.totalCount).toBe(3);\n      expect(result.currentPage).toBe(0);\n      expect(result.hasMore).toBe(false);\n    });\n\n    it('should apply pagination correctly', async () => {\n      const options: TryonHistoryQueryOptions = {\n        page: 0,\n        pageSize: 2\n      };\n\n      const result = await historyService.getEntries(options);\n\n      expect(result.entries).toHaveLength(2);\n      expect(result.totalCount).toBe(3);\n      expect(result.currentPage).toBe(0);\n      expect(result.pageSize).toBe(2);\n      expect(result.hasMore).toBe(true);\n    });\n\n    it('should filter by favorites only', async () => {\n      const options: TryonHistoryQueryOptions = {\n        favoritesOnly: true\n      };\n\n      const result = await historyService.getEntries(options);\n\n      expect(result.entries).toHaveLength(1);\n      expect(result.entries[0].isFavorite).toBe(true);\n    });\n\n    it('should filter by search term', async () => {\n      const options: TryonHistoryQueryOptions = {\n        searchTerm: 'Second'\n      };\n\n      const result = await historyService.getEntries(options);\n\n      expect(result.entries).toHaveLength(1);\n      expect(result.entries[0].notes).toContain('Second');\n    });\n\n    it('should sort entries correctly', async () => {\n      const options: TryonHistoryQueryOptions = {\n        sortBy: 'timestamp',\n        sortDirection: 'asc'\n      };\n\n      const result = await historyService.getEntries(options);\n\n      expect(result.entries).toHaveLength(3);\n      // Should be in ascending order\n      const timestamps = result.entries.map(e => new Date(e.timestamp).getTime());\n      expect(timestamps[0]).toBeLessThanOrEqual(timestamps[1]);\n      expect(timestamps[1]).toBeLessThanOrEqual(timestamps[2]);\n    });\n  });\n\n  describe('Single Entry Operations', () => {\n    let entryId: string;\n\n    beforeEach(async () => {\n      const entry = await historyService.addEntry(sampleHistoryEntry);\n      entryId = entry.id;\n    });\n\n    it('should retrieve a specific entry by ID', async () => {\n      const entry = await historyService.getEntry(entryId);\n\n      expect(entry).not.toBeNull();\n      expect(entry!.id).toBe(entryId);\n      expect(entry!.generatedImage).toBe(sampleHistoryEntry.generatedImage);\n    });\n\n    it('should return null for non-existent entry', async () => {\n      const entry = await historyService.getEntry('non-existent-id');\n\n      expect(entry).toBeNull();\n    });\n\n    it('should update an existing entry', async () => {\n      const updates = {\n        notes: 'Updated notes',\n        isFavorite: true,\n        tags: ['updated', 'tags']\n      };\n\n      const updatedEntry = await historyService.updateEntry(entryId, updates);\n\n      expect(updatedEntry.id).toBe(entryId);\n      expect(updatedEntry.notes).toBe('Updated notes');\n      expect(updatedEntry.isFavorite).toBe(true);\n      expect(updatedEntry.tags).toEqual(['updated', 'tags']);\n      // Original data should be preserved\n      expect(updatedEntry.generatedImage).toBe(sampleHistoryEntry.generatedImage);\n    });\n\n    it('should throw error when updating non-existent entry', async () => {\n      await expect(\n        historyService.updateEntry('non-existent-id', { notes: 'test' })\n      ).rejects.toThrow('History entry with ID non-existent-id not found');\n    });\n\n    it('should delete an entry successfully', async () => {\n      const deleted = await historyService.deleteEntry(entryId);\n\n      expect(deleted).toBe(true);\n\n      // Entry should no longer exist\n      const entry = await historyService.getEntry(entryId);\n      expect(entry).toBeNull();\n    });\n\n    it('should return false when deleting non-existent entry', async () => {\n      const deleted = await historyService.deleteEntry('non-existent-id');\n\n      expect(deleted).toBe(false);\n    });\n  });\n\n  describe('Bulk Operations', () => {\n    beforeEach(async () => {\n      // Add multiple test entries\n      for (let i = 0; i < 5; i++) {\n        await historyService.addEntry({\n          ...sampleHistoryEntry,\n          notes: `Entry ${i}`\n        });\n      }\n    });\n\n    it('should clear all entries', async () => {\n      const cleared = await historyService.clearAll();\n\n      expect(cleared).toBe(true);\n\n      const result = await historyService.getEntries();\n      expect(result.entries).toHaveLength(0);\n    });\n\n    it('should export all history data', async () => {\n      const exported = await historyService.exportHistory();\n\n      expect(exported).toHaveLength(5);\n      expect(exported[0].notes).toContain('Entry');\n    });\n\n    it('should import history data', async () => {\n      // Clear existing entries\n      await historyService.clearAll();\n\n      // Create import data\n      const importData = [\n        {\n          id: 'import-1',\n          timestamp: new Date().toISOString(),\n          generatedImage: 'imported-generated',\n          modelImage: 'imported-model',\n          apparelImages: ['imported-apparel'],\n          tags: ['imported'],\n          notes: 'Imported entry',\n          isFavorite: false\n        }\n      ];\n\n      const importedCount = await historyService.importHistory(importData);\n\n      expect(importedCount).toBe(1);\n\n      const result = await historyService.getEntries();\n      expect(result.entries).toHaveLength(1);\n      expect(result.entries[0].id).toBe('import-1');\n    });\n\n    it('should not import duplicate entries', async () => {\n      const existingEntries = await historyService.exportHistory();\n      const duplicateImport = existingEntries.slice(0, 2); // Try to import first 2 existing entries\n\n      const importedCount = await historyService.importHistory(duplicateImport);\n\n      expect(importedCount).toBe(0); // No new entries should be imported\n    });\n  });\n\n  describe('Storage Statistics', () => {\n    beforeEach(async () => {\n      // Add test entries with different timestamps\n      await historyService.addEntry({\n        ...sampleHistoryEntry,\n        notes: 'First entry'\n      });\n      \n      // Add slight delay to ensure different timestamps\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      await historyService.addEntry({\n        ...sampleHistoryEntry,\n        notes: 'Last entry'\n      });\n    });\n\n    it('should return accurate storage statistics', async () => {\n      const stats = await historyService.getStorageStats();\n\n      expect(stats.totalEntries).toBe(2);\n      expect(stats.totalSizeKB).toBeGreaterThan(0);\n      expect(stats.oldestEntry).toBeDefined();\n      expect(stats.newestEntry).toBeDefined();\n      expect(new Date(stats.oldestEntry!).getTime()).toBeLessThanOrEqual(\n        new Date(stats.newestEntry!).getTime()\n      );\n    });\n  });\n\n  describe('Configuration Management', () => {\n    it('should update configuration correctly', () => {\n      const newConfig = {\n        maxEntries: 200,\n        compressImages: false\n      };\n\n      historyService.updateConfig(newConfig);\n\n      const config = historyService.getConfig();\n      expect(config.maxEntries).toBe(200);\n      expect(config.compressImages).toBe(false);\n    });\n\n    it('should perform cleanup when maxEntries is exceeded', async () => {\n      // Set low max entries limit\n      historyService.updateConfig({ maxEntries: 2 });\n\n      // Add more entries than the limit with small delays to ensure different timestamps\n      await historyService.addEntry({ ...sampleHistoryEntry, notes: 'Entry 1' });\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      await historyService.addEntry({ ...sampleHistoryEntry, notes: 'Entry 2' });\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      await historyService.addEntry({ ...sampleHistoryEntry, notes: 'Entry 3' });\n\n      const result = await historyService.getEntries();\n\n      // Should only keep the most recent entries (sorted by timestamp desc)\n      expect(result.entries).toHaveLength(2);\n      \n      // The most recent entries should be kept (Entry 2 and Entry 3)\n      // Entry 1 should be removed as it's the oldest\n      const entryNotes = result.entries.map(e => e.notes);\n      expect(entryNotes).toContain('Entry 2');\n      expect(entryNotes).toContain('Entry 3');\n      expect(entryNotes).not.toContain('Entry 1');\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle localStorage write errors gracefully', async () => {\n      // Mock localStorage.setItem to throw an error\n      mockLocalStorage.setItem.mockImplementationOnce(() => {\n        throw new Error('localStorage full');\n      });\n\n      await expect(\n        historyService.addEntry(sampleHistoryEntry)\n      ).rejects.toThrow('Failed to save history entries');\n    });\n\n    it('should handle corrupted localStorage data', () => {\n      // Set corrupted data in localStorage\n      mockLocalStorage.getItem.mockReturnValueOnce('invalid-json');\n\n      // Should return empty array instead of throwing\n      const entries = (historyService as any).getStoredEntries();\n      expect(entries).toEqual([]);\n    });\n  });\n});"],"names":["jest","mock","compressBase64","fn","base64","Promise","resolve","getBase64Size","CompressionFailedError","Error","constructor","message","name","mockLocalStorage","store","getItem","key","setItem","value","removeItem","clear","Object","defineProperty","window","describe","historyService","sampleHistoryEntry","generatedImage","modelImage","apparelImages","processingTime","metadata","modelVersion","appliedQuality","tags","notes","beforeEach","clearAllMocks","LocalStorageTryonHistoryService","it","expect","toHaveBeenCalledWith","stringContaining","customConfig","maxEntries","compressImages","customService","getConfig","toBe","undefined","configurable","toThrow","entry","addEntry","id","toBeDefined","timestamp","toEqual","entry1","entry2","not","minimalEntry","isFavorite","compressEnabledService","compressionQuality","require","toHaveBeenCalled","result","getEntries","entries","toHaveLength","totalCount","currentPage","hasMore","options","page","pageSize","favoritesOnly","searchTerm","toContain","sortBy","sortDirection","timestamps","map","e","Date","getTime","toBeLessThanOrEqual","entryId","getEntry","toBeNull","updates","updatedEntry","updateEntry","rejects","deleted","deleteEntry","i","cleared","clearAll","exported","exportHistory","importData","toISOString","importedCount","importHistory","existingEntries","duplicateImport","slice","setTimeout","stats","getStorageStats","totalEntries","totalSizeKB","toBeGreaterThan","oldestEntry","newestEntry","newConfig","updateConfig","config","entryNotes","mockImplementationOnce","mockReturnValueOnce","getStoredEntries"],"mappings":"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"}