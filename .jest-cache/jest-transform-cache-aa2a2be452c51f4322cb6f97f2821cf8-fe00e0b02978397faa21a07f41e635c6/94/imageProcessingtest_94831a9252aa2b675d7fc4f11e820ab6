781ec4d0cf5bce4812ef266ab4231e64
// Image Processing Integration Tests
// Tests for image processing utilities and integration with try-on mutations
// Mock the image processing module before any imports
"use strict";
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        processImageForTryon: jest.fn(),
        ImageProcessingError: jest.fn(),
        ImageDimensionError: jest.fn()
    }));
// Mock other dependencies
jest.mock('../../../src/business-layer/utils/optimisticUpdates', ()=>({
        getOptimisticUpdatesManager: ()=>({
                startOptimisticUpdate: jest.fn(()=>({
                        optimisticId: 'test-id',
                        rollbackFunctions: []
                    })),
                completeOptimisticUpdate: jest.fn(),
                rollbackOptimisticUpdate: jest.fn()
            }),
        OptimisticUpdatesManager: jest.fn()
    }));
jest.mock('../../../src/business-layer/utils/cacheInvalidation', ()=>({
        invalidateCacheAfterMutation: jest.fn().mockResolvedValue(undefined)
    }));
jest.mock('../../../src/business-layer/utils/errorHandling', ()=>({
        classifyTryonError: jest.fn(()=>({
                userMessage: 'Error',
                technicalMessage: 'Error',
                errorCode: 'TEST',
                retryable: false,
                category: 'TEST',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        logAndClassifyError: jest.fn(()=>({
                userMessage: 'Error',
                technicalMessage: 'Error',
                errorCode: 'TEST',
                retryable: false,
                category: 'TEST',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        isErrorRetryable: jest.fn(()=>false)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useTryonMutation = require("../../../src/business-layer/mutations/useTryonMutation");
const _testUtils = require("../../../src/business-layer/tests/testUtils");
const _imageProcessing = /*#__PURE__*/ _interop_require_wildcard(require("../../../src/business-layer/utils/imageProcessing"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Image Processing Integration', ()=>{
    let queryClient;
    let consoleRef;
    const mockProcessImageForTryon = _imageProcessing.processImageForTryon;
    beforeEach(()=>{
        queryClient = (0, _testUtils.createTestQueryClient)();
        consoleRef = (0, _testUtils.mockConsole)();
        jest.clearAllMocks();
        (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
    });
    afterEach(()=>{
        queryClient.clear();
        consoleRef.restore();
    });
    describe('File Processing', ()=>{
        it('should process File objects successfully', async ()=>{
            const mockProcessingResult = {
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed-image',
                metadata: {
                    originalDimensions: {
                        width: 1920,
                        height: 1080
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockProcessingResult);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: {
                    imageProcessing: {
                        targetWidth: 1024,
                        targetHeight: 1536,
                        maxSizeKB: 1024,
                        compressionQuality: 0.9
                    }
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(mockProcessImageForTryon).toHaveBeenCalledTimes(2); // model + apparel image
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, expect.objectContaining({
                targetWidth: 1024,
                targetHeight: 1536,
                maxSizeKB: 1024,
                quality: 0.9
            }));
        });
        it('should handle mixed File and base64 inputs', async ()=>{
            const mockProcessingResult = {
                originalSize: 1536000,
                processedSize: 768000,
                compressionRatio: 0.5,
                processingTime: 89,
                processedImage: 'data:image/jpeg;base64,processed-file',
                metadata: {
                    originalDimensions: {
                        width: 1200,
                        height: 800
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockProcessingResult);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const base64Image = 'data:image/jpeg;base64,existing-base64';
            const variables = {
                modelImage: base64Image,
                apparelImages: [
                    mockFile,
                    base64Image
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            // Should only process the File object, not the base64 string
            expect(mockProcessImageForTryon).toHaveBeenCalledTimes(1);
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, undefined);
        });
        it('should skip processing when all inputs are base64', async ()=>{
            const base64Model = 'data:image/jpeg;base64,model-image';
            const base64Apparel = 'data:image/jpeg;base64,apparel-image';
            const variables = {
                modelImage: base64Model,
                apparelImages: [
                    base64Apparel
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            // Should not call image processing for base64 inputs
            expect(mockProcessImageForTryon).not.toHaveBeenCalled();
        });
    });
    describe('Processing Configuration', ()=>{
        it('should pass image processing options correctly', async ()=>{
            mockProcessImageForTryon.mockResolvedValue({
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed',
                metadata: {}
            });
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const imageProcessingConfig = {
                targetWidth: 800,
                targetHeight: 1200,
                maxSizeKB: 512,
                compressionQuality: 0.8,
                preserveAspectRatio: true
            };
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {
                    imageProcessing: imageProcessingConfig
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, expect.objectContaining({
                targetWidth: 800,
                targetHeight: 1200,
                maxSizeKB: 512,
                quality: 0.8,
                preserveAspectRatio: true
            }));
        });
        it('should use default processing options when not specified', async ()=>{
            mockProcessImageForTryon.mockResolvedValue({
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed',
                metadata: {}
            });
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(mockProcessImageForTryon).toHaveBeenCalledWith(mockFile, undefined);
        });
    });
    describe('Processing Errors', ()=>{
        it('should handle image processing errors gracefully', async ()=>{
            const processingError = new Error('Image processing failed');
            mockProcessImageForTryon.mockRejectedValue(processingError);
            const mockFile = new File([
                'invalid content'
            ], 'test.txt', {
                type: 'text/plain'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
            expect(mockProcessImageForTryon).toHaveBeenCalled();
        });
        it('should handle specific image processing error types', async ()=>{
            const dimensionError = new Error('Image dimensions too large');
            dimensionError.name = 'ImageDimensionError';
            mockProcessImageForTryon.mockRejectedValue(dimensionError);
            const mockFile = new File([
                'mock content'
            ], 'huge-image.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
        });
        it('should fallback to original variables when processing fails', async ()=>{
            const processingError = new Error('Processing failed');
            mockProcessImageForTryon.mockRejectedValue(processingError);
            const onMutate = jest.fn().mockResolvedValue({
                fallback: true
            });
            const config = {
                onMutate
            };
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            // onMutate should still be called with processed variables attempt
            expect(onMutate).toHaveBeenCalled();
        });
    });
    describe('Performance Tests', ()=>{
        it('should handle multiple large images efficiently', async ()=>{
            const mockLargeProcessingResult = {
                originalSize: 10485760,
                processedSize: 1048576,
                compressionRatio: 0.1,
                processingTime: 500,
                processedImage: 'data:image/jpeg;base64,large-processed',
                metadata: {
                    originalDimensions: {
                        width: 4000,
                        height: 3000
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockLargeProcessingResult);
            const largeFile = new File([
                new ArrayBuffer(10 * 1024 * 1024)
            ], 'large-image.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: largeFile,
                apparelImages: [
                    largeFile,
                    largeFile,
                    largeFile
                ],
                options: {
                    imageProcessing: {
                        targetWidth: 1024,
                        targetHeight: 1536,
                        maxSizeKB: 1024,
                        compressionQuality: 0.8
                    }
                }
            };
            const startTime = Date.now();
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const processingTime = Date.now() - startTime;
            expect(mockProcessImageForTryon).toHaveBeenCalledTimes(4); // model + 3 apparel
            expect(processingTime).toBeLessThan(5000); // Should complete within 5 seconds
            expect(result.current.context?.imageProcessingResults).toBeDefined();
            expect(result.current.context?.imageProcessingResults?.totalProcessingTime).toBeDefined();
        });
        it('should track processing times accurately', async ()=>{
            const processingTimes = [
                100,
                200,
                150,
                300
            ];
            let callIndex = 0;
            mockProcessImageForTryon.mockImplementation(()=>{
                const processingTime = processingTimes[callIndex++];
                return Promise.resolve({
                    originalSize: 2048576,
                    processedSize: 1048576,
                    compressionRatio: 0.5,
                    processingTime,
                    processedImage: `data:image/jpeg;base64,processed-${callIndex}`,
                    metadata: {}
                });
            });
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile,
                    mockFile,
                    mockFile
                ],
                options: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            const imageResults = result.current.context?.imageProcessingResults;
            expect(imageResults).toBeDefined();
            expect(imageResults?.modelImageResult?.processingTime).toBe(100);
            expect(imageResults?.apparelImageResults).toHaveLength(3);
            expect(imageResults?.apparelImageResults?.[0].processingTime).toBe(200);
            expect(imageResults?.apparelImageResults?.[1].processingTime).toBe(150);
            expect(imageResults?.apparelImageResults?.[2].processingTime).toBe(300);
            expect(imageResults?.totalProcessingTime).toBeGreaterThan(0);
        });
    });
    describe('Context Preservation', ()=>{
        it('should preserve image processing results in mutation context', async ()=>{
            const mockProcessingResult = {
                originalSize: 2048576,
                processedSize: 1048576,
                compressionRatio: 0.5,
                processingTime: 123,
                processedImage: 'data:image/jpeg;base64,processed-image',
                metadata: {
                    originalDimensions: {
                        width: 1920,
                        height: 1080
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            };
            mockProcessImageForTryon.mockResolvedValue(mockProcessingResult);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variables = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: {}
            };
            const onSuccess = jest.fn();
            const config = {
                onSuccess
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(onSuccess).toHaveBeenCalledWith(_testUtils.mockTryonResponse, expect.objectContaining({
                modelImage: 'data:image/jpeg;base64,processed-image',
                apparelImages: [
                    'data:image/jpeg;base64,processed-image'
                ]
            }), expect.objectContaining({
                imageProcessingResults: expect.objectContaining({
                    modelImageResult: mockProcessingResult,
                    apparelImageResults: [
                        mockProcessingResult
                    ],
                    totalProcessingTime: expect.any(Number)
                })
            }));
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltYWdlIFByb2Nlc3NpbmcgSW50ZWdyYXRpb24gVGVzdHNcbi8vIFRlc3RzIGZvciBpbWFnZSBwcm9jZXNzaW5nIHV0aWxpdGllcyBhbmQgaW50ZWdyYXRpb24gd2l0aCB0cnktb24gbXV0YXRpb25zXG5cbi8vIE1vY2sgdGhlIGltYWdlIHByb2Nlc3NpbmcgbW9kdWxlIGJlZm9yZSBhbnkgaW1wb3J0c1xuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJywgKCkgPT4gKHtcbiAgcHJvY2Vzc0ltYWdlRm9yVHJ5b246IGplc3QuZm4oKSxcbiAgSW1hZ2VQcm9jZXNzaW5nRXJyb3I6IGplc3QuZm4oKSxcbiAgSW1hZ2VEaW1lbnNpb25FcnJvcjogamVzdC5mbigpXG59KSk7XG5cbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlVHJ5b25NdXRhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci9tdXRhdGlvbnMvdXNlVHJ5b25NdXRhdGlvbic7XG5pbXBvcnQge1xuICBjcmVhdGVUZXN0UXVlcnlDbGllbnQsXG4gIGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcixcbiAgbW9ja1RyeW9uQVBJLFxuICBtb2NrVHJ5b25SZXNwb25zZSxcbiAgbW9ja0NvbnNvbGVcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3Rlc3RzL3Rlc3RVdGlscyc7XG5pbXBvcnQgKiBhcyBpbWFnZVByb2Nlc3NpbmdNb2R1bGUgZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2ltYWdlUHJvY2Vzc2luZyc7XG5cbi8vIE1vY2sgb3RoZXIgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9vcHRpbWlzdGljVXBkYXRlcycsICgpID0+ICh7XG4gIGdldE9wdGltaXN0aWNVcGRhdGVzTWFuYWdlcjogKCkgPT4gKHtcbiAgICBzdGFydE9wdGltaXN0aWNVcGRhdGU6IGplc3QuZm4oKCkgPT4gKHsgb3B0aW1pc3RpY0lkOiAndGVzdC1pZCcsIHJvbGxiYWNrRnVuY3Rpb25zOiBbXSB9KSksXG4gICAgY29tcGxldGVPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKCksXG4gICAgcm9sbGJhY2tPcHRpbWlzdGljVXBkYXRlOiBqZXN0LmZuKClcbiAgfSksXG4gIE9wdGltaXN0aWNVcGRhdGVzTWFuYWdlcjogamVzdC5mbigpXG59KSk7XG5cbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2NhY2hlSW52YWxpZGF0aW9uJywgKCkgPT4gKHtcbiAgaW52YWxpZGF0ZUNhY2hlQWZ0ZXJNdXRhdGlvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZClcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvZXJyb3JIYW5kbGluZycsICgpID0+ICh7XG4gIGNsYXNzaWZ5VHJ5b25FcnJvcjogamVzdC5mbigoKSA9PiAoeyB1c2VyTWVzc2FnZTogJ0Vycm9yJywgdGVjaG5pY2FsTWVzc2FnZTogJ0Vycm9yJywgZXJyb3JDb2RlOiAnVEVTVCcsIHJldHJ5YWJsZTogZmFsc2UsIGNhdGVnb3J5OiAnVEVTVCcsIHNldmVyaXR5OiAnTUVESVVNJywgcmVjb3ZlcnlBY3Rpb25zOiBbXSB9KSksXG4gIGxvZ0FuZENsYXNzaWZ5RXJyb3I6IGplc3QuZm4oKCkgPT4gKHsgdXNlck1lc3NhZ2U6ICdFcnJvcicsIHRlY2huaWNhbE1lc3NhZ2U6ICdFcnJvcicsIGVycm9yQ29kZTogJ1RFU1QnLCByZXRyeWFibGU6IGZhbHNlLCBjYXRlZ29yeTogJ1RFU1QnLCBzZXZlcml0eTogJ01FRElVTScsIHJlY292ZXJ5QWN0aW9uczogW10gfSkpLFxuICBpc0Vycm9yUmV0cnlhYmxlOiBqZXN0LmZuKCgpID0+IGZhbHNlKVxufSkpO1xuXG5kZXNjcmliZSgnSW1hZ2UgUHJvY2Vzc2luZyBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgbGV0IHF1ZXJ5Q2xpZW50OiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVUZXN0UXVlcnlDbGllbnQ+O1xuICBsZXQgY29uc29sZVJlZjogUmV0dXJuVHlwZTx0eXBlb2YgbW9ja0NvbnNvbGU+O1xuICBjb25zdCBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24gPSBpbWFnZVByb2Nlc3NpbmdNb2R1bGUucHJvY2Vzc0ltYWdlRm9yVHJ5b24gYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgaW1hZ2VQcm9jZXNzaW5nTW9kdWxlLnByb2Nlc3NJbWFnZUZvclRyeW9uPjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBxdWVyeUNsaWVudCA9IGNyZWF0ZVRlc3RRdWVyeUNsaWVudCgpO1xuICAgIGNvbnNvbGVSZWYgPSBtb2NrQ29uc29sZSgpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgcXVlcnlDbGllbnQuY2xlYXIoKTtcbiAgICBjb25zb2xlUmVmLnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpbGUgUHJvY2Vzc2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgRmlsZSBvYmplY3RzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQcm9jZXNzaW5nUmVzdWx0ID0ge1xuICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZScsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAgfSxcbiAgICAgICAgICBwcm9jZXNzZWREaW1lbnNpb25zOiB7IHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDE1MzYgfSxcbiAgICAgICAgICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgICAgICBxdWFsaXR5OiAwLjlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9jZXNzaW5nUmVzdWx0KTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2sgY29udGVudCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZV0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBpbWFnZVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIHRhcmdldFdpZHRoOiAxMDI0LFxuICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0OiAxNTM2LFxuICAgICAgICAgICAgbWF4U2l6ZUtCOiAxMDI0LFxuICAgICAgICAgICAgY29tcHJlc3Npb25RdWFsaXR5OiAwLjlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpOyAvLyBtb2RlbCArIGFwcGFyZWwgaW1hZ2VcbiAgICAgIGV4cGVjdChtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrRmlsZSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHRhcmdldFdpZHRoOiAxMDI0LFxuICAgICAgICAgIHRhcmdldEhlaWdodDogMTUzNixcbiAgICAgICAgICBtYXhTaXplS0I6IDEwMjQsXG4gICAgICAgICAgcXVhbGl0eTogMC45XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgRmlsZSBhbmQgYmFzZTY0IGlucHV0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQcm9jZXNzaW5nUmVzdWx0ID0ge1xuICAgICAgICBvcmlnaW5hbFNpemU6IDE1MzYwMDAsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDc2ODAwMCxcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogMC41LFxuICAgICAgICBwcm9jZXNzaW5nVGltZTogODksXG4gICAgICAgIHByb2Nlc3NlZEltYWdlOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtZmlsZScsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiAxMjAwLCBoZWlnaHQ6IDgwMCB9LFxuICAgICAgICAgIHByb2Nlc3NlZERpbWVuc2lvbnM6IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogMTUzNiB9LFxuICAgICAgICAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAgICAgIHF1YWxpdHk6IDAuOVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2Nlc3NpbmdSZXN1bHQpO1xuXG4gICAgICBjb25zdCBtb2NrRmlsZSA9IG5ldyBGaWxlKFsnbW9jayBjb250ZW50J10sICd0ZXN0LmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pO1xuICAgICAgY29uc3QgYmFzZTY0SW1hZ2UgPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxleGlzdGluZy1iYXNlNjQnO1xuICAgICAgXG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IGJhc2U2NEltYWdlLCAvLyBBbHJlYWR5IGJhc2U2NFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbbW9ja0ZpbGUsIGJhc2U2NEltYWdlXSwgLy8gTWl4ZWQgdHlwZXNcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG9ubHkgcHJvY2VzcyB0aGUgRmlsZSBvYmplY3QsIG5vdCB0aGUgYmFzZTY0IHN0cmluZ1xuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0ZpbGUsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgcHJvY2Vzc2luZyB3aGVuIGFsbCBpbnB1dHMgYXJlIGJhc2U2NCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGJhc2U2NE1vZGVsID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsbW9kZWwtaW1hZ2UnO1xuICAgICAgY29uc3QgYmFzZTY0QXBwYXJlbCA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LGFwcGFyZWwtaW1hZ2UnO1xuICAgICAgXG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IGJhc2U2NE1vZGVsLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbYmFzZTY0QXBwYXJlbF0sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKHZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCBjYWxsIGltYWdlIHByb2Nlc3NpbmcgZm9yIGJhc2U2NCBpbnB1dHNcbiAgICAgIGV4cGVjdChtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9jZXNzaW5nIENvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwYXNzIGltYWdlIHByb2Nlc3Npbmcgb3B0aW9ucyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZCcsXG4gICAgICAgIG1ldGFkYXRhOiB7fVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCBpbWFnZVByb2Nlc3NpbmdDb25maWcgPSB7XG4gICAgICAgIHRhcmdldFdpZHRoOiA4MDAsXG4gICAgICAgIHRhcmdldEhlaWdodDogMTIwMCxcbiAgICAgICAgbWF4U2l6ZUtCOiA1MTIsXG4gICAgICAgIGNvbXByZXNzaW9uUXVhbGl0eTogMC44LFxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGltYWdlUHJvY2Vzc2luZzogaW1hZ2VQcm9jZXNzaW5nQ29uZmlnXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIG1vY2tGaWxlLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdGFyZ2V0V2lkdGg6IDgwMCxcbiAgICAgICAgICB0YXJnZXRIZWlnaHQ6IDEyMDAsXG4gICAgICAgICAgbWF4U2l6ZUtCOiA1MTIsXG4gICAgICAgICAgcXVhbGl0eTogMC44LFxuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IHRydWVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IHByb2Nlc3Npbmcgb3B0aW9ucyB3aGVuIG5vdCBzcGVjaWZpZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZCcsXG4gICAgICAgIG1ldGFkYXRhOiB7fVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0ZpbGUsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9jZXNzaW5nIEVycm9ycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbWFnZSBwcm9jZXNzaW5nIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ0Vycm9yID0gbmV3IEVycm9yKCdJbWFnZSBwcm9jZXNzaW5nIGZhaWxlZCcpO1xuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tSZWplY3RlZFZhbHVlKHByb2Nlc3NpbmdFcnJvcik7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydpbnZhbGlkIGNvbnRlbnQnXSwgJ3Rlc3QudHh0JywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3BlY2lmaWMgaW1hZ2UgcHJvY2Vzc2luZyBlcnJvciB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbkVycm9yID0gbmV3IEVycm9yKCdJbWFnZSBkaW1lbnNpb25zIHRvbyBsYXJnZScpO1xuICAgICAgZGltZW5zaW9uRXJyb3IubmFtZSA9ICdJbWFnZURpbWVuc2lvbkVycm9yJztcbiAgICAgIG1vY2tQcm9jZXNzSW1hZ2VGb3JUcnlvbi5tb2NrUmVqZWN0ZWRWYWx1ZShkaW1lbnNpb25FcnJvcik7XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ2h1Z2UtaW1hZ2UuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmYWxsYmFjayB0byBvcmlnaW5hbCB2YXJpYWJsZXMgd2hlbiBwcm9jZXNzaW5nIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ0Vycm9yID0gbmV3IEVycm9yKCdQcm9jZXNzaW5nIGZhaWxlZCcpO1xuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tSZWplY3RlZFZhbHVlKHByb2Nlc3NpbmdFcnJvcik7XG5cbiAgICAgIGNvbnN0IG9uTXV0YXRlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZmFsbGJhY2s6IHRydWUgfSk7XG4gICAgICBjb25zdCBjb25maWcgPSB7IG9uTXV0YXRlIH07XG5cbiAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrIGNvbnRlbnQnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IG1vY2tGaWxlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG9uTXV0YXRlIHNob3VsZCBzdGlsbCBiZSBjYWxsZWQgd2l0aCBwcm9jZXNzZWQgdmFyaWFibGVzIGF0dGVtcHRcbiAgICAgIGV4cGVjdChvbk11dGF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgbGFyZ2UgaW1hZ2VzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xhcmdlUHJvY2Vzc2luZ1Jlc3VsdCA9IHtcbiAgICAgICAgb3JpZ2luYWxTaXplOiAxMDQ4NTc2MCwgLy8gMTBNQlxuICAgICAgICBwcm9jZXNzZWRTaXplOiAxMDQ4NTc2LCAvLyAxTUJcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogMC4xLFxuICAgICAgICBwcm9jZXNzaW5nVGltZTogNTAwLFxuICAgICAgICBwcm9jZXNzZWRJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsbGFyZ2UtcHJvY2Vzc2VkJyxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBvcmlnaW5hbERpbWVuc2lvbnM6IHsgd2lkdGg6IDQwMDAsIGhlaWdodDogMzAwMCB9LFxuICAgICAgICAgIHByb2Nlc3NlZERpbWVuc2lvbnM6IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogMTUzNiB9LFxuICAgICAgICAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAgICAgIHF1YWxpdHk6IDAuOVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24ubW9ja1Jlc29sdmVkVmFsdWUobW9ja0xhcmdlUHJvY2Vzc2luZ1Jlc3VsdCk7XG5cbiAgICAgIGNvbnN0IGxhcmdlRmlsZSA9IG5ldyBGaWxlKFxuICAgICAgICBbbmV3IEFycmF5QnVmZmVyKDEwICogMTAyNCAqIDEwMjQpXSwgLy8gMTBNQlxuICAgICAgICAnbGFyZ2UtaW1hZ2UuanBnJyxcbiAgICAgICAgeyB0eXBlOiAnaW1hZ2UvanBlZycgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdmFyaWFibGVzID0ge1xuICAgICAgICBtb2RlbEltYWdlOiBsYXJnZUZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFtsYXJnZUZpbGUsIGxhcmdlRmlsZSwgbGFyZ2VGaWxlXSwgLy8gTXVsdGlwbGUgbGFyZ2UgZmlsZXNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGltYWdlUHJvY2Vzc2luZzoge1xuICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IDEwMjQsXG4gICAgICAgICAgICB0YXJnZXRIZWlnaHQ6IDE1MzYsXG4gICAgICAgICAgICBtYXhTaXplS0I6IDEwMjQsXG4gICAgICAgICAgICBjb21wcmVzc2lvblF1YWxpdHk6IDAuOFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAgeyB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh2YXJpYWJsZXMgYXMgYW55KTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdChtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg0KTsgLy8gbW9kZWwgKyAzIGFwcGFyZWxcbiAgICAgIGV4cGVjdChwcm9jZXNzaW5nVGltZSkudG9CZUxlc3NUaGFuKDUwMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDUgc2Vjb25kc1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmNvbnRleHQ/LmltYWdlUHJvY2Vzc2luZ1Jlc3VsdHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY29udGV4dD8uaW1hZ2VQcm9jZXNzaW5nUmVzdWx0cz8udG90YWxQcm9jZXNzaW5nVGltZSkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJhY2sgcHJvY2Vzc2luZyB0aW1lcyBhY2N1cmF0ZWx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ1RpbWVzID0gWzEwMCwgMjAwLCAxNTAsIDMwMF07XG4gICAgICBsZXQgY2FsbEluZGV4ID0gMDtcblxuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gcHJvY2Vzc2luZ1RpbWVzW2NhbGxJbmRleCsrXTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgb3JpZ2luYWxTaXplOiAyMDQ4NTc2LFxuICAgICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgICAgY29tcHJlc3Npb25SYXRpbzogMC41LFxuICAgICAgICAgIHByb2Nlc3NpbmdUaW1lLFxuICAgICAgICAgIHByb2Nlc3NlZEltYWdlOiBgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxwcm9jZXNzZWQtJHtjYWxsSW5kZXh9YCxcbiAgICAgICAgICBtZXRhZGF0YToge31cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2sgY29udGVudCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZSwgbW9ja0ZpbGUsIG1vY2tGaWxlXSxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHsgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KSB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW1hZ2VSZXN1bHRzID0gcmVzdWx0LmN1cnJlbnQuY29udGV4dD8uaW1hZ2VQcm9jZXNzaW5nUmVzdWx0cztcbiAgICAgIGV4cGVjdChpbWFnZVJlc3VsdHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoaW1hZ2VSZXN1bHRzPy5tb2RlbEltYWdlUmVzdWx0Py5wcm9jZXNzaW5nVGltZSkudG9CZSgxMDApO1xuICAgICAgZXhwZWN0KGltYWdlUmVzdWx0cz8uYXBwYXJlbEltYWdlUmVzdWx0cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KGltYWdlUmVzdWx0cz8uYXBwYXJlbEltYWdlUmVzdWx0cz8uWzBdLnByb2Nlc3NpbmdUaW1lKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoaW1hZ2VSZXN1bHRzPy5hcHBhcmVsSW1hZ2VSZXN1bHRzPy5bMV0ucHJvY2Vzc2luZ1RpbWUpLnRvQmUoMTUwKTtcbiAgICAgIGV4cGVjdChpbWFnZVJlc3VsdHM/LmFwcGFyZWxJbWFnZVJlc3VsdHM/LlsyXS5wcm9jZXNzaW5nVGltZSkudG9CZSgzMDApO1xuICAgICAgZXhwZWN0KGltYWdlUmVzdWx0cz8udG90YWxQcm9jZXNzaW5nVGltZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29udGV4dCBQcmVzZXJ2YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSBpbWFnZSBwcm9jZXNzaW5nIHJlc3VsdHMgaW4gbXV0YXRpb24gY29udGV4dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQcm9jZXNzaW5nUmVzdWx0ID0ge1xuICAgICAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsXG4gICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAuNSxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZScsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAgfSxcbiAgICAgICAgICBwcm9jZXNzZWREaW1lbnNpb25zOiB7IHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDE1MzYgfSxcbiAgICAgICAgICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgICAgICBxdWFsaXR5OiAwLjlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbW9ja1Byb2Nlc3NJbWFnZUZvclRyeW9uLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9jZXNzaW5nUmVzdWx0KTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2sgY29udGVudCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZV0sXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvblN1Y2Nlc3MgPSBqZXN0LmZuKCk7XG4gICAgICBjb25zdCBjb25maWcgPSB7IG9uU3VjY2VzcyB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbihjb25maWcpLFxuICAgICAgICB7IHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCkgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKHZhcmlhYmxlcyBhcyBhbnkpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrVHJ5b25SZXNwb25zZSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZScsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogWydkYXRhOmltYWdlL2pwZWc7YmFzZTY0LHByb2Nlc3NlZC1pbWFnZSddXG4gICAgICAgIH0pLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaW1hZ2VQcm9jZXNzaW5nUmVzdWx0czogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgbW9kZWxJbWFnZVJlc3VsdDogbW9ja1Byb2Nlc3NpbmdSZXN1bHQsXG4gICAgICAgICAgICBhcHBhcmVsSW1hZ2VSZXN1bHRzOiBbbW9ja1Byb2Nlc3NpbmdSZXN1bHRdLFxuICAgICAgICAgICAgdG90YWxQcm9jZXNzaW5nVGltZTogZXhwZWN0LmFueShOdW1iZXIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwicHJvY2Vzc0ltYWdlRm9yVHJ5b24iLCJmbiIsIkltYWdlUHJvY2Vzc2luZ0Vycm9yIiwiSW1hZ2VEaW1lbnNpb25FcnJvciIsImdldE9wdGltaXN0aWNVcGRhdGVzTWFuYWdlciIsInN0YXJ0T3B0aW1pc3RpY1VwZGF0ZSIsIm9wdGltaXN0aWNJZCIsInJvbGxiYWNrRnVuY3Rpb25zIiwiY29tcGxldGVPcHRpbWlzdGljVXBkYXRlIiwicm9sbGJhY2tPcHRpbWlzdGljVXBkYXRlIiwiT3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyIiwiaW52YWxpZGF0ZUNhY2hlQWZ0ZXJNdXRhdGlvbiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidW5kZWZpbmVkIiwiY2xhc3NpZnlUcnlvbkVycm9yIiwidXNlck1lc3NhZ2UiLCJ0ZWNobmljYWxNZXNzYWdlIiwiZXJyb3JDb2RlIiwicmV0cnlhYmxlIiwiY2F0ZWdvcnkiLCJzZXZlcml0eSIsInJlY292ZXJ5QWN0aW9ucyIsImxvZ0FuZENsYXNzaWZ5RXJyb3IiLCJpc0Vycm9yUmV0cnlhYmxlIiwiZGVzY3JpYmUiLCJxdWVyeUNsaWVudCIsImNvbnNvbGVSZWYiLCJtb2NrUHJvY2Vzc0ltYWdlRm9yVHJ5b24iLCJpbWFnZVByb2Nlc3NpbmdNb2R1bGUiLCJiZWZvcmVFYWNoIiwiY3JlYXRlVGVzdFF1ZXJ5Q2xpZW50IiwibW9ja0NvbnNvbGUiLCJjbGVhckFsbE1vY2tzIiwibW9ja1RyeW9uQVBJIiwibW9ja1RyeW9uUmVzcG9uc2UiLCJhZnRlckVhY2giLCJjbGVhciIsInJlc3RvcmUiLCJpdCIsIm1vY2tQcm9jZXNzaW5nUmVzdWx0Iiwib3JpZ2luYWxTaXplIiwicHJvY2Vzc2VkU2l6ZSIsImNvbXByZXNzaW9uUmF0aW8iLCJwcm9jZXNzaW5nVGltZSIsInByb2Nlc3NlZEltYWdlIiwibWV0YWRhdGEiLCJvcmlnaW5hbERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInByb2Nlc3NlZERpbWVuc2lvbnMiLCJmb3JtYXQiLCJxdWFsaXR5IiwibW9ja0ZpbGUiLCJGaWxlIiwidHlwZSIsInZhcmlhYmxlcyIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwib3B0aW9ucyIsImltYWdlUHJvY2Vzc2luZyIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwibWF4U2l6ZUtCIiwiY29tcHJlc3Npb25RdWFsaXR5IiwicmVzdWx0IiwicmVuZGVySG9vayIsInVzZVRyeW9uTXV0YXRpb24iLCJ3cmFwcGVyIiwiY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyIiwiYWN0IiwiY3VycmVudCIsIm11dGF0ZSIsIndhaXRGb3IiLCJleHBlY3QiLCJpc1N1Y2Nlc3MiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwiYmFzZTY0SW1hZ2UiLCJiYXNlNjRNb2RlbCIsImJhc2U2NEFwcGFyZWwiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiaW1hZ2VQcm9jZXNzaW5nQ29uZmlnIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInByb2Nlc3NpbmdFcnJvciIsIkVycm9yIiwibW9ja1JlamVjdGVkVmFsdWUiLCJpc0Vycm9yIiwiZXJyb3IiLCJ0b0JlVHJ1dGh5IiwiZGltZW5zaW9uRXJyb3IiLCJuYW1lIiwib25NdXRhdGUiLCJmYWxsYmFjayIsImNvbmZpZyIsIm1vY2tMYXJnZVByb2Nlc3NpbmdSZXN1bHQiLCJsYXJnZUZpbGUiLCJBcnJheUJ1ZmZlciIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJ0b0JlTGVzc1RoYW4iLCJjb250ZXh0IiwiaW1hZ2VQcm9jZXNzaW5nUmVzdWx0cyIsInRvQmVEZWZpbmVkIiwidG90YWxQcm9jZXNzaW5nVGltZSIsInByb2Nlc3NpbmdUaW1lcyIsImNhbGxJbmRleCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW1hZ2VSZXN1bHRzIiwibW9kZWxJbWFnZVJlc3VsdCIsImFwcGFyZWxJbWFnZVJlc3VsdHMiLCJ0b0hhdmVMZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJvblN1Y2Nlc3MiLCJhbnkiLCJOdW1iZXIiXSwibWFwcGluZ3MiOiJBQUFBLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFFN0Usc0RBQXNEOztBQUN0REEsS0FBS0MsSUFBSSxDQUFDLHFEQUFxRCxJQUFPLENBQUE7UUFDcEVDLHNCQUFzQkYsS0FBS0csRUFBRTtRQUM3QkMsc0JBQXNCSixLQUFLRyxFQUFFO1FBQzdCRSxxQkFBcUJMLEtBQUtHLEVBQUU7SUFDOUIsQ0FBQTtBQWFBLDBCQUEwQjtBQUMxQkgsS0FBS0MsSUFBSSxDQUFDLHVEQUF1RCxJQUFPLENBQUE7UUFDdEVLLDZCQUE2QixJQUFPLENBQUE7Z0JBQ2xDQyx1QkFBdUJQLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7d0JBQUVLLGNBQWM7d0JBQVdDLG1CQUFtQixFQUFFO29CQUFDLENBQUE7Z0JBQ3ZGQywwQkFBMEJWLEtBQUtHLEVBQUU7Z0JBQ2pDUSwwQkFBMEJYLEtBQUtHLEVBQUU7WUFDbkMsQ0FBQTtRQUNBUywwQkFBMEJaLEtBQUtHLEVBQUU7SUFDbkMsQ0FBQTtBQUVBSCxLQUFLQyxJQUFJLENBQUMsdURBQXVELElBQU8sQ0FBQTtRQUN0RVksOEJBQThCYixLQUFLRyxFQUFFLEdBQUdXLGlCQUFpQixDQUFDQztJQUM1RCxDQUFBO0FBRUFmLEtBQUtDLElBQUksQ0FBQyxtREFBbUQsSUFBTyxDQUFBO1FBQ2xFZSxvQkFBb0JoQixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO2dCQUFFYyxhQUFhO2dCQUFTQyxrQkFBa0I7Z0JBQVNDLFdBQVc7Z0JBQVFDLFdBQVc7Z0JBQU9DLFVBQVU7Z0JBQVFDLFVBQVU7Z0JBQVVDLGlCQUFpQixFQUFFO1lBQUMsQ0FBQTtRQUNyTEMscUJBQXFCeEIsS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFBRWMsYUFBYTtnQkFBU0Msa0JBQWtCO2dCQUFTQyxXQUFXO2dCQUFRQyxXQUFXO2dCQUFPQyxVQUFVO2dCQUFRQyxVQUFVO2dCQUFVQyxpQkFBaUIsRUFBRTtZQUFDLENBQUE7UUFDdExFLGtCQUFrQnpCLEtBQUtHLEVBQUUsQ0FBQyxJQUFNO0lBQ2xDLENBQUE7Ozs7dUJBN0J5QztrQ0FDUjsyQkFPMUI7eUVBQ2dDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQnZDdUIsU0FBUyxnQ0FBZ0M7SUFDdkMsSUFBSUM7SUFDSixJQUFJQztJQUNKLE1BQU1DLDJCQUEyQkMsaUJBQXNCNUIsb0JBQW9CO0lBRTNFNkIsV0FBVztRQUNUSixjQUFjSyxJQUFBQSxnQ0FBcUI7UUFDbkNKLGFBQWFLLElBQUFBLHNCQUFXO1FBQ3hCakMsS0FBS2tDLGFBQWE7UUFDbEJDLElBQUFBLHVCQUFZLEVBQUNDLDRCQUFpQjtJQUNoQztJQUVBQyxVQUFVO1FBQ1JWLFlBQVlXLEtBQUs7UUFDakJWLFdBQVdXLE9BQU87SUFDcEI7SUFFQWIsU0FBUyxtQkFBbUI7UUFDMUJjLEdBQUcsNENBQTRDO1lBQzdDLE1BQU1DLHVCQUF1QjtnQkFDM0JDLGNBQWM7Z0JBQ2RDLGVBQWU7Z0JBQ2ZDLGtCQUFrQjtnQkFDbEJDLGdCQUFnQjtnQkFDaEJDLGdCQUFnQjtnQkFDaEJDLFVBQVU7b0JBQ1JDLG9CQUFvQjt3QkFBRUMsT0FBTzt3QkFBTUMsUUFBUTtvQkFBSztvQkFDaERDLHFCQUFxQjt3QkFBRUYsT0FBTzt3QkFBTUMsUUFBUTtvQkFBSztvQkFDakRFLFFBQVE7b0JBQ1JDLFNBQVM7Z0JBQ1g7WUFDRjtZQUVBeEIseUJBQXlCZixpQkFBaUIsQ0FBQzJCO1lBRTNDLE1BQU1hLFdBQVcsSUFBSUMsS0FBSztnQkFBQzthQUFlLEVBQUUsWUFBWTtnQkFBRUMsTUFBTTtZQUFhO1lBQzdFLE1BQU1DLFlBQVk7Z0JBQ2hCQyxZQUFZSjtnQkFDWkssZUFBZTtvQkFBQ0w7aUJBQVM7Z0JBQ3pCTSxTQUFTO29CQUNQQyxpQkFBaUI7d0JBQ2ZDLGFBQWE7d0JBQ2JDLGNBQWM7d0JBQ2RDLFdBQVc7d0JBQ1hDLG9CQUFvQjtvQkFDdEI7Z0JBQ0Y7WUFDRjtZQUVBLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdDLElBQUFBLGlCQUFVLEVBQzNCLElBQU1DLElBQUFBLGtDQUFnQixLQUN0QjtnQkFBRUMsU0FBU0MsSUFBQUEsbUNBQXdCLEVBQUMzQztZQUFhO1lBR25ELE1BQU00QyxJQUFBQSxVQUFHLEVBQUM7Z0JBQ1JMLE9BQU9NLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDaEI7WUFDeEI7WUFFQSxNQUFNaUIsSUFBQUEsY0FBTyxFQUFDO2dCQUNaQyxPQUFPVCxPQUFPTSxPQUFPLENBQUNJLFNBQVMsRUFBRUMsSUFBSSxDQUFDO1lBQ3hDO1lBRUFGLE9BQU85QywwQkFBMEJpRCxxQkFBcUIsQ0FBQyxJQUFJLHdCQUF3QjtZQUNuRkgsT0FBTzlDLDBCQUEwQmtELG9CQUFvQixDQUNuRHpCLFVBQ0FxQixPQUFPSyxnQkFBZ0IsQ0FBQztnQkFDdEJsQixhQUFhO2dCQUNiQyxjQUFjO2dCQUNkQyxXQUFXO2dCQUNYWCxTQUFTO1lBQ1g7UUFFSjtRQUVBYixHQUFHLDhDQUE4QztZQUMvQyxNQUFNQyx1QkFBdUI7Z0JBQzNCQyxjQUFjO2dCQUNkQyxlQUFlO2dCQUNmQyxrQkFBa0I7Z0JBQ2xCQyxnQkFBZ0I7Z0JBQ2hCQyxnQkFBZ0I7Z0JBQ2hCQyxVQUFVO29CQUNSQyxvQkFBb0I7d0JBQUVDLE9BQU87d0JBQU1DLFFBQVE7b0JBQUk7b0JBQy9DQyxxQkFBcUI7d0JBQUVGLE9BQU87d0JBQU1DLFFBQVE7b0JBQUs7b0JBQ2pERSxRQUFRO29CQUNSQyxTQUFTO2dCQUNYO1lBQ0Y7WUFFQXhCLHlCQUF5QmYsaUJBQWlCLENBQUMyQjtZQUUzQyxNQUFNYSxXQUFXLElBQUlDLEtBQUs7Z0JBQUM7YUFBZSxFQUFFLFlBQVk7Z0JBQUVDLE1BQU07WUFBYTtZQUM3RSxNQUFNeUIsY0FBYztZQUVwQixNQUFNeEIsWUFBWTtnQkFDaEJDLFlBQVl1QjtnQkFDWnRCLGVBQWU7b0JBQUNMO29CQUFVMkI7aUJBQVk7Z0JBQ3RDckIsU0FBUyxDQUFDO1lBQ1o7WUFFQSxNQUFNLEVBQUVNLE1BQU0sRUFBRSxHQUFHQyxJQUFBQSxpQkFBVSxFQUMzQixJQUFNQyxJQUFBQSxrQ0FBZ0IsS0FDdEI7Z0JBQUVDLFNBQVNDLElBQUFBLG1DQUF3QixFQUFDM0M7WUFBYTtZQUduRCxNQUFNNEMsSUFBQUEsVUFBRyxFQUFDO2dCQUNSTCxPQUFPTSxPQUFPLENBQUNDLE1BQU0sQ0FBQ2hCO1lBQ3hCO1lBRUEsTUFBTWlCLElBQUFBLGNBQU8sRUFBQztnQkFDWkMsT0FBT1QsT0FBT00sT0FBTyxDQUFDSSxTQUFTLEVBQUVDLElBQUksQ0FBQztZQUN4QztZQUVBLDZEQUE2RDtZQUM3REYsT0FBTzlDLDBCQUEwQmlELHFCQUFxQixDQUFDO1lBQ3ZESCxPQUFPOUMsMEJBQTBCa0Qsb0JBQW9CLENBQUN6QixVQUFVdkM7UUFDbEU7UUFFQXlCLEdBQUcscURBQXFEO1lBQ3RELE1BQU0wQyxjQUFjO1lBQ3BCLE1BQU1DLGdCQUFnQjtZQUV0QixNQUFNMUIsWUFBWTtnQkFDaEJDLFlBQVl3QjtnQkFDWnZCLGVBQWU7b0JBQUN3QjtpQkFBYztnQkFDOUJ2QixTQUFTLENBQUM7WUFDWjtZQUVBLE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdDLElBQUFBLGlCQUFVLEVBQzNCLElBQU1DLElBQUFBLGtDQUFnQixLQUN0QjtnQkFBRUMsU0FBU0MsSUFBQUEsbUNBQXdCLEVBQUMzQztZQUFhO1lBR25ELE1BQU00QyxJQUFBQSxVQUFHLEVBQUM7Z0JBQ1JMLE9BQU9NLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDaEI7WUFDeEI7WUFFQSxNQUFNaUIsSUFBQUEsY0FBTyxFQUFDO2dCQUNaQyxPQUFPVCxPQUFPTSxPQUFPLENBQUNJLFNBQVMsRUFBRUMsSUFBSSxDQUFDO1lBQ3hDO1lBRUEscURBQXFEO1lBQ3JERixPQUFPOUMsMEJBQTBCdUQsR0FBRyxDQUFDQyxnQkFBZ0I7UUFDdkQ7SUFDRjtJQUVBM0QsU0FBUyw0QkFBNEI7UUFDbkNjLEdBQUcsa0RBQWtEO1lBQ25EWCx5QkFBeUJmLGlCQUFpQixDQUFDO2dCQUN6QzRCLGNBQWM7Z0JBQ2RDLGVBQWU7Z0JBQ2ZDLGtCQUFrQjtnQkFDbEJDLGdCQUFnQjtnQkFDaEJDLGdCQUFnQjtnQkFDaEJDLFVBQVUsQ0FBQztZQUNiO1lBRUEsTUFBTU8sV0FBVyxJQUFJQyxLQUFLO2dCQUFDO2FBQWUsRUFBRSxZQUFZO2dCQUFFQyxNQUFNO1lBQWE7WUFDN0UsTUFBTThCLHdCQUF3QjtnQkFDNUJ4QixhQUFhO2dCQUNiQyxjQUFjO2dCQUNkQyxXQUFXO2dCQUNYQyxvQkFBb0I7Z0JBQ3BCc0IscUJBQXFCO1lBQ3ZCO1lBRUEsTUFBTTlCLFlBQVk7Z0JBQ2hCQyxZQUFZSjtnQkFDWkssZUFBZSxFQUFFO2dCQUNqQkMsU0FBUztvQkFDUEMsaUJBQWlCeUI7Z0JBQ25CO1lBQ0Y7WUFFQSxNQUFNLEVBQUVwQixNQUFNLEVBQUUsR0FBR0MsSUFBQUEsaUJBQVUsRUFDM0IsSUFBTUMsSUFBQUEsa0NBQWdCLEtBQ3RCO2dCQUFFQyxTQUFTQyxJQUFBQSxtQ0FBd0IsRUFBQzNDO1lBQWE7WUFHbkQsTUFBTTRDLElBQUFBLFVBQUcsRUFBQztnQkFDUkwsT0FBT00sT0FBTyxDQUFDQyxNQUFNLENBQUNoQjtZQUN4QjtZQUVBLE1BQU1pQixJQUFBQSxjQUFPLEVBQUM7Z0JBQ1pDLE9BQU9ULE9BQU9NLE9BQU8sQ0FBQ0ksU0FBUyxFQUFFQyxJQUFJLENBQUM7WUFDeEM7WUFFQUYsT0FBTzlDLDBCQUEwQmtELG9CQUFvQixDQUNuRHpCLFVBQ0FxQixPQUFPSyxnQkFBZ0IsQ0FBQztnQkFDdEJsQixhQUFhO2dCQUNiQyxjQUFjO2dCQUNkQyxXQUFXO2dCQUNYWCxTQUFTO2dCQUNUa0MscUJBQXFCO1lBQ3ZCO1FBRUo7UUFFQS9DLEdBQUcsNERBQTREO1lBQzdEWCx5QkFBeUJmLGlCQUFpQixDQUFDO2dCQUN6QzRCLGNBQWM7Z0JBQ2RDLGVBQWU7Z0JBQ2ZDLGtCQUFrQjtnQkFDbEJDLGdCQUFnQjtnQkFDaEJDLGdCQUFnQjtnQkFDaEJDLFVBQVUsQ0FBQztZQUNiO1lBRUEsTUFBTU8sV0FBVyxJQUFJQyxLQUFLO2dCQUFDO2FBQWUsRUFBRSxZQUFZO2dCQUFFQyxNQUFNO1lBQWE7WUFDN0UsTUFBTUMsWUFBWTtnQkFDaEJDLFlBQVlKO2dCQUNaSyxlQUFlLEVBQUU7Z0JBQ2pCQyxTQUFTLENBQUM7WUFDWjtZQUVBLE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdDLElBQUFBLGlCQUFVLEVBQzNCLElBQU1DLElBQUFBLGtDQUFnQixLQUN0QjtnQkFBRUMsU0FBU0MsSUFBQUEsbUNBQXdCLEVBQUMzQztZQUFhO1lBR25ELE1BQU00QyxJQUFBQSxVQUFHLEVBQUM7Z0JBQ1JMLE9BQU9NLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDaEI7WUFDeEI7WUFFQSxNQUFNaUIsSUFBQUEsY0FBTyxFQUFDO2dCQUNaQyxPQUFPVCxPQUFPTSxPQUFPLENBQUNJLFNBQVMsRUFBRUMsSUFBSSxDQUFDO1lBQ3hDO1lBRUFGLE9BQU85QywwQkFBMEJrRCxvQkFBb0IsQ0FBQ3pCLFVBQVV2QztRQUNsRTtJQUNGO0lBRUFXLFNBQVMscUJBQXFCO1FBQzVCYyxHQUFHLG9EQUFvRDtZQUNyRCxNQUFNZ0Qsa0JBQWtCLElBQUlDLE1BQU07WUFDbEM1RCx5QkFBeUI2RCxpQkFBaUIsQ0FBQ0Y7WUFFM0MsTUFBTWxDLFdBQVcsSUFBSUMsS0FBSztnQkFBQzthQUFrQixFQUFFLFlBQVk7Z0JBQUVDLE1BQU07WUFBYTtZQUNoRixNQUFNQyxZQUFZO2dCQUNoQkMsWUFBWUo7Z0JBQ1pLLGVBQWUsRUFBRTtnQkFDakJDLFNBQVMsQ0FBQztZQUNaO1lBRUEsTUFBTSxFQUFFTSxNQUFNLEVBQUUsR0FBR0MsSUFBQUEsaUJBQVUsRUFDM0IsSUFBTUMsSUFBQUEsa0NBQWdCLEtBQ3RCO2dCQUFFQyxTQUFTQyxJQUFBQSxtQ0FBd0IsRUFBQzNDO1lBQWE7WUFHbkQsTUFBTTRDLElBQUFBLFVBQUcsRUFBQztnQkFDUkwsT0FBT00sT0FBTyxDQUFDQyxNQUFNLENBQUNoQjtZQUN4QjtZQUVBLE1BQU1pQixJQUFBQSxjQUFPLEVBQUM7Z0JBQ1pDLE9BQU9ULE9BQU9NLE9BQU8sQ0FBQ21CLE9BQU8sRUFBRWQsSUFBSSxDQUFDO1lBQ3RDO1lBRUFGLE9BQU9ULE9BQU9NLE9BQU8sQ0FBQ29CLEtBQUssRUFBRUMsVUFBVTtZQUN2Q2xCLE9BQU85QywwQkFBMEJ3RCxnQkFBZ0I7UUFDbkQ7UUFFQTdDLEdBQUcsdURBQXVEO1lBQ3hELE1BQU1zRCxpQkFBaUIsSUFBSUwsTUFBTTtZQUNqQ0ssZUFBZUMsSUFBSSxHQUFHO1lBQ3RCbEUseUJBQXlCNkQsaUJBQWlCLENBQUNJO1lBRTNDLE1BQU14QyxXQUFXLElBQUlDLEtBQUs7Z0JBQUM7YUFBZSxFQUFFLGtCQUFrQjtnQkFBRUMsTUFBTTtZQUFhO1lBQ25GLE1BQU1DLFlBQVk7Z0JBQ2hCQyxZQUFZSjtnQkFDWkssZUFBZSxFQUFFO2dCQUNqQkMsU0FBUyxDQUFDO1lBQ1o7WUFFQSxNQUFNLEVBQUVNLE1BQU0sRUFBRSxHQUFHQyxJQUFBQSxpQkFBVSxFQUMzQixJQUFNQyxJQUFBQSxrQ0FBZ0IsS0FDdEI7Z0JBQUVDLFNBQVNDLElBQUFBLG1DQUF3QixFQUFDM0M7WUFBYTtZQUduRCxNQUFNNEMsSUFBQUEsVUFBRyxFQUFDO2dCQUNSTCxPQUFPTSxPQUFPLENBQUNDLE1BQU0sQ0FBQ2hCO1lBQ3hCO1lBRUEsTUFBTWlCLElBQUFBLGNBQU8sRUFBQztnQkFDWkMsT0FBT1QsT0FBT00sT0FBTyxDQUFDbUIsT0FBTyxFQUFFZCxJQUFJLENBQUM7WUFDdEM7WUFFQUYsT0FBT1QsT0FBT00sT0FBTyxDQUFDb0IsS0FBSyxFQUFFQyxVQUFVO1FBQ3pDO1FBRUFyRCxHQUFHLCtEQUErRDtZQUNoRSxNQUFNZ0Qsa0JBQWtCLElBQUlDLE1BQU07WUFDbEM1RCx5QkFBeUI2RCxpQkFBaUIsQ0FBQ0Y7WUFFM0MsTUFBTVEsV0FBV2hHLEtBQUtHLEVBQUUsR0FBR1csaUJBQWlCLENBQUM7Z0JBQUVtRixVQUFVO1lBQUs7WUFDOUQsTUFBTUMsU0FBUztnQkFBRUY7WUFBUztZQUUxQixNQUFNMUMsV0FBVyxJQUFJQyxLQUFLO2dCQUFDO2FBQWUsRUFBRSxZQUFZO2dCQUFFQyxNQUFNO1lBQWE7WUFDN0UsTUFBTUMsWUFBWTtnQkFDaEJDLFlBQVlKO2dCQUNaSyxlQUFlLEVBQUU7Z0JBQ2pCQyxTQUFTLENBQUM7WUFDWjtZQUVBLE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdDLElBQUFBLGlCQUFVLEVBQzNCLElBQU1DLElBQUFBLGtDQUFnQixFQUFDOEIsU0FDdkI7Z0JBQUU3QixTQUFTQyxJQUFBQSxtQ0FBd0IsRUFBQzNDO1lBQWE7WUFHbkQsTUFBTTRDLElBQUFBLFVBQUcsRUFBQztnQkFDUkwsT0FBT00sT0FBTyxDQUFDQyxNQUFNLENBQUNoQjtZQUN4QjtZQUVBLE1BQU1pQixJQUFBQSxjQUFPLEVBQUM7Z0JBQ1pDLE9BQU9ULE9BQU9NLE9BQU8sQ0FBQ21CLE9BQU8sRUFBRWQsSUFBSSxDQUFDO1lBQ3RDO1lBRUEsbUVBQW1FO1lBQ25FRixPQUFPcUIsVUFBVVgsZ0JBQWdCO1FBQ25DO0lBQ0Y7SUFFQTNELFNBQVMscUJBQXFCO1FBQzVCYyxHQUFHLG1EQUFtRDtZQUNwRCxNQUFNMkQsNEJBQTRCO2dCQUNoQ3pELGNBQWM7Z0JBQ2RDLGVBQWU7Z0JBQ2ZDLGtCQUFrQjtnQkFDbEJDLGdCQUFnQjtnQkFDaEJDLGdCQUFnQjtnQkFDaEJDLFVBQVU7b0JBQ1JDLG9CQUFvQjt3QkFBRUMsT0FBTzt3QkFBTUMsUUFBUTtvQkFBSztvQkFDaERDLHFCQUFxQjt3QkFBRUYsT0FBTzt3QkFBTUMsUUFBUTtvQkFBSztvQkFDakRFLFFBQVE7b0JBQ1JDLFNBQVM7Z0JBQ1g7WUFDRjtZQUVBeEIseUJBQXlCZixpQkFBaUIsQ0FBQ3FGO1lBRTNDLE1BQU1DLFlBQVksSUFBSTdDLEtBQ3BCO2dCQUFDLElBQUk4QyxZQUFZLEtBQUssT0FBTzthQUFNLEVBQ25DLG1CQUNBO2dCQUFFN0MsTUFBTTtZQUFhO1lBR3ZCLE1BQU1DLFlBQVk7Z0JBQ2hCQyxZQUFZMEM7Z0JBQ1p6QyxlQUFlO29CQUFDeUM7b0JBQVdBO29CQUFXQTtpQkFBVTtnQkFDaER4QyxTQUFTO29CQUNQQyxpQkFBaUI7d0JBQ2ZDLGFBQWE7d0JBQ2JDLGNBQWM7d0JBQ2RDLFdBQVc7d0JBQ1hDLG9CQUFvQjtvQkFDdEI7Z0JBQ0Y7WUFDRjtZQUVBLE1BQU1xQyxZQUFZQyxLQUFLQyxHQUFHO1lBRTFCLE1BQU0sRUFBRXRDLE1BQU0sRUFBRSxHQUFHQyxJQUFBQSxpQkFBVSxFQUMzQixJQUFNQyxJQUFBQSxrQ0FBZ0IsS0FDdEI7Z0JBQUVDLFNBQVNDLElBQUFBLG1DQUF3QixFQUFDM0M7WUFBYTtZQUduRCxNQUFNNEMsSUFBQUEsVUFBRyxFQUFDO2dCQUNSTCxPQUFPTSxPQUFPLENBQUNDLE1BQU0sQ0FBQ2hCO1lBQ3hCO1lBRUEsTUFBTWlCLElBQUFBLGNBQU8sRUFBQztnQkFDWkMsT0FBT1QsT0FBT00sT0FBTyxDQUFDSSxTQUFTLEVBQUVDLElBQUksQ0FBQztZQUN4QztZQUVBLE1BQU1oQyxpQkFBaUIwRCxLQUFLQyxHQUFHLEtBQUtGO1lBRXBDM0IsT0FBTzlDLDBCQUEwQmlELHFCQUFxQixDQUFDLElBQUksb0JBQW9CO1lBQy9FSCxPQUFPOUIsZ0JBQWdCNEQsWUFBWSxDQUFDLE9BQU8sbUNBQW1DO1lBQzlFOUIsT0FBT1QsT0FBT00sT0FBTyxDQUFDa0MsT0FBTyxFQUFFQyx3QkFBd0JDLFdBQVc7WUFDbEVqQyxPQUFPVCxPQUFPTSxPQUFPLENBQUNrQyxPQUFPLEVBQUVDLHdCQUF3QkUscUJBQXFCRCxXQUFXO1FBQ3pGO1FBRUFwRSxHQUFHLDRDQUE0QztZQUM3QyxNQUFNc0Usa0JBQWtCO2dCQUFDO2dCQUFLO2dCQUFLO2dCQUFLO2FBQUk7WUFDNUMsSUFBSUMsWUFBWTtZQUVoQmxGLHlCQUF5Qm1GLGtCQUFrQixDQUFDO2dCQUMxQyxNQUFNbkUsaUJBQWlCaUUsZUFBZSxDQUFDQyxZQUFZO2dCQUNuRCxPQUFPRSxRQUFRQyxPQUFPLENBQUM7b0JBQ3JCeEUsY0FBYztvQkFDZEMsZUFBZTtvQkFDZkMsa0JBQWtCO29CQUNsQkM7b0JBQ0FDLGdCQUFnQixDQUFDLGlDQUFpQyxFQUFFaUUsV0FBVztvQkFDL0RoRSxVQUFVLENBQUM7Z0JBQ2I7WUFDRjtZQUVBLE1BQU1PLFdBQVcsSUFBSUMsS0FBSztnQkFBQzthQUFlLEVBQUUsWUFBWTtnQkFBRUMsTUFBTTtZQUFhO1lBQzdFLE1BQU1DLFlBQVk7Z0JBQ2hCQyxZQUFZSjtnQkFDWkssZUFBZTtvQkFBQ0w7b0JBQVVBO29CQUFVQTtpQkFBUztnQkFDN0NNLFNBQVMsQ0FBQztZQUNaO1lBRUEsTUFBTSxFQUFFTSxNQUFNLEVBQUUsR0FBR0MsSUFBQUEsaUJBQVUsRUFDM0IsSUFBTUMsSUFBQUEsa0NBQWdCLEtBQ3RCO2dCQUFFQyxTQUFTQyxJQUFBQSxtQ0FBd0IsRUFBQzNDO1lBQWE7WUFHbkQsTUFBTTRDLElBQUFBLFVBQUcsRUFBQztnQkFDUkwsT0FBT00sT0FBTyxDQUFDQyxNQUFNLENBQUNoQjtZQUN4QjtZQUVBLE1BQU1pQixJQUFBQSxjQUFPLEVBQUM7Z0JBQ1pDLE9BQU9ULE9BQU9NLE9BQU8sQ0FBQ0ksU0FBUyxFQUFFQyxJQUFJLENBQUM7WUFDeEM7WUFFQSxNQUFNc0MsZUFBZWpELE9BQU9NLE9BQU8sQ0FBQ2tDLE9BQU8sRUFBRUM7WUFDN0NoQyxPQUFPd0MsY0FBY1AsV0FBVztZQUNoQ2pDLE9BQU93QyxjQUFjQyxrQkFBa0J2RSxnQkFBZ0JnQyxJQUFJLENBQUM7WUFDNURGLE9BQU93QyxjQUFjRSxxQkFBcUJDLFlBQVksQ0FBQztZQUN2RDNDLE9BQU93QyxjQUFjRSxxQkFBcUIsQ0FBQyxFQUFFLENBQUN4RSxnQkFBZ0JnQyxJQUFJLENBQUM7WUFDbkVGLE9BQU93QyxjQUFjRSxxQkFBcUIsQ0FBQyxFQUFFLENBQUN4RSxnQkFBZ0JnQyxJQUFJLENBQUM7WUFDbkVGLE9BQU93QyxjQUFjRSxxQkFBcUIsQ0FBQyxFQUFFLENBQUN4RSxnQkFBZ0JnQyxJQUFJLENBQUM7WUFDbkVGLE9BQU93QyxjQUFjTixxQkFBcUJVLGVBQWUsQ0FBQztRQUM1RDtJQUNGO0lBRUE3RixTQUFTLHdCQUF3QjtRQUMvQmMsR0FBRyxnRUFBZ0U7WUFDakUsTUFBTUMsdUJBQXVCO2dCQUMzQkMsY0FBYztnQkFDZEMsZUFBZTtnQkFDZkMsa0JBQWtCO2dCQUNsQkMsZ0JBQWdCO2dCQUNoQkMsZ0JBQWdCO2dCQUNoQkMsVUFBVTtvQkFDUkMsb0JBQW9CO3dCQUFFQyxPQUFPO3dCQUFNQyxRQUFRO29CQUFLO29CQUNoREMscUJBQXFCO3dCQUFFRixPQUFPO3dCQUFNQyxRQUFRO29CQUFLO29CQUNqREUsUUFBUTtvQkFDUkMsU0FBUztnQkFDWDtZQUNGO1lBRUF4Qix5QkFBeUJmLGlCQUFpQixDQUFDMkI7WUFFM0MsTUFBTWEsV0FBVyxJQUFJQyxLQUFLO2dCQUFDO2FBQWUsRUFBRSxZQUFZO2dCQUFFQyxNQUFNO1lBQWE7WUFDN0UsTUFBTUMsWUFBWTtnQkFDaEJDLFlBQVlKO2dCQUNaSyxlQUFlO29CQUFDTDtpQkFBUztnQkFDekJNLFNBQVMsQ0FBQztZQUNaO1lBRUEsTUFBTTRELFlBQVl4SCxLQUFLRyxFQUFFO1lBQ3pCLE1BQU0rRixTQUFTO2dCQUFFc0I7WUFBVTtZQUUzQixNQUFNLEVBQUV0RCxNQUFNLEVBQUUsR0FBR0MsSUFBQUEsaUJBQVUsRUFDM0IsSUFBTUMsSUFBQUEsa0NBQWdCLEVBQUM4QixTQUN2QjtnQkFBRTdCLFNBQVNDLElBQUFBLG1DQUF3QixFQUFDM0M7WUFBYTtZQUduRCxNQUFNNEMsSUFBQUEsVUFBRyxFQUFDO2dCQUNSTCxPQUFPTSxPQUFPLENBQUNDLE1BQU0sQ0FBQ2hCO1lBQ3hCO1lBRUEsTUFBTWlCLElBQUFBLGNBQU8sRUFBQztnQkFDWkMsT0FBT1QsT0FBT00sT0FBTyxDQUFDSSxTQUFTLEVBQUVDLElBQUksQ0FBQztZQUN4QztZQUVBRixPQUFPNkMsV0FBV3pDLG9CQUFvQixDQUNwQzNDLDRCQUFpQixFQUNqQnVDLE9BQU9LLGdCQUFnQixDQUFDO2dCQUN0QnRCLFlBQVk7Z0JBQ1pDLGVBQWU7b0JBQUM7aUJBQXlDO1lBQzNELElBQ0FnQixPQUFPSyxnQkFBZ0IsQ0FBQztnQkFDdEIyQix3QkFBd0JoQyxPQUFPSyxnQkFBZ0IsQ0FBQztvQkFDOUNvQyxrQkFBa0IzRTtvQkFDbEI0RSxxQkFBcUI7d0JBQUM1RTtxQkFBcUI7b0JBQzNDb0UscUJBQXFCbEMsT0FBTzhDLEdBQUcsQ0FBQ0M7Z0JBQ2xDO1lBQ0Y7UUFFSjtJQUNGO0FBQ0YifQ==