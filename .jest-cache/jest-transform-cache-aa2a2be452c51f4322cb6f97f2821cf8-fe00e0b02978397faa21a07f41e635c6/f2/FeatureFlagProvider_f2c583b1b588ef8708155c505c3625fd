6709ad8517bbb4c55808d2adcfa891be
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "FeatureFlagProvider", {
    enumerable: true,
    get: function() {
        return FeatureFlagProvider;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reactquery = require("@tanstack/react-query");
const _FeatureFlagContext = require("./FeatureFlagContext");
const _ErrorBoundary = require("./ErrorBoundary");
const _featureFlagtypes = require("../types/featureFlag.types");
const _constants = require("../config/constants");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Default configuration
const DEFAULT_CONFIG = {
    flags: [
        ..._featureFlagtypes.DEFAULT_TRYON_FLAGS,
        ..._featureFlagtypes.DEFAULT_IMAGE_PROCESSING_FLAGS,
        ..._featureFlagtypes.DEFAULT_UI_FLAGS
    ],
    environment: process.env.NODE_ENV || 'development',
    enableRemoteConfig: false,
    refreshInterval: 5 * 60 * 1000,
    fallbackToDefaults: true
};
// Utility function to create feature flag from config
const createFeatureFlagFromConfig = (config, environment)=>{
    // Check if flag is enabled for current environment
    const isEnabledForEnvironment = !config.environment || config.environment.includes(environment);
    return {
        key: config.key,
        description: config.description,
        category: config.category,
        defaultValue: config.defaultValue,
        type: config.type,
        environment: config.environment,
        enabled: isEnabledForEnvironment,
        value: config.defaultValue,
        lastUpdated: new Date().toISOString()
    };
};
// Mock function for remote config fetching (to be implemented)
const fetchRemoteFlags = async (url)=>{
    // TODO: Implement actual remote config fetching
    if (!url) {
        throw new Error('Remote config URL not provided');
    }
    // For now, return empty array - this would be replaced with actual API call
    return [];
};
// Environment variable parser for feature flags
const parseEnvironmentFlags = ()=>{
    const envFlags = {};
    // Parse environment variables with FEATURE_FLAG_ prefix
    Object.entries(process.env).forEach(([key, value])=>{
        if (key.startsWith('FEATURE_FLAG_') && value !== undefined) {
            const flagKey = key.replace('FEATURE_FLAG_', '').toLowerCase();
            // Try to parse as boolean
            if (value === 'true' || value === 'false') {
                envFlags[flagKey] = value === 'true';
            } else if (!isNaN(Number(value))) {
                envFlags[flagKey] = Number(value);
            } else {
                envFlags[flagKey] = value;
            }
        }
    });
    return envFlags;
};
const FeatureFlagProviderContent = ({ children, config = {}, environment = DEFAULT_CONFIG.environment, initialFlags = DEFAULT_CONFIG.flags, enableRemoteConfig = DEFAULT_CONFIG.enableRemoteConfig, fallbackToDefaults = DEFAULT_CONFIG.fallbackToDefaults, onError })=>{
    const mergedConfig = (0, _react.useMemo)(()=>({
            ...DEFAULT_CONFIG,
            ...config,
            flags: initialFlags,
            environment,
            enableRemoteConfig,
            fallbackToDefaults
        }), [
        config,
        environment,
        initialFlags,
        enableRemoteConfig,
        fallbackToDefaults
    ]);
    // Query for remote feature flags (if enabled)
    const { data: remoteFlags = [], isLoading: isLoadingRemote, error: remoteError, refetch: refetchRemoteFlags } = (0, _reactquery.useQuery)({
        queryKey: [
            ..._constants.QUERY_KEYS.FEATURE_FLAGS,
            'remote',
            mergedConfig.remoteConfigUrl
        ],
        queryFn: ()=>fetchRemoteFlags(mergedConfig.remoteConfigUrl),
        enabled: enableRemoteConfig && !!mergedConfig.remoteConfigUrl,
        staleTime: mergedConfig.refreshInterval,
        retry: 2,
        retryDelay: 1000
    });
    // Combine local and remote flags with environment overrides
    const combinedFlags = (0, _react.useMemo)(()=>{
        const envFlags = parseEnvironmentFlags();
        const allConfigs = [
            ...mergedConfig.flags,
            ...remoteFlags
        ];
        const flagMap = {};
        // Create flags from configurations
        allConfigs.forEach((flagConfig)=>{
            const flag = createFeatureFlagFromConfig(flagConfig, environment);
            // Override with environment variable if available
            const envValue = envFlags[flagConfig.key.toLowerCase()];
            if (envValue !== undefined) {
                flag.value = envValue;
            }
            flagMap[flagConfig.key] = flag;
        });
        return flagMap;
    }, [
        mergedConfig.flags,
        remoteFlags,
        environment
    ]);
    // Context value implementation
    const contextValue = (0, _react.useMemo)(()=>{
        const getFlag = (key)=>{
            const flag = combinedFlags[key];
            return flag;
        };
        const isEnabled = (key)=>{
            const flag = combinedFlags[key];
            return flag ? flag.enabled && Boolean(flag.value) : false;
        };
        const getValue = (key, defaultValue)=>{
            const flag = combinedFlags[key];
            if (!flag || !flag.enabled) {
                return defaultValue;
            }
            return flag.value;
        };
        const updateFlag = (key, value)=>{
            const flag = combinedFlags[key];
            if (flag) {
                flag.value = value;
                flag.lastUpdated = new Date().toISOString();
            }
        };
        const refreshFlags = async ()=>{
            if (enableRemoteConfig) {
                await refetchRemoteFlags();
            }
        };
        return {
            flags: combinedFlags,
            getFlag,
            isEnabled,
            getValue,
            updateFlag,
            refreshFlags,
            isLoading: isLoadingRemote,
            error: remoteError instanceof Error ? remoteError : null
        };
    }, [
        combinedFlags,
        isLoadingRemote,
        remoteError,
        refetchRemoteFlags,
        enableRemoteConfig
    ]);
    // Handle errors
    _react.default.useEffect(()=>{
        if (remoteError && onError) {
            onError(remoteError instanceof Error ? remoteError : new Error('Unknown feature flag error'));
        }
    }, [
        remoteError,
        onError
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_FeatureFlagContext.FeatureFlagContext.Provider, {
        value: contextValue,
        children: children
    });
};
const FeatureFlagProvider = (props)=>{
    const { onError, fallbackToDefaults = true } = props;
    const handleError = (0, _react.useCallback)((error)=>{
        console.error('FeatureFlagProvider Error:', error);
        onError?.(error);
    }, [
        onError
    ]);
    // Fallback component for error boundary
    const ErrorFallback = (0, _react.useCallback)(({ error, resetError })=>{
        if (!fallbackToDefaults) {
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                className: "feature-flag-error",
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("h3", {
                        children: "Feature Flag Error"
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                        children: error.message
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        onClick: resetError,
                        children: "Retry"
                    })
                ]
            });
        }
        // Render children with default flags only
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(FeatureFlagProviderContent, {
            ...props,
            enableRemoteConfig: false,
            config: {
                ...props.config,
                enableRemoteConfig: false
            }
        });
    }, [
        fallbackToDefaults,
        props
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_ErrorBoundary.ErrorBoundary, {
        onError: handleError,
        fallback: ErrorFallback,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(FeatureFlagProviderContent, {
            ...props
        })
    });
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL3Byb3ZpZGVycy9GZWF0dXJlRmxhZ1Byb3ZpZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVF1ZXJ5IH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5JztcbmltcG9ydCB7IEZlYXR1cmVGbGFnQ29udGV4dCB9IGZyb20gJy4vRmVhdHVyZUZsYWdDb250ZXh0JztcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICcuL0Vycm9yQm91bmRhcnknO1xuaW1wb3J0IHR5cGUge1xuICBGZWF0dXJlRmxhZyxcbiAgRmVhdHVyZUZsYWdDb25maWcsXG4gIEZlYXR1cmVGbGFnQ29sbGVjdGlvbixcbiAgRmVhdHVyZUZsYWdQcm92aWRlckNvbmZpZyxcbiAgRmVhdHVyZUZsYWdDb250ZXh0VmFsdWUsXG4gIEZlYXR1cmVGbGFnVmFsdWUsXG4gIEVudmlyb25tZW50LFxufSBmcm9tICcuLi90eXBlcy9mZWF0dXJlRmxhZy50eXBlcyc7XG5pbXBvcnQge1xuICBERUZBVUxUX1RSWU9OX0ZMQUdTLFxuICBERUZBVUxUX0lNQUdFX1BST0NFU1NJTkdfRkxBR1MsXG4gIERFRkFVTFRfVUlfRkxBR1MsXG59IGZyb20gJy4uL3R5cGVzL2ZlYXR1cmVGbGFnLnR5cGVzJztcbmltcG9ydCB7IFFVRVJZX0tFWVMgfSBmcm9tICcuLi9jb25maWcvY29uc3RhbnRzJztcblxuaW50ZXJmYWNlIEZlYXR1cmVGbGFnUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIGNvbmZpZz86IFBhcnRpYWw8RmVhdHVyZUZsYWdQcm92aWRlckNvbmZpZz47XG4gIGVudmlyb25tZW50PzogRW52aXJvbm1lbnQ7XG4gIGluaXRpYWxGbGFncz86IEZlYXR1cmVGbGFnQ29uZmlnW107XG4gIGVuYWJsZVJlbW90ZUNvbmZpZz86IGJvb2xlYW47XG4gIGZhbGxiYWNrVG9EZWZhdWx0cz86IGJvb2xlYW47XG4gIG9uRXJyb3I/OiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xufVxuXG4vLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbmNvbnN0IERFRkFVTFRfQ09ORklHOiBGZWF0dXJlRmxhZ1Byb3ZpZGVyQ29uZmlnID0ge1xuICBmbGFnczogWy4uLkRFRkFVTFRfVFJZT05fRkxBR1MsIC4uLkRFRkFVTFRfSU1BR0VfUFJPQ0VTU0lOR19GTEFHUywgLi4uREVGQVVMVF9VSV9GTEFHU10sXG4gIGVudmlyb25tZW50OiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgYXMgRW52aXJvbm1lbnQpIHx8ICdkZXZlbG9wbWVudCcsXG4gIGVuYWJsZVJlbW90ZUNvbmZpZzogZmFsc2UsXG4gIHJlZnJlc2hJbnRlcnZhbDogNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzXG4gIGZhbGxiYWNrVG9EZWZhdWx0czogdHJ1ZSxcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGZlYXR1cmUgZmxhZyBmcm9tIGNvbmZpZ1xuY29uc3QgY3JlYXRlRmVhdHVyZUZsYWdGcm9tQ29uZmlnID0gKFxuICBjb25maWc6IEZlYXR1cmVGbGFnQ29uZmlnLFxuICBlbnZpcm9ubWVudDogRW52aXJvbm1lbnRcbik6IEZlYXR1cmVGbGFnID0+IHtcbiAgLy8gQ2hlY2sgaWYgZmxhZyBpcyBlbmFibGVkIGZvciBjdXJyZW50IGVudmlyb25tZW50XG4gIGNvbnN0IGlzRW5hYmxlZEZvckVudmlyb25tZW50ID0gIWNvbmZpZy5lbnZpcm9ubWVudCB8fCBcbiAgICBjb25maWcuZW52aXJvbm1lbnQuaW5jbHVkZXMoZW52aXJvbm1lbnQpO1xuXG4gIHJldHVybiB7XG4gICAga2V5OiBjb25maWcua2V5LFxuICAgIGRlc2NyaXB0aW9uOiBjb25maWcuZGVzY3JpcHRpb24sXG4gICAgY2F0ZWdvcnk6IGNvbmZpZy5jYXRlZ29yeSxcbiAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZy5kZWZhdWx0VmFsdWUsXG4gICAgdHlwZTogY29uZmlnLnR5cGUsXG4gICAgZW52aXJvbm1lbnQ6IGNvbmZpZy5lbnZpcm9ubWVudCxcbiAgICBlbmFibGVkOiBpc0VuYWJsZWRGb3JFbnZpcm9ubWVudCxcbiAgICB2YWx1ZTogY29uZmlnLmRlZmF1bHRWYWx1ZSxcbiAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9O1xufTtcblxuLy8gTW9jayBmdW5jdGlvbiBmb3IgcmVtb3RlIGNvbmZpZyBmZXRjaGluZyAodG8gYmUgaW1wbGVtZW50ZWQpXG5jb25zdCBmZXRjaFJlbW90ZUZsYWdzID0gYXN5bmMgKHVybD86IHN0cmluZyk6IFByb21pc2U8RmVhdHVyZUZsYWdDb25maWdbXT4gPT4ge1xuICAvLyBUT0RPOiBJbXBsZW1lbnQgYWN0dWFsIHJlbW90ZSBjb25maWcgZmV0Y2hpbmdcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbW90ZSBjb25maWcgVVJMIG5vdCBwcm92aWRlZCcpO1xuICB9XG4gIFxuICAvLyBGb3Igbm93LCByZXR1cm4gZW1wdHkgYXJyYXkgLSB0aGlzIHdvdWxkIGJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIEFQSSBjYWxsXG4gIHJldHVybiBbXTtcbn07XG5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHBhcnNlciBmb3IgZmVhdHVyZSBmbGFnc1xuY29uc3QgcGFyc2VFbnZpcm9ubWVudEZsYWdzID0gKCk6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgRmVhdHVyZUZsYWdWYWx1ZT4+ID0+IHtcbiAgY29uc3QgZW52RmxhZ3M6IFJlY29yZDxzdHJpbmcsIEZlYXR1cmVGbGFnVmFsdWU+ID0ge307XG4gIFxuICAvLyBQYXJzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2l0aCBGRUFUVVJFX0ZMQUdfIHByZWZpeFxuICBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKCdGRUFUVVJFX0ZMQUdfJykgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZmxhZ0tleSA9IGtleS5yZXBsYWNlKCdGRUFUVVJFX0ZMQUdfJywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBcbiAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBib29sZWFuXG4gICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICBlbnZGbGFnc1tmbGFnS2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XG4gICAgICB9XG4gICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgbnVtYmVyXG4gICAgICBlbHNlIGlmICghaXNOYU4oTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgZW52RmxhZ3NbZmxhZ0tleV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gVHJlYXQgYXMgc3RyaW5nXG4gICAgICBlbHNlIHtcbiAgICAgICAgZW52RmxhZ3NbZmxhZ0tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGVudkZsYWdzO1xufTtcblxuY29uc3QgRmVhdHVyZUZsYWdQcm92aWRlckNvbnRlbnQ6IFJlYWN0LkZDPEZlYXR1cmVGbGFnUHJvdmlkZXJQcm9wcz4gPSAoe1xuICBjaGlsZHJlbixcbiAgY29uZmlnID0ge30sXG4gIGVudmlyb25tZW50ID0gREVGQVVMVF9DT05GSUcuZW52aXJvbm1lbnQsXG4gIGluaXRpYWxGbGFncyA9IERFRkFVTFRfQ09ORklHLmZsYWdzLFxuICBlbmFibGVSZW1vdGVDb25maWcgPSBERUZBVUxUX0NPTkZJRy5lbmFibGVSZW1vdGVDb25maWcsXG4gIGZhbGxiYWNrVG9EZWZhdWx0cyA9IERFRkFVTFRfQ09ORklHLmZhbGxiYWNrVG9EZWZhdWx0cyxcbiAgb25FcnJvcixcbn0pID0+IHtcbiAgY29uc3QgbWVyZ2VkQ29uZmlnID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLkRFRkFVTFRfQ09ORklHLFxuICAgIC4uLmNvbmZpZyxcbiAgICBmbGFnczogaW5pdGlhbEZsYWdzLFxuICAgIGVudmlyb25tZW50LFxuICAgIGVuYWJsZVJlbW90ZUNvbmZpZyxcbiAgICBmYWxsYmFja1RvRGVmYXVsdHMsXG4gIH0pLCBbY29uZmlnLCBlbnZpcm9ubWVudCwgaW5pdGlhbEZsYWdzLCBlbmFibGVSZW1vdGVDb25maWcsIGZhbGxiYWNrVG9EZWZhdWx0c10pO1xuXG4gIC8vIFF1ZXJ5IGZvciByZW1vdGUgZmVhdHVyZSBmbGFncyAoaWYgZW5hYmxlZClcbiAgY29uc3Qge1xuICAgIGRhdGE6IHJlbW90ZUZsYWdzID0gW10sXG4gICAgaXNMb2FkaW5nOiBpc0xvYWRpbmdSZW1vdGUsXG4gICAgZXJyb3I6IHJlbW90ZUVycm9yLFxuICAgIHJlZmV0Y2g6IHJlZmV0Y2hSZW1vdGVGbGFncyxcbiAgfSA9IHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogWy4uLlFVRVJZX0tFWVMuRkVBVFVSRV9GTEFHUywgJ3JlbW90ZScsIG1lcmdlZENvbmZpZy5yZW1vdGVDb25maWdVcmxdLFxuICAgIHF1ZXJ5Rm46ICgpID0+IGZldGNoUmVtb3RlRmxhZ3MobWVyZ2VkQ29uZmlnLnJlbW90ZUNvbmZpZ1VybCksXG4gICAgZW5hYmxlZDogZW5hYmxlUmVtb3RlQ29uZmlnICYmICEhbWVyZ2VkQ29uZmlnLnJlbW90ZUNvbmZpZ1VybCxcbiAgICBzdGFsZVRpbWU6IG1lcmdlZENvbmZpZy5yZWZyZXNoSW50ZXJ2YWwsXG4gICAgcmV0cnk6IDIsXG4gICAgcmV0cnlEZWxheTogMTAwMCxcbiAgfSk7XG5cbiAgLy8gQ29tYmluZSBsb2NhbCBhbmQgcmVtb3RlIGZsYWdzIHdpdGggZW52aXJvbm1lbnQgb3ZlcnJpZGVzXG4gIGNvbnN0IGNvbWJpbmVkRmxhZ3MgPSB1c2VNZW1vKCgpOiBGZWF0dXJlRmxhZ0NvbGxlY3Rpb24gPT4ge1xuICAgIGNvbnN0IGVudkZsYWdzID0gcGFyc2VFbnZpcm9ubWVudEZsYWdzKCk7XG4gICAgY29uc3QgYWxsQ29uZmlncyA9IFsuLi5tZXJnZWRDb25maWcuZmxhZ3MsIC4uLnJlbW90ZUZsYWdzXTtcbiAgICBjb25zdCBmbGFnTWFwOiBGZWF0dXJlRmxhZ0NvbGxlY3Rpb24gPSB7fTtcblxuICAgIC8vIENyZWF0ZSBmbGFncyBmcm9tIGNvbmZpZ3VyYXRpb25zXG4gICAgYWxsQ29uZmlncy5mb3JFYWNoKChmbGFnQ29uZmlnKSA9PiB7XG4gICAgICBjb25zdCBmbGFnID0gY3JlYXRlRmVhdHVyZUZsYWdGcm9tQ29uZmlnKGZsYWdDb25maWcsIGVudmlyb25tZW50KTtcbiAgICAgIFxuICAgICAgLy8gT3ZlcnJpZGUgd2l0aCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpZiBhdmFpbGFibGVcbiAgICAgIGNvbnN0IGVudlZhbHVlID0gZW52RmxhZ3NbZmxhZ0NvbmZpZy5rZXkudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoZW52VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmbGFnLnZhbHVlID0gZW52VmFsdWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZsYWdNYXBbZmxhZ0NvbmZpZy5rZXldID0gZmxhZztcbiAgICB9KTtcblxuICAgIHJldHVybiBmbGFnTWFwO1xuICB9LCBbbWVyZ2VkQ29uZmlnLmZsYWdzLCByZW1vdGVGbGFncywgZW52aXJvbm1lbnRdKTtcblxuICAvLyBDb250ZXh0IHZhbHVlIGltcGxlbWVudGF0aW9uXG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCk6IEZlYXR1cmVGbGFnQ29udGV4dFZhbHVlID0+IHtcbiAgICBjb25zdCBnZXRGbGFnID0gPFQgZXh0ZW5kcyBGZWF0dXJlRmxhZ1ZhbHVlPihrZXk6IHN0cmluZyk6IEZlYXR1cmVGbGFnPFQ+IHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGNvbnN0IGZsYWcgPSBjb21iaW5lZEZsYWdzW2tleV07XG4gICAgICByZXR1cm4gZmxhZyBhcyBGZWF0dXJlRmxhZzxUPiB8IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNFbmFibGVkID0gKGtleTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBmbGFnID0gY29tYmluZWRGbGFnc1trZXldO1xuICAgICAgcmV0dXJuIGZsYWcgPyBmbGFnLmVuYWJsZWQgJiYgQm9vbGVhbihmbGFnLnZhbHVlKSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IDxUIGV4dGVuZHMgRmVhdHVyZUZsYWdWYWx1ZT4oa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IFQpOiBUID0+IHtcbiAgICAgIGNvbnN0IGZsYWcgPSBjb21iaW5lZEZsYWdzW2tleV07XG4gICAgICBpZiAoIWZsYWcgfHwgIWZsYWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIGFzIFQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhZy52YWx1ZSBhcyBUO1xuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVGbGFnID0gKGtleTogc3RyaW5nLCB2YWx1ZTogRmVhdHVyZUZsYWdWYWx1ZSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgZmxhZyA9IGNvbWJpbmVkRmxhZ3Nba2V5XTtcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgIGZsYWcudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZmxhZy5sYXN0VXBkYXRlZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVmcmVzaEZsYWdzID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgaWYgKGVuYWJsZVJlbW90ZUNvbmZpZykge1xuICAgICAgICBhd2FpdCByZWZldGNoUmVtb3RlRmxhZ3MoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZsYWdzOiBjb21iaW5lZEZsYWdzLFxuICAgICAgZ2V0RmxhZyxcbiAgICAgIGlzRW5hYmxlZCxcbiAgICAgIGdldFZhbHVlLFxuICAgICAgdXBkYXRlRmxhZyxcbiAgICAgIHJlZnJlc2hGbGFncyxcbiAgICAgIGlzTG9hZGluZzogaXNMb2FkaW5nUmVtb3RlLFxuICAgICAgZXJyb3I6IHJlbW90ZUVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyByZW1vdGVFcnJvciA6IG51bGwsXG4gICAgfTtcbiAgfSwgW2NvbWJpbmVkRmxhZ3MsIGlzTG9hZGluZ1JlbW90ZSwgcmVtb3RlRXJyb3IsIHJlZmV0Y2hSZW1vdGVGbGFncywgZW5hYmxlUmVtb3RlQ29uZmlnXSk7XG5cbiAgLy8gSGFuZGxlIGVycm9yc1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW1vdGVFcnJvciAmJiBvbkVycm9yKSB7XG4gICAgICBvbkVycm9yKHJlbW90ZUVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyByZW1vdGVFcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBmZWF0dXJlIGZsYWcgZXJyb3InKSk7XG4gICAgfVxuICB9LCBbcmVtb3RlRXJyb3IsIG9uRXJyb3JdKTtcblxuICByZXR1cm4gKFxuICAgIDxGZWF0dXJlRmxhZ0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9GZWF0dXJlRmxhZ0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG4vLyBNYWluIHByb3ZpZGVyIGNvbXBvbmVudCB3aXRoIGVycm9yIGJvdW5kYXJ5XG5leHBvcnQgY29uc3QgRmVhdHVyZUZsYWdQcm92aWRlcjogUmVhY3QuRkM8RmVhdHVyZUZsYWdQcm92aWRlclByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IG9uRXJyb3IsIGZhbGxiYWNrVG9EZWZhdWx0cyA9IHRydWUgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGhhbmRsZUVycm9yID0gdXNlQ2FsbGJhY2soKGVycm9yOiBFcnJvcikgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZlYXR1cmVGbGFnUHJvdmlkZXIgRXJyb3I6JywgZXJyb3IpO1xuICAgIG9uRXJyb3I/LihlcnJvcik7XG4gIH0sIFtvbkVycm9yXSk7XG5cbiAgLy8gRmFsbGJhY2sgY29tcG9uZW50IGZvciBlcnJvciBib3VuZGFyeVxuICBjb25zdCBFcnJvckZhbGxiYWNrID0gdXNlQ2FsbGJhY2soKHsgZXJyb3IsIHJlc2V0RXJyb3IgfTogeyBlcnJvcjogRXJyb3I7IHJlc2V0RXJyb3I6ICgpID0+IHZvaWQgfSkgPT4ge1xuICAgIGlmICghZmFsbGJhY2tUb0RlZmF1bHRzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZlYXR1cmUtZmxhZy1lcnJvclwiPlxuICAgICAgICAgIDxoMz5GZWF0dXJlIEZsYWcgRXJyb3I8L2gzPlxuICAgICAgICAgIDxwPntlcnJvci5tZXNzYWdlfTwvcD5cbiAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3Jlc2V0RXJyb3J9PlJldHJ5PC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgY2hpbGRyZW4gd2l0aCBkZWZhdWx0IGZsYWdzIG9ubHlcbiAgICByZXR1cm4gKFxuICAgICAgPEZlYXR1cmVGbGFnUHJvdmlkZXJDb250ZW50XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgZW5hYmxlUmVtb3RlQ29uZmlnPXtmYWxzZX1cbiAgICAgICAgY29uZmlnPXt7IC4uLnByb3BzLmNvbmZpZywgZW5hYmxlUmVtb3RlQ29uZmlnOiBmYWxzZSB9fVxuICAgICAgLz5cbiAgICApO1xuICB9LCBbZmFsbGJhY2tUb0RlZmF1bHRzLCBwcm9wc10pO1xuXG4gIHJldHVybiAoXG4gICAgPEVycm9yQm91bmRhcnkgb25FcnJvcj17aGFuZGxlRXJyb3J9IGZhbGxiYWNrPXtFcnJvckZhbGxiYWNrfT5cbiAgICAgIDxGZWF0dXJlRmxhZ1Byb3ZpZGVyQ29udGVudCB7Li4ucHJvcHN9IC8+XG4gICAgPC9FcnJvckJvdW5kYXJ5PlxuICApO1xufTtcblxuLy8gRXhwb3J0IHR5cGVzIGZvciBjb252ZW5pZW5jZVxuZXhwb3J0IHR5cGUgeyBGZWF0dXJlRmxhZ1Byb3ZpZGVyUHJvcHMgfTsiXSwibmFtZXMiOlsiRmVhdHVyZUZsYWdQcm92aWRlciIsIkRFRkFVTFRfQ09ORklHIiwiZmxhZ3MiLCJERUZBVUxUX1RSWU9OX0ZMQUdTIiwiREVGQVVMVF9JTUFHRV9QUk9DRVNTSU5HX0ZMQUdTIiwiREVGQVVMVF9VSV9GTEFHUyIsImVudmlyb25tZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZW5hYmxlUmVtb3RlQ29uZmlnIiwicmVmcmVzaEludGVydmFsIiwiZmFsbGJhY2tUb0RlZmF1bHRzIiwiY3JlYXRlRmVhdHVyZUZsYWdGcm9tQ29uZmlnIiwiY29uZmlnIiwiaXNFbmFibGVkRm9yRW52aXJvbm1lbnQiLCJpbmNsdWRlcyIsImtleSIsImRlc2NyaXB0aW9uIiwiY2F0ZWdvcnkiLCJkZWZhdWx0VmFsdWUiLCJ0eXBlIiwiZW5hYmxlZCIsInZhbHVlIiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmZXRjaFJlbW90ZUZsYWdzIiwidXJsIiwiRXJyb3IiLCJwYXJzZUVudmlyb25tZW50RmxhZ3MiLCJlbnZGbGFncyIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwic3RhcnRzV2l0aCIsInVuZGVmaW5lZCIsImZsYWdLZXkiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJpc05hTiIsIk51bWJlciIsIkZlYXR1cmVGbGFnUHJvdmlkZXJDb250ZW50IiwiY2hpbGRyZW4iLCJpbml0aWFsRmxhZ3MiLCJvbkVycm9yIiwibWVyZ2VkQ29uZmlnIiwidXNlTWVtbyIsImRhdGEiLCJyZW1vdGVGbGFncyIsImlzTG9hZGluZyIsImlzTG9hZGluZ1JlbW90ZSIsImVycm9yIiwicmVtb3RlRXJyb3IiLCJyZWZldGNoIiwicmVmZXRjaFJlbW90ZUZsYWdzIiwidXNlUXVlcnkiLCJxdWVyeUtleSIsIlFVRVJZX0tFWVMiLCJGRUFUVVJFX0ZMQUdTIiwicmVtb3RlQ29uZmlnVXJsIiwicXVlcnlGbiIsInN0YWxlVGltZSIsInJldHJ5IiwicmV0cnlEZWxheSIsImNvbWJpbmVkRmxhZ3MiLCJhbGxDb25maWdzIiwiZmxhZ01hcCIsImZsYWdDb25maWciLCJmbGFnIiwiZW52VmFsdWUiLCJjb250ZXh0VmFsdWUiLCJnZXRGbGFnIiwiaXNFbmFibGVkIiwiQm9vbGVhbiIsImdldFZhbHVlIiwidXBkYXRlRmxhZyIsInJlZnJlc2hGbGFncyIsIlJlYWN0IiwidXNlRWZmZWN0IiwiRmVhdHVyZUZsYWdDb250ZXh0IiwiUHJvdmlkZXIiLCJwcm9wcyIsImhhbmRsZUVycm9yIiwidXNlQ2FsbGJhY2siLCJjb25zb2xlIiwiRXJyb3JGYWxsYmFjayIsInJlc2V0RXJyb3IiLCJkaXYiLCJjbGFzc05hbWUiLCJoMyIsInAiLCJtZXNzYWdlIiwiYnV0dG9uIiwib25DbGljayIsIkVycm9yQm91bmRhcnkiLCJmYWxsYmFjayJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OytCQXlOYUE7OztlQUFBQTs7OzsrREF2TitCOzRCQUNuQjtvQ0FDVTsrQkFDTDtrQ0FjdkI7MkJBQ29COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZM0Isd0JBQXdCO0FBQ3hCLE1BQU1DLGlCQUE0QztJQUNoREMsT0FBTztXQUFJQyxxQ0FBbUI7V0FBS0MsZ0RBQThCO1dBQUtDLGtDQUFnQjtLQUFDO0lBQ3ZGQyxhQUFhLEFBQUNDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxJQUFvQjtJQUN0REMsb0JBQW9CO0lBQ3BCQyxpQkFBaUIsSUFBSSxLQUFLO0lBQzFCQyxvQkFBb0I7QUFDdEI7QUFFQSxzREFBc0Q7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