ce1a0a76b5a055e9fd54e44d7a3dd8ec
// Test Utilities for Optimistic Updates and Cache Management
// Common utilities and mocks for testing optimistic updates functionality
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assertOptimisticUpdateCompleted: function() {
        return assertOptimisticUpdateCompleted;
    },
    assertOptimisticUpdateCreated: function() {
        return assertOptimisticUpdateCreated;
    },
    assertOptimisticUpdateRolledBack: function() {
        return assertOptimisticUpdateRolledBack;
    },
    createMockFetchResponse: function() {
        return createMockFetchResponse;
    },
    createMockHistoryEntries: function() {
        return createMockHistoryEntries;
    },
    createQueryClientWrapper: function() {
        return createQueryClientWrapper;
    },
    createTestQueryClient: function() {
        return createTestQueryClient;
    },
    mockConsole: function() {
        return mockConsole;
    },
    mockTryonAPI: function() {
        return mockTryonAPI;
    },
    mockTryonContext: function() {
        return mockTryonContext;
    },
    mockTryonError: function() {
        return mockTryonError;
    },
    mockTryonResponse: function() {
        return mockTryonResponse;
    },
    mockTryonVariables: function() {
        return mockTryonVariables;
    },
    renderHookWithQueryClient: function() {
        return renderHookWithQueryClient;
    },
    wait: function() {
        return wait;
    },
    waitForPromises: function() {
        return waitForPromises;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _reactquery = require("@tanstack/react-query");
const _react1 = require("@testing-library/react");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function createTestQueryClient(options) {
    return new _reactquery.QueryClient({
        defaultOptions: {
            queries: {
                retry: false,
                gcTime: 0,
                staleTime: 0,
                ...options?.defaultOptions?.queries
            },
            mutations: {
                retry: false,
                ...options?.defaultOptions?.mutations
            }
        },
        logger: {
            log: ()=>{},
            warn: ()=>{},
            error: ()=>{}
        }
    });
}
function createQueryClientWrapper(queryClient) {
    const client = queryClient || createTestQueryClient();
    return ({ children })=>_react.default.createElement(_reactquery.QueryClientProvider, {
            client
        }, children);
}
function renderHookWithQueryClient(hook, queryClient) {
    const wrapper = createQueryClientWrapper(queryClient);
    return (0, _react1.renderHook)(hook, {
        wrapper
    });
}
const mockTryonVariables = {
    modelImage: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/mock-model-image',
    apparelImages: [
        'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/mock-apparel-1',
        'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/mock-apparel-2'
    ],
    options: {
        quality: 'high',
        timeout: 10000,
        enableOptimisticUpdates: true,
        metadata: {
            testMode: true,
            timestamp: '2024-01-15T10:30:00Z'
        },
        imageProcessing: {
            targetWidth: 1024,
            targetHeight: 1536,
            maxSizeKB: 1024,
            compressionQuality: 0.9,
            preserveAspectRatio: false
        }
    }
};
const mockTryonResponse = {
    img_generated: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/mock-generated-result',
    metadata: {
        processingTime: 5234,
        modelVersion: 'v2.1.0',
        appliedQuality: 'high',
        timestamp: '2024-01-15T10:30:05Z',
        processingInfo: {
            stepsCompleted: [
                'image-processing',
                'ai-generation',
                'post-processing'
            ],
            totalSteps: 3,
            gpuUsage: 0.85,
            memoryUsage: 0.67
        }
    }
};
const mockTryonContext = {
    variables: mockTryonVariables,
    startTime: Date.now() - 5234,
    retryCount: 0,
    optimisticId: 'test-optimistic-12345',
    imageProcessingResults: {
        modelImageResult: {
            originalSize: 2048576,
            processedSize: 1048576,
            compressionRatio: 0.5,
            processingTime: 123,
            processedImage: mockTryonVariables.modelImage,
            metadata: {
                originalDimensions: {
                    width: 1920,
                    height: 1080
                },
                processedDimensions: {
                    width: 1024,
                    height: 1536
                },
                format: 'jpeg',
                quality: 0.9
            }
        },
        apparelImageResults: [
            {
                originalSize: 1536000,
                processedSize: 768000,
                compressionRatio: 0.5,
                processingTime: 89,
                processedImage: mockTryonVariables.apparelImages[0],
                metadata: {
                    originalDimensions: {
                        width: 1200,
                        height: 800
                    },
                    processedDimensions: {
                        width: 1024,
                        height: 1536
                    },
                    format: 'jpeg',
                    quality: 0.9
                }
            }
        ],
        totalProcessingTime: 212
    }
};
const mockTryonError = {
    error: 'Processing failed: Invalid image format',
    details: 'The provided model image is not in a supported format. Please use JPEG, PNG, or WebP.',
    code: 'INVALID_IMAGE_FORMAT',
    status: 400,
    retryable: false,
    category: 'VALIDATION_ERROR',
    severity: 'HIGH',
    recoveryActions: [
        {
            type: 'USER_ACTION',
            description: 'Convert image to a supported format',
            actionData: {
                supportedFormats: [
                    'jpeg',
                    'png',
                    'webp'
                ]
            }
        }
    ]
};
function createMockFetchResponse(data, status = 200, ok = true) {
    return {
        ok,
        status,
        json: jest.fn().mockResolvedValue(data),
        text: jest.fn().mockResolvedValue(JSON.stringify(data)),
        headers: new Headers(),
        redirected: false,
        statusText: ok ? 'OK' : 'Error',
        type: 'basic',
        url: 'http://localhost:3000/api/tryon',
        body: null,
        bodyUsed: false,
        clone: jest.fn(),
        arrayBuffer: jest.fn(),
        blob: jest.fn(),
        formData: jest.fn()
    };
}
function mockTryonAPI(response, error, delay = 0) {
    const mockResponse = response || mockTryonResponse;
    const mockError = error;
    return jest.spyOn(global, 'fetch').mockImplementation((url)=>{
        const urlString = typeof url === 'string' ? url : url.toString();
        if (urlString.includes('/api/tryon')) {
            return new Promise((resolve, reject)=>{
                setTimeout(()=>{
                    if (mockError) {
                        // Handle basic Error objects by converting them to TryonMutationError format
                        let errorResponse;
                        if (mockError instanceof Error && !('status' in mockError)) {
                            // Convert basic Error to TryonMutationError format
                            errorResponse = {
                                error: 'An error occurred',
                                details: mockError.message,
                                code: 'UNKNOWN_ERROR',
                                status: 500,
                                retryable: false,
                                category: 'NETWORK_ERROR',
                                severity: 'MEDIUM',
                                recoveryActions: []
                            };
                        } else {
                            // Use the error as-is if it's already in TryonMutationError format
                            errorResponse = mockError;
                        }
                        resolve(createMockFetchResponse(errorResponse, errorResponse.status || 500, false));
                    } else {
                        resolve(createMockFetchResponse(mockResponse));
                    }
                }, delay);
            });
        }
        return Promise.reject(new Error(`Unmocked fetch call to ${urlString}`));
    });
}
function waitForPromises() {
    return new Promise((resolve)=>setTimeout(resolve, 0));
}
function wait(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
function createMockHistoryEntries(count = 5) {
    return Array.from({
        length: count
    }, (_, index)=>({
            id: `history-entry-${index}`,
            timestamp: new Date(Date.now() - index * 60000).toISOString(),
            generatedImage: `data:image/jpeg;base64,mock-generated-${index}`,
            modelImage: `data:image/jpeg;base64,mock-model-${index}`,
            apparelImages: [
                `data:image/jpeg;base64,mock-apparel-${index}`
            ],
            processingTime: 3000 + Math.random() * 2000,
            metadata: {
                modelVersion: 'v2.1.0',
                appliedQuality: 'high',
                processingConfig: {
                    imageProcessing: mockTryonVariables.options?.imageProcessing,
                    requestOptions: {
                        timeout: 10000,
                        quality: 'high'
                    }
                }
            },
            tags: index % 2 === 0 ? [
                'casual'
            ] : [
                'formal'
            ],
            notes: `Test entry ${index}`,
            isFavorite: index % 3 === 0
        }));
}
function assertOptimisticUpdateCreated(queryClient, optimisticId, config = {}) {
    const { expectHistory = true, expectProgress = true, expectResult = true } = config;
    if (expectHistory) {
        const historyData = queryClient.getQueryData([
            'tryon-history',
            'entries'
        ]);
        expect(historyData).toBeDefined();
        expect(historyData.entries).toContainEqual(expect.objectContaining({
            id: expect.stringContaining('optimistic_history'),
            tags: expect.arrayContaining([
                'processing',
                'optimistic'
            ])
        }));
    }
    if (expectProgress) {
        const progressData = queryClient.getQueryData([
            'tryon-progress',
            optimisticId
        ]);
        expect(progressData).toBeDefined();
        expect(progressData).toMatchObject({
            id: optimisticId,
            status: 'processing',
            progress: expect.any(Number),
            stage: expect.any(String)
        });
    }
    if (expectResult) {
        const resultData = queryClient.getQueryData([
            'tryon-result',
            optimisticId
        ]);
        expect(resultData).toBeDefined();
        expect(resultData).toMatchObject({
            id: optimisticId,
            status: 'pending',
            variables: expect.any(Object)
        });
    }
}
function assertOptimisticUpdateCompleted(queryClient, optimisticId, expectedResult) {
    // Check history was updated
    const historyData = queryClient.getQueryData([
        'tryon-history',
        'entries'
    ]);
    expect(historyData).toBeDefined();
    const entry = historyData.entries.find((e)=>!e.id.includes('optimistic_history'));
    expect(entry).toBeDefined();
    expect(entry.generatedImage).toBe(expectedResult.img_generated);
    expect(entry.tags).not.toContain('processing');
    expect(entry.tags).not.toContain('optimistic');
    // Check progress was completed
    const progressData = queryClient.getQueryData([
        'tryon-progress',
        optimisticId
    ]);
    expect(progressData).toMatchObject({
        id: optimisticId,
        status: 'completed',
        progress: 100,
        stage: 'completed'
    });
    // Check result was cached
    const resultData = queryClient.getQueryData([
        'tryon-result',
        optimisticId
    ]);
    expect(resultData).toMatchObject({
        id: optimisticId,
        status: 'completed',
        result: expectedResult
    });
}
function assertOptimisticUpdateRolledBack(queryClient, optimisticId, expectedError) {
    // Check history entry was removed
    const historyData = queryClient.getQueryData([
        'tryon-history',
        'entries'
    ]);
    expect(historyData).toBeDefined();
    const optimisticEntry = historyData.entries.find((e)=>e.id.includes('optimistic_history'));
    expect(optimisticEntry).toBeUndefined();
    // Check progress shows error state
    const progressData = queryClient.getQueryData([
        'tryon-progress',
        optimisticId
    ]);
    expect(progressData).toMatchObject({
        id: optimisticId,
        status: 'error',
        progress: 0,
        stage: 'error'
    });
    if (expectedError) {
        expect(progressData.error).toBe(expectedError);
    }
}
function mockConsole() {
    const originalConsole = {
        ...console
    };
    const consoleMocks = {
        log: jest.spyOn(console, 'log').mockImplementation(),
        warn: jest.spyOn(console, 'warn').mockImplementation(),
        error: jest.spyOn(console, 'error').mockImplementation(),
        info: jest.spyOn(console, 'info').mockImplementation()
    };
    return {
        mocks: consoleMocks,
        restore: ()=>{
            Object.assign(console, originalConsole);
        }
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL3Rlc3RzL3Rlc3RVdGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUZXN0IFV0aWxpdGllcyBmb3IgT3B0aW1pc3RpYyBVcGRhdGVzIGFuZCBDYWNoZSBNYW5hZ2VtZW50XG4vLyBDb21tb24gdXRpbGl0aWVzIGFuZCBtb2NrcyBmb3IgdGVzdGluZyBvcHRpbWlzdGljIHVwZGF0ZXMgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUXVlcnlDbGllbnQsIFF1ZXJ5Q2xpZW50UHJvdmlkZXIgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xuaW1wb3J0IHsgcmVuZGVySG9vayB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBcbiAgVHJ5b25NdXRhdGlvblZhcmlhYmxlcyxcbiAgVHJ5b25NdXRhdGlvblJlc3BvbnNlLFxuICBUcnlvbk11dGF0aW9uQ29udGV4dCxcbiAgVHJ5b25NdXRhdGlvbkVycm9yXG59IGZyb20gJy4uL3R5cGVzL3RyeW9uLnR5cGVzJztcblxuLyoqXG4gKiBDcmVhdGUgYSB0ZXN0IHF1ZXJ5IGNsaWVudCB3aXRoIGFwcHJvcHJpYXRlIHNldHRpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXN0UXVlcnlDbGllbnQob3B0aW9ucz86IHtcbiAgZGVmYXVsdE9wdGlvbnM/OiB7XG4gICAgcXVlcmllcz86IGFueTtcbiAgICBtdXRhdGlvbnM/OiBhbnk7XG4gIH07XG59KTogUXVlcnlDbGllbnQge1xuICByZXR1cm4gbmV3IFF1ZXJ5Q2xpZW50KHtcbiAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgcXVlcmllczoge1xuICAgICAgICByZXRyeTogZmFsc2UsXG4gICAgICAgIGdjVGltZTogMCxcbiAgICAgICAgc3RhbGVUaW1lOiAwLFxuICAgICAgICAuLi5vcHRpb25zPy5kZWZhdWx0T3B0aW9ucz8ucXVlcmllc1xuICAgICAgfSxcbiAgICAgIG11dGF0aW9uczoge1xuICAgICAgICByZXRyeTogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnM/LmRlZmF1bHRPcHRpb25zPy5tdXRhdGlvbnNcbiAgICAgIH1cbiAgICB9LFxuICAgIGxvZ2dlcjoge1xuICAgICAgbG9nOiAoKSA9PiB7fSxcbiAgICAgIHdhcm46ICgpID0+IHt9LFxuICAgICAgZXJyb3I6ICgpID0+IHt9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB3cmFwcGVyIGNvbXBvbmVudCB3aXRoIFF1ZXJ5Q2xpZW50IGZvciBob29rIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50KSB7XG4gIGNvbnN0IGNsaWVudCA9IHF1ZXJ5Q2xpZW50IHx8IGNyZWF0ZVRlc3RRdWVyeUNsaWVudCgpO1xuICBcbiAgcmV0dXJuICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiAoXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChRdWVyeUNsaWVudFByb3ZpZGVyLCB7IGNsaWVudCB9LCBjaGlsZHJlbilcbiAgKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgaG9vayB3aXRoIHF1ZXJ5IGNsaWVudCB3cmFwcGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJIb29rV2l0aFF1ZXJ5Q2xpZW50PFQ+KFxuICBob29rOiAoKSA9PiBULFxuICBxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50XG4pIHtcbiAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudCk7XG4gIHJldHVybiByZW5kZXJIb29rKGhvb2ssIHsgd3JhcHBlciB9KTtcbn1cblxuLyoqXG4gKiBNb2NrIHRyeS1vbiBtdXRhdGlvbiB2YXJpYWJsZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG1vY2tUcnlvblZhcmlhYmxlczogVHJ5b25NdXRhdGlvblZhcmlhYmxlcyA9IHtcbiAgbW9kZWxJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFEL21vY2stbW9kZWwtaW1hZ2UnLFxuICBhcHBhcmVsSW1hZ2VzOiBbXG4gICAgJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFEL21vY2stYXBwYXJlbC0xJyxcbiAgICAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvbW9jay1hcHBhcmVsLTInXG4gIF0sXG4gIG9wdGlvbnM6IHtcbiAgICBxdWFsaXR5OiAnaGlnaCcsXG4gICAgdGltZW91dDogMTAwMDAsXG4gICAgZW5hYmxlT3B0aW1pc3RpY1VwZGF0ZXM6IHRydWUsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHRlc3RNb2RlOiB0cnVlLFxuICAgICAgdGltZXN0YW1wOiAnMjAyNC0wMS0xNVQxMDozMDowMFonXG4gICAgfSxcbiAgICBpbWFnZVByb2Nlc3Npbmc6IHtcbiAgICAgIHRhcmdldFdpZHRoOiAxMDI0LFxuICAgICAgdGFyZ2V0SGVpZ2h0OiAxNTM2LFxuICAgICAgbWF4U2l6ZUtCOiAxMDI0LFxuICAgICAgY29tcHJlc3Npb25RdWFsaXR5OiAwLjksXG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBmYWxzZVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2NrIHRyeS1vbiBtdXRhdGlvbiByZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgbW9ja1RyeW9uUmVzcG9uc2U6IFRyeW9uTXV0YXRpb25SZXNwb25zZSA9IHtcbiAgaW1nX2dlbmVyYXRlZDogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFEL21vY2stZ2VuZXJhdGVkLXJlc3VsdCcsXG4gIG1ldGFkYXRhOiB7XG4gICAgcHJvY2Vzc2luZ1RpbWU6IDUyMzQsXG4gICAgbW9kZWxWZXJzaW9uOiAndjIuMS4wJyxcbiAgICBhcHBsaWVkUXVhbGl0eTogJ2hpZ2gnLFxuICAgIHRpbWVzdGFtcDogJzIwMjQtMDEtMTVUMTA6MzA6MDVaJyxcbiAgICBwcm9jZXNzaW5nSW5mbzoge1xuICAgICAgc3RlcHNDb21wbGV0ZWQ6IFsnaW1hZ2UtcHJvY2Vzc2luZycsICdhaS1nZW5lcmF0aW9uJywgJ3Bvc3QtcHJvY2Vzc2luZyddLFxuICAgICAgdG90YWxTdGVwczogMyxcbiAgICAgIGdwdVVzYWdlOiAwLjg1LFxuICAgICAgbWVtb3J5VXNhZ2U6IDAuNjdcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9jayB0cnktb24gbXV0YXRpb24gY29udGV4dFxuICovXG5leHBvcnQgY29uc3QgbW9ja1RyeW9uQ29udGV4dDogVHJ5b25NdXRhdGlvbkNvbnRleHQgPSB7XG4gIHZhcmlhYmxlczogbW9ja1RyeW9uVmFyaWFibGVzLFxuICBzdGFydFRpbWU6IERhdGUubm93KCkgLSA1MjM0LFxuICByZXRyeUNvdW50OiAwLFxuICBvcHRpbWlzdGljSWQ6ICd0ZXN0LW9wdGltaXN0aWMtMTIzNDUnLFxuICBpbWFnZVByb2Nlc3NpbmdSZXN1bHRzOiB7XG4gICAgbW9kZWxJbWFnZVJlc3VsdDoge1xuICAgICAgb3JpZ2luYWxTaXplOiAyMDQ4NTc2LCAvLyAyTUJcbiAgICAgIHByb2Nlc3NlZFNpemU6IDEwNDg1NzYsIC8vIDFNQlxuICAgICAgY29tcHJlc3Npb25SYXRpbzogMC41LFxuICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICAgIHByb2Nlc3NlZEltYWdlOiBtb2NrVHJ5b25WYXJpYWJsZXMubW9kZWxJbWFnZSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIG9yaWdpbmFsRGltZW5zaW9uczogeyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwIH0sXG4gICAgICAgIHByb2Nlc3NlZERpbWVuc2lvbnM6IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogMTUzNiB9LFxuICAgICAgICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgICAgcXVhbGl0eTogMC45XG4gICAgICB9XG4gICAgfSxcbiAgICBhcHBhcmVsSW1hZ2VSZXN1bHRzOiBbXG4gICAgICB7XG4gICAgICAgIG9yaWdpbmFsU2l6ZTogMTUzNjAwMCxcbiAgICAgICAgcHJvY2Vzc2VkU2l6ZTogNzY4MDAwLFxuICAgICAgICBjb21wcmVzc2lvblJhdGlvOiAwLjUsXG4gICAgICAgIHByb2Nlc3NpbmdUaW1lOiA4OSxcbiAgICAgICAgcHJvY2Vzc2VkSW1hZ2U6IG1vY2tUcnlvblZhcmlhYmxlcy5hcHBhcmVsSW1hZ2VzWzBdLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIG9yaWdpbmFsRGltZW5zaW9uczogeyB3aWR0aDogMTIwMCwgaGVpZ2h0OiA4MDAgfSxcbiAgICAgICAgICBwcm9jZXNzZWREaW1lbnNpb25zOiB7IHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDE1MzYgfSxcbiAgICAgICAgICBmb3JtYXQ6ICdqcGVnJyxcbiAgICAgICAgICBxdWFsaXR5OiAwLjlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0sXG4gICAgdG90YWxQcm9jZXNzaW5nVGltZTogMjEyXG4gIH1cbn07XG5cbi8qKlxuICogTW9jayB0cnktb24gbXV0YXRpb24gZXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IG1vY2tUcnlvbkVycm9yOiBUcnlvbk11dGF0aW9uRXJyb3IgPSB7XG4gIGVycm9yOiAnUHJvY2Vzc2luZyBmYWlsZWQ6IEludmFsaWQgaW1hZ2UgZm9ybWF0JyxcbiAgZGV0YWlsczogJ1RoZSBwcm92aWRlZCBtb2RlbCBpbWFnZSBpcyBub3QgaW4gYSBzdXBwb3J0ZWQgZm9ybWF0LiBQbGVhc2UgdXNlIEpQRUcsIFBORywgb3IgV2ViUC4nLFxuICBjb2RlOiAnSU5WQUxJRF9JTUFHRV9GT1JNQVQnLFxuICBzdGF0dXM6IDQwMCxcbiAgcmV0cnlhYmxlOiBmYWxzZSxcbiAgY2F0ZWdvcnk6ICdWQUxJREFUSU9OX0VSUk9SJyBhcyBhbnksXG4gIHNldmVyaXR5OiAnSElHSCcgYXMgYW55LFxuICByZWNvdmVyeUFjdGlvbnM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnVVNFUl9BQ1RJT04nIGFzIGFueSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29udmVydCBpbWFnZSB0byBhIHN1cHBvcnRlZCBmb3JtYXQnLFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBzdXBwb3J0ZWRGb3JtYXRzOiBbJ2pwZWcnLCAncG5nJywgJ3dlYnAnXVxuICAgICAgfVxuICAgIH1cbiAgXVxufTtcblxuLyoqXG4gKiBDcmVhdGUgbW9jayBmZXRjaCByZXNwb25zZSBmb3IgQVBJIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tGZXRjaFJlc3BvbnNlKFxuICBkYXRhOiBhbnksXG4gIHN0YXR1cyA9IDIwMCxcbiAgb2sgPSB0cnVlXG4pOiBSZXNwb25zZSB7XG4gIHJldHVybiB7XG4gICAgb2ssXG4gICAgc3RhdHVzLFxuICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShkYXRhKSxcbiAgICB0ZXh0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoSlNPTi5zdHJpbmdpZnkoZGF0YSkpLFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gICAgcmVkaXJlY3RlZDogZmFsc2UsXG4gICAgc3RhdHVzVGV4dDogb2sgPyAnT0snIDogJ0Vycm9yJyxcbiAgICB0eXBlOiAnYmFzaWMnLFxuICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvdHJ5b24nLFxuICAgIGJvZHk6IG51bGwsXG4gICAgYm9keVVzZWQ6IGZhbHNlLFxuICAgIGNsb25lOiBqZXN0LmZuKCksXG4gICAgYXJyYXlCdWZmZXI6IGplc3QuZm4oKSxcbiAgICBibG9iOiBqZXN0LmZuKCksXG4gICAgZm9ybURhdGE6IGplc3QuZm4oKVxuICB9IGFzIHVua25vd24gYXMgUmVzcG9uc2U7XG59XG5cbi8qKlxuICogTW9jayB0aGUgdHJ5LW9uIEFQSSBlbmRwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gbW9ja1RyeW9uQVBJKFxuICByZXNwb25zZT86IFRyeW9uTXV0YXRpb25SZXNwb25zZSxcbiAgZXJyb3I/OiBUcnlvbk11dGF0aW9uRXJyb3IgfCBFcnJvcixcbiAgZGVsYXkgPSAwXG4pOiBqZXN0LlNweUluc3RhbmNlIHtcbiAgY29uc3QgbW9ja1Jlc3BvbnNlID0gcmVzcG9uc2UgfHwgbW9ja1RyeW9uUmVzcG9uc2U7XG4gIGNvbnN0IG1vY2tFcnJvciA9IGVycm9yO1xuXG4gIHJldHVybiBqZXN0LnNweU9uKGdsb2JhbCwgJ2ZldGNoJykubW9ja0ltcGxlbWVudGF0aW9uKFxuICAgICh1cmw6IHN0cmluZyB8IFVSTCB8IFJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IHVybFN0cmluZyA9IHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnID8gdXJsIDogdXJsLnRvU3RyaW5nKCk7XG4gICAgICBcbiAgICAgIGlmICh1cmxTdHJpbmcuaW5jbHVkZXMoJy9hcGkvdHJ5b24nKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1vY2tFcnJvcikge1xuICAgICAgICAgICAgICAvLyBIYW5kbGUgYmFzaWMgRXJyb3Igb2JqZWN0cyBieSBjb252ZXJ0aW5nIHRoZW0gdG8gVHJ5b25NdXRhdGlvbkVycm9yIGZvcm1hdFxuICAgICAgICAgICAgICBsZXQgZXJyb3JSZXNwb25zZTtcbiAgICAgICAgICAgICAgaWYgKG1vY2tFcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoJ3N0YXR1cycgaW4gbW9ja0Vycm9yKSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYmFzaWMgRXJyb3IgdG8gVHJ5b25NdXRhdGlvbkVycm9yIGZvcm1hdFxuICAgICAgICAgICAgICAgIGVycm9yUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcjogJ0FuIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgICAgICAgIGRldGFpbHM6IG1vY2tFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgY29kZTogJ1VOS05PV05fRVJST1InLFxuICAgICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgICByZXRyeWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdORVRXT1JLX0VSUk9SJyBhcyBhbnksXG4gICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ01FRElVTScgYXMgYW55LFxuICAgICAgICAgICAgICAgICAgcmVjb3ZlcnlBY3Rpb25zOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBlcnJvciBhcy1pcyBpZiBpdCdzIGFscmVhZHkgaW4gVHJ5b25NdXRhdGlvbkVycm9yIGZvcm1hdFxuICAgICAgICAgICAgICAgIGVycm9yUmVzcG9uc2UgPSBtb2NrRXJyb3IgYXMgVHJ5b25NdXRhdGlvbkVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlTW9ja0ZldGNoUmVzcG9uc2UoZXJyb3JSZXNwb25zZSwgZXJyb3JSZXNwb25zZS5zdGF0dXMgfHwgNTAwLCBmYWxzZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVNb2NrRmV0Y2hSZXNwb25zZShtb2NrUmVzcG9uc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBVbm1vY2tlZCBmZXRjaCBjYWxsIHRvICR7dXJsU3RyaW5nfWApKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgYWxsIHBlbmRpbmcgcHJvbWlzZXMgdG8gcmVzb2x2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FpdEZvclByb21pc2VzKCk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcbn1cblxuLyoqXG4gKiBXYWl0IGZvciBhIHNwZWNpZmljIGFtb3VudCBvZiB0aW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YWl0KG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBtb2NrIGhpc3RvcnkgZW50cmllcyBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9ja0hpc3RvcnlFbnRyaWVzKGNvdW50ID0gNSkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogY291bnQgfSwgKF8sIGluZGV4KSA9PiAoe1xuICAgIGlkOiBgaGlzdG9yeS1lbnRyeS0ke2luZGV4fWAsXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gaW5kZXggKiA2MDAwMCkudG9JU09TdHJpbmcoKSxcbiAgICBnZW5lcmF0ZWRJbWFnZTogYGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsbW9jay1nZW5lcmF0ZWQtJHtpbmRleH1gLFxuICAgIG1vZGVsSW1hZ2U6IGBkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vY2stbW9kZWwtJHtpbmRleH1gLFxuICAgIGFwcGFyZWxJbWFnZXM6IFtgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrLWFwcGFyZWwtJHtpbmRleH1gXSxcbiAgICBwcm9jZXNzaW5nVGltZTogMzAwMCArIE1hdGgucmFuZG9tKCkgKiAyMDAwLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBtb2RlbFZlcnNpb246ICd2Mi4xLjAnLFxuICAgICAgYXBwbGllZFF1YWxpdHk6ICdoaWdoJyxcbiAgICAgIHByb2Nlc3NpbmdDb25maWc6IHtcbiAgICAgICAgaW1hZ2VQcm9jZXNzaW5nOiBtb2NrVHJ5b25WYXJpYWJsZXMub3B0aW9ucz8uaW1hZ2VQcm9jZXNzaW5nLFxuICAgICAgICByZXF1ZXN0T3B0aW9uczoge1xuICAgICAgICAgIHRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICAgIHF1YWxpdHk6ICdoaWdoJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWdzOiBpbmRleCAlIDIgPT09IDAgPyBbJ2Nhc3VhbCddIDogWydmb3JtYWwnXSxcbiAgICBub3RlczogYFRlc3QgZW50cnkgJHtpbmRleH1gLFxuICAgIGlzRmF2b3JpdGU6IGluZGV4ICUgMyA9PT0gMFxuICB9KSk7XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgb3B0aW1pc3RpYyB1cGRhdGUgd2FzIGNyZWF0ZWQgY29ycmVjdGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPcHRpbWlzdGljVXBkYXRlQ3JlYXRlZChcbiAgcXVlcnlDbGllbnQ6IFF1ZXJ5Q2xpZW50LFxuICBvcHRpbWlzdGljSWQ6IHN0cmluZyxcbiAgY29uZmlnOiB7XG4gICAgZXhwZWN0SGlzdG9yeT86IGJvb2xlYW47XG4gICAgZXhwZWN0UHJvZ3Jlc3M/OiBib29sZWFuO1xuICAgIGV4cGVjdFJlc3VsdD86IGJvb2xlYW47XG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHsgZXhwZWN0SGlzdG9yeSA9IHRydWUsIGV4cGVjdFByb2dyZXNzID0gdHJ1ZSwgZXhwZWN0UmVzdWx0ID0gdHJ1ZSB9ID0gY29uZmlnO1xuXG4gIGlmIChleHBlY3RIaXN0b3J5KSB7XG4gICAgY29uc3QgaGlzdG9yeURhdGEgPSBxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEoWyd0cnlvbi1oaXN0b3J5JywgJ2VudHJpZXMnXSk7XG4gICAgZXhwZWN0KGhpc3RvcnlEYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgIGV4cGVjdCgoaGlzdG9yeURhdGEgYXMgYW55KS5lbnRyaWVzKS50b0NvbnRhaW5FcXVhbChcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgaWQ6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdvcHRpbWlzdGljX2hpc3RvcnknKSxcbiAgICAgICAgdGFnczogZXhwZWN0LmFycmF5Q29udGFpbmluZyhbJ3Byb2Nlc3NpbmcnLCAnb3B0aW1pc3RpYyddKVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgaWYgKGV4cGVjdFByb2dyZXNzKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NEYXRhID0gcXVlcnlDbGllbnQuZ2V0UXVlcnlEYXRhKFsndHJ5b24tcHJvZ3Jlc3MnLCBvcHRpbWlzdGljSWRdKTtcbiAgICBleHBlY3QocHJvZ3Jlc3NEYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgIGV4cGVjdChwcm9ncmVzc0RhdGEpLnRvTWF0Y2hPYmplY3Qoe1xuICAgICAgaWQ6IG9wdGltaXN0aWNJZCxcbiAgICAgIHN0YXR1czogJ3Byb2Nlc3NpbmcnLFxuICAgICAgcHJvZ3Jlc3M6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgIHN0YWdlOiBleHBlY3QuYW55KFN0cmluZylcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChleHBlY3RSZXN1bHQpIHtcbiAgICBjb25zdCByZXN1bHREYXRhID0gcXVlcnlDbGllbnQuZ2V0UXVlcnlEYXRhKFsndHJ5b24tcmVzdWx0Jywgb3B0aW1pc3RpY0lkXSk7XG4gICAgZXhwZWN0KHJlc3VsdERhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHJlc3VsdERhdGEpLnRvTWF0Y2hPYmplY3Qoe1xuICAgICAgaWQ6IG9wdGltaXN0aWNJZCxcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgdmFyaWFibGVzOiBleHBlY3QuYW55KE9iamVjdClcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IG9wdGltaXN0aWMgdXBkYXRlIHdhcyBjb21wbGV0ZWQgY29ycmVjdGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPcHRpbWlzdGljVXBkYXRlQ29tcGxldGVkKFxuICBxdWVyeUNsaWVudDogUXVlcnlDbGllbnQsXG4gIG9wdGltaXN0aWNJZDogc3RyaW5nLFxuICBleHBlY3RlZFJlc3VsdDogVHJ5b25NdXRhdGlvblJlc3BvbnNlXG4pIHtcbiAgLy8gQ2hlY2sgaGlzdG9yeSB3YXMgdXBkYXRlZFxuICBjb25zdCBoaXN0b3J5RGF0YSA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShbJ3RyeW9uLWhpc3RvcnknLCAnZW50cmllcyddKTtcbiAgZXhwZWN0KGhpc3RvcnlEYXRhKS50b0JlRGVmaW5lZCgpO1xuICBjb25zdCBlbnRyeSA9IChoaXN0b3J5RGF0YSBhcyBhbnkpLmVudHJpZXMuZmluZCgoZTogYW55KSA9PiBcbiAgICAhZS5pZC5pbmNsdWRlcygnb3B0aW1pc3RpY19oaXN0b3J5JylcbiAgKTtcbiAgZXhwZWN0KGVudHJ5KS50b0JlRGVmaW5lZCgpO1xuICBleHBlY3QoZW50cnkuZ2VuZXJhdGVkSW1hZ2UpLnRvQmUoZXhwZWN0ZWRSZXN1bHQuaW1nX2dlbmVyYXRlZCk7XG4gIGV4cGVjdChlbnRyeS50YWdzKS5ub3QudG9Db250YWluKCdwcm9jZXNzaW5nJyk7XG4gIGV4cGVjdChlbnRyeS50YWdzKS5ub3QudG9Db250YWluKCdvcHRpbWlzdGljJyk7XG5cbiAgLy8gQ2hlY2sgcHJvZ3Jlc3Mgd2FzIGNvbXBsZXRlZFxuICBjb25zdCBwcm9ncmVzc0RhdGEgPSBxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEoWyd0cnlvbi1wcm9ncmVzcycsIG9wdGltaXN0aWNJZF0pO1xuICBleHBlY3QocHJvZ3Jlc3NEYXRhKS50b01hdGNoT2JqZWN0KHtcbiAgICBpZDogb3B0aW1pc3RpY0lkLFxuICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICBzdGFnZTogJ2NvbXBsZXRlZCdcbiAgfSk7XG5cbiAgLy8gQ2hlY2sgcmVzdWx0IHdhcyBjYWNoZWRcbiAgY29uc3QgcmVzdWx0RGF0YSA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShbJ3RyeW9uLXJlc3VsdCcsIG9wdGltaXN0aWNJZF0pO1xuICBleHBlY3QocmVzdWx0RGF0YSkudG9NYXRjaE9iamVjdCh7XG4gICAgaWQ6IG9wdGltaXN0aWNJZCxcbiAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgIHJlc3VsdDogZXhwZWN0ZWRSZXN1bHRcbiAgfSk7XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgb3B0aW1pc3RpYyB1cGRhdGUgd2FzIHJvbGxlZCBiYWNrIGNvcnJlY3RseVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T3B0aW1pc3RpY1VwZGF0ZVJvbGxlZEJhY2soXG4gIHF1ZXJ5Q2xpZW50OiBRdWVyeUNsaWVudCxcbiAgb3B0aW1pc3RpY0lkOiBzdHJpbmcsXG4gIGV4cGVjdGVkRXJyb3I/OiBzdHJpbmdcbikge1xuICAvLyBDaGVjayBoaXN0b3J5IGVudHJ5IHdhcyByZW1vdmVkXG4gIGNvbnN0IGhpc3RvcnlEYXRhID0gcXVlcnlDbGllbnQuZ2V0UXVlcnlEYXRhKFsndHJ5b24taGlzdG9yeScsICdlbnRyaWVzJ10pO1xuICBleHBlY3QoaGlzdG9yeURhdGEpLnRvQmVEZWZpbmVkKCk7XG4gIGNvbnN0IG9wdGltaXN0aWNFbnRyeSA9IChoaXN0b3J5RGF0YSBhcyBhbnkpLmVudHJpZXMuZmluZCgoZTogYW55KSA9PiBcbiAgICBlLmlkLmluY2x1ZGVzKCdvcHRpbWlzdGljX2hpc3RvcnknKVxuICApO1xuICBleHBlY3Qob3B0aW1pc3RpY0VudHJ5KS50b0JlVW5kZWZpbmVkKCk7XG5cbiAgLy8gQ2hlY2sgcHJvZ3Jlc3Mgc2hvd3MgZXJyb3Igc3RhdGVcbiAgY29uc3QgcHJvZ3Jlc3NEYXRhID0gcXVlcnlDbGllbnQuZ2V0UXVlcnlEYXRhKFsndHJ5b24tcHJvZ3Jlc3MnLCBvcHRpbWlzdGljSWRdKTtcbiAgZXhwZWN0KHByb2dyZXNzRGF0YSkudG9NYXRjaE9iamVjdCh7XG4gICAgaWQ6IG9wdGltaXN0aWNJZCxcbiAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgcHJvZ3Jlc3M6IDAsXG4gICAgc3RhZ2U6ICdlcnJvcidcbiAgfSk7XG5cbiAgaWYgKGV4cGVjdGVkRXJyb3IpIHtcbiAgICBleHBlY3QoKHByb2dyZXNzRGF0YSBhcyBhbnkpLmVycm9yKS50b0JlKGV4cGVjdGVkRXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogTW9jayBjb25zb2xlIG1ldGhvZHMgdG8gYXZvaWQgdGVzdCBvdXRwdXQgcG9sbHV0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2NrQ29uc29sZSgpIHtcbiAgY29uc3Qgb3JpZ2luYWxDb25zb2xlID0geyAuLi5jb25zb2xlIH07XG4gIFxuICBjb25zdCBjb25zb2xlTW9ja3MgPSB7XG4gICAgbG9nOiBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKSxcbiAgICB3YXJuOiBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCksXG4gICAgZXJyb3I6IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCksXG4gICAgaW5mbzogamVzdC5zcHlPbihjb25zb2xlLCAnaW5mbycpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtb2NrczogY29uc29sZU1vY2tzLFxuICAgIHJlc3RvcmU6ICgpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY29uc29sZSwgb3JpZ2luYWxDb25zb2xlKTtcbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbImFzc2VydE9wdGltaXN0aWNVcGRhdGVDb21wbGV0ZWQiLCJhc3NlcnRPcHRpbWlzdGljVXBkYXRlQ3JlYXRlZCIsImFzc2VydE9wdGltaXN0aWNVcGRhdGVSb2xsZWRCYWNrIiwiY3JlYXRlTW9ja0ZldGNoUmVzcG9uc2UiLCJjcmVhdGVNb2NrSGlzdG9yeUVudHJpZXMiLCJjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIiLCJjcmVhdGVUZXN0UXVlcnlDbGllbnQiLCJtb2NrQ29uc29sZSIsIm1vY2tUcnlvbkFQSSIsIm1vY2tUcnlvbkNvbnRleHQiLCJtb2NrVHJ5b25FcnJvciIsIm1vY2tUcnlvblJlc3BvbnNlIiwibW9ja1RyeW9uVmFyaWFibGVzIiwicmVuZGVySG9va1dpdGhRdWVyeUNsaWVudCIsIndhaXQiLCJ3YWl0Rm9yUHJvbWlzZXMiLCJvcHRpb25zIiwiUXVlcnlDbGllbnQiLCJkZWZhdWx0T3B0aW9ucyIsInF1ZXJpZXMiLCJyZXRyeSIsImdjVGltZSIsInN0YWxlVGltZSIsIm11dGF0aW9ucyIsImxvZ2dlciIsImxvZyIsIndhcm4iLCJlcnJvciIsInF1ZXJ5Q2xpZW50IiwiY2xpZW50IiwiY2hpbGRyZW4iLCJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJRdWVyeUNsaWVudFByb3ZpZGVyIiwiaG9vayIsIndyYXBwZXIiLCJyZW5kZXJIb29rIiwibW9kZWxJbWFnZSIsImFwcGFyZWxJbWFnZXMiLCJxdWFsaXR5IiwidGltZW91dCIsImVuYWJsZU9wdGltaXN0aWNVcGRhdGVzIiwibWV0YWRhdGEiLCJ0ZXN0TW9kZSIsInRpbWVzdGFtcCIsImltYWdlUHJvY2Vzc2luZyIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwibWF4U2l6ZUtCIiwiY29tcHJlc3Npb25RdWFsaXR5IiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImltZ19nZW5lcmF0ZWQiLCJwcm9jZXNzaW5nVGltZSIsIm1vZGVsVmVyc2lvbiIsImFwcGxpZWRRdWFsaXR5IiwicHJvY2Vzc2luZ0luZm8iLCJzdGVwc0NvbXBsZXRlZCIsInRvdGFsU3RlcHMiLCJncHVVc2FnZSIsIm1lbW9yeVVzYWdlIiwidmFyaWFibGVzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJldHJ5Q291bnQiLCJvcHRpbWlzdGljSWQiLCJpbWFnZVByb2Nlc3NpbmdSZXN1bHRzIiwibW9kZWxJbWFnZVJlc3VsdCIsIm9yaWdpbmFsU2l6ZSIsInByb2Nlc3NlZFNpemUiLCJjb21wcmVzc2lvblJhdGlvIiwicHJvY2Vzc2VkSW1hZ2UiLCJvcmlnaW5hbERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInByb2Nlc3NlZERpbWVuc2lvbnMiLCJmb3JtYXQiLCJhcHBhcmVsSW1hZ2VSZXN1bHRzIiwidG90YWxQcm9jZXNzaW5nVGltZSIsImRldGFpbHMiLCJjb2RlIiwic3RhdHVzIiwicmV0cnlhYmxlIiwiY2F0ZWdvcnkiLCJzZXZlcml0eSIsInJlY292ZXJ5QWN0aW9ucyIsInR5cGUiLCJkZXNjcmlwdGlvbiIsImFjdGlvbkRhdGEiLCJzdXBwb3J0ZWRGb3JtYXRzIiwiZGF0YSIsIm9rIiwianNvbiIsImplc3QiLCJmbiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidGV4dCIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwiSGVhZGVycyIsInJlZGlyZWN0ZWQiLCJzdGF0dXNUZXh0IiwidXJsIiwiYm9keSIsImJvZHlVc2VkIiwiY2xvbmUiLCJhcnJheUJ1ZmZlciIsImJsb2IiLCJmb3JtRGF0YSIsInJlc3BvbnNlIiwiZGVsYXkiLCJtb2NrUmVzcG9uc2UiLCJtb2NrRXJyb3IiLCJzcHlPbiIsImdsb2JhbCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInVybFN0cmluZyIsInRvU3RyaW5nIiwiaW5jbHVkZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNldFRpbWVvdXQiLCJlcnJvclJlc3BvbnNlIiwiRXJyb3IiLCJtZXNzYWdlIiwibXMiLCJjb3VudCIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpbmRleCIsImlkIiwidG9JU09TdHJpbmciLCJnZW5lcmF0ZWRJbWFnZSIsIk1hdGgiLCJyYW5kb20iLCJwcm9jZXNzaW5nQ29uZmlnIiwicmVxdWVzdE9wdGlvbnMiLCJ0YWdzIiwibm90ZXMiLCJpc0Zhdm9yaXRlIiwiY29uZmlnIiwiZXhwZWN0SGlzdG9yeSIsImV4cGVjdFByb2dyZXNzIiwiZXhwZWN0UmVzdWx0IiwiaGlzdG9yeURhdGEiLCJnZXRRdWVyeURhdGEiLCJleHBlY3QiLCJ0b0JlRGVmaW5lZCIsImVudHJpZXMiLCJ0b0NvbnRhaW5FcXVhbCIsIm9iamVjdENvbnRhaW5pbmciLCJzdHJpbmdDb250YWluaW5nIiwiYXJyYXlDb250YWluaW5nIiwicHJvZ3Jlc3NEYXRhIiwidG9NYXRjaE9iamVjdCIsInByb2dyZXNzIiwiYW55IiwiTnVtYmVyIiwic3RhZ2UiLCJTdHJpbmciLCJyZXN1bHREYXRhIiwiT2JqZWN0IiwiZXhwZWN0ZWRSZXN1bHQiLCJlbnRyeSIsImZpbmQiLCJlIiwidG9CZSIsIm5vdCIsInRvQ29udGFpbiIsInJlc3VsdCIsImV4cGVjdGVkRXJyb3IiLCJvcHRpbWlzdGljRW50cnkiLCJ0b0JlVW5kZWZpbmVkIiwib3JpZ2luYWxDb25zb2xlIiwiY29uc29sZSIsImNvbnNvbGVNb2NrcyIsImluZm8iLCJtb2NrcyIsInJlc3RvcmUiLCJhc3NpZ24iXSwibWFwcGluZ3MiOiJBQUFBLDZEQUE2RDtBQUM3RCwwRUFBMEU7Ozs7Ozs7Ozs7OztJQXNWMURBLCtCQUErQjtlQUEvQkE7O0lBL0NBQyw2QkFBNkI7ZUFBN0JBOztJQW9GQUMsZ0NBQWdDO2VBQWhDQTs7SUEzTUFDLHVCQUF1QjtlQUF2QkE7O0lBMkZBQyx3QkFBd0I7ZUFBeEJBOztJQTlOQUMsd0JBQXdCO2VBQXhCQTs7SUE5QkFDLHFCQUFxQjtlQUFyQkE7O0lBMFlBQyxXQUFXO2VBQVhBOztJQTlNQUMsWUFBWTtlQUFaQTs7SUExRkhDLGdCQUFnQjtlQUFoQkE7O0lBeUNBQyxjQUFjO2VBQWRBOztJQTVEQUMsaUJBQWlCO2VBQWpCQTs7SUEzQkFDLGtCQUFrQjtlQUFs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