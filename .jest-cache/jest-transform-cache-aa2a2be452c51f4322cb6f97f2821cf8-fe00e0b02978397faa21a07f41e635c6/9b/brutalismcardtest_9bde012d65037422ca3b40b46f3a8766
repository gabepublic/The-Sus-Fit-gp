0ab9979d3b09359e70d4fee03bdc33dd
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _brutalismcard = require("../../../src/components/ui/brutalism-card");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock console.error to capture validation messages
const originalError = console.error;
beforeAll(()=>{
    console.error = jest.fn();
});
afterAll(()=>{
    console.error = originalError;
});
describe('BrutalismCard File Validation', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    it('validates file types - rejects non-image files', async ()=>{
        const mockTextFile = new File([
            'test'
        ], 'test.txt', {
            type: 'text/plain'
        });
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        // Find the hidden file input
        const fileInput = _react1.screen.getByRole('button');
        const input = document.querySelector('input[type="file"]');
        // Simulate file selection by setting the files property and triggering change event
        Object.defineProperty(input, 'files', {
            value: [
                mockTextFile
            ],
            writable: true
        });
        // Trigger the change event
        _react1.fireEvent.change(input);
        // Verify console.error was called with the correct message
        expect(console.error).toHaveBeenCalledWith('Selected file is not an image');
    });
    it('validates file size - rejects files larger than 5MB', async ()=>{
        const mockLargeFile = new File([
            'x'.repeat(6 * 1024 * 1024)
        ], 'large.jpg', {
            type: 'image/jpeg'
        });
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        // Find the hidden file input
        const input = document.querySelector('input[type="file"]');
        // Simulate file selection
        Object.defineProperty(input, 'files', {
            value: [
                mockLargeFile
            ],
            writable: true
        });
        // Trigger the change event
        _react1.fireEvent.change(input);
        // Verify console.error was called with the correct message
        expect(console.error).toHaveBeenCalledWith('Image file is too large (max 5MB)');
    });
    it('accepts valid image files', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        const onFileUpload = jest.fn();
        const onImageUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onFileUpload: onFileUpload,
            onImageUpload: onImageUpload
        }));
        // Find the hidden file input
        const input = document.querySelector('input[type="file"]');
        // Simulate file selection
        Object.defineProperty(input, 'files', {
            value: [
                mockValidFile
            ],
            writable: true
        });
        // Trigger the change event
        _react1.fireEvent.change(input);
        // Verify no error was logged
        expect(console.error).not.toHaveBeenCalled();
        // Verify callbacks were called (need to wait for FileReader)
        await new Promise((resolve)=>setTimeout(resolve, 100));
        expect(onFileUpload).toHaveBeenCalledWith(mockValidFile);
    });
    it('handles drag and drop with invalid file type', async ()=>{
        const mockTextFile = new File([
            'test'
        ], 'test.txt', {
            type: 'text/plain'
        });
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        // Simulate drag and drop with invalid file
        _react1.fireEvent.drop(dropZone, {
            dataTransfer: {
                files: [
                    mockTextFile
                ]
            }
        });
        // Verify no error was logged (drag and drop doesn't trigger validation for non-images)
        expect(console.error).not.toHaveBeenCalled();
    });
    it('handles drag and drop with large file', async ()=>{
        const mockLargeFile = new File([
            'x'.repeat(6 * 1024 * 1024)
        ], 'large.jpg', {
            type: 'image/jpeg'
        });
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        // Simulate drag and drop with large file
        _react1.fireEvent.drop(dropZone, {
            dataTransfer: {
                files: [
                    mockLargeFile
                ]
            }
        });
        // Verify error was logged
        expect(console.error).toHaveBeenCalledWith('Image file is too large (max 5MB)');
    });
    it('handles drag and drop with valid file', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        const onFileUpload = jest.fn();
        const onImageUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onFileUpload: onFileUpload,
            onImageUpload: onImageUpload
        }));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        // Simulate drag and drop with valid file
        _react1.fireEvent.drop(dropZone, {
            dataTransfer: {
                files: [
                    mockValidFile
                ]
            }
        });
        // Verify no error was logged
        expect(console.error).not.toHaveBeenCalled();
        // Verify callbacks were called (need to wait for FileReader)
        await new Promise((resolve)=>setTimeout(resolve, 100));
        expect(onFileUpload).toHaveBeenCalledWith(mockValidFile);
    });
});
describe('BrutalismCard Drag and Drop Event Handlers', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    it('handles drag over event correctly', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        // Simulate drag over event
        _react1.fireEvent.dragOver(dropZone);
        // The component should now be in dragging state
        // We verify the event handler was called by checking the element is still present
        expect(dropZone).toBeInTheDocument();
    });
    it('handles drag leave event correctly', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        // First trigger drag over to set dragging state
        _react1.fireEvent.dragOver(dropZone);
        // Then trigger drag leave
        _react1.fireEvent.dragLeave(dropZone);
        // The component should no longer be in dragging state
        // Note: The visual state change might be immediate, so we test the event handler was called
        expect(dropZone).toBeInTheDocument();
    });
    it('handles drag over and drag leave sequence', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        // Simulate drag over
        _react1.fireEvent.dragOver(dropZone);
        // Simulate drag leave
        _react1.fireEvent.dragLeave(dropZone);
        // Verify the drop zone is still present
        expect(dropZone).toBeInTheDocument();
    });
    it('prevents default on drag over event', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        const mockEvent = {
            preventDefault: jest.fn()
        };
        // Simulate drag over with mock event
        _react1.fireEvent.dragOver(dropZone, mockEvent);
        // The preventDefault should be called in the handler
        // Note: fireEvent.dragOver doesn't actually call preventDefault, but the handler does
        expect(dropZone).toBeInTheDocument();
    });
    it('prevents default on drop event', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        const mockEvent = {
            preventDefault: jest.fn(),
            dataTransfer: {
                files: []
            }
        };
        // Simulate drop with mock event
        _react1.fireEvent.drop(dropZone, mockEvent);
        // The preventDefault should be called in the handler
        expect(dropZone).toBeInTheDocument();
    });
});
describe('BrutalismCard Component Props and Rendering', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    it('renders with default props', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        expect(_react1.screen.getByText('Upload Your Angle')).toBeInTheDocument();
        expect(_react1.screen.getByRole('button')).toBeInTheDocument();
    });
    it('renders with custom title', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            title: "Custom Upload Title"
        }));
        expect(_react1.screen.getByText('Custom Upload Title')).toBeInTheDocument();
    });
    it('renders with custom className', ()=>{
        const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            className: "custom-class"
        }));
        const mainDiv = container.firstChild;
        expect(mainDiv).toHaveClass('custom-class');
    });
    it('renders with children content', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "child-content",
                children: "Child content"
            })
        }));
        expect(_react1.screen.getByTestId('child-content')).toBeInTheDocument();
        expect(_react1.screen.getByText('Child content')).toBeInTheDocument();
    });
    it('renders with right button position', ()=>{
        const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            buttonPosition: "right"
        }));
        // The button should be positioned on the right
        const buttonContainer = container.querySelector('[class*="-right-14"]');
        expect(buttonContainer).toBeInTheDocument();
    });
    it('renders with custom background image', ()=>{
        const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            backgroundImage: "/custom-image.jpg"
        }));
        const cardElement = container.querySelector('[style*="background-image"]');
        expect(cardElement).toHaveStyle({
            backgroundImage: "url('/custom-image.jpg')"
        });
    });
    it('renders with custom shadow rotation', ()=>{
        const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            shadowRotation: "rotate-45"
        }));
        const shadowElement = container.querySelector('[class*="rotate-45"]');
        expect(shadowElement).toBeInTheDocument();
    });
    it('renders upload icon when no image is uploaded', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        // The upload icon should be present (SVG element)
        const uploadIcon = document.querySelector('svg');
        expect(uploadIcon).toBeInTheDocument();
    });
    it('does not render upload icon when image is uploaded', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const input = document.querySelector('input[type="file"]');
        // Simulate file selection
        Object.defineProperty(input, 'files', {
            value: [
                mockValidFile
            ],
            writable: true
        });
        // Trigger the change event
        _react1.fireEvent.change(input);
        // Wait for the image to be processed
        await (0, _react1.waitFor)(()=>{
            const uploadIcon = document.querySelector('svg');
            expect(uploadIcon).not.toBeInTheDocument();
        });
    });
});
describe('BrutalismCard File Upload Callbacks', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    it('calls onFileUpload callback when valid file is selected', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        const onFileUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onFileUpload: onFileUpload
        }));
        const input = document.querySelector('input[type="file"]');
        Object.defineProperty(input, 'files', {
            value: [
                mockValidFile
            ],
            writable: true
        });
        _react1.fireEvent.change(input);
        await (0, _react1.waitFor)(()=>{
            expect(onFileUpload).toHaveBeenCalledWith(mockValidFile);
        });
    });
    it('calls onImageUpload callback when valid file is selected', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        const onImageUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onImageUpload: onImageUpload
        }));
        const input = document.querySelector('input[type="file"]');
        Object.defineProperty(input, 'files', {
            value: [
                mockValidFile
            ],
            writable: true
        });
        _react1.fireEvent.change(input);
        await (0, _react1.waitFor)(()=>{
            expect(onImageUpload).toHaveBeenCalled();
        });
    });
    it('calls onFileUpload callback when valid file is dropped', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        const onFileUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onFileUpload: onFileUpload
        }));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        _react1.fireEvent.drop(dropZone, {
            dataTransfer: {
                files: [
                    mockValidFile
                ]
            }
        });
        await (0, _react1.waitFor)(()=>{
            expect(onFileUpload).toHaveBeenCalledWith(mockValidFile);
        });
    });
    it('calls onImageUpload callback when valid file is dropped', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        const onImageUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onImageUpload: onImageUpload
        }));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        _react1.fireEvent.drop(dropZone, {
            dataTransfer: {
                files: [
                    mockValidFile
                ]
            }
        });
        await (0, _react1.waitFor)(()=>{
            expect(onImageUpload).toHaveBeenCalled();
        });
    });
    it('does not call callbacks when no file is selected', ()=>{
        const onFileUpload = jest.fn();
        const onImageUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onFileUpload: onFileUpload,
            onImageUpload: onImageUpload
        }));
        expect(onFileUpload).not.toHaveBeenCalled();
        expect(onImageUpload).not.toHaveBeenCalled();
    });
    it('does not call callbacks when invalid file is selected', ()=>{
        const mockInvalidFile = new File([
            'test'
        ], 'test.txt', {
            type: 'text/plain'
        });
        const onFileUpload = jest.fn();
        const onImageUpload = jest.fn();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onFileUpload: onFileUpload,
            onImageUpload: onImageUpload
        }));
        const input = document.querySelector('input[type="file"]');
        Object.defineProperty(input, 'files', {
            value: [
                mockInvalidFile
            ],
            writable: true
        });
        _react1.fireEvent.change(input);
        expect(onFileUpload).not.toHaveBeenCalled();
        expect(onImageUpload).not.toHaveBeenCalled();
    });
});
describe('BrutalismCard Edge Cases', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    it('handles empty file input', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const input = document.querySelector('input[type="file"]');
        // Simulate empty file selection
        Object.defineProperty(input, 'files', {
            value: [],
            writable: true
        });
        _react1.fireEvent.change(input);
        // Should not throw any errors
        expect(console.error).not.toHaveBeenCalled();
    });
    it('handles null file input', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const input = document.querySelector('input[type="file"]');
        // Simulate null file selection
        Object.defineProperty(input, 'files', {
            value: null,
            writable: true
        });
        _react1.fireEvent.change(input);
        // Should not throw any errors
        expect(console.error).not.toHaveBeenCalled();
    });
    it('handles drop with no files', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        _react1.fireEvent.drop(dropZone, {
            dataTransfer: {
                files: []
            }
        });
        // Should not throw any errors
        expect(console.error).not.toHaveBeenCalled();
    });
    it('handles drop with null files', ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {}));
        const dropZone = _react1.screen.getByText('Upload Your Angle').closest('div');
        _react1.fireEvent.drop(dropZone, {
            dataTransfer: {
                files: null
            }
        });
        // Should not throw any errors
        expect(console.error).not.toHaveBeenCalled();
    });
    it('handles FileReader error gracefully', async ()=>{
        const mockValidFile = new File([
            'test'
        ], 'test.jpg', {
            type: 'image/jpeg'
        });
        const onImageUpload = jest.fn();
        // Mock FileReader to simulate error
        const originalFileReader = global.FileReader;
        const mockFileReader = jest.fn().mockImplementation(()=>({
                readAsDataURL: jest.fn(),
                onload: null,
                onerror: null
            }));
        global.FileReader = mockFileReader;
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_brutalismcard.BrutalismCard, {
            onImageUpload: onImageUpload
        }));
        const input = document.querySelector('input[type="file"]');
        Object.defineProperty(input, 'files', {
            value: [
                mockValidFile
            ],
            writable: true
        });
        _react1.fireEvent.change(input);
        // Restore original FileReader
        global.FileReader = originalFileReader;
        // Should not throw any errors
        expect(console.error).not.toHaveBeenCalled();
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2NvbXBvbmVudHMvdWkvYnJ1dGFsaXNtLWNhcmQudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnXG5pbXBvcnQgdXNlckV2ZW50IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudCdcbmltcG9ydCB7IEJydXRhbGlzbUNhcmQgfSBmcm9tICdAL2NvbXBvbmVudHMvdWkvYnJ1dGFsaXNtLWNhcmQnXG5cbi8vIE1vY2sgY29uc29sZS5lcnJvciB0byBjYXB0dXJlIHZhbGlkYXRpb24gbWVzc2FnZXNcbmNvbnN0IG9yaWdpbmFsRXJyb3IgPSBjb25zb2xlLmVycm9yXG5iZWZvcmVBbGwoKCkgPT4ge1xuICBjb25zb2xlLmVycm9yID0gamVzdC5mbigpXG59KVxuXG5hZnRlckFsbCgoKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbEVycm9yXG59KVxuXG5kZXNjcmliZSgnQnJ1dGFsaXNtQ2FyZCBGaWxlIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gIH0pXG5cbiAgaXQoJ3ZhbGlkYXRlcyBmaWxlIHR5cGVzIC0gcmVqZWN0cyBub24taW1hZ2UgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1RleHRGaWxlID0gbmV3IEZpbGUoWyd0ZXN0J10sICd0ZXN0LnR4dCcsIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pXG4gICAgXG4gICAgcmVuZGVyKDxCcnV0YWxpc21DYXJkIC8+KVxuICAgIFxuICAgIC8vIEZpbmQgdGhlIGhpZGRlbiBmaWxlIGlucHV0XG4gICAgY29uc3QgZmlsZUlucHV0ID0gc2NyZWVuLmdldEJ5Um9sZSgnYnV0dG9uJykgYXMgSFRNTExhYmVsRWxlbWVudFxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImZpbGVcIl0nKSBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZmlsZSBzZWxlY3Rpb24gYnkgc2V0dGluZyB0aGUgZmlsZXMgcHJvcGVydHkgYW5kIHRyaWdnZXJpbmcgY2hhbmdlIGV2ZW50XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGlucHV0LCAnZmlsZXMnLCB7XG4gICAgICB2YWx1ZTogW21vY2tUZXh0RmlsZV0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgXG4gICAgLy8gVHJpZ2dlciB0aGUgY2hhbmdlIGV2ZW50XG4gICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dClcbiAgICBcbiAgICAvLyBWZXJpZnkgY29uc29sZS5lcnJvciB3YXMgY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgbWVzc2FnZVxuICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnU2VsZWN0ZWQgZmlsZSBpcyBub3QgYW4gaW1hZ2UnKVxuICB9KVxuXG4gIGl0KCd2YWxpZGF0ZXMgZmlsZSBzaXplIC0gcmVqZWN0cyBmaWxlcyBsYXJnZXIgdGhhbiA1TUInLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0xhcmdlRmlsZSA9IG5ldyBGaWxlKFsneCcucmVwZWF0KDYgKiAxMDI0ICogMTAyNCldLCAnbGFyZ2UuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICBcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgLz4pXG4gICAgXG4gICAgLy8gRmluZCB0aGUgaGlkZGVuIGZpbGUgaW5wdXRcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJykgYXMgSFRNTElucHV0RWxlbWVudFxuICAgIFxuICAgIC8vIFNpbXVsYXRlIGZpbGUgc2VsZWN0aW9uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGlucHV0LCAnZmlsZXMnLCB7XG4gICAgICB2YWx1ZTogW21vY2tMYXJnZUZpbGVdLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KVxuICAgIFxuICAgIC8vIFRyaWdnZXIgdGhlIGNoYW5nZSBldmVudFxuICAgIGZpcmVFdmVudC5jaGFuZ2UoaW5wdXQpXG4gICAgXG4gICAgLy8gVmVyaWZ5IGNvbnNvbGUuZXJyb3Igd2FzIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IG1lc3NhZ2VcbiAgICBleHBlY3QoY29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0ltYWdlIGZpbGUgaXMgdG9vIGxhcmdlIChtYXggNU1CKScpXG4gIH0pXG5cbiAgaXQoJ2FjY2VwdHMgdmFsaWQgaW1hZ2UgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1ZhbGlkRmlsZSA9IG5ldyBGaWxlKFsndGVzdCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgIGNvbnN0IG9uRmlsZVVwbG9hZCA9IGplc3QuZm4oKVxuICAgIGNvbnN0IG9uSW1hZ2VVcGxvYWQgPSBqZXN0LmZuKClcbiAgICBcbiAgICByZW5kZXIoXG4gICAgICA8QnJ1dGFsaXNtQ2FyZCBcbiAgICAgICAgb25GaWxlVXBsb2FkPXtvbkZpbGVVcGxvYWR9XG4gICAgICAgIG9uSW1hZ2VVcGxvYWQ9e29uSW1hZ2VVcGxvYWR9XG4gICAgICAvPlxuICAgIClcbiAgICBcbiAgICAvLyBGaW5kIHRoZSBoaWRkZW4gZmlsZSBpbnB1dFxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImZpbGVcIl0nKSBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZmlsZSBzZWxlY3Rpb25cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdmaWxlcycsIHtcbiAgICAgIHZhbHVlOiBbbW9ja1ZhbGlkRmlsZV0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgXG4gICAgLy8gVHJpZ2dlciB0aGUgY2hhbmdlIGV2ZW50XG4gICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dClcbiAgICBcbiAgICAvLyBWZXJpZnkgbm8gZXJyb3Igd2FzIGxvZ2dlZFxuICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgXG4gICAgLy8gVmVyaWZ5IGNhbGxiYWNrcyB3ZXJlIGNhbGxlZCAobmVlZCB0byB3YWl0IGZvciBGaWxlUmVhZGVyKVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKVxuICAgIGV4cGVjdChvbkZpbGVVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tWYWxpZEZpbGUpXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgZHJhZyBhbmQgZHJvcCB3aXRoIGludmFsaWQgZmlsZSB0eXBlJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tUZXh0RmlsZSA9IG5ldyBGaWxlKFsndGVzdCddLCAndGVzdC50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KVxuICAgIFxuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCAvPilcbiAgICBcbiAgICBjb25zdCBkcm9wWm9uZSA9IHNjcmVlbi5nZXRCeVRleHQoJ1VwbG9hZCBZb3VyIEFuZ2xlJykuY2xvc2VzdCgnZGl2JykgYXMgSFRNTEVsZW1lbnRcbiAgICBcbiAgICAvLyBTaW11bGF0ZSBkcmFnIGFuZCBkcm9wIHdpdGggaW52YWxpZCBmaWxlXG4gICAgZmlyZUV2ZW50LmRyb3AoZHJvcFpvbmUsIHtcbiAgICAgIGRhdGFUcmFuc2Zlcjoge1xuICAgICAgICBmaWxlczogW21vY2tUZXh0RmlsZV1cbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIFZlcmlmeSBubyBlcnJvciB3YXMgbG9nZ2VkIChkcmFnIGFuZCBkcm9wIGRvZXNuJ3QgdHJpZ2dlciB2YWxpZGF0aW9uIGZvciBub24taW1hZ2VzKVxuICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgZHJhZyBhbmQgZHJvcCB3aXRoIGxhcmdlIGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0xhcmdlRmlsZSA9IG5ldyBGaWxlKFsneCcucmVwZWF0KDYgKiAxMDI0ICogMTAyNCldLCAnbGFyZ2UuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICBcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgLz4pXG4gICAgXG4gICAgY29uc3QgZHJvcFpvbmUgPSBzY3JlZW4uZ2V0QnlUZXh0KCdVcGxvYWQgWW91ciBBbmdsZScpLmNsb3Nlc3QoJ2RpdicpIGFzIEhUTUxFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZHJhZyBhbmQgZHJvcCB3aXRoIGxhcmdlIGZpbGVcbiAgICBmaXJlRXZlbnQuZHJvcChkcm9wWm9uZSwge1xuICAgICAgZGF0YVRyYW5zZmVyOiB7XG4gICAgICAgIGZpbGVzOiBbbW9ja0xhcmdlRmlsZV1cbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIFZlcmlmeSBlcnJvciB3YXMgbG9nZ2VkXG4gICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdJbWFnZSBmaWxlIGlzIHRvbyBsYXJnZSAobWF4IDVNQiknKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIGRyYWcgYW5kIGRyb3Agd2l0aCB2YWxpZCBmaWxlJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tWYWxpZEZpbGUgPSBuZXcgRmlsZShbJ3Rlc3QnXSwgJ3Rlc3QuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICBjb25zdCBvbkZpbGVVcGxvYWQgPSBqZXN0LmZuKClcbiAgICBjb25zdCBvbkltYWdlVXBsb2FkID0gamVzdC5mbigpXG4gICAgXG4gICAgcmVuZGVyKFxuICAgICAgPEJydXRhbGlzbUNhcmQgXG4gICAgICAgIG9uRmlsZVVwbG9hZD17b25GaWxlVXBsb2FkfVxuICAgICAgICBvbkltYWdlVXBsb2FkPXtvbkltYWdlVXBsb2FkfVxuICAgICAgLz5cbiAgICApXG4gICAgXG4gICAgY29uc3QgZHJvcFpvbmUgPSBzY3JlZW4uZ2V0QnlUZXh0KCdVcGxvYWQgWW91ciBBbmdsZScpLmNsb3Nlc3QoJ2RpdicpIGFzIEhUTUxFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZHJhZyBhbmQgZHJvcCB3aXRoIHZhbGlkIGZpbGVcbiAgICBmaXJlRXZlbnQuZHJvcChkcm9wWm9uZSwge1xuICAgICAgZGF0YVRyYW5zZmVyOiB7XG4gICAgICAgIGZpbGVzOiBbbW9ja1ZhbGlkRmlsZV1cbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIFZlcmlmeSBubyBlcnJvciB3YXMgbG9nZ2VkXG4gICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICBcbiAgICAvLyBWZXJpZnkgY2FsbGJhY2tzIHdlcmUgY2FsbGVkIChuZWVkIHRvIHdhaXQgZm9yIEZpbGVSZWFkZXIpXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpXG4gICAgZXhwZWN0KG9uRmlsZVVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1ZhbGlkRmlsZSlcbiAgfSlcbn0pXG5cbmRlc2NyaWJlKCdCcnV0YWxpc21DYXJkIERyYWcgYW5kIERyb3AgRXZlbnQgSGFuZGxlcnMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgZHJhZyBvdmVyIGV2ZW50IGNvcnJlY3RseScsICgpID0+IHtcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgLz4pXG4gICAgXG4gICAgY29uc3QgZHJvcFpvbmUgPSBzY3JlZW4uZ2V0QnlUZXh0KCdVcGxvYWQgWW91ciBBbmdsZScpLmNsb3Nlc3QoJ2RpdicpIGFzIEhUTUxFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZHJhZyBvdmVyIGV2ZW50XG4gICAgZmlyZUV2ZW50LmRyYWdPdmVyKGRyb3Bab25lKVxuICAgIFxuICAgIC8vIFRoZSBjb21wb25lbnQgc2hvdWxkIG5vdyBiZSBpbiBkcmFnZ2luZyBzdGF0ZVxuICAgIC8vIFdlIHZlcmlmeSB0aGUgZXZlbnQgaGFuZGxlciB3YXMgY2FsbGVkIGJ5IGNoZWNraW5nIHRoZSBlbGVtZW50IGlzIHN0aWxsIHByZXNlbnRcbiAgICBleHBlY3QoZHJvcFpvbmUpLnRvQmVJblRoZURvY3VtZW50KClcbiAgfSlcblxuICBpdCgnaGFuZGxlcyBkcmFnIGxlYXZlIGV2ZW50IGNvcnJlY3RseScsICgpID0+IHtcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgLz4pXG4gICAgXG4gICAgY29uc3QgZHJvcFpvbmUgPSBzY3JlZW4uZ2V0QnlUZXh0KCdVcGxvYWQgWW91ciBBbmdsZScpLmNsb3Nlc3QoJ2RpdicpIGFzIEhUTUxFbGVtZW50XG4gICAgXG4gICAgLy8gRmlyc3QgdHJpZ2dlciBkcmFnIG92ZXIgdG8gc2V0IGRyYWdnaW5nIHN0YXRlXG4gICAgZmlyZUV2ZW50LmRyYWdPdmVyKGRyb3Bab25lKVxuICAgIFxuICAgIC8vIFRoZW4gdHJpZ2dlciBkcmFnIGxlYXZlXG4gICAgZmlyZUV2ZW50LmRyYWdMZWF2ZShkcm9wWm9uZSlcbiAgICBcbiAgICAvLyBUaGUgY29tcG9uZW50IHNob3VsZCBubyBsb25nZXIgYmUgaW4gZHJhZ2dpbmcgc3RhdGVcbiAgICAvLyBOb3RlOiBUaGUgdmlzdWFsIHN0YXRlIGNoYW5nZSBtaWdodCBiZSBpbW1lZGlhdGUsIHNvIHdlIHRlc3QgdGhlIGV2ZW50IGhhbmRsZXIgd2FzIGNhbGxlZFxuICAgIGV4cGVjdChkcm9wWm9uZSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIGRyYWcgb3ZlciBhbmQgZHJhZyBsZWF2ZSBzZXF1ZW5jZScsICgpID0+IHtcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgLz4pXG4gICAgXG4gICAgY29uc3QgZHJvcFpvbmUgPSBzY3JlZW4uZ2V0QnlUZXh0KCdVcGxvYWQgWW91ciBBbmdsZScpLmNsb3Nlc3QoJ2RpdicpIGFzIEhUTUxFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZHJhZyBvdmVyXG4gICAgZmlyZUV2ZW50LmRyYWdPdmVyKGRyb3Bab25lKVxuICAgIFxuICAgIC8vIFNpbXVsYXRlIGRyYWcgbGVhdmVcbiAgICBmaXJlRXZlbnQuZHJhZ0xlYXZlKGRyb3Bab25lKVxuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgZHJvcCB6b25lIGlzIHN0aWxsIHByZXNlbnRcbiAgICBleHBlY3QoZHJvcFpvbmUpLnRvQmVJblRoZURvY3VtZW50KClcbiAgfSlcblxuICBpdCgncHJldmVudHMgZGVmYXVsdCBvbiBkcmFnIG92ZXIgZXZlbnQnLCAoKSA9PiB7XG4gICAgcmVuZGVyKDxCcnV0YWxpc21DYXJkIC8+KVxuICAgIFxuICAgIGNvbnN0IGRyb3Bab25lID0gc2NyZWVuLmdldEJ5VGV4dCgnVXBsb2FkIFlvdXIgQW5nbGUnKS5jbG9zZXN0KCdkaXYnKSBhcyBIVE1MRWxlbWVudFxuICAgIFxuICAgIGNvbnN0IG1vY2tFdmVudCA9IHtcbiAgICAgIHByZXZlbnREZWZhdWx0OiBqZXN0LmZuKClcbiAgICB9IGFzIHVua25vd24gYXMgUmVhY3QuRHJhZ0V2ZW50PEhUTUxEaXZFbGVtZW50PlxuICAgIFxuICAgIC8vIFNpbXVsYXRlIGRyYWcgb3ZlciB3aXRoIG1vY2sgZXZlbnRcbiAgICBmaXJlRXZlbnQuZHJhZ092ZXIoZHJvcFpvbmUsIG1vY2tFdmVudClcbiAgICBcbiAgICAvLyBUaGUgcHJldmVudERlZmF1bHQgc2hvdWxkIGJlIGNhbGxlZCBpbiB0aGUgaGFuZGxlclxuICAgIC8vIE5vdGU6IGZpcmVFdmVudC5kcmFnT3ZlciBkb2Vzbid0IGFjdHVhbGx5IGNhbGwgcHJldmVudERlZmF1bHQsIGJ1dCB0aGUgaGFuZGxlciBkb2VzXG4gICAgZXhwZWN0KGRyb3Bab25lKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gIH0pXG5cbiAgaXQoJ3ByZXZlbnRzIGRlZmF1bHQgb24gZHJvcCBldmVudCcsICgpID0+IHtcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgLz4pXG4gICAgXG4gICAgY29uc3QgZHJvcFpvbmUgPSBzY3JlZW4uZ2V0QnlUZXh0KCdVcGxvYWQgWW91ciBBbmdsZScpLmNsb3Nlc3QoJ2RpdicpIGFzIEhUTUxFbGVtZW50XG4gICAgXG4gICAgY29uc3QgbW9ja0V2ZW50ID0ge1xuICAgICAgcHJldmVudERlZmF1bHQ6IGplc3QuZm4oKSxcbiAgICAgIGRhdGFUcmFuc2Zlcjoge1xuICAgICAgICBmaWxlczogW11cbiAgICAgIH1cbiAgICB9IGFzIHVua25vd24gYXMgUmVhY3QuRHJhZ0V2ZW50PEhUTUxEaXZFbGVtZW50PlxuICAgIFxuICAgIC8vIFNpbXVsYXRlIGRyb3Agd2l0aCBtb2NrIGV2ZW50XG4gICAgZmlyZUV2ZW50LmRyb3AoZHJvcFpvbmUsIG1vY2tFdmVudClcbiAgICBcbiAgICAvLyBUaGUgcHJldmVudERlZmF1bHQgc2hvdWxkIGJlIGNhbGxlZCBpbiB0aGUgaGFuZGxlclxuICAgIGV4cGVjdChkcm9wWm9uZSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICB9KVxufSlcblxuZGVzY3JpYmUoJ0JydXRhbGlzbUNhcmQgQ29tcG9uZW50IFByb3BzIGFuZCBSZW5kZXJpbmcnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gIH0pXG5cbiAgaXQoJ3JlbmRlcnMgd2l0aCBkZWZhdWx0IHByb3BzJywgKCkgPT4ge1xuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCAvPilcbiAgICBcbiAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVXBsb2FkIFlvdXIgQW5nbGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICB9KVxuXG4gIGl0KCdyZW5kZXJzIHdpdGggY3VzdG9tIHRpdGxlJywgKCkgPT4ge1xuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCB0aXRsZT1cIkN1c3RvbSBVcGxvYWQgVGl0bGVcIiAvPilcbiAgICBcbiAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnQ3VzdG9tIFVwbG9hZCBUaXRsZScpKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gIH0pXG5cbiAgaXQoJ3JlbmRlcnMgd2l0aCBjdXN0b20gY2xhc3NOYW1lJywgKCkgPT4ge1xuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoPEJydXRhbGlzbUNhcmQgY2xhc3NOYW1lPVwiY3VzdG9tLWNsYXNzXCIgLz4pXG4gICAgXG4gICAgY29uc3QgbWFpbkRpdiA9IGNvbnRhaW5lci5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50XG4gICAgZXhwZWN0KG1haW5EaXYpLnRvSGF2ZUNsYXNzKCdjdXN0b20tY2xhc3MnKVxuICB9KVxuXG4gIGl0KCdyZW5kZXJzIHdpdGggY2hpbGRyZW4gY29udGVudCcsICgpID0+IHtcbiAgICByZW5kZXIoXG4gICAgICA8QnJ1dGFsaXNtQ2FyZD5cbiAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImNoaWxkLWNvbnRlbnRcIj5DaGlsZCBjb250ZW50PC9kaXY+XG4gICAgICA8L0JydXRhbGlzbUNhcmQ+XG4gICAgKVxuICAgIFxuICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ2NoaWxkLWNvbnRlbnQnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdDaGlsZCBjb250ZW50JykpLnRvQmVJblRoZURvY3VtZW50KClcbiAgfSlcblxuICBpdCgncmVuZGVycyB3aXRoIHJpZ2h0IGJ1dHRvbiBwb3NpdGlvbicsICgpID0+IHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKDxCcnV0YWxpc21DYXJkIGJ1dHRvblBvc2l0aW9uPVwicmlnaHRcIiAvPilcbiAgICBcbiAgICAvLyBUaGUgYnV0dG9uIHNob3VsZCBiZSBwb3NpdGlvbmVkIG9uIHRoZSByaWdodFxuICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdbY2xhc3MqPVwiLXJpZ2h0LTE0XCJdJylcbiAgICBleHBlY3QoYnV0dG9uQ29udGFpbmVyKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gIH0pXG5cbiAgaXQoJ3JlbmRlcnMgd2l0aCBjdXN0b20gYmFja2dyb3VuZCBpbWFnZScsICgpID0+IHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxuICAgICAgPEJydXRhbGlzbUNhcmQgYmFja2dyb3VuZEltYWdlPVwiL2N1c3RvbS1pbWFnZS5qcGdcIiAvPlxuICAgIClcbiAgICBcbiAgICBjb25zdCBjYXJkRWxlbWVudCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdbc3R5bGUqPVwiYmFja2dyb3VuZC1pbWFnZVwiXScpIGFzIEhUTUxFbGVtZW50XG4gICAgZXhwZWN0KGNhcmRFbGVtZW50KS50b0hhdmVTdHlsZSh7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKCcvY3VzdG9tLWltYWdlLmpwZycpXCJcbiAgICB9KVxuICB9KVxuXG4gIGl0KCdyZW5kZXJzIHdpdGggY3VzdG9tIHNoYWRvdyByb3RhdGlvbicsICgpID0+IHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxuICAgICAgPEJydXRhbGlzbUNhcmQgc2hhZG93Um90YXRpb249XCJyb3RhdGUtNDVcIiAvPlxuICAgIClcbiAgICBcbiAgICBjb25zdCBzaGFkb3dFbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ1tjbGFzcyo9XCJyb3RhdGUtNDVcIl0nKVxuICAgIGV4cGVjdChzaGFkb3dFbGVtZW50KS50b0JlSW5UaGVEb2N1bWVudCgpXG4gIH0pXG5cbiAgaXQoJ3JlbmRlcnMgdXBsb2FkIGljb24gd2hlbiBubyBpbWFnZSBpcyB1cGxvYWRlZCcsICgpID0+IHtcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgLz4pXG4gICAgXG4gICAgLy8gVGhlIHVwbG9hZCBpY29uIHNob3VsZCBiZSBwcmVzZW50IChTVkcgZWxlbWVudClcbiAgICBjb25zdCB1cGxvYWRJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnJylcbiAgICBleHBlY3QodXBsb2FkSWNvbikudG9CZUluVGhlRG9jdW1lbnQoKVxuICB9KVxuXG4gIGl0KCdkb2VzIG5vdCByZW5kZXIgdXBsb2FkIGljb24gd2hlbiBpbWFnZSBpcyB1cGxvYWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrVmFsaWRGaWxlID0gbmV3IEZpbGUoWyd0ZXN0J10sICd0ZXN0LmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgXG4gICAgcmVuZGVyKDxCcnV0YWxpc21DYXJkIC8+KVxuICAgIFxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImZpbGVcIl0nKSBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZmlsZSBzZWxlY3Rpb25cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdmaWxlcycsIHtcbiAgICAgIHZhbHVlOiBbbW9ja1ZhbGlkRmlsZV0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgXG4gICAgLy8gVHJpZ2dlciB0aGUgY2hhbmdlIGV2ZW50XG4gICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dClcbiAgICBcbiAgICAvLyBXYWl0IGZvciB0aGUgaW1hZ2UgdG8gYmUgcHJvY2Vzc2VkXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBjb25zdCB1cGxvYWRJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnJylcbiAgICAgIGV4cGVjdCh1cGxvYWRJY29uKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgIH0pXG4gIH0pXG59KVxuXG5kZXNjcmliZSgnQnJ1dGFsaXNtQ2FyZCBGaWxlIFVwbG9hZCBDYWxsYmFja3MnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gIH0pXG5cbiAgaXQoJ2NhbGxzIG9uRmlsZVVwbG9hZCBjYWxsYmFjayB3aGVuIHZhbGlkIGZpbGUgaXMgc2VsZWN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1ZhbGlkRmlsZSA9IG5ldyBGaWxlKFsndGVzdCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgIGNvbnN0IG9uRmlsZVVwbG9hZCA9IGplc3QuZm4oKVxuICAgIFxuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCBvbkZpbGVVcGxvYWQ9e29uRmlsZVVwbG9hZH0gLz4pXG4gICAgXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdmaWxlcycsIHtcbiAgICAgIHZhbHVlOiBbbW9ja1ZhbGlkRmlsZV0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgXG4gICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dClcbiAgICBcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChvbkZpbGVVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tWYWxpZEZpbGUpXG4gICAgfSlcbiAgfSlcblxuICBpdCgnY2FsbHMgb25JbWFnZVVwbG9hZCBjYWxsYmFjayB3aGVuIHZhbGlkIGZpbGUgaXMgc2VsZWN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1ZhbGlkRmlsZSA9IG5ldyBGaWxlKFsndGVzdCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgIGNvbnN0IG9uSW1hZ2VVcGxvYWQgPSBqZXN0LmZuKClcbiAgICBcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgb25JbWFnZVVwbG9hZD17b25JbWFnZVVwbG9hZH0gLz4pXG4gICAgXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdmaWxlcycsIHtcbiAgICAgIHZhbHVlOiBbbW9ja1ZhbGlkRmlsZV0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgXG4gICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dClcbiAgICBcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChvbkltYWdlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuICB9KVxuXG4gIGl0KCdjYWxscyBvbkZpbGVVcGxvYWQgY2FsbGJhY2sgd2hlbiB2YWxpZCBmaWxlIGlzIGRyb3BwZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1ZhbGlkRmlsZSA9IG5ldyBGaWxlKFsndGVzdCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgIGNvbnN0IG9uRmlsZVVwbG9hZCA9IGplc3QuZm4oKVxuICAgIFxuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCBvbkZpbGVVcGxvYWQ9e29uRmlsZVVwbG9hZH0gLz4pXG4gICAgXG4gICAgY29uc3QgZHJvcFpvbmUgPSBzY3JlZW4uZ2V0QnlUZXh0KCdVcGxvYWQgWW91ciBBbmdsZScpLmNsb3Nlc3QoJ2RpdicpIGFzIEhUTUxFbGVtZW50XG4gICAgXG4gICAgZmlyZUV2ZW50LmRyb3AoZHJvcFpvbmUsIHtcbiAgICAgIGRhdGFUcmFuc2Zlcjoge1xuICAgICAgICBmaWxlczogW21vY2tWYWxpZEZpbGVdXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChvbkZpbGVVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tWYWxpZEZpbGUpXG4gICAgfSlcbiAgfSlcblxuICBpdCgnY2FsbHMgb25JbWFnZVVwbG9hZCBjYWxsYmFjayB3aGVuIHZhbGlkIGZpbGUgaXMgZHJvcHBlZCcsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrVmFsaWRGaWxlID0gbmV3IEZpbGUoWyd0ZXN0J10sICd0ZXN0LmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgY29uc3Qgb25JbWFnZVVwbG9hZCA9IGplc3QuZm4oKVxuICAgIFxuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCBvbkltYWdlVXBsb2FkPXtvbkltYWdlVXBsb2FkfSAvPilcbiAgICBcbiAgICBjb25zdCBkcm9wWm9uZSA9IHNjcmVlbi5nZXRCeVRleHQoJ1VwbG9hZCBZb3VyIEFuZ2xlJykuY2xvc2VzdCgnZGl2JykgYXMgSFRNTEVsZW1lbnRcbiAgICBcbiAgICBmaXJlRXZlbnQuZHJvcChkcm9wWm9uZSwge1xuICAgICAgZGF0YVRyYW5zZmVyOiB7XG4gICAgICAgIGZpbGVzOiBbbW9ja1ZhbGlkRmlsZV1cbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KG9uSW1hZ2VVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG4gIH0pXG5cbiAgaXQoJ2RvZXMgbm90IGNhbGwgY2FsbGJhY2tzIHdoZW4gbm8gZmlsZSBpcyBzZWxlY3RlZCcsICgpID0+IHtcbiAgICBjb25zdCBvbkZpbGVVcGxvYWQgPSBqZXN0LmZuKClcbiAgICBjb25zdCBvbkltYWdlVXBsb2FkID0gamVzdC5mbigpXG4gICAgXG4gICAgcmVuZGVyKFxuICAgICAgPEJydXRhbGlzbUNhcmQgXG4gICAgICAgIG9uRmlsZVVwbG9hZD17b25GaWxlVXBsb2FkfVxuICAgICAgICBvbkltYWdlVXBsb2FkPXtvbkltYWdlVXBsb2FkfVxuICAgICAgLz5cbiAgICApXG4gICAgXG4gICAgZXhwZWN0KG9uRmlsZVVwbG9hZCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIGV4cGVjdChvbkltYWdlVXBsb2FkKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gIH0pXG5cbiAgaXQoJ2RvZXMgbm90IGNhbGwgY2FsbGJhY2tzIHdoZW4gaW52YWxpZCBmaWxlIGlzIHNlbGVjdGVkJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tJbnZhbGlkRmlsZSA9IG5ldyBGaWxlKFsndGVzdCddLCAndGVzdC50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KVxuICAgIGNvbnN0IG9uRmlsZVVwbG9hZCA9IGplc3QuZm4oKVxuICAgIGNvbnN0IG9uSW1hZ2VVcGxvYWQgPSBqZXN0LmZuKClcbiAgICBcbiAgICByZW5kZXIoXG4gICAgICA8QnJ1dGFsaXNtQ2FyZCBcbiAgICAgICAgb25GaWxlVXBsb2FkPXtvbkZpbGVVcGxvYWR9XG4gICAgICAgIG9uSW1hZ2VVcGxvYWQ9e29uSW1hZ2VVcGxvYWR9XG4gICAgICAvPlxuICAgIClcbiAgICBcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJykgYXMgSFRNTElucHV0RWxlbWVudFxuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnB1dCwgJ2ZpbGVzJywge1xuICAgICAgdmFsdWU6IFttb2NrSW52YWxpZEZpbGVdLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KVxuICAgIFxuICAgIGZpcmVFdmVudC5jaGFuZ2UoaW5wdXQpXG4gICAgXG4gICAgZXhwZWN0KG9uRmlsZVVwbG9hZCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIGV4cGVjdChvbkltYWdlVXBsb2FkKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gIH0pXG59KVxuXG5kZXNjcmliZSgnQnJ1dGFsaXNtQ2FyZCBFZGdlIENhc2VzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIGVtcHR5IGZpbGUgaW5wdXQnLCAoKSA9PiB7XG4gICAgcmVuZGVyKDxCcnV0YWxpc21DYXJkIC8+KVxuICAgIFxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImZpbGVcIl0nKSBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgZW1wdHkgZmlsZSBzZWxlY3Rpb25cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdmaWxlcycsIHtcbiAgICAgIHZhbHVlOiBbXSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSlcbiAgICBcbiAgICBmaXJlRXZlbnQuY2hhbmdlKGlucHV0KVxuICAgIFxuICAgIC8vIFNob3VsZCBub3QgdGhyb3cgYW55IGVycm9yc1xuICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgbnVsbCBmaWxlIGlucHV0JywgKCkgPT4ge1xuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCAvPilcbiAgICBcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJykgYXMgSFRNTElucHV0RWxlbWVudFxuICAgIFxuICAgIC8vIFNpbXVsYXRlIG51bGwgZmlsZSBzZWxlY3Rpb25cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdmaWxlcycsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KVxuICAgIFxuICAgIGZpcmVFdmVudC5jaGFuZ2UoaW5wdXQpXG4gICAgXG4gICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBhbnkgZXJyb3JzXG4gICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgfSlcblxuICBpdCgnaGFuZGxlcyBkcm9wIHdpdGggbm8gZmlsZXMnLCAoKSA9PiB7XG4gICAgcmVuZGVyKDxCcnV0YWxpc21DYXJkIC8+KVxuICAgIFxuICAgIGNvbnN0IGRyb3Bab25lID0gc2NyZWVuLmdldEJ5VGV4dCgnVXBsb2FkIFlvdXIgQW5nbGUnKS5jbG9zZXN0KCdkaXYnKSBhcyBIVE1MRWxlbWVudFxuICAgIFxuICAgIGZpcmVFdmVudC5kcm9wKGRyb3Bab25lLCB7XG4gICAgICBkYXRhVHJhbnNmZXI6IHtcbiAgICAgICAgZmlsZXM6IFtdXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAvLyBTaG91bGQgbm90IHRocm93IGFueSBlcnJvcnNcbiAgICBleHBlY3QoY29uc29sZS5lcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIGRyb3Agd2l0aCBudWxsIGZpbGVzJywgKCkgPT4ge1xuICAgIHJlbmRlcig8QnJ1dGFsaXNtQ2FyZCAvPilcbiAgICBcbiAgICBjb25zdCBkcm9wWm9uZSA9IHNjcmVlbi5nZXRCeVRleHQoJ1VwbG9hZCBZb3VyIEFuZ2xlJykuY2xvc2VzdCgnZGl2JykgYXMgSFRNTEVsZW1lbnRcbiAgICBcbiAgICBmaXJlRXZlbnQuZHJvcChkcm9wWm9uZSwge1xuICAgICAgZGF0YVRyYW5zZmVyOiB7XG4gICAgICAgIGZpbGVzOiBudWxsXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAvLyBTaG91bGQgbm90IHRocm93IGFueSBlcnJvcnNcbiAgICBleHBlY3QoY29uc29sZS5lcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIEZpbGVSZWFkZXIgZXJyb3IgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrVmFsaWRGaWxlID0gbmV3IEZpbGUoWyd0ZXN0J10sICd0ZXN0LmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgY29uc3Qgb25JbWFnZVVwbG9hZCA9IGplc3QuZm4oKVxuICAgIFxuICAgIC8vIE1vY2sgRmlsZVJlYWRlciB0byBzaW11bGF0ZSBlcnJvclxuICAgIGNvbnN0IG9yaWdpbmFsRmlsZVJlYWRlciA9IGdsb2JhbC5GaWxlUmVhZGVyXG4gICAgY29uc3QgbW9ja0ZpbGVSZWFkZXIgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgICByZWFkQXNEYXRhVVJMOiBqZXN0LmZuKCksXG4gICAgICBvbmxvYWQ6IG51bGwsXG4gICAgICBvbmVycm9yOiBudWxsXG4gICAgfSkpXG4gICAgZ2xvYmFsLkZpbGVSZWFkZXIgPSBtb2NrRmlsZVJlYWRlciBhcyBhbnlcbiAgICBcbiAgICByZW5kZXIoPEJydXRhbGlzbUNhcmQgb25JbWFnZVVwbG9hZD17b25JbWFnZVVwbG9hZH0gLz4pXG4gICAgXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdmaWxlcycsIHtcbiAgICAgIHZhbHVlOiBbbW9ja1ZhbGlkRmlsZV0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgXG4gICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dClcbiAgICBcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIEZpbGVSZWFkZXJcbiAgICBnbG9iYWwuRmlsZVJlYWRlciA9IG9yaWdpbmFsRmlsZVJlYWRlclxuICAgIFxuICAgIC8vIFNob3VsZCBub3QgdGhyb3cgYW55IGVycm9yc1xuICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gIH0pXG59KSAiXSwibmFtZXMiOlsib3JpZ2luYWxFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsImJlZm9yZUFsbCIsImplc3QiLCJmbiIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwibW9ja1RleHRGaWxlIiwiRmlsZSIsInR5cGUiLCJyZW5kZXIiLCJCcnV0YWxpc21DYXJkIiwiZmlsZUlucHV0Iiwic2NyZWVuIiwiZ2V0QnlSb2xlIiwiaW5wdXQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwid3JpdGFibGUiLCJmaXJlRXZlbnQiLCJjaGFuZ2UiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1vY2tMYXJnZUZpbGUiLCJyZXBlYXQiLCJtb2NrVmFsaWRGaWxlIiwib25GaWxlVXBsb2FkIiwib25JbWFnZVVwbG9hZCIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJkcm9wWm9uZSIsImdldEJ5VGV4dCIsImNsb3Nlc3QiLCJkcm9wIiwiZGF0YVRyYW5zZmVyIiwiZmlsZXMiLCJkcmFnT3ZlciIsInRvQmVJblRoZURvY3VtZW50IiwiZHJhZ0xlYXZlIiwibW9ja0V2ZW50IiwicHJldmVudERlZmF1bHQiLCJ0aXRsZSIsImNvbnRhaW5lciIsImNsYXNzTmFtZSIsIm1haW5EaXYiLCJmaXJzdENoaWxkIiwidG9IYXZlQ2xhc3MiLCJkaXYiLCJkYXRhLXRlc3RpZCIsImdldEJ5VGVzdElkIiwiYnV0dG9uUG9zaXRpb24iLCJidXR0b25Db250YWluZXIiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJjYXJkRWxlbWVudCIsInRvSGF2ZVN0eWxlIiwic2hhZG93Um90YXRpb24iLCJzaGFkb3dFbGVtZW50IiwidXBsb2FkSWNvbiIsIndhaXRGb3IiLCJtb2NrSW52YWxpZEZpbGUiLCJvcmlnaW5hbEZpbGVSZWFkZXIiLCJnbG9iYWwiLCJGaWxlUmVhZGVyIiwibW9ja0ZpbGVSZWFkZXIiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJyZWFkQXNEYXRhVVJMIiwib25sb2FkIiwib25lcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OERBQWtCO3dCQUNpQzsrQkFFckI7Ozs7OztBQUU5QixvREFBb0Q7QUFDcEQsTUFBTUEsZ0JBQWdCQyxRQUFRQyxLQUFLO0FBQ25DQyxVQUFVO0lBQ1JGLFFBQVFDLEtBQUssR0FBR0UsS0FBS0MsRUFBRTtBQUN6QjtBQUVBQyxTQUFTO0lBQ1BMLFFBQVFDLEtBQUssR0FBR0Y7QUFDbEI7QUFFQU8sU0FBUyxpQ0FBaUM7SUFDeENDLFdBQVc7UUFDVEosS0FBS0ssYUFBYTtJQUNwQjtJQUVBQyxHQUFHLGtEQUFrRDtRQUNuRCxNQUFNQyxlQUFlLElBQUlDLEtBQUs7WUFBQztTQUFPLEVBQUUsWUFBWTtZQUFFQyxNQUFNO1FBQWE7UUFFekVDLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLDRCQUFhO1FBRXJCLDZCQUE2QjtRQUM3QixNQUFNQyxZQUFZQyxjQUFNLENBQUNDLFNBQVMsQ0FBQztRQUNuQyxNQUFNQyxRQUFRQyxTQUFTQyxhQUFhLENBQUM7UUFFckMsb0ZBQW9GO1FBQ3BGQyxPQUFPQyxjQUFjLENBQUNKLE9BQU8sU0FBUztZQUNwQ0ssT0FBTztnQkFBQ2I7YUFBYTtZQUNyQmMsVUFBVTtRQUNaO1FBRUEsMkJBQTJCO1FBQzNCQyxpQkFBUyxDQUFDQyxNQUFNLENBQUNSO1FBRWpCLDJEQUEyRDtRQUMzRFMsT0FBTzNCLFFBQVFDLEtBQUss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