385bf46f4b711f8e5a7e59c67808bdb4
"use strict";
// Mock the utility functions
jest.mock('@/utils/image', ()=>({
        fileToBase64: jest.fn().mockResolvedValue('mock-base64-data'),
        compressBase64: jest.fn().mockResolvedValue('mock-compressed-data'),
        CompressionFailedError: class CompressionFailedError extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
// Mock Next.js Image component
jest.mock('next/image', ()=>{
    return function MockImage({ src, alt, onLoad, ...props }) {
        _react.default.useEffect(()=>{
            if (onLoad) {
                setTimeout(()=>onLoad(), 10);
            }
        }, [
            onLoad
        ]);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
            src: src,
            alt: alt,
            ...props
        });
    };
});
// Mock SaucyTicker component
jest.mock('@/components/ui/saucy-ticker', ()=>({
        SaucyTicker: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "saucy-ticker",
                children: "Saucy Ticker"
            })
    }));
// Mock HeroImageWithButton component to ensure button is only rendered when not disabled
jest.mock('@/components/ui/hero-image-with-button', ()=>({
        HeroImageWithButton: ({ overlayButton, ...props })=>{
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                className: "relative w-full flex items-center justify-center h-[50vh] min-h-[400px] max-h-[800px]",
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
                        src: props.src,
                        alt: props.alt,
                        className: "object-contain drop-shadow-2xl"
                    }),
                    overlayButton && !overlayButton.disabled && /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        onClick: overlayButton.onClick,
                        disabled: overlayButton.disabled,
                        className: `absolute z-20 rounded-full w-8 h-8 transition-all duration-150 ease-in-out ${overlayButton.disabled ? "cursor-not-allowed opacity-50" : "hover:scale-110 active:scale-95 cursor-pointer"} ${overlayButton.className || ''}`,
                        style: {
                            left: overlayButton.position.leftPercent,
                            top: overlayButton.position.topPercent,
                            transform: 'translate(-50%, -50%)',
                            background: `
                radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0) 60%),
                #D80E0E
              `,
                            border: '2px solid #BF1212',
                            boxShadow: `
                0 15px 25px rgba(0, 0, 0, 0.4),
                0 0 0 4px rgba(240, 228, 228, 0.5)
              `
                        },
                        "aria-label": "Camera capture button"
                    })
                ]
            });
        }
    }));
// Mock PolaroidPhotoGenerator component
jest.mock('@/components/ui/polaroid-photo-generator', ()=>({
        PolaroidPhotoGenerator: ({ isGenerating, onGenerationStart, onGenerationComplete, onClose, onRetry, generatedImage, hasError })=>{
            _react.default.useEffect(()=>{
                if (isGenerating) {
                    onGenerationStart();
                }
            }, [
                isGenerating,
                onGenerationStart
            ]);
            _react.default.useEffect(()=>{
                if (generatedImage && !isGenerating) {
                    onGenerationComplete(generatedImage);
                }
            }, [
                generatedImage,
                isGenerating,
                onGenerationComplete
            ]);
            return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "polaroid",
                className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50",
                children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    className: "bg-white p-6 rounded-lg max-w-md w-full mx-4",
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("h2", {
                            className: "text-xl font-bold mb-4",
                            children: "Generated Image"
                        }),
                        isGenerating && /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                            children: "Generating..."
                        }),
                        hasError && /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                            className: "text-red-500",
                            children: "Failed to generate image"
                        }),
                        generatedImage && /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
                            src: generatedImage,
                            alt: "Generated",
                            className: "w-full mb-4"
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                            className: "flex gap-2",
                            children: [
                                /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                                    onClick: onClose,
                                    className: "px-4 py-2 bg-gray-500 text-white rounded",
                                    children: "Close"
                                }),
                                hasError && /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                                    onClick: onRetry,
                                    className: "px-4 py-2 bg-blue-500 text-white rounded",
                                    children: "Retry"
                                })
                            ]
                        })
                    ]
                })
            });
        }
    }));
// Mock BrutalismCard component
jest.mock('@/components/ui/brutalism-card', ()=>({
        BrutalismCard: ({ title, onImageUpload, onFileUpload, imageUrl, isUploading, error, onErrorClick, onUploadClick, className, children })=>{
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                className: `brutalism-card ${className || ''}`,
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("h3", {
                        children: title
                    }),
                    children,
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("input", {
                        type: "file",
                        accept: "image/*",
                        onChange: (e)=>{
                            const file = e.target.files?.[0];
                            if (file) {
                                // Call both callbacks like the real component does
                                if (onFileUpload) {
                                    onFileUpload(file);
                                }
                                if (onImageUpload) {
                                    onImageUpload('mock-image-url');
                                }
                            }
                        },
                        style: {
                            display: 'none'
                        }
                    }),
                    imageUrl && /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
                        src: imageUrl,
                        alt: title
                    }),
                    isUploading && /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                        children: "Uploading..."
                    }),
                    error && /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        onClick: onErrorClick,
                        className: "error-button",
                        children: error
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("button", {
                        onClick: onUploadClick,
                        className: "upload-button",
                        children: "Upload Image"
                    })
                ]
            });
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _utils = require("../../src/test/utils");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _page = /*#__PURE__*/ _interop_require_default(require("../../src/app/page"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Setup user event
const user = _userevent.default.setup();
// Mock URL.createObjectURL
global.URL.createObjectURL = jest.fn(()=>'mock-object-url');
// Mock fetch for API calls
global.fetch = jest.fn();
// Mock console methods to avoid noise in tests
const originalLog = console.log;
const originalError = console.error;
beforeAll(()=>{
    console.log = jest.fn();
    console.error = jest.fn();
});
afterAll(()=>{
    console.log = originalLog;
    console.error = originalError;
});
describe('SusFitPage - Coverage Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        global.fetch.mockResolvedValue({
            ok: true,
            json: jest.fn().mockResolvedValue({
                img_generated: 'data:image/jpeg;base64,mock-generated-image'
            })
        });
    });
    describe('Targeted Coverage Tests', ()=>{
        it('covers logImageDimensions function with onload callback execution', ()=>{
            // Mock console.log
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create a mock image that will actually trigger onload
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                        // Immediately trigger the callback to simulate image load
                        if (callback) {
                            callback() // Call synchronously instead of using setTimeout
                            ;
                        }
                    },
                    onerror: null,
                    width: 800,
                    height: 600,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Render the component
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            // Get the file inputs
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            // Upload a file to trigger the logImageDimensions function
            (0, _utils.act)(()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
            });
            // Should log the file objects update since onload was triggered synchronously
            expect(consoleSpy).toHaveBeenCalledWith('File objects updated:', expect.objectContaining({
                userImageFile: expect.any(String)
            }));
            consoleSpy.mockRestore();
            global.Image = originalImage;
        });
        it('covers resizeImageTo1024x1536 function with onload callback execution', async ()=>{
            // Mock canvas and context
            const mockContext = {
                drawImage: jest.fn(),
                getImageData: jest.fn(),
                putImageData: jest.fn()
            };
            const mockCanvas = {
                getContext: jest.fn(()=>mockContext),
                toDataURL: jest.fn(()=>'data:image/jpeg;base64,mock-resized'),
                width: 1024,
                height: 1536
            };
            // Mock document.createElement
            const originalCreateElement = document.createElement;
            document.createElement = jest.fn((tagName)=>{
                if (tagName === 'canvas') {
                    return mockCanvas;
                }
                return originalCreateElement.call(document, tagName);
            });
            // Create a mock image that will actually trigger onload
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                        // Immediately trigger the callback to simulate image load
                        if (callback) {
                            callback() // Call synchronously instead of using setTimeout
                            ;
                        }
                    },
                    onerror: null,
                    width: 800,
                    height: 600,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Render the component
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            // Get the file inputs
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            // Upload a file to trigger the resizeImageTo1024x1536 function
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
            });
            // The resizeImageTo1024x1536 function should be called and complete successfully
            expect(mockCanvas.getContext).toHaveBeenCalledWith('2d');
            expect(mockContext.drawImage).toHaveBeenCalled();
            expect(mockCanvas.toDataURL).toHaveBeenCalledWith('image/jpeg', 0.9);
            // Restore mocks
            document.createElement = originalCreateElement;
            global.Image = originalImage;
        });
        it('covers generic error handling in handleCameraButtonClick', async ()=>{
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            const { fileToBase64, compressBase64 } = require('@/utils/image');
            fileToBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            compressBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            global.fetch.mockRejectedValue(new Error('Generic network error'));
            // Simulate both image uploads
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const apparelFileInput = fileInputs[1];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            const apparelMockFile = new File([
                'mock'
            ], 'apparel.jpg', {
                type: 'image/jpeg'
            });
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
                _utils.fireEvent.change(apparelFileInput, {
                    target: {
                        files: [
                            apparelMockFile
                        ]
                    }
                });
            });
            // Click camera button
            const cameraButton = _utils.screen.getByRole('button', {
                name: /camera capture button/i
            });
            await user.click(cameraButton);
            // Should handle generic error gracefully (error logging is now handled by React Query)
            await (0, _utils.waitFor)(()=>{
                expect(_utils.screen.getByText(/Failed to generate image/)).toBeInTheDocument();
            });
        });
        it('covers logImageDimensions function without onload callback', ()=>{
            // Mock console.log
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create a mock image that won't trigger onload
            const originalImage = global.Image;
            global.Image = jest.fn(()=>({
                    src: '',
                    onload: null,
                    onerror: null,
                    width: 0,
                    height: 0,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Test the logImageDimensions function directly
            const testLogImageDimensions = (imageUrl, cardName)=>{
                const img = new Image();
                img.src = imageUrl;
            // Don't set onload - this should not trigger the console.log
            // This tests the branch where onload is null/undefined
            };
            // Test the function without onload
            testLogImageDimensions('mock-image-url', 'Test Card');
            // Should not log anything since onload is not set
            expect(consoleSpy).not.toHaveBeenCalledWith('Test Card image dimensions:', expect.any(Object));
            consoleSpy.mockRestore();
            global.Image = originalImage;
        });
        it('covers logImageDimensions function with onload set but not triggered', ()=>{
            // Mock console.log
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create a mock image that sets onload but doesn't trigger it
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                    // Don't call the callback - this tests the branch where onload is set but not executed
                    },
                    onerror: null,
                    width: 0,
                    height: 0,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Test the logImageDimensions function directly
            const testLogImageDimensions = (imageUrl, cardName)=>{
                const img = new Image();
                img.src = imageUrl;
            // onload is set by the function but we don't trigger it
            };
            // Test the function - onload should be set but not called
            testLogImageDimensions('mock-image-url', 'Test Card');
            // Should not log anything since onload callback is not executed
            expect(consoleSpy).not.toHaveBeenCalledWith('Test Card image dimensions:', expect.any(Object));
            // Verify onload was set but not called
            expect(onloadCallback).toBeDefined();
            consoleSpy.mockRestore();
            global.Image = originalImage;
        });
    });
    describe('Utility Functions - Integration Testing', ()=>{
        it('tests resizeImageTo1024x1536 through component behavior', async ()=>{
            // Mock canvas and context
            const mockContext = {
                drawImage: jest.fn(),
                getImageData: jest.fn(),
                putImageData: jest.fn()
            };
            const mockCanvas = {
                getContext: jest.fn(()=>mockContext),
                toDataURL: jest.fn(()=>'data:image/jpeg;base64,mock-resized'),
                width: 1024,
                height: 1536
            };
            // Mock document.createElement
            const originalCreateElement = document.createElement;
            document.createElement = jest.fn((tagName)=>{
                if (tagName === 'canvas') {
                    return mockCanvas;
                }
                return originalCreateElement.call(document, tagName);
            });
            // Create a mock image that will actually trigger onload
            const originalImage = global.Image;
            let onloadCallback = null;
            global.Image = jest.fn(()=>({
                    src: '',
                    get onload () {
                        return onloadCallback;
                    },
                    set onload (callback){
                        onloadCallback = callback;
                        // Immediately trigger the callback to simulate image load
                        if (callback) {
                            callback() // Call synchronously instead of using setTimeout
                            ;
                        }
                    },
                    onerror: null,
                    width: 800,
                    height: 600,
                    addEventListener: jest.fn(),
                    removeEventListener: jest.fn()
                }));
            // Render the component
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            // Get the file inputs
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            // Upload a file to trigger the resizeImageTo1024x1536 function
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
            });
            // The resizeImageTo1024x1536 function should be called and complete successfully
            expect(mockCanvas.getContext).toHaveBeenCalledWith('2d');
            expect(mockContext.drawImage).toHaveBeenCalled();
            expect(mockCanvas.toDataURL).toHaveBeenCalledWith('image/jpeg', 0.9);
            // Restore mocks
            document.createElement = originalCreateElement;
            global.Image = originalImage;
        });
    });
    describe('Error Handling Edge Cases', ()=>{
        it('handles AbortError specifically', async ()=>{
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            const { fileToBase64, compressBase64 } = require('@/utils/image');
            fileToBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            compressBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            global.fetch.mockRejectedValue(new Error('AbortError'));
            // Simulate both image uploads
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const apparelFileInput = fileInputs[1];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            const apparelMockFile = new File([
                'mock'
            ], 'apparel.jpg', {
                type: 'image/jpeg'
            });
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
                _utils.fireEvent.change(apparelFileInput, {
                    target: {
                        files: [
                            apparelMockFile
                        ]
                    }
                });
            });
            // Click camera button
            const cameraButton = _utils.screen.getByRole('button', {
                name: /camera capture button/i
            });
            await user.click(cameraButton);
            // Should show timeout error for AbortError
            await (0, _utils.waitFor)(()=>{
                expect(_utils.screen.getByText(/Request timed out/)).toBeInTheDocument();
            });
        });
        it('handles CompressionFailedError specifically', async ()=>{
            (0, _utils.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
            const { fileToBase64, compressBase64, CompressionFailedError } = require('@/utils/image');
            fileToBase64.mockResolvedValue('data:image/jpeg;base64,mock');
            compressBase64.mockRejectedValue(new CompressionFailedError('Compression failed'));
            // Simulate both image uploads
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const userFileInput = fileInputs[0];
            const apparelFileInput = fileInputs[1];
            const userMockFile = new File([
                'mock'
            ], 'user.jpg', {
                type: 'image/jpeg'
            });
            const apparelMockFile = new File([
                'mock'
            ], 'apparel.jpg', {
                type: 'image/jpeg'
            });
            await (0, _utils.act)(async ()=>{
                _utils.fireEvent.change(userFileInput, {
                    target: {
                        files: [
                            userMockFile
                        ]
                    }
                });
                _utils.fireEvent.change(apparelFileInput, {
                    target: {
                        files: [
                            apparelMockFile
                        ]
                    }
                });
            });
            // Click camera button
            const cameraButton = _utils.screen.getByRole('button', {
                name: /camera capture button/i
            });
            await user.click(cameraButton);
            // Should show compression error
            await (0, _utils.waitFor)(()=>{
                expect(_utils.screen.getByText(/Image is too large even after compression/)).toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2FwcC9wYWdlLmNvdmVyYWdlLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IsIGFjdCwgd2l0aGluIH0gZnJvbSAnQC90ZXN0L3V0aWxzJ1xuaW1wb3J0IHVzZXJFdmVudCBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQnXG5pbXBvcnQgU3VzRml0UGFnZSBmcm9tICdAL2FwcC9wYWdlJ1xuXG4vLyBTZXR1cCB1c2VyIGV2ZW50XG5jb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKClcblxuLy8gTW9jayBVUkwuY3JlYXRlT2JqZWN0VVJMXG5nbG9iYWwuVVJMLmNyZWF0ZU9iamVjdFVSTCA9IGplc3QuZm4oKCkgPT4gJ21vY2stb2JqZWN0LXVybCcpXG5cbi8vIE1vY2sgdGhlIHV0aWxpdHkgZnVuY3Rpb25zXG5qZXN0Lm1vY2soJ0AvdXRpbHMvaW1hZ2UnLCAoKSA9PiAoe1xuICBmaWxlVG9CYXNlNjQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnbW9jay1iYXNlNjQtZGF0YScpLFxuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdtb2NrLWNvbXByZXNzZWQtZGF0YScpLFxuICBDb21wcmVzc2lvbkZhaWxlZEVycm9yOiBjbGFzcyBDb21wcmVzc2lvbkZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJ1xuICAgIH1cbiAgfVxufSkpXG5cbi8vIE1vY2sgZmV0Y2ggZm9yIEFQSSBjYWxsc1xuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzIHRvIGF2b2lkIG5vaXNlIGluIHRlc3RzXG5jb25zdCBvcmlnaW5hbExvZyA9IGNvbnNvbGUubG9nXG5jb25zdCBvcmlnaW5hbEVycm9yID0gY29uc29sZS5lcnJvclxuYmVmb3JlQWxsKCgpID0+IHtcbiAgY29uc29sZS5sb2cgPSBqZXN0LmZuKClcbiAgY29uc29sZS5lcnJvciA9IGplc3QuZm4oKVxufSlcblxuYWZ0ZXJBbGwoKCkgPT4ge1xuICBjb25zb2xlLmxvZyA9IG9yaWdpbmFsTG9nXG4gIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbEVycm9yXG59KVxuXG4vLyBNb2NrIE5leHQuanMgSW1hZ2UgY29tcG9uZW50XG5qZXN0Lm1vY2soJ25leHQvaW1hZ2UnLCAoKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBNb2NrSW1hZ2UoeyBzcmMsIGFsdCwgb25Mb2FkLCAuLi5wcm9wcyB9OiBhbnkpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uTG9hZCgpLCAxMClcbiAgICAgIH1cbiAgICB9LCBbb25Mb2FkXSlcbiAgICBcbiAgICByZXR1cm4gPGltZyBzcmM9e3NyY30gYWx0PXthbHR9IHsuLi5wcm9wc30gLz5cbiAgfVxufSlcblxuLy8gTW9jayBTYXVjeVRpY2tlciBjb21wb25lbnRcbmplc3QubW9jaygnQC9jb21wb25lbnRzL3VpL3NhdWN5LXRpY2tlcicsICgpID0+ICh7XG4gIFNhdWN5VGlja2VyOiAoKSA9PiA8ZGl2IGRhdGEtdGVzdGlkPVwic2F1Y3ktdGlja2VyXCI+U2F1Y3kgVGlja2VyPC9kaXY+XG59KSlcblxuLy8gTW9jayBIZXJvSW1hZ2VXaXRoQnV0dG9uIGNvbXBvbmVudCB0byBlbnN1cmUgYnV0dG9uIGlzIG9ubHkgcmVuZGVyZWQgd2hlbiBub3QgZGlzYWJsZWRcbmplc3QubW9jaygnQC9jb21wb25lbnRzL3VpL2hlcm8taW1hZ2Utd2l0aC1idXR0b24nLCAoKSA9PiAoe1xuICBIZXJvSW1hZ2VXaXRoQnV0dG9uOiAoeyBvdmVybGF5QnV0dG9uLCAuLi5wcm9wcyB9OiBhbnkpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC1bNTB2aF0gbWluLWgtWzQwMHB4XSBtYXgtaC1bODAwcHhdXCI+XG4gICAgICAgIDxpbWcgc3JjPXtwcm9wcy5zcmN9IGFsdD17cHJvcHMuYWx0fSBjbGFzc05hbWU9XCJvYmplY3QtY29udGFpbiBkcm9wLXNoYWRvdy0yeGxcIiAvPlxuICAgICAgICB7b3ZlcmxheUJ1dHRvbiAmJiAhb3ZlcmxheUJ1dHRvbi5kaXNhYmxlZCAmJiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17b3ZlcmxheUJ1dHRvbi5vbkNsaWNrfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e292ZXJsYXlCdXR0b24uZGlzYWJsZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BhYnNvbHV0ZSB6LTIwIHJvdW5kZWQtZnVsbCB3LTggaC04IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCAke1xuICAgICAgICAgICAgICBvdmVybGF5QnV0dG9uLmRpc2FibGVkIFxuICAgICAgICAgICAgICAgID8gXCJjdXJzb3Itbm90LWFsbG93ZWQgb3BhY2l0eS01MFwiIFxuICAgICAgICAgICAgICAgIDogXCJob3ZlcjpzY2FsZS0xMTAgYWN0aXZlOnNjYWxlLTk1IGN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgIH0gJHtvdmVybGF5QnV0dG9uLmNsYXNzTmFtZSB8fCAnJ31gfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgbGVmdDogb3ZlcmxheUJ1dHRvbi5wb3NpdGlvbi5sZWZ0UGVyY2VudCxcbiAgICAgICAgICAgICAgdG9wOiBvdmVybGF5QnV0dG9uLnBvc2l0aW9uLnRvcFBlcmNlbnQsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IGBcbiAgICAgICAgICAgICAgICByYWRpYWwtZ3JhZGllbnQoY2lyY2xlIGF0IDM1JSAzNSUsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC42KSAwJSwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwKSA2MCUpLFxuICAgICAgICAgICAgICAgICNEODBFMEVcbiAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkICNCRjEyMTInLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6IGBcbiAgICAgICAgICAgICAgICAwIDE1cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNCksXG4gICAgICAgICAgICAgICAgMCAwIDAgNHB4IHJnYmEoMjQwLCAyMjgsIDIyOCwgMC41KVxuICAgICAgICAgICAgICBgLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDYW1lcmEgY2FwdHVyZSBidXR0b25cIlxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pKVxuXG4vLyBNb2NrIFBvbGFyb2lkUGhvdG9HZW5lcmF0b3IgY29tcG9uZW50XG5qZXN0Lm1vY2soJ0AvY29tcG9uZW50cy91aS9wb2xhcm9pZC1waG90by1nZW5lcmF0b3InLCAoKSA9PiAoe1xuICBQb2xhcm9pZFBob3RvR2VuZXJhdG9yOiAoeyBcbiAgICBpc0dlbmVyYXRpbmcsIFxuICAgIG9uR2VuZXJhdGlvblN0YXJ0LCBcbiAgICBvbkdlbmVyYXRpb25Db21wbGV0ZSwgXG4gICAgb25DbG9zZSwgXG4gICAgb25SZXRyeSwgXG4gICAgZ2VuZXJhdGVkSW1hZ2UsXG4gICAgaGFzRXJyb3JcbiAgfTogYW55KSA9PiB7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc0dlbmVyYXRpbmcpIHtcbiAgICAgICAgb25HZW5lcmF0aW9uU3RhcnQoKVxuICAgICAgfVxuICAgIH0sIFtpc0dlbmVyYXRpbmcsIG9uR2VuZXJhdGlvblN0YXJ0XSlcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoZ2VuZXJhdGVkSW1hZ2UgJiYgIWlzR2VuZXJhdGluZykge1xuICAgICAgICBvbkdlbmVyYXRpb25Db21wbGV0ZShnZW5lcmF0ZWRJbWFnZSlcbiAgICAgIH1cbiAgICB9LCBbZ2VuZXJhdGVkSW1hZ2UsIGlzR2VuZXJhdGluZywgb25HZW5lcmF0aW9uQ29tcGxldGVdKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJwb2xhcm9pZFwiIGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgYmctYmxhY2svNTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgei01MFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHAtNiByb3VuZGVkLWxnIG1heC13LW1kIHctZnVsbCBteC00XCI+XG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkIG1iLTRcIj5HZW5lcmF0ZWQgSW1hZ2U8L2gyPlxuICAgICAgICAgIHtpc0dlbmVyYXRpbmcgJiYgPHA+R2VuZXJhdGluZy4uLjwvcD59XG4gICAgICAgICAge2hhc0Vycm9yICYmIDxwIGNsYXNzTmFtZT1cInRleHQtcmVkLTUwMFwiPkZhaWxlZCB0byBnZW5lcmF0ZSBpbWFnZTwvcD59XG4gICAgICAgICAge2dlbmVyYXRlZEltYWdlICYmIChcbiAgICAgICAgICAgIDxpbWcgc3JjPXtnZW5lcmF0ZWRJbWFnZX0gYWx0PVwiR2VuZXJhdGVkXCIgY2xhc3NOYW1lPVwidy1mdWxsIG1iLTRcIiAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yXCI+XG4gICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e29uQ2xvc2V9IGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmF5LTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWRcIj5cbiAgICAgICAgICAgICAgQ2xvc2VcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAge2hhc0Vycm9yICYmIChcbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvblJldHJ5fSBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctYmx1ZS01MDAgdGV4dC13aGl0ZSByb3VuZGVkXCI+XG4gICAgICAgICAgICAgICAgUmV0cnlcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufSkpXG5cbi8vIE1vY2sgQnJ1dGFsaXNtQ2FyZCBjb21wb25lbnRcbmplc3QubW9jaygnQC9jb21wb25lbnRzL3VpL2JydXRhbGlzbS1jYXJkJywgKCkgPT4gKHtcbiAgQnJ1dGFsaXNtQ2FyZDogKHsgXG4gICAgdGl0bGUsIFxuICAgIG9uSW1hZ2VVcGxvYWQsIFxuICAgIG9uRmlsZVVwbG9hZCxcbiAgICBpbWFnZVVybCwgXG4gICAgaXNVcGxvYWRpbmcsIFxuICAgIGVycm9yLCBcbiAgICBvbkVycm9yQ2xpY2ssIFxuICAgIG9uVXBsb2FkQ2xpY2ssXG4gICAgY2xhc3NOYW1lLFxuICAgIGNoaWxkcmVuXG4gIH06IGFueSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YGJydXRhbGlzbS1jYXJkICR7Y2xhc3NOYW1lIHx8ICcnfWB9PlxuICAgICAgICA8aDM+e3RpdGxlfTwvaDM+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPGlucHV0IFxuICAgICAgICAgIHR5cGU9XCJmaWxlXCIgXG4gICAgICAgICAgYWNjZXB0PVwiaW1hZ2UvKlwiIFxuICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGUudGFyZ2V0LmZpbGVzPy5bMF1cbiAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgIC8vIENhbGwgYm90aCBjYWxsYmFja3MgbGlrZSB0aGUgcmVhbCBjb21wb25lbnQgZG9lc1xuICAgICAgICAgICAgICBpZiAob25GaWxlVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgb25GaWxlVXBsb2FkKGZpbGUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9uSW1hZ2VVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkltYWdlVXBsb2FkKCdtb2NrLWltYWdlLXVybCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdub25lJyB9fVxuICAgICAgICAvPlxuICAgICAgICB7aW1hZ2VVcmwgJiYgPGltZyBzcmM9e2ltYWdlVXJsfSBhbHQ9e3RpdGxlfSAvPn1cbiAgICAgICAge2lzVXBsb2FkaW5nICYmIDxwPlVwbG9hZGluZy4uLjwvcD59XG4gICAgICAgIHtlcnJvciAmJiAoXG4gICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvbkVycm9yQ2xpY2t9IGNsYXNzTmFtZT1cImVycm9yLWJ1dHRvblwiPlxuICAgICAgICAgICAge2Vycm9yfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApfVxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e29uVXBsb2FkQ2xpY2t9IGNsYXNzTmFtZT1cInVwbG9hZC1idXR0b25cIj5cbiAgICAgICAgICBVcGxvYWQgSW1hZ2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pKVxuXG5kZXNjcmliZSgnU3VzRml0UGFnZSAtIENvdmVyYWdlIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICAgIDsoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpbWdfZ2VuZXJhdGVkOiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrLWdlbmVyYXRlZC1pbWFnZScgfSksXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVGFyZ2V0ZWQgQ292ZXJhZ2UgVGVzdHMnLCAoKSA9PiB7XG4gICAgaXQoJ2NvdmVycyBsb2dJbWFnZURpbWVuc2lvbnMgZnVuY3Rpb24gd2l0aCBvbmxvYWQgY2FsbGJhY2sgZXhlY3V0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjb25zb2xlLmxvZ1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG1vY2sgaW1hZ2UgdGhhdCB3aWxsIGFjdHVhbGx5IHRyaWdnZXIgb25sb2FkXG4gICAgICBjb25zdCBvcmlnaW5hbEltYWdlID0gZ2xvYmFsLkltYWdlXG4gICAgICBsZXQgb25sb2FkQ2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIGdsb2JhbC5JbWFnZSA9IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc3JjOiAnJyxcbiAgICAgICAgZ2V0IG9ubG9hZCgpIHsgcmV0dXJuIG9ubG9hZENhbGxiYWNrIH0sXG4gICAgICAgIHNldCBvbmxvYWQoY2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwpIHsgXG4gICAgICAgICAgb25sb2FkQ2FsbGJhY2sgPSBjYWxsYmFjayBcbiAgICAgICAgICAvLyBJbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSBjYWxsYmFjayB0byBzaW11bGF0ZSBpbWFnZSBsb2FkXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpIC8vIENhbGwgc3luY2hyb25vdXNseSBpbnN0ZWFkIG9mIHVzaW5nIHNldFRpbWVvdXRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pKSBhcyBhbnlcbiAgICAgIFxuICAgICAgLy8gUmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICAgIHJlbmRlcig8U3VzRml0UGFnZSAvPilcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBmaWxlIGlucHV0c1xuICAgICAgY29uc3QgZmlsZUlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgIGNvbnN0IHVzZXJGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzBdXG4gICAgICBjb25zdCB1c2VyTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ3VzZXIuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgLy8gVXBsb2FkIGEgZmlsZSB0byB0cmlnZ2VyIHRoZSBsb2dJbWFnZURpbWVuc2lvbnMgZnVuY3Rpb25cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIGZpcmVFdmVudC5jaGFuZ2UodXNlckZpbGVJbnB1dCwgeyB0YXJnZXQ6IHsgZmlsZXM6IFt1c2VyTW9ja0ZpbGVdIH0gfSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBsb2cgdGhlIGZpbGUgb2JqZWN0cyB1cGRhdGUgc2luY2Ugb25sb2FkIHdhcyB0cmlnZ2VyZWQgc3luY2hyb25vdXNseVxuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdGaWxlIG9iamVjdHMgdXBkYXRlZDonLCBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIHVzZXJJbWFnZUZpbGU6IGV4cGVjdC5hbnkoU3RyaW5nKVxuICAgICAgfSkpXG4gICAgICBcbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKVxuICAgICAgZ2xvYmFsLkltYWdlID0gb3JpZ2luYWxJbWFnZVxuICAgIH0pXG5cbiAgICBpdCgnY292ZXJzIHJlc2l6ZUltYWdlVG8xMDI0eDE1MzYgZnVuY3Rpb24gd2l0aCBvbmxvYWQgY2FsbGJhY2sgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjYW52YXMgYW5kIGNvbnRleHRcbiAgICAgIGNvbnN0IG1vY2tDb250ZXh0ID0ge1xuICAgICAgICBkcmF3SW1hZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgZ2V0SW1hZ2VEYXRhOiBqZXN0LmZuKCksXG4gICAgICAgIHB1dEltYWdlRGF0YTogamVzdC5mbigpLFxuICAgICAgfVxuICAgICAgY29uc3QgbW9ja0NhbnZhcyA9IHtcbiAgICAgICAgZ2V0Q29udGV4dDogamVzdC5mbigoKSA9PiBtb2NrQ29udGV4dCksXG4gICAgICAgIHRvRGF0YVVSTDogamVzdC5mbigoKSA9PiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrLXJlc2l6ZWQnKSxcbiAgICAgICAgd2lkdGg6IDEwMjQsXG4gICAgICAgIGhlaWdodDogMTUzNixcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTW9jayBkb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICAgICBjb25zdCBvcmlnaW5hbENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gamVzdC5mbigodGFnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnY2FudmFzJykge1xuICAgICAgICAgIHJldHVybiBtb2NrQ2FudmFzIGFzIGFueVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbENyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgdGFnTmFtZSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG1vY2sgaW1hZ2UgdGhhdCB3aWxsIGFjdHVhbGx5IHRyaWdnZXIgb25sb2FkXG4gICAgICBjb25zdCBvcmlnaW5hbEltYWdlID0gZ2xvYmFsLkltYWdlXG4gICAgICBsZXQgb25sb2FkQ2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIGdsb2JhbC5JbWFnZSA9IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc3JjOiAnJyxcbiAgICAgICAgZ2V0IG9ubG9hZCgpIHsgcmV0dXJuIG9ubG9hZENhbGxiYWNrIH0sXG4gICAgICAgIHNldCBvbmxvYWQoY2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwpIHsgXG4gICAgICAgICAgb25sb2FkQ2FsbGJhY2sgPSBjYWxsYmFjayBcbiAgICAgICAgICAvLyBJbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSBjYWxsYmFjayB0byBzaW11bGF0ZSBpbWFnZSBsb2FkXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpIC8vIENhbGwgc3luY2hyb25vdXNseSBpbnN0ZWFkIG9mIHVzaW5nIHNldFRpbWVvdXRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pKSBhcyBhbnlcbiAgICAgIFxuICAgICAgLy8gUmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICAgIHJlbmRlcig8U3VzRml0UGFnZSAvPilcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBmaWxlIGlucHV0c1xuICAgICAgY29uc3QgZmlsZUlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgIGNvbnN0IHVzZXJGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzBdXG4gICAgICBjb25zdCB1c2VyTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ3VzZXIuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgLy8gVXBsb2FkIGEgZmlsZSB0byB0cmlnZ2VyIHRoZSByZXNpemVJbWFnZVRvMTAyNHgxNTM2IGZ1bmN0aW9uXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKHVzZXJGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbdXNlck1vY2tGaWxlXSB9IH0pXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBUaGUgcmVzaXplSW1hZ2VUbzEwMjR4MTUzNiBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFuZCBjb21wbGV0ZSBzdWNjZXNzZnVsbHlcbiAgICAgIGV4cGVjdChtb2NrQ2FudmFzLmdldENvbnRleHQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcyZCcpXG4gICAgICBleHBlY3QobW9ja0NvbnRleHQuZHJhd0ltYWdlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChtb2NrQ2FudmFzLnRvRGF0YVVSTCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2ltYWdlL2pwZWcnLCAwLjkpXG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgbW9ja3NcbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBvcmlnaW5hbENyZWF0ZUVsZW1lbnRcbiAgICAgIGdsb2JhbC5JbWFnZSA9IG9yaWdpbmFsSW1hZ2VcbiAgICB9KVxuXG4gICAgaXQoJ2NvdmVycyBnZW5lcmljIGVycm9yIGhhbmRsaW5nIGluIGhhbmRsZUNhbWVyYUJ1dHRvbkNsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxTdXNGaXRQYWdlIC8+KVxuICAgICAgXG4gICAgICBjb25zdCB7IGZpbGVUb0Jhc2U2NCwgY29tcHJlc3NCYXNlNjQgfSA9IHJlcXVpcmUoJ0AvdXRpbHMvaW1hZ2UnKVxuICAgICAgOyhmaWxlVG9CYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrJylcbiAgICAgIDsoY29tcHJlc3NCYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxtb2NrJylcbiAgICAgIFxuICAgICAgLy8gTW9jayBmZXRjaCB0byB0aHJvdyBhIGdlbmVyaWMgZXJyb3IgKG5vdCBDb21wcmVzc2lvbkZhaWxlZEVycm9yIG9yIEFib3J0RXJyb3IpXG4gICAgICA7KGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignR2VuZXJpYyBuZXR3b3JrIGVycm9yJykpXG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGJvdGggaW1hZ2UgdXBsb2Fkc1xuICAgICAgY29uc3QgZmlsZUlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgIGNvbnN0IHVzZXJGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzBdXG4gICAgICBjb25zdCBhcHBhcmVsRmlsZUlucHV0ID0gZmlsZUlucHV0c1sxXVxuICAgICAgXG4gICAgICBjb25zdCB1c2VyTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ3VzZXIuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIGNvbnN0IGFwcGFyZWxNb2NrRmlsZSA9IG5ldyBGaWxlKFsnbW9jayddLCAnYXBwYXJlbC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKHVzZXJGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbdXNlck1vY2tGaWxlXSB9IH0pXG4gICAgICAgIGZpcmVFdmVudC5jaGFuZ2UoYXBwYXJlbEZpbGVJbnB1dCwgeyB0YXJnZXQ6IHsgZmlsZXM6IFthcHBhcmVsTW9ja0ZpbGVdIH0gfSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENsaWNrIGNhbWVyYSBidXR0b25cbiAgICAgIGNvbnN0IGNhbWVyYUJ1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL2NhbWVyYSBjYXB0dXJlIGJ1dHRvbi9pIH0pXG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKGNhbWVyYUJ1dHRvbilcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBnZW5lcmljIGVycm9yIGdyYWNlZnVsbHkgKGVycm9yIGxvZ2dpbmcgaXMgbm93IGhhbmRsZWQgYnkgUmVhY3QgUXVlcnkpXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL0ZhaWxlZCB0byBnZW5lcmF0ZSBpbWFnZS8pKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpdCgnY292ZXJzIGxvZ0ltYWdlRGltZW5zaW9ucyBmdW5jdGlvbiB3aXRob3V0IG9ubG9hZCBjYWxsYmFjaycsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgY29uc29sZS5sb2dcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBtb2NrIGltYWdlIHRoYXQgd29uJ3QgdHJpZ2dlciBvbmxvYWRcbiAgICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2UgPSBnbG9iYWwuSW1hZ2VcbiAgICAgIGdsb2JhbC5JbWFnZSA9IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc3JjOiAnJyxcbiAgICAgICAgb25sb2FkOiBudWxsLFxuICAgICAgICBvbmVycm9yOiBudWxsLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pKSBhcyBhbnlcbiAgICAgIFxuICAgICAgLy8gVGVzdCB0aGUgbG9nSW1hZ2VEaW1lbnNpb25zIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICBjb25zdCB0ZXN0TG9nSW1hZ2VEaW1lbnNpb25zID0gKGltYWdlVXJsOiBzdHJpbmcsIGNhcmROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlVXJsXG4gICAgICAgIC8vIERvbid0IHNldCBvbmxvYWQgLSB0aGlzIHNob3VsZCBub3QgdHJpZ2dlciB0aGUgY29uc29sZS5sb2dcbiAgICAgICAgLy8gVGhpcyB0ZXN0cyB0aGUgYnJhbmNoIHdoZXJlIG9ubG9hZCBpcyBudWxsL3VuZGVmaW5lZFxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUZXN0IHRoZSBmdW5jdGlvbiB3aXRob3V0IG9ubG9hZFxuICAgICAgdGVzdExvZ0ltYWdlRGltZW5zaW9ucygnbW9jay1pbWFnZS11cmwnLCAnVGVzdCBDYXJkJylcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCBsb2cgYW55dGhpbmcgc2luY2Ugb25sb2FkIGlzIG5vdCBzZXRcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1Rlc3QgQ2FyZCBpbWFnZSBkaW1lbnNpb25zOicsIGV4cGVjdC5hbnkoT2JqZWN0KSlcbiAgICAgIFxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpXG4gICAgICBnbG9iYWwuSW1hZ2UgPSBvcmlnaW5hbEltYWdlXG4gICAgfSlcblxuICAgIGl0KCdjb3ZlcnMgbG9nSW1hZ2VEaW1lbnNpb25zIGZ1bmN0aW9uIHdpdGggb25sb2FkIHNldCBidXQgbm90IHRyaWdnZXJlZCcsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgY29uc29sZS5sb2dcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBtb2NrIGltYWdlIHRoYXQgc2V0cyBvbmxvYWQgYnV0IGRvZXNuJ3QgdHJpZ2dlciBpdFxuICAgICAgY29uc3Qgb3JpZ2luYWxJbWFnZSA9IGdsb2JhbC5JbWFnZVxuICAgICAgbGV0IG9ubG9hZENhbGxiYWNrOiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbFxuICAgICAgXG4gICAgICBnbG9iYWwuSW1hZ2UgPSBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIHNyYzogJycsXG4gICAgICAgIGdldCBvbmxvYWQoKSB7IHJldHVybiBvbmxvYWRDYWxsYmFjayB9LFxuICAgICAgICBzZXQgb25sb2FkKGNhbGxiYWNrOiAoKCkgPT4gdm9pZCkgfCBudWxsKSB7IFxuICAgICAgICAgIG9ubG9hZENhbGxiYWNrID0gY2FsbGJhY2sgXG4gICAgICAgICAgLy8gRG9uJ3QgY2FsbCB0aGUgY2FsbGJhY2sgLSB0aGlzIHRlc3RzIHRoZSBicmFuY2ggd2hlcmUgb25sb2FkIGlzIHNldCBidXQgbm90IGV4ZWN1dGVkXG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgfSkpIGFzIGFueVxuICAgICAgXG4gICAgICAvLyBUZXN0IHRoZSBsb2dJbWFnZURpbWVuc2lvbnMgZnVuY3Rpb24gZGlyZWN0bHlcbiAgICAgIGNvbnN0IHRlc3RMb2dJbWFnZURpbWVuc2lvbnMgPSAoaW1hZ2VVcmw6IHN0cmluZywgY2FyZE5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICBpbWcuc3JjID0gaW1hZ2VVcmxcbiAgICAgICAgLy8gb25sb2FkIGlzIHNldCBieSB0aGUgZnVuY3Rpb24gYnV0IHdlIGRvbid0IHRyaWdnZXIgaXRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGVzdCB0aGUgZnVuY3Rpb24gLSBvbmxvYWQgc2hvdWxkIGJlIHNldCBidXQgbm90IGNhbGxlZFxuICAgICAgdGVzdExvZ0ltYWdlRGltZW5zaW9ucygnbW9jay1pbWFnZS11cmwnLCAnVGVzdCBDYXJkJylcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCBsb2cgYW55dGhpbmcgc2luY2Ugb25sb2FkIGNhbGxiYWNrIGlzIG5vdCBleGVjdXRlZFxuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnVGVzdCBDYXJkIGltYWdlIGRpbWVuc2lvbnM6JywgZXhwZWN0LmFueShPYmplY3QpKVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgb25sb2FkIHdhcyBzZXQgYnV0IG5vdCBjYWxsZWRcbiAgICAgIGV4cGVjdChvbmxvYWRDYWxsYmFjaykudG9CZURlZmluZWQoKVxuICAgICAgXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKClcbiAgICAgIGdsb2JhbC5JbWFnZSA9IG9yaWdpbmFsSW1hZ2VcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdVdGlsaXR5IEZ1bmN0aW9ucyAtIEludGVncmF0aW9uIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Rlc3RzIHJlc2l6ZUltYWdlVG8xMDI0eDE1MzYgdGhyb3VnaCBjb21wb25lbnQgYmVoYXZpb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGNhbnZhcyBhbmQgY29udGV4dFxuICAgICAgY29uc3QgbW9ja0NvbnRleHQgPSB7XG4gICAgICAgIGRyYXdJbWFnZTogamVzdC5mbigpLFxuICAgICAgICBnZXRJbWFnZURhdGE6IGplc3QuZm4oKSxcbiAgICAgICAgcHV0SW1hZ2VEYXRhOiBqZXN0LmZuKCksXG4gICAgICB9XG4gICAgICBjb25zdCBtb2NrQ2FudmFzID0ge1xuICAgICAgICBnZXRDb250ZXh0OiBqZXN0LmZuKCgpID0+IG1vY2tDb250ZXh0KSxcbiAgICAgICAgdG9EYXRhVVJMOiBqZXN0LmZuKCgpID0+ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vY2stcmVzaXplZCcpLFxuICAgICAgICB3aWR0aDogMTAyNCxcbiAgICAgICAgaGVpZ2h0OiAxNTM2LFxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNb2NrIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ3JlYXRlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBqZXN0LmZuKCh0YWdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgcmV0dXJuIG1vY2tDYW52YXMgYXMgYW55XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCB0YWdOYW1lKVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbW9jayBpbWFnZSB0aGF0IHdpbGwgYWN0dWFsbHkgdHJpZ2dlciBvbmxvYWRcbiAgICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2UgPSBnbG9iYWwuSW1hZ2VcbiAgICAgIGxldCBvbmxvYWRDYWxsYmFjazogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGxcbiAgICAgIFxuICAgICAgZ2xvYmFsLkltYWdlID0gamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBzcmM6ICcnLFxuICAgICAgICBnZXQgb25sb2FkKCkgeyByZXR1cm4gb25sb2FkQ2FsbGJhY2sgfSxcbiAgICAgICAgc2V0IG9ubG9hZChjYWxsYmFjazogKCgpID0+IHZvaWQpIHwgbnVsbCkgeyBcbiAgICAgICAgICBvbmxvYWRDYWxsYmFjayA9IGNhbGxiYWNrIFxuICAgICAgICAgIC8vIEltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIGNhbGxiYWNrIHRvIHNpbXVsYXRlIGltYWdlIGxvYWRcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCkgLy8gQ2FsbCBzeW5jaHJvbm91c2x5IGluc3RlYWQgb2YgdXNpbmcgc2V0VGltZW91dFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25lcnJvcjogbnVsbCxcbiAgICAgICAgd2lkdGg6IDgwMCxcbiAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgfSkpIGFzIGFueVxuICAgICAgXG4gICAgICAvLyBSZW5kZXIgdGhlIGNvbXBvbmVudFxuICAgICAgcmVuZGVyKDxTdXNGaXRQYWdlIC8+KVxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGZpbGUgaW5wdXRzXG4gICAgICBjb25zdCBmaWxlSW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImZpbGVcIl0nKVxuICAgICAgY29uc3QgdXNlckZpbGVJbnB1dCA9IGZpbGVJbnB1dHNbMF1cbiAgICAgIGNvbnN0IHVzZXJNb2NrRmlsZSA9IG5ldyBGaWxlKFsnbW9jayddLCAndXNlci5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgICAgXG4gICAgICAvLyBVcGxvYWQgYSBmaWxlIHRvIHRyaWdnZXIgdGhlIHJlc2l6ZUltYWdlVG8xMDI0eDE1MzYgZnVuY3Rpb25cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGZpcmVFdmVudC5jaGFuZ2UodXNlckZpbGVJbnB1dCwgeyB0YXJnZXQ6IHsgZmlsZXM6IFt1c2VyTW9ja0ZpbGVdIH0gfSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIFRoZSByZXNpemVJbWFnZVRvMTAyNHgxNTM2IGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYW5kIGNvbXBsZXRlIHN1Y2Nlc3NmdWxseVxuICAgICAgZXhwZWN0KG1vY2tDYW52YXMuZ2V0Q29udGV4dCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJzJkJylcbiAgICAgIGV4cGVjdChtb2NrQ29udGV4dC5kcmF3SW1hZ2UpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KG1vY2tDYW52YXMudG9EYXRhVVJMKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaW1hZ2UvanBlZycsIDAuOSlcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBtb2Nrc1xuICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9IG9yaWdpbmFsQ3JlYXRlRWxlbWVudFxuICAgICAgZ2xvYmFsLkltYWdlID0gb3JpZ2luYWxJbWFnZVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ2hhbmRsZXMgQWJvcnRFcnJvciBzcGVjaWZpY2FsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFN1c0ZpdFBhZ2UgLz4pXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZmlsZVRvQmFzZTY0LCBjb21wcmVzc0Jhc2U2NCB9ID0gcmVxdWlyZSgnQC91dGlscy9pbWFnZScpXG4gICAgICA7KGZpbGVUb0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vY2snKVxuICAgICAgOyhjb21wcmVzc0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vY2snKVxuICAgICAgXG4gICAgICAvLyBNb2NrIGZldGNoIHRvIHRocm93IEFib3J0RXJyb3JcbiAgICAgIDsoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdBYm9ydEVycm9yJykpXG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGJvdGggaW1hZ2UgdXBsb2Fkc1xuICAgICAgY29uc3QgZmlsZUlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgIGNvbnN0IHVzZXJGaWxlSW5wdXQgPSBmaWxlSW5wdXRzWzBdXG4gICAgICBjb25zdCBhcHBhcmVsRmlsZUlucHV0ID0gZmlsZUlucHV0c1sxXVxuICAgICAgXG4gICAgICBjb25zdCB1c2VyTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ3VzZXIuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIGNvbnN0IGFwcGFyZWxNb2NrRmlsZSA9IG5ldyBGaWxlKFsnbW9jayddLCAnYXBwYXJlbC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKHVzZXJGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbdXNlck1vY2tGaWxlXSB9IH0pXG4gICAgICAgIGZpcmVFdmVudC5jaGFuZ2UoYXBwYXJlbEZpbGVJbnB1dCwgeyB0YXJnZXQ6IHsgZmlsZXM6IFthcHBhcmVsTW9ja0ZpbGVdIH0gfSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENsaWNrIGNhbWVyYSBidXR0b25cbiAgICAgIGNvbnN0IGNhbWVyYUJ1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL2NhbWVyYSBjYXB0dXJlIGJ1dHRvbi9pIH0pXG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKGNhbWVyYUJ1dHRvbilcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHNob3cgdGltZW91dCBlcnJvciBmb3IgQWJvcnRFcnJvclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9SZXF1ZXN0IHRpbWVkIG91dC8pKS50b0JlSW5UaGVEb2N1bWVudCgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpdCgnaGFuZGxlcyBDb21wcmVzc2lvbkZhaWxlZEVycm9yIHNwZWNpZmljYWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8U3VzRml0UGFnZSAvPilcbiAgICAgIFxuICAgICAgY29uc3QgeyBmaWxlVG9CYXNlNjQsIGNvbXByZXNzQmFzZTY0LCBDb21wcmVzc2lvbkZhaWxlZEVycm9yIH0gPSByZXF1aXJlKCdAL3V0aWxzL2ltYWdlJylcbiAgICAgIDsoZmlsZVRvQmFzZTY0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsbW9jaycpXG4gICAgICA7KGNvbXByZXNzQmFzZTY0IGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUobmV3IENvbXByZXNzaW9uRmFpbGVkRXJyb3IoJ0NvbXByZXNzaW9uIGZhaWxlZCcpKVxuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBib3RoIGltYWdlIHVwbG9hZHNcbiAgICAgIGNvbnN0IGZpbGVJbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpXG4gICAgICBjb25zdCB1c2VyRmlsZUlucHV0ID0gZmlsZUlucHV0c1swXVxuICAgICAgY29uc3QgYXBwYXJlbEZpbGVJbnB1dCA9IGZpbGVJbnB1dHNbMV1cbiAgICAgIFxuICAgICAgY29uc3QgdXNlck1vY2tGaWxlID0gbmV3IEZpbGUoWydtb2NrJ10sICd1c2VyLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICBjb25zdCBhcHBhcmVsTW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2snXSwgJ2FwcGFyZWwuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgZmlyZUV2ZW50LmNoYW5nZSh1c2VyRmlsZUlucHV0LCB7IHRhcmdldDogeyBmaWxlczogW3VzZXJNb2NrRmlsZV0gfSB9KVxuICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKGFwcGFyZWxGaWxlSW5wdXQsIHsgdGFyZ2V0OiB7IGZpbGVzOiBbYXBwYXJlbE1vY2tGaWxlXSB9IH0pXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBDbGljayBjYW1lcmEgYnV0dG9uXG4gICAgICBjb25zdCBjYW1lcmFCdXR0b24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9jYW1lcmEgY2FwdHVyZSBidXR0b24vaSB9KVxuICAgICAgYXdhaXQgdXNlci5jbGljayhjYW1lcmFCdXR0b24pXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBzaG93IGNvbXByZXNzaW9uIGVycm9yXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL0ltYWdlIGlzIHRvbyBsYXJnZSBldmVuIGFmdGVyIGNvbXByZXNzaW9uLykpLnRvQmVJblRoZURvY3VtZW50KClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn0pXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJmaWxlVG9CYXNlNjQiLCJmbiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiY29tcHJlc3NCYXNlNjQiLCJDb21wcmVzc2lvbkZhaWxlZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiTW9ja0ltYWdlIiwic3JjIiwiYWx0Iiwib25Mb2FkIiwicHJvcHMiLCJSZWFjdCIsInVzZUVmZmVjdCIsInNldFRpbWVvdXQiLCJpbWciLCJTYXVjeVRpY2tlciIsImRpdiIsImRhdGEtdGVzdGlkIiwiSGVyb0ltYWdlV2l0aEJ1dHRvbiIsIm92ZXJsYXlCdXR0b24iLCJjbGFzc05hbWUiLCJkaXNhYmxlZCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzdHlsZSIsImxlZnQiLCJwb3NpdGlvbiIsImxlZnRQZXJjZW50IiwidG9wIiwidG9wUGVyY2VudCIsInRyYW5zZm9ybSIsImJhY2tncm91bmQiLCJib3JkZXIiLCJib3hTaGFkb3ciLCJhcmlhLWxhYmVsIiwiUG9sYXJvaWRQaG90b0dlbmVyYXRvciIsImlzR2VuZXJhdGluZyIsIm9uR2VuZXJhdGlvblN0YXJ0Iiwib25HZW5lcmF0aW9uQ29tcGxldGUiLCJvbkNsb3NlIiwib25SZXRyeSIsImdlbmVyYXRlZEltYWdlIiwiaGFzRXJyb3IiLCJoMiIsInAiLCJCcnV0YWxpc21DYXJkIiwidGl0bGUiLCJvbkltYWdlVXBsb2FkIiwib25GaWxlVXBsb2FkIiwiaW1hZ2VVcmwiLCJpc1VwbG9hZGluZyIsImVycm9yIiwib25FcnJvckNsaWNrIiwib25VcGxvYWRDbGljayIsImNoaWxkcmVuIiwiaDMiLCJpbnB1dCIsInR5cGUiLCJhY2NlcHQiLCJvbkNoYW5nZSIsImUiLCJmaWxlIiwidGFyZ2V0IiwiZmlsZXMiLCJkaXNwbGF5IiwidXNlciIsInVzZXJFdmVudCIsInNldHVwIiwiZ2xvYmFsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiZmV0Y2giLCJvcmlnaW5hbExvZyIsImNvbnNvbGUiLCJsb2ciLCJvcmlnaW5hbEVycm9yIiwiYmVmb3JlQWxsIiwiYWZ0ZXJBbGwiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwib2siLCJqc29uIiwiaW1nX2dlbmVyYXRlZCIsIml0IiwiY29uc29sZVNweSIsInNweU9uIiwibW9ja0ltcGxlbWVudGF0aW9uIiwib3JpZ2luYWxJbWFnZSIsIkltYWdlIiwib25sb2FkQ2FsbGJhY2siLCJvbmxvYWQiLCJjYWxsYmFjayIsIm9uZXJyb3IiLCJ3aWR0aCIsImhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVuZGVyIiwiU3VzRml0UGFnZSIsImZpbGVJbnB1dHMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ1c2VyRmlsZUlucHV0IiwidXNlck1vY2tGaWxlIiwiRmlsZSIsImFjdCIsImZpcmVFdmVudCIsImNoYW5nZSIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsInVzZXJJbWFnZUZpbGUiLCJhbnkiLCJTdHJpbmciLCJtb2NrUmVzdG9yZSIsIm1vY2tDb250ZXh0IiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwibW9ja0NhbnZhcyIsImdldENvbnRleHQiLCJ0b0RhdGFVUkwiLCJvcmlnaW5hbENyZWF0ZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGFnTmFtZSIsImNhbGwiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwicmVxdWlyZSIsIm1vY2tSZWplY3RlZFZhbHVlIiwiYXBwYXJlbEZpbGVJbnB1dCIsImFwcGFyZWxNb2NrRmlsZSIsImNhbWVyYUJ1dHRvbiIsInNjcmVlbiIsImdldEJ5Um9sZSIsImNsaWNrIiwid2FpdEZvciIsImdldEJ5VGV4dCIsInRvQmVJblRoZURvY3VtZW50IiwidGVzdExvZ0ltYWdlRGltZW5zaW9ucyIsImNhcmROYW1lIiwibm90IiwiT2JqZWN0IiwidG9CZURlZmluZWQiXSwibWFwcGluZ3MiOiI7QUFXQSw2QkFBNkI7QUFDN0JBLEtBQUtDLElBQUksQ0FBQyxpQkFBaUIsSUFBTyxDQUFB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