b2331e3fd34e27703a1e1dcb7f5cf802
// Comprehensive Tests for useTryonMutation Hook
// Tests covering all scenarios: success, error, retry, image processing, optimistic updates
"use strict";
// Mock the optimistic updates manager
jest.mock('../../../src/business-layer/utils/optimisticUpdates', ()=>({
        getOptimisticUpdatesManager: ()=>({
                startOptimisticUpdate: mockStartOptimisticUpdate,
                completeOptimisticUpdate: mockCompleteOptimisticUpdate,
                rollbackOptimisticUpdate: mockRollbackOptimisticUpdate
            }),
        OptimisticUpdatesManager: jest.fn(()=>({
                startOptimisticUpdate: mockStartOptimisticUpdate,
                completeOptimisticUpdate: mockCompleteOptimisticUpdate,
                rollbackOptimisticUpdate: mockRollbackOptimisticUpdate
            }))
    }));
// Mock the cache invalidation utility
jest.mock('../../../src/business-layer/utils/cacheInvalidation', ()=>({
        invalidateCacheAfterMutation: jest.fn().mockResolvedValue(undefined),
        getCacheInvalidationManager: jest.fn(()=>({
                invalidateAfterSuccess: jest.fn(),
                invalidateAfterError: jest.fn()
            }))
    }));
// Mock image processing utilities
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        processImageForTryon: jest.fn().mockResolvedValue({
            originalSize: 2048576,
            processedSize: 1048576,
            compressionRatio: 0.5,
            processingTime: 123,
            processedImage: 'data:image/jpeg;base64,processed-image',
            metadata: {
                originalDimensions: {
                    width: 1920,
                    height: 1080
                },
                processedDimensions: {
                    width: 1024,
                    height: 1536
                },
                format: 'jpeg',
                quality: 0.9
            }
        })
    }));
// Mock error handling utilities
jest.mock('../../../src/business-layer/utils/errorHandling', ()=>({
        classifyTryonError: jest.fn((error)=>({
                userMessage: 'An error occurred',
                technicalMessage: error.message || 'Unknown error',
                errorCode: 'UNKNOWN_ERROR',
                retryable: false,
                category: 'NETWORK_ERROR',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        logAndClassifyError: jest.fn((error)=>({
                userMessage: 'An error occurred',
                technicalMessage: error.details || error.message || 'Unknown error',
                errorCode: 'UNKNOWN_ERROR',
                retryable: false,
                category: 'NETWORK_ERROR',
                severity: 'MEDIUM',
                recoveryActions: []
            })),
        isErrorRetryable: jest.fn(()=>true)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useTryonMutation = require("../../../src/business-layer/mutations/useTryonMutation");
const _testUtils = require("../../../src/business-layer/tests/testUtils");
// Create persistent mock functions for optimistic updates
const mockStartOptimisticUpdate = jest.fn(()=>({
        optimisticId: 'mock-optimistic-id',
        variables: {},
        config: {},
        startTime: Date.now(),
        rollbackFunctions: []
    }));
const mockCompleteOptimisticUpdate = jest.fn();
const mockRollbackOptimisticUpdate = jest.fn();
describe('useTryonMutation Hook', ()=>{
    let queryClient;
    let consoleRef;
    beforeEach(()=>{
        queryClient = (0, _testUtils.createTestQueryClient)();
        // Temporarily disable console mocking to see debug logs
        // consoleRef = mockConsole();
        jest.clearAllMocks();
        // Clear the specific optimistic update mocks
        mockStartOptimisticUpdate.mockClear();
        mockCompleteOptimisticUpdate.mockClear();
        mockRollbackOptimisticUpdate.mockClear();
        // Initialize fresh fetch mock for each test
        global.fetch = jest.fn();
    });
    afterEach(()=>{
        queryClient.clear();
        // consoleRef.restore();
        jest.restoreAllMocks();
    });
    describe('Basic Functionality', ()=>{
        it('should initialize with correct default state', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            expect(result.current.data).toBeUndefined();
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.isSuccess).toBe(false);
            expect(result.current.isError).toBe(false);
            expect(result.current.isIdle).toBe(true);
            expect(result.current.status).toBe('idle');
            expect(typeof result.current.mutate).toBe('function');
            expect(typeof result.current.mutateAsync).toBe('function');
            expect(typeof result.current.reset).toBe('function');
        });
        it('should accept custom configuration', ()=>{
            const config = {
                enableRetry: false,
                maxRetries: 5,
                initialRetryDelay: 2000,
                enableOptimisticUpdates: true
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            expect(result.current.isIdle).toBe(true);
        });
    });
    describe('Success Scenarios', ()=>{
        it('should handle successful mutation with base64 strings', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(global.fetch).toHaveBeenCalledWith('/api/tryon', expect.objectContaining({
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: expect.stringContaining('"modelImage":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/mock-model-image"')
            }));
        });
        it('should handle successful mutation with File objects', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const mockFile = new File([
                'mock content'
            ], 'test.jpg', {
                type: 'image/jpeg'
            });
            const variablesWithFiles = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: _testUtils.mockTryonVariables.options
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variablesWithFiles);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
        });
        it('should call success callback on successful mutation', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const onSuccess = jest.fn();
            const config = {
                onSuccess
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(onSuccess).toHaveBeenCalledWith(_testUtils.mockTryonResponse, expect.objectContaining(_testUtils.mockTryonVariables), expect.objectContaining({
                variables: expect.objectContaining(_testUtils.mockTryonVariables),
                startTime: expect.any(Number),
                retryCount: 0
            }));
        });
        it('should handle mutation with timeout configuration', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 100); // 100ms delay
            const variablesWithTimeout = {
                ..._testUtils.mockTryonVariables,
                options: {
                    ..._testUtils.mockTryonVariables.options,
                    timeout: 5000
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variablesWithTimeout);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
        });
    });
    describe('Error Scenarios', ()=>{
        it('should handle API error responses', async ()=>{
            const apiError = {
                ..._testUtils.mockTryonError,
                status: 400
            };
            (0, _testUtils.mockTryonAPI)(undefined, apiError);
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
            expect(result.current.data).toBeUndefined();
            expect(result.current.isLoading).toBe(false);
        });
        it('should call error callback on failed mutation', async ()=>{
            const apiError = {
                ..._testUtils.mockTryonError,
                error: 'An error occurred',
                details: 'API request failed'
            };
            (0, _testUtils.mockTryonAPI)(undefined, apiError);
            const onError = jest.fn();
            const config = {
                onError
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(onError).toHaveBeenCalledWith(expect.objectContaining({
                error: 'An error occurred',
                details: 'API request failed'
            }), expect.objectContaining(_testUtils.mockTryonVariables), expect.objectContaining({
                variables: expect.objectContaining(_testUtils.mockTryonVariables)
            }));
        });
        it('should handle network timeout errors', async ()=>{
            // Mock fetch to simulate timeout
            global.fetch.mockImplementation(()=>{
                return new Promise((_, reject)=>{
                    setTimeout(()=>{
                        const error = new Error('Request timeout');
                        error.name = 'AbortError';
                        reject(error);
                    }, 50);
                });
            });
            const variablesWithShortTimeout = {
                ..._testUtils.mockTryonVariables,
                options: {
                    ..._testUtils.mockTryonVariables.options,
                    timeout: 10 // Very short timeout
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variablesWithShortTimeout);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            }, {
                timeout: 1000
            });
            expect(result.current.error).toBeTruthy();
        });
        it('should handle image processing errors', async ()=>{
            const { processImageForTryon } = require('../../../src/business-layer/utils/imageProcessing');
            processImageForTryon.mockRejectedValueOnce(new Error('Invalid image format'));
            const mockFile = new File([
                'invalid content'
            ], 'test.txt', {
                type: 'text/plain'
            });
            const variablesWithInvalidFile = {
                modelImage: mockFile,
                apparelImages: [
                    mockFile
                ],
                options: _testUtils.mockTryonVariables.options
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(variablesWithInvalidFile);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
        });
    });
    describe('Retry Logic', ()=>{
        it('should retry on retryable errors', async ()=>{
            let callCount = 0;
            global.fetch.mockImplementation(()=>{
                callCount++;
                if (callCount <= 2) {
                    return Promise.resolve({
                        ok: false,
                        status: 500,
                        json: ()=>Promise.resolve({
                                error: 'Internal Server Error'
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(_testUtils.mockTryonResponse)
                });
            });
            const config = {
                enableRetry: true,
                maxRetries: 3,
                initialRetryDelay: 10 // Short delay for testing
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            }, {
                timeout: 5000
            });
            expect(callCount).toBe(3);
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
        });
        it('should not retry when retry is disabled', async ()=>{
            let callCount = 0;
            global.fetch.mockImplementation(()=>{
                callCount++;
                return Promise.resolve({
                    ok: false,
                    status: 500,
                    json: ()=>Promise.resolve({
                            error: 'Internal Server Error'
                        })
                });
            });
            const config = {
                enableRetry: false
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(callCount).toBe(1);
        });
        it('should stop retrying after max retries reached', async ()=>{
            let callCount = 0;
            global.fetch.mockImplementation(()=>{
                callCount++;
                return Promise.resolve({
                    ok: false,
                    status: 500,
                    json: ()=>Promise.resolve({
                            error: 'Internal Server Error'
                        })
                });
            });
            const config = {
                enableRetry: true,
                maxRetries: 2,
                initialRetryDelay: 10
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            }, {
                timeout: 5000
            });
            expect(callCount).toBe(3); // Initial call + 2 retries
        });
    });
    describe('Optimistic Updates Integration', ()=>{
        it('should start optimistic updates when enabled', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const config = {
                enableOptimisticUpdates: true,
                optimisticConfig: {
                    showPreview: true,
                    updateHistory: true
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(mockStartOptimisticUpdate).toHaveBeenCalledWith(expect.objectContaining(_testUtils.mockTryonVariables), expect.objectContaining({
                showPreview: true,
                updateHistory: true
            }));
            expect(mockCompleteOptimisticUpdate).toHaveBeenCalledWith('mock-optimistic-id', _testUtils.mockTryonResponse, expect.any(Object));
        });
        it('should rollback optimistic updates on error', async ()=>{
            // Use direct fetch mock instead of mockTryonAPI
            // Use status 400 (client error) which is NOT retryable by default
            global.fetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                json: ()=>Promise.resolve({
                        error: 'An error occurred',
                        details: 'API request failed',
                        code: 'UNKNOWN_ERROR'
                    })
            });
            const config = {
                enableOptimisticUpdates: true
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            console.log('🟠 TEST: About to call mutate', result.current);
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            console.log('🟠 TEST: After mutate call', result.current);
            await (0, _react.waitFor)(()=>{
                console.log('🟠 TEST: Checking mutation state', {
                    isError: result.current.isError,
                    status: result.current.status,
                    error: result.current.error
                });
                expect(result.current.isError).toBe(true);
            });
            expect(mockRollbackOptimisticUpdate).toHaveBeenCalledWith('mock-optimistic-id', expect.any(Error));
        });
    });
    describe('Cache Invalidation Integration', ()=>{
        it('should invalidate cache on successful mutation', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const { invalidateCacheAfterMutation } = require('../../../src/business-layer/utils/cacheInvalidation');
            const config = {
                cacheInvalidationConfig: {
                    invalidateHistory: true,
                    invalidateUserData: true
                }
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(invalidateCacheAfterMutation).toHaveBeenCalledWith(queryClient, _testUtils.mockTryonResponse, expect.objectContaining(_testUtils.mockTryonVariables), expect.any(Object), expect.objectContaining({
                invalidateHistory: true,
                invalidateUserData: true
            }));
        });
        it('should handle cache invalidation failures gracefully', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const { invalidateCacheAfterMutation } = require('../../../src/business-layer/utils/cacheInvalidation');
            invalidateCacheAfterMutation.mockRejectedValueOnce(new Error('Cache invalidation failed'));
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            // Should still succeed even if cache invalidation fails
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            expect(consoleRef.mocks.warn).toHaveBeenCalledWith('Failed to invalidate cache after mutation:', expect.any(Error));
        });
    });
    describe('Lifecycle Callbacks', ()=>{
        it('should call onMutate callback before mutation', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 100);
            const onMutate = jest.fn().mockResolvedValue({
                customData: 'test'
            });
            const config = {
                onMutate
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            expect(onMutate).toHaveBeenCalledWith(expect.objectContaining(_testUtils.mockTryonVariables));
        });
        it('should call onSettled callback after mutation completes', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const onSettled = jest.fn();
            const config = {
                onSettled
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(onSettled).toHaveBeenCalledWith(_testUtils.mockTryonResponse, null, expect.objectContaining(_testUtils.mockTryonVariables), expect.objectContaining({
                variables: expect.objectContaining(_testUtils.mockTryonVariables)
            }));
        });
        it('should call onSettled callback after mutation fails', async ()=>{
            const apiError = new Error('API request failed');
            (0, _testUtils.mockTryonAPI)(undefined, apiError);
            const onSettled = jest.fn();
            const config = {
                onSettled
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(config), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(onSettled).toHaveBeenCalledWith(undefined, expect.objectContaining({
                error: 'An error occurred'
            }), expect.objectContaining(_testUtils.mockTryonVariables), expect.objectContaining({
                variables: expect.objectContaining(_testUtils.mockTryonVariables)
            }));
        });
    });
    describe('Reset Functionality', ()=>{
        it('should reset mutation state correctly', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse);
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Execute mutation
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSuccess).toBe(true);
            });
            expect(result.current.data).toEqual(_testUtils.mockTryonResponse);
            // Reset mutation
            (0, _react.act)(()=>{
                result.current.reset();
            });
            expect(result.current.data).toBeUndefined();
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.isSuccess).toBe(false);
            expect(result.current.isError).toBe(false);
            expect(result.current.isIdle).toBe(true);
            expect(result.current.status).toBe('idle');
        });
    });
    describe('Edge Cases', ()=>{
        it('should handle malformed API responses', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: true,
                status: 200,
                json: ()=>Promise.resolve({
                        invalid: 'response'
                    }) // Missing img_generated field
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
        });
        it('should handle JSON parsing errors', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: true,
                status: 200,
                json: ()=>Promise.reject(new Error('Invalid JSON'))
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)(), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isError).toBe(true);
            });
            expect(result.current.error).toBeTruthy();
        });
        it('should handle component unmount during mutation', async ()=>{
            (0, _testUtils.mockTryonAPI)(_testUtils.mockTryonResponse, undefined, 500); // Long delay
            const { result, unmount } = (0, _react.renderHook)(()=>(0, _useTryonMutation.useTryonMutation)({
                    enableOptimisticUpdates: true
                }), {
                wrapper: (0, _testUtils.createQueryClientWrapper)(queryClient)
            });
            // Start mutation
            await (0, _react.act)(async ()=>{
                result.current.mutate(_testUtils.mockTryonVariables);
            });
            // Unmount component before mutation completes
            unmount();
            // Wait for cleanup
            await (0, _testUtils.waitForPromises)();
            // Should rollback optimistic updates on unmount
            expect(mockRollbackOptimisticUpdate).toHaveBeenCalledWith('mock-optimistic-id', expect.objectContaining({
                message: 'Component unmounted'
            }));
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL211dGF0aW9ucy91c2VUcnlvbk11dGF0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29tcHJlaGVuc2l2ZSBUZXN0cyBmb3IgdXNlVHJ5b25NdXRhdGlvbiBIb29rXG4vLyBUZXN0cyBjb3ZlcmluZyBhbGwgc2NlbmFyaW9zOiBzdWNjZXNzLCBlcnJvciwgcmV0cnksIGltYWdlIHByb2Nlc3NpbmcsIG9wdGltaXN0aWMgdXBkYXRlc1xuXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IFF1ZXJ5Q2xpZW50IH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5JztcbmltcG9ydCB7IHVzZVRyeW9uTXV0YXRpb24gfSBmcm9tICcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvbXV0YXRpb25zL3VzZVRyeW9uTXV0YXRpb24nO1xuaW1wb3J0IHR5cGUge1xuICBUcnlvbk11dGF0aW9uVmFyaWFibGVzLFxuICBUcnlvbk11dGF0aW9uUmVzcG9uc2UsXG4gIFRyeW9uTXV0YXRpb25FcnJvcixcbiAgVXNlVHJ5b25NdXRhdGlvbkNvbmZpZ1xufSBmcm9tICcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdHlwZXMvdHJ5b24udHlwZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVzdFF1ZXJ5Q2xpZW50LFxuICBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIsXG4gIG1vY2tUcnlvbkFQSSxcbiAgbW9ja1RyeW9uVmFyaWFibGVzLFxuICBtb2NrVHJ5b25SZXNwb25zZSxcbiAgbW9ja1RyeW9uRXJyb3IsXG4gIG1vY2tDb25zb2xlLFxuICB3YWl0Rm9yUHJvbWlzZXNcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3Rlc3RzL3Rlc3RVdGlscyc7XG5cbi8vIENyZWF0ZSBwZXJzaXN0ZW50IG1vY2sgZnVuY3Rpb25zIGZvciBvcHRpbWlzdGljIHVwZGF0ZXNcbmNvbnN0IG1vY2tTdGFydE9wdGltaXN0aWNVcGRhdGUgPSBqZXN0LmZuKCgpID0+ICh7XG4gIG9wdGltaXN0aWNJZDogJ21vY2stb3B0aW1pc3RpYy1pZCcsXG4gIHZhcmlhYmxlczoge30sIC8vIFdpbGwgYmUgcG9wdWxhdGVkIGZyb20gdGVzdCBkYXRhXG4gIGNvbmZpZzoge30sXG4gIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgcm9sbGJhY2tGdW5jdGlvbnM6IFtdXG59KSk7XG5jb25zdCBtb2NrQ29tcGxldGVPcHRpbWlzdGljVXBkYXRlID0gamVzdC5mbigpO1xuY29uc3QgbW9ja1JvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSA9IGplc3QuZm4oKTtcblxuLy8gTW9jayB0aGUgb3B0aW1pc3RpYyB1cGRhdGVzIG1hbmFnZXJcbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL29wdGltaXN0aWNVcGRhdGVzJywgKCkgPT4gKHtcbiAgZ2V0T3B0aW1pc3RpY1VwZGF0ZXNNYW5hZ2VyOiAoKSA9PiAoe1xuICAgIHN0YXJ0T3B0aW1pc3RpY1VwZGF0ZTogbW9ja1N0YXJ0T3B0aW1pc3RpY1VwZGF0ZSxcbiAgICBjb21wbGV0ZU9wdGltaXN0aWNVcGRhdGU6IG1vY2tDb21wbGV0ZU9wdGltaXN0aWNVcGRhdGUsXG4gICAgcm9sbGJhY2tPcHRpbWlzdGljVXBkYXRlOiBtb2NrUm9sbGJhY2tPcHRpbWlzdGljVXBkYXRlXG4gIH0pLFxuICBPcHRpbWlzdGljVXBkYXRlc01hbmFnZXI6IGplc3QuZm4oKCkgPT4gKHtcbiAgICBzdGFydE9wdGltaXN0aWNVcGRhdGU6IG1vY2tTdGFydE9wdGltaXN0aWNVcGRhdGUsXG4gICAgY29tcGxldGVPcHRpbWlzdGljVXBkYXRlOiBtb2NrQ29tcGxldGVPcHRpbWlzdGljVXBkYXRlLFxuICAgIHJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZTogbW9ja1JvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZVxuICB9KSlcbn0pKTtcblxuLy8gTW9jayB0aGUgY2FjaGUgaW52YWxpZGF0aW9uIHV0aWxpdHlcbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2NhY2hlSW52YWxpZGF0aW9uJywgKCkgPT4gKHtcbiAgaW52YWxpZGF0ZUNhY2hlQWZ0ZXJNdXRhdGlvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCksXG4gIGdldENhY2hlSW52YWxpZGF0aW9uTWFuYWdlcjogamVzdC5mbigoKSA9PiAoe1xuICAgIGludmFsaWRhdGVBZnRlclN1Y2Nlc3M6IGplc3QuZm4oKSxcbiAgICBpbnZhbGlkYXRlQWZ0ZXJFcnJvcjogamVzdC5mbigpXG4gIH0pKVxufSkpO1xuXG4vLyBNb2NrIGltYWdlIHByb2Nlc3NpbmcgdXRpbGl0aWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9pbWFnZVByb2Nlc3NpbmcnLCAoKSA9PiAoe1xuICBwcm9jZXNzSW1hZ2VGb3JUcnlvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICBvcmlnaW5hbFNpemU6IDIwNDg1NzYsXG4gICAgcHJvY2Vzc2VkU2l6ZTogMTA0ODU3NixcbiAgICBjb21wcmVzc2lvblJhdGlvOiAwLjUsXG4gICAgcHJvY2Vzc2luZ1RpbWU6IDEyMyxcbiAgICBwcm9jZXNzZWRJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQscHJvY2Vzc2VkLWltYWdlJyxcbiAgICBtZXRhZGF0YToge1xuICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAgfSxcbiAgICAgIHByb2Nlc3NlZERpbWVuc2lvbnM6IHsgd2lkdGg6IDEwMjQsIGhlaWdodDogMTUzNiB9LFxuICAgICAgZm9ybWF0OiAnanBlZycsXG4gICAgICBxdWFsaXR5OiAwLjlcbiAgICB9XG4gIH0pXG59KSk7XG5cbi8vIE1vY2sgZXJyb3IgaGFuZGxpbmcgdXRpbGl0aWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9lcnJvckhhbmRsaW5nJywgKCkgPT4gKHtcbiAgY2xhc3NpZnlUcnlvbkVycm9yOiBqZXN0LmZuKChlcnJvcikgPT4gKHtcbiAgICB1c2VyTWVzc2FnZTogJ0FuIGVycm9yIG9jY3VycmVkJyxcbiAgICB0ZWNobmljYWxNZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICBlcnJvckNvZGU6ICdVTktOT1dOX0VSUk9SJyxcbiAgICByZXRyeWFibGU6IGZhbHNlLFxuICAgIGNhdGVnb3J5OiAnTkVUV09SS19FUlJPUicsXG4gICAgc2V2ZXJpdHk6ICdNRURJVU0nLFxuICAgIHJlY292ZXJ5QWN0aW9uczogW11cbiAgfSkpLFxuICBsb2dBbmRDbGFzc2lmeUVycm9yOiBqZXN0LmZuKChlcnJvcikgPT4gKHtcbiAgICB1c2VyTWVzc2FnZTogJ0FuIGVycm9yIG9jY3VycmVkJyxcbiAgICB0ZWNobmljYWxNZXNzYWdlOiBlcnJvci5kZXRhaWxzIHx8IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgIGVycm9yQ29kZTogJ1VOS05PV05fRVJST1InLFxuICAgIHJldHJ5YWJsZTogZmFsc2UsXG4gICAgY2F0ZWdvcnk6ICdORVRXT1JLX0VSUk9SJyxcbiAgICBzZXZlcml0eTogJ01FRElVTScsXG4gICAgcmVjb3ZlcnlBY3Rpb25zOiBbXVxuICB9KSksXG4gIGlzRXJyb3JSZXRyeWFibGU6IGplc3QuZm4oKCkgPT4gdHJ1ZSlcbn0pKTtcblxuZGVzY3JpYmUoJ3VzZVRyeW9uTXV0YXRpb24gSG9vaycsICgpID0+IHtcbiAgbGV0IHF1ZXJ5Q2xpZW50OiBRdWVyeUNsaWVudDtcbiAgbGV0IGNvbnNvbGVSZWY6IFJldHVyblR5cGU8dHlwZW9mIG1vY2tDb25zb2xlPjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBxdWVyeUNsaWVudCA9IGNyZWF0ZVRlc3RRdWVyeUNsaWVudCgpO1xuICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGUgY29uc29sZSBtb2NraW5nIHRvIHNlZSBkZWJ1ZyBsb2dzXG4gICAgLy8gY29uc29sZVJlZiA9IG1vY2tDb25zb2xlKCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgLy8gQ2xlYXIgdGhlIHNwZWNpZmljIG9wdGltaXN0aWMgdXBkYXRlIG1vY2tzXG4gICAgbW9ja1N0YXJ0T3B0aW1pc3RpY1VwZGF0ZS5tb2NrQ2xlYXIoKTtcbiAgICBtb2NrQ29tcGxldGVPcHRpbWlzdGljVXBkYXRlLm1vY2tDbGVhcigpO1xuICAgIG1vY2tSb2xsYmFja09wdGltaXN0aWNVcGRhdGUubW9ja0NsZWFyKCk7XG4gICAgLy8gSW5pdGlhbGl6ZSBmcmVzaCBmZXRjaCBtb2NrIGZvciBlYWNoIHRlc3RcbiAgICBnbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgcXVlcnlDbGllbnQuY2xlYXIoKTtcbiAgICAvLyBjb25zb2xlUmVmLnJlc3RvcmUoKTtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFzaWMgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgd2l0aCBjb3JyZWN0IGRlZmF1bHQgc3RhdGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0lkbGUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3RhdHVzKS50b0JlKCdpZGxlJyk7XG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSkudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0LmN1cnJlbnQubXV0YXRlQXN5bmMpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5jdXJyZW50LnJlc2V0KS50b0JlKCdmdW5jdGlvbicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhY2NlcHQgY3VzdG9tIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWc6IFVzZVRyeW9uTXV0YXRpb25Db25maWcgPSB7XG4gICAgICAgIGVuYWJsZVJldHJ5OiBmYWxzZSxcbiAgICAgICAgbWF4UmV0cmllczogNSxcbiAgICAgICAgaW5pdGlhbFJldHJ5RGVsYXk6IDIwMDAsXG4gICAgICAgIGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbihjb25maWcpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNJZGxlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3VjY2VzcyBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3VjY2Vzc2Z1bCBtdXRhdGlvbiB3aXRoIGJhc2U2NCBzdHJpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAge1xuICAgICAgICAgIHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudClcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKG1vY2tUcnlvblZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwobW9ja1RyeW9uUmVzcG9uc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJy9hcGkvdHJ5b24nLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1wibW9kZWxJbWFnZVwiOlwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvbW9jay1tb2RlbC1pbWFnZVwiJylcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzdWNjZXNzZnVsIG11dGF0aW9uIHdpdGggRmlsZSBvYmplY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ21vY2sgY29udGVudCddLCAndGVzdC5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlc1dpdGhGaWxlcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZV0sXG4gICAgICAgIG9wdGlvbnM6IG1vY2tUcnlvblZhcmlhYmxlcy5vcHRpb25zXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzV2l0aEZpbGVzIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwobW9ja1RyeW9uUmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjYWxsIHN1Y2Nlc3MgY2FsbGJhY2sgb24gc3VjY2Vzc2Z1bCBtdXRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IG9uU3VjY2VzcyA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IGNvbmZpZzogVXNlVHJ5b25NdXRhdGlvbkNvbmZpZyA9IHsgb25TdWNjZXNzIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrVHJ5b25SZXNwb25zZSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcobW9ja1RyeW9uVmFyaWFibGVzKSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHZhcmlhYmxlczogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcobW9ja1RyeW9uVmFyaWFibGVzKSxcbiAgICAgICAgICBzdGFydFRpbWU6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgICByZXRyeUNvdW50OiAwXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXV0YXRpb24gd2l0aCB0aW1lb3V0IGNvbmZpZ3VyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgMTAwKTsgLy8gMTAwbXMgZGVsYXlcblxuICAgICAgY29uc3QgdmFyaWFibGVzV2l0aFRpbWVvdXQgPSB7XG4gICAgICAgIC4uLm1vY2tUcnlvblZhcmlhYmxlcyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIC4uLm1vY2tUcnlvblZhcmlhYmxlcy5vcHRpb25zLFxuICAgICAgICAgIHRpbWVvdXQ6IDUwMDBcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAge1xuICAgICAgICAgIHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudClcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKHZhcmlhYmxlc1dpdGhUaW1lb3V0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrVHJ5b25SZXNwb25zZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQVBJIGVycm9yIHJlc3BvbnNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFwaUVycm9yID0ge1xuICAgICAgICAuLi5tb2NrVHJ5b25FcnJvcixcbiAgICAgICAgc3RhdHVzOiA0MDBcbiAgICAgIH07XG4gICAgICBtb2NrVHJ5b25BUEkodW5kZWZpbmVkLCBhcGlFcnJvcik7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNFcnJvcikudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVUcnV0aHkoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2FsbCBlcnJvciBjYWxsYmFjayBvbiBmYWlsZWQgbXV0YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhcGlFcnJvciA9IHtcbiAgICAgICAgLi4ubW9ja1RyeW9uRXJyb3IsXG4gICAgICAgIGVycm9yOiAnQW4gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICBkZXRhaWxzOiAnQVBJIHJlcXVlc3QgZmFpbGVkJ1xuICAgICAgfTtcbiAgICAgIG1vY2tUcnlvbkFQSSh1bmRlZmluZWQsIGFwaUVycm9yKTtcblxuICAgICAgY29uc3Qgb25FcnJvciA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IGNvbmZpZzogVXNlVHJ5b25NdXRhdGlvbkNvbmZpZyA9IHsgb25FcnJvciB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbihjb25maWcpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUobW9ja1RyeW9uVmFyaWFibGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZXJyb3I6ICdBbiBlcnJvciBvY2N1cnJlZCcsXG4gICAgICAgICAgZGV0YWlsczogJ0FQSSByZXF1ZXN0IGZhaWxlZCdcbiAgICAgICAgfSksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKG1vY2tUcnlvblZhcmlhYmxlcyksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICB2YXJpYWJsZXM6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKG1vY2tUcnlvblZhcmlhYmxlcylcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIHRpbWVvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBmZXRjaCB0byBzaW11bGF0ZSB0aW1lb3V0XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFyaWFibGVzV2l0aFNob3J0VGltZW91dCA9IHtcbiAgICAgICAgLi4ubW9ja1RyeW9uVmFyaWFibGVzLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgLi4ubW9ja1RyeW9uVmFyaWFibGVzLm9wdGlvbnMsXG4gICAgICAgICAgdGltZW91dDogMTAgLy8gVmVyeSBzaG9ydCB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKCksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZSh2YXJpYWJsZXNXaXRoU2hvcnRUaW1lb3V0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDEwMDAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW1hZ2UgcHJvY2Vzc2luZyBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHByb2Nlc3NJbWFnZUZvclRyeW9uIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJyk7XG4gICAgICBwcm9jZXNzSW1hZ2VGb3JUcnlvbi5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdJbnZhbGlkIGltYWdlIGZvcm1hdCcpKTtcblxuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ2ludmFsaWQgY29udGVudCddLCAndGVzdC50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlc1dpdGhJbnZhbGlkRmlsZSA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogbW9ja0ZpbGUsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFttb2NrRmlsZV0sXG4gICAgICAgIG9wdGlvbnM6IG1vY2tUcnlvblZhcmlhYmxlcy5vcHRpb25zXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUodmFyaWFibGVzV2l0aEludmFsaWRGaWxlIGFzIGFueSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZVRydXRoeSgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmV0cnkgTG9naWMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXRyeSBvbiByZXRyeWFibGUgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY2FsbENvdW50Kys7XG4gICAgICAgIGlmIChjYWxsQ291bnQgPD0gMikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBlcnJvcjogJ0ludGVybmFsIFNlcnZlciBFcnJvcicgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1RyeW9uUmVzcG9uc2UpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbmZpZzogVXNlVHJ5b25NdXRhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgZW5hYmxlUmV0cnk6IHRydWUsXG4gICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICAgIGluaXRpYWxSZXRyeURlbGF5OiAxMCAvLyBTaG9ydCBkZWxheSBmb3IgdGVzdGluZ1xuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oY29uZmlnKSxcbiAgICAgICAge1xuICAgICAgICAgIHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudClcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKG1vY2tUcnlvblZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDUwMDAgfSk7XG5cbiAgICAgIGV4cGVjdChjYWxsQ291bnQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrVHJ5b25SZXNwb25zZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSB3aGVuIHJldHJ5IGlzIGRpc2FibGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY2FsbENvdW50Kys7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBlcnJvcjogJ0ludGVybmFsIFNlcnZlciBFcnJvcicgfSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29uZmlnOiBVc2VUcnlvbk11dGF0aW9uQ29uZmlnID0ge1xuICAgICAgICBlbmFibGVSZXRyeTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNFcnJvcikudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoY2FsbENvdW50KS50b0JlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIHJldHJ5aW5nIGFmdGVyIG1heCByZXRyaWVzIHJlYWNoZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjYWxsQ291bnQrKztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IGVycm9yOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyB9KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb25maWc6IFVzZVRyeW9uTXV0YXRpb25Db25maWcgPSB7XG4gICAgICAgIGVuYWJsZVJldHJ5OiB0cnVlLFxuICAgICAgICBtYXhSZXRyaWVzOiAyLFxuICAgICAgICBpbml0aWFsUmV0cnlEZWxheTogMTBcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNFcnJvcikudG9CZSh0cnVlKTtcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KTtcblxuICAgICAgZXhwZWN0KGNhbGxDb3VudCkudG9CZSgzKTsgLy8gSW5pdGlhbCBjYWxsICsgMiByZXRyaWVzXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdPcHRpbWlzdGljIFVwZGF0ZXMgSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdGFydCBvcHRpbWlzdGljIHVwZGF0ZXMgd2hlbiBlbmFibGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgY29uZmlnOiBVc2VUcnlvbk11dGF0aW9uQ29uZmlnID0ge1xuICAgICAgICBlbmFibGVPcHRpbWlzdGljVXBkYXRlczogdHJ1ZSxcbiAgICAgICAgb3B0aW1pc3RpY0NvbmZpZzoge1xuICAgICAgICAgIHNob3dQcmV2aWV3OiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZUhpc3Rvcnk6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oY29uZmlnKSxcbiAgICAgICAge1xuICAgICAgICAgIHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudClcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKG1vY2tUcnlvblZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tTdGFydE9wdGltaXN0aWNVcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyhtb2NrVHJ5b25WYXJpYWJsZXMpLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc2hvd1ByZXZpZXc6IHRydWUsXG4gICAgICAgICAgdXBkYXRlSGlzdG9yeTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrQ29tcGxldGVPcHRpbWlzdGljVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ21vY2stb3B0aW1pc3RpYy1pZCcsXG4gICAgICAgIG1vY2tUcnlvblJlc3BvbnNlLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJvbGxiYWNrIG9wdGltaXN0aWMgdXBkYXRlcyBvbiBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFVzZSBkaXJlY3QgZmV0Y2ggbW9jayBpbnN0ZWFkIG9mIG1vY2tUcnlvbkFQSVxuICAgICAgLy8gVXNlIHN0YXR1cyA0MDAgKGNsaWVudCBlcnJvcikgd2hpY2ggaXMgTk9UIHJldHJ5YWJsZSBieSBkZWZhdWx0XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBlcnJvcjogJ0FuIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICBkZXRhaWxzOiAnQVBJIHJlcXVlc3QgZmFpbGVkJyxcbiAgICAgICAgICBjb2RlOiAnVU5LTk9XTl9FUlJPUidcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb25maWc6IFVzZVRyeW9uTXV0YXRpb25Db25maWcgPSB7XG4gICAgICAgIGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbihjb25maWcpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+foCBURVNUOiBBYm91dCB0byBjYWxsIG11dGF0ZScsIHJlc3VsdC5jdXJyZW50KTtcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygn8J+foCBURVNUOiBBZnRlciBtdXRhdGUgY2FsbCcsIHJlc3VsdC5jdXJyZW50KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5+gIFRFU1Q6IENoZWNraW5nIG11dGF0aW9uIHN0YXRlJywgeyBcbiAgICAgICAgICBpc0Vycm9yOiByZXN1bHQuY3VycmVudC5pc0Vycm9yLCBcbiAgICAgICAgICBzdGF0dXM6IHJlc3VsdC5jdXJyZW50LnN0YXR1cyxcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmN1cnJlbnQuZXJyb3IgXG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNFcnJvcikudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1JvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdtb2NrLW9wdGltaXN0aWMtaWQnLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhY2hlIEludmFsaWRhdGlvbiBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGludmFsaWRhdGUgY2FjaGUgb24gc3VjY2Vzc2Z1bCBtdXRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHsgaW52YWxpZGF0ZUNhY2hlQWZ0ZXJNdXRhdGlvbiB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3V0aWxzL2NhY2hlSW52YWxpZGF0aW9uJyk7XG5cbiAgICAgIGNvbnN0IGNvbmZpZzogVXNlVHJ5b25NdXRhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgY2FjaGVJbnZhbGlkYXRpb25Db25maWc6IHtcbiAgICAgICAgICBpbnZhbGlkYXRlSGlzdG9yeTogdHJ1ZSxcbiAgICAgICAgICBpbnZhbGlkYXRlVXNlckRhdGE6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oY29uZmlnKSxcbiAgICAgICAge1xuICAgICAgICAgIHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudClcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKG1vY2tUcnlvblZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGludmFsaWRhdGVDYWNoZUFmdGVyTXV0YXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBxdWVyeUNsaWVudCxcbiAgICAgICAgbW9ja1RyeW9uUmVzcG9uc2UsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKG1vY2tUcnlvblZhcmlhYmxlcyksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGludmFsaWRhdGVIaXN0b3J5OiB0cnVlLFxuICAgICAgICAgIGludmFsaWRhdGVVc2VyRGF0YTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIGludmFsaWRhdGlvbiBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyBpbnZhbGlkYXRlQ2FjaGVBZnRlck11dGF0aW9uIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvY2FjaGVJbnZhbGlkYXRpb24nKTtcbiAgICAgIGludmFsaWRhdGVDYWNoZUFmdGVyTXV0YXRpb24ubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignQ2FjaGUgaW52YWxpZGF0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAge1xuICAgICAgICAgIHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudClcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKG1vY2tUcnlvblZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIHN0aWxsIHN1Y2NlZWQgZXZlbiBpZiBjYWNoZSBpbnZhbGlkYXRpb24gZmFpbHNcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tUcnlvblJlc3BvbnNlKTtcbiAgICAgIGV4cGVjdChjb25zb2xlUmVmLm1vY2tzLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnRmFpbGVkIHRvIGludmFsaWRhdGUgY2FjaGUgYWZ0ZXIgbXV0YXRpb246JyxcbiAgICAgICAgZXhwZWN0LmFueShFcnJvcilcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMaWZlY3ljbGUgQ2FsbGJhY2tzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY2FsbCBvbk11dGF0ZSBjYWxsYmFjayBiZWZvcmUgbXV0YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgMTAwKTtcblxuICAgICAgY29uc3Qgb25NdXRhdGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBjdXN0b21EYXRhOiAndGVzdCcgfSk7XG4gICAgICBjb25zdCBjb25maWc6IFVzZVRyeW9uTXV0YXRpb25Db25maWcgPSB7IG9uTXV0YXRlIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvbk11dGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKG1vY2tUcnlvblZhcmlhYmxlcylcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNhbGwgb25TZXR0bGVkIGNhbGxiYWNrIGFmdGVyIG11dGF0aW9uIGNvbXBsZXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tUcnlvbkFQSShtb2NrVHJ5b25SZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IG9uU2V0dGxlZCA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IGNvbmZpZzogVXNlVHJ5b25NdXRhdGlvbkNvbmZpZyA9IHsgb25TZXR0bGVkIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvblNldHRsZWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrVHJ5b25SZXNwb25zZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcobW9ja1RyeW9uVmFyaWFibGVzKSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHZhcmlhYmxlczogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcobW9ja1RyeW9uVmFyaWFibGVzKVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2FsbCBvblNldHRsZWQgY2FsbGJhY2sgYWZ0ZXIgbXV0YXRpb24gZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcignQVBJIHJlcXVlc3QgZmFpbGVkJyk7XG4gICAgICBtb2NrVHJ5b25BUEkodW5kZWZpbmVkLCBhcGlFcnJvcik7XG5cbiAgICAgIGNvbnN0IG9uU2V0dGxlZCA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IGNvbmZpZzogVXNlVHJ5b25NdXRhdGlvbkNvbmZpZyA9IHsgb25TZXR0bGVkIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKFxuICAgICAgICAoKSA9PiB1c2VUcnlvbk11dGF0aW9uKGNvbmZpZyksXG4gICAgICAgIHtcbiAgICAgICAgICB3cmFwcGVyOiBjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIocXVlcnlDbGllbnQpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm11dGF0ZShtb2NrVHJ5b25WYXJpYWJsZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNFcnJvcikudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3Qob25TZXR0bGVkKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZXJyb3I6ICdBbiBlcnJvciBvY2N1cnJlZCdcbiAgICAgICAgfSksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKG1vY2tUcnlvblZhcmlhYmxlcyksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICB2YXJpYWJsZXM6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKG1vY2tUcnlvblZhcmlhYmxlcylcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZXNldCBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVzZXQgbXV0YXRpb24gc3RhdGUgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1RyeW9uQVBJKG1vY2tUcnlvblJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soXG4gICAgICAgICgpID0+IHVzZVRyeW9uTXV0YXRpb24oKSxcbiAgICAgICAge1xuICAgICAgICAgIHdyYXBwZXI6IGNyZWF0ZVF1ZXJ5Q2xpZW50V3JhcHBlcihxdWVyeUNsaWVudClcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gRXhlY3V0ZSBtdXRhdGlvblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKG1vY2tUcnlvblZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwobW9ja1RyeW9uUmVzcG9uc2UpO1xuXG4gICAgICAvLyBSZXNldCBtdXRhdGlvblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQucmVzZXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Vycm9yKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0lkbGUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3RhdHVzKS50b0JlKCdpZGxlJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCBBUEkgcmVzcG9uc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgaW52YWxpZDogJ3Jlc3BvbnNlJyB9KSAvLyBNaXNzaW5nIGltZ19nZW5lcmF0ZWQgZmllbGRcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUobW9ja1RyeW9uVmFyaWFibGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlVHJ1dGh5KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBKU09OIHBhcnNpbmcgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIEpTT04nKSlcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbigpLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5tdXRhdGUobW9ja1RyeW9uVmFyaWFibGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlVHJ1dGh5KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wb25lbnQgdW5tb3VudCBkdXJpbmcgbXV0YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVHJ5b25BUEkobW9ja1RyeW9uUmVzcG9uc2UsIHVuZGVmaW5lZCwgNTAwKTsgLy8gTG9uZyBkZWxheVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgdW5tb3VudCB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKCkgPT4gdXNlVHJ5b25NdXRhdGlvbih7IGVuYWJsZU9wdGltaXN0aWNVcGRhdGVzOiB0cnVlIH0pLFxuICAgICAgICB7XG4gICAgICAgICAgd3JhcHBlcjogY3JlYXRlUXVlcnlDbGllbnRXcmFwcGVyKHF1ZXJ5Q2xpZW50KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBTdGFydCBtdXRhdGlvblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubXV0YXRlKG1vY2tUcnlvblZhcmlhYmxlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVW5tb3VudCBjb21wb25lbnQgYmVmb3JlIG11dGF0aW9uIGNvbXBsZXRlc1xuICAgICAgdW5tb3VudCgpO1xuXG4gICAgICAvLyBXYWl0IGZvciBjbGVhbnVwXG4gICAgICBhd2FpdCB3YWl0Rm9yUHJvbWlzZXMoKTtcblxuICAgICAgLy8gU2hvdWxkIHJvbGxiYWNrIG9wdGltaXN0aWMgdXBkYXRlcyBvbiB1bm1vdW50XG4gICAgICBleHBlY3QobW9ja1JvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdtb2NrLW9wdGltaXN0aWMtaWQnLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IG1lc3NhZ2U6ICdDb21wb25lbnQgdW5tb3VudGVkJyB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJnZXRPcHRpbWlzdGljVXBkYXRlc01hbmFnZXIiLCJzdGFydE9wdGltaXN0aWNVcGRhdGUiLCJtb2NrU3RhcnRPcHRpbWlzdGljVXBkYXRlIiwiY29tcGxldGVPcHRpbWlzdGljVXBkYXRlIiwibW9ja0NvbXBsZXRlT3B0aW1pc3RpY1VwZGF0ZSIsInJvbGxiYWNrT3B0aW1pc3RpY1VwZGF0ZSIsIm1vY2tSb2xsYmFja09wdGltaXN0aWNVcGRhdGUiLCJPcHRpbWlzdGljVXBkYXRlc01hbmFnZXIiLCJmbiIsImludmFsaWRhdGVDYWNoZUFmdGVyTXV0YXRpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVuZGVmaW5lZCIsImdldENhY2hlSW52YWxpZGF0aW9uTWFuYWdlciIsImludmFsaWRhdGVBZnRlclN1Y2Nlc3MiLCJpbnZhbGlkYXRlQWZ0ZXJFcnJvciIsInByb2Nlc3NJbWFnZUZvclRyeW9uIiwib3JpZ2luYWxTaXplIiwicHJvY2Vzc2VkU2l6ZSIsImNvbXByZXNzaW9uUmF0aW8iLCJwcm9jZXNzaW5nVGltZSIsInByb2Nlc3NlZEltYWdlIiwibWV0YWRhdGEiLCJvcmlnaW5hbERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsInByb2Nlc3NlZERpbWVuc2lvbnMiLCJmb3JtYXQiLCJxdWFsaXR5IiwiY2xhc3NpZnlUcnlvbkVycm9yIiwiZXJyb3IiLCJ1c2VyTWVzc2FnZSIsInRlY2huaWNhbE1lc3NhZ2UiLCJtZXNzYWdlIiwiZXJyb3JDb2RlIiwicmV0cnlhYmxlIiwiY2F0ZWdvcnkiLCJzZXZlcml0eSIsInJlY292ZXJ5QWN0aW9ucyIsImxvZ0FuZENsYXNzaWZ5RXJyb3IiLCJkZXRhaWxzIiwiaXNFcnJvclJldHJ5YWJsZSIsIm9wdGltaXN0aWNJZCIsInZhcmlhYmxlcyIsImNvbmZpZyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJyb2xsYmFja0Z1bmN0aW9ucyIsImRlc2NyaWJlIiwicXVlcnlDbGllbnQiLCJjb25zb2xlUmVmIiwiYmVmb3JlRWFjaCIsImNyZWF0ZVRlc3RRdWVyeUNsaWVudCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJnbG9iYWwiLCJmZXRjaCIsImFmdGVyRWFjaCIsImNsZWFyIiwicmVzdG9yZUFsbE1vY2tzIiwiaXQiLCJyZXN1bHQiLCJyZW5kZXJIb29rIiwidXNlVHJ5b25NdXRhdGlvbiIsIndyYXBwZXIiLCJjcmVhdGVRdWVyeUNsaWVudFdyYXBwZXIiLCJleHBlY3QiLCJjdXJyZW50IiwiZGF0YSIsInRvQmVVbmRlZmluZWQiLCJ0b0JlTnVsbCIsImlzTG9hZGluZyIsInRvQmUiLCJpc1N1Y2Nlc3MiLCJpc0Vycm9yIiwiaXNJZGxlIiwic3RhdHVzIiwibXV0YXRlIiwibXV0YXRlQXN5bmMiLCJyZXNldCIsImVuYWJsZVJldHJ5IiwibWF4UmV0cmllcyIsImluaXRpYWxSZXRyeURlbGF5IiwiZW5hYmxlT3B0aW1pc3RpY1VwZGF0ZXMiLCJtb2NrVHJ5b25BUEkiLCJtb2NrVHJ5b25SZXNwb25zZSIsImFjdCIsIm1vY2tUcnlvblZhcmlhYmxlcyIsIndhaXRGb3IiLCJ0b0VxdWFsIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzdHJpbmdDb250YWluaW5nIiwibW9ja0ZpbGUiLCJGaWxlIiwidHlwZSIsInZhcmlhYmxlc1dpdGhGaWxlcyIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwib3B0aW9ucyIsIm9uU3VjY2VzcyIsImFueSIsIk51bWJlciIsInJldHJ5Q291bnQiLCJ2YXJpYWJsZXNXaXRoVGltZW91dCIsInRpbWVvdXQiLCJhcGlFcnJvciIsIm1vY2tUcnlvbkVycm9yIiwidG9CZVRydXRoeSIsIm9uRXJyb3IiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJFcnJvciIsIm5hbWUiLCJ2YXJpYWJsZXNXaXRoU2hvcnRUaW1lb3V0IiwicmVxdWlyZSIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsInZhcmlhYmxlc1dpdGhJbnZhbGlkRmlsZSIsImNhbGxDb3VudCIsInJlc29sdmUiLCJvayIsImpzb24iLCJvcHRpbWlzdGljQ29uZmlnIiwic2hvd1ByZXZpZXciLCJ1cGRhdGVIaXN0b3J5IiwiT2JqZWN0IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwiY29kZSIsImNvbnNvbGUiLCJsb2ciLCJjYWNoZUludmFsaWRhdGlvbkNvbmZpZyIsImludmFsaWRhdGVIaXN0b3J5IiwiaW52YWxpZGF0ZVVzZXJEYXRhIiwibW9ja3MiLCJ3YXJuIiwib25NdXRhdGUiLCJjdXN0b21EYXRhIiwib25TZXR0bGVkIiwiaW52YWxpZCIsInVubW91bnQiLCJ3YWl0Rm9yUHJvbWlzZXMiXSwibWFwcGluZ3MiOiJBQUFBLGdEQUFnRDtBQUNoRCw0RkFBNEY7O0FBaUM1RixzQ0FBc0M7QUFDdENBLEtBQUtDLElBQUksQ0FBQyx1REFBdUQsSUFBTyxDQUFBO1FBQ3RFQyw2QkFBNkIsSUFBTyxD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