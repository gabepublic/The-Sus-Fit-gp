5855717250cb96ddaf94af873b31b4ac
/**
 * @jest-environment jsdom
 */ "use strict";
// Mock compression utilities
jest.mock('../../../src/business-layer/utils/imageProcessing', ()=>({
        compressBase64: jest.fn((base64)=>Promise.resolve(base64)),
        getBase64Size: jest.fn(()=>1024),
        CompressionFailedError: class extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _tryonHistoryService = require("../../../src/business-layer/services/tryonHistoryService");
// Mock localStorage with complete interface
const mockLocalStorage = (()=>{
    let store = {};
    return {
        getItem: jest.fn((key)=>store[key] || null),
        setItem: jest.fn((key, value)=>{
            store[key] = value;
        }),
        removeItem: jest.fn((key)=>{
            delete store[key];
        }),
        clear: jest.fn(()=>{
            store = {};
        }),
        get length () {
            return Object.keys(store).length;
        },
        key: jest.fn((index)=>{
            const keys = Object.keys(store);
            return keys[index] || null;
        })
    };
})();
// Ensure localStorage is properly available for the service's existence check
Object.defineProperty(window, 'localStorage', {
    value: mockLocalStorage,
    writable: true,
    configurable: true,
    enumerable: true
});
// Also set on global for extra compatibility
Object.defineProperty(global, 'localStorage', {
    value: mockLocalStorage,
    writable: true,
    configurable: true,
    enumerable: true
});
describe('LocalStorageTryonHistoryService', ()=>{
    let historyService;
    const sampleHistoryEntry = {
        generatedImage: 'data:image/jpeg;base64,generated-image-data',
        modelImage: 'data:image/jpeg;base64,model-image-data',
        apparelImages: [
            'data:image/jpeg;base64,apparel-image-data'
        ],
        processingTime: 5000,
        metadata: {
            modelVersion: '1.0.0',
            appliedQuality: 'high'
        },
        tags: [
            'test',
            'sample'
        ],
        notes: 'Test history entry'
    };
    beforeEach(()=>{
        // Clear localStorage
        mockLocalStorage.clear();
        jest.clearAllMocks();
        // Create new service instance
        historyService = new _tryonHistoryService.LocalStorageTryonHistoryService();
    });
    describe('Initialization', ()=>{
        it('should initialize localStorage with default values', async ()=>{
            // Force initialization by calling a method
            await historyService.getEntries();
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_config', expect.stringContaining('localStorage'));
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_entries', '[]');
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_metadata', expect.stringContaining('version'));
        });
        it('should use custom configuration when provided', ()=>{
            const customConfig = {
                maxEntries: 100,
                compressImages: false
            };
            const customService = new _tryonHistoryService.LocalStorageTryonHistoryService(customConfig);
            expect(customService.getConfig().maxEntries).toBe(100);
            expect(customService.getConfig().compressImages).toBe(false);
        });
        it('should handle localStorage unavailability gracefully', async ()=>{
            // Mock localStorage as undefined
            Object.defineProperty(window, 'localStorage', {
                value: undefined,
                configurable: true
            });
            const testService = new _tryonHistoryService.LocalStorageTryonHistoryService();
            await expect(testService.getEntries()).rejects.toThrow('History storage initialization failed');
            // Restore localStorage
            Object.defineProperty(window, 'localStorage', {
                value: mockLocalStorage,
                configurable: true
            });
        });
    });
    describe('Adding History Entries', ()=>{
        it('should add a new history entry successfully', async ()=>{
            const entry = await historyService.addEntry(sampleHistoryEntry);
            expect(entry.id).toBeDefined();
            expect(entry.timestamp).toBeDefined();
            expect(entry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
            expect(entry.modelImage).toBe(sampleHistoryEntry.modelImage);
            expect(entry.apparelImages).toEqual(sampleHistoryEntry.apparelImages);
            expect(entry.processingTime).toBe(sampleHistoryEntry.processingTime);
            expect(entry.tags).toEqual(sampleHistoryEntry.tags);
            expect(entry.notes).toBe(sampleHistoryEntry.notes);
            // Verify localStorage was updated
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('susfit_tryon_history_entries', expect.stringContaining(entry.id));
        });
        it('should generate unique IDs for entries', async ()=>{
            const entry1 = await historyService.addEntry(sampleHistoryEntry);
            const entry2 = await historyService.addEntry(sampleHistoryEntry);
            expect(entry1.id).not.toBe(entry2.id);
        });
        it('should apply default values for optional fields', async ()=>{
            const minimalEntry = {
                generatedImage: 'generated',
                modelImage: 'model',
                apparelImages: [
                    'apparel'
                ]
            };
            const entry = await historyService.addEntry(minimalEntry);
            expect(entry.tags).toEqual([]);
            expect(entry.isFavorite).toBe(false);
            expect(entry.notes).toBe('');
        });
        it('should handle compression when enabled', async ()=>{
            const compressEnabledService = new _tryonHistoryService.LocalStorageTryonHistoryService({
                compressImages: true,
                compressionQuality: 0.8
            });
            const entry = await compressEnabledService.addEntry(sampleHistoryEntry);
            expect(entry.id).toBeDefined();
            // Compression mock should have been called - access via jest.mocked
            const imageUtils = jest.mocked(require('../../../src/business-layer/utils/imageProcessing'));
            expect(imageUtils.compressBase64).toHaveBeenCalled();
        });
    });
    describe('Retrieving History Entries', ()=>{
        beforeEach(async ()=>{
            // Add some test entries
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag1'
                ],
                notes: 'First entry'
            });
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag2'
                ],
                notes: 'Second entry',
                isFavorite: true
            });
            await historyService.addEntry({
                ...sampleHistoryEntry,
                tags: [
                    'tag1',
                    'tag2'
                ],
                notes: 'Third entry'
            });
        });
        it('should retrieve all entries without options', async ()=>{
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(3);
            expect(result.totalCount).toBe(3);
            expect(result.currentPage).toBe(0);
            expect(result.hasMore).toBe(false);
        });
        it('should apply pagination correctly', async ()=>{
            const options = {
                page: 0,
                pageSize: 2
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(2);
            expect(result.totalCount).toBe(3);
            expect(result.currentPage).toBe(0);
            expect(result.pageSize).toBe(2);
            expect(result.hasMore).toBe(true);
        });
        it('should filter by favorites only', async ()=>{
            const options = {
                favoritesOnly: true
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].isFavorite).toBe(true);
        });
        it('should filter by search term', async ()=>{
            const options = {
                searchTerm: 'Second'
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].notes).toContain('Second');
        });
        it('should sort entries correctly', async ()=>{
            const options = {
                sortBy: 'timestamp',
                sortDirection: 'asc'
            };
            const result = await historyService.getEntries(options);
            expect(result.entries).toHaveLength(3);
            // Should be in ascending order
            const timestamps = result.entries.map((e)=>new Date(e.timestamp).getTime());
            expect(timestamps[0]).toBeLessThanOrEqual(timestamps[1]);
            expect(timestamps[1]).toBeLessThanOrEqual(timestamps[2]);
        });
    });
    describe('Single Entry Operations', ()=>{
        let entryId;
        beforeEach(async ()=>{
            const entry = await historyService.addEntry(sampleHistoryEntry);
            entryId = entry.id;
        });
        it('should retrieve a specific entry by ID', async ()=>{
            const entry = await historyService.getEntry(entryId);
            expect(entry).not.toBeNull();
            expect(entry.id).toBe(entryId);
            expect(entry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
        });
        it('should return null for non-existent entry', async ()=>{
            const entry = await historyService.getEntry('non-existent-id');
            expect(entry).toBeNull();
        });
        it('should update an existing entry', async ()=>{
            const updates = {
                notes: 'Updated notes',
                isFavorite: true,
                tags: [
                    'updated',
                    'tags'
                ]
            };
            const updatedEntry = await historyService.updateEntry(entryId, updates);
            expect(updatedEntry.id).toBe(entryId);
            expect(updatedEntry.notes).toBe('Updated notes');
            expect(updatedEntry.isFavorite).toBe(true);
            expect(updatedEntry.tags).toEqual([
                'updated',
                'tags'
            ]);
            // Original data should be preserved
            expect(updatedEntry.generatedImage).toBe(sampleHistoryEntry.generatedImage);
        });
        it('should throw error when updating non-existent entry', async ()=>{
            await expect(historyService.updateEntry('non-existent-id', {
                notes: 'test'
            })).rejects.toThrow('History entry with ID non-existent-id not found');
        });
        it('should delete an entry successfully', async ()=>{
            const deleted = await historyService.deleteEntry(entryId);
            expect(deleted).toBe(true);
            // Entry should no longer exist
            const entry = await historyService.getEntry(entryId);
            expect(entry).toBeNull();
        });
        it('should return false when deleting non-existent entry', async ()=>{
            const deleted = await historyService.deleteEntry('non-existent-id');
            expect(deleted).toBe(false);
        });
    });
    describe('Bulk Operations', ()=>{
        beforeEach(async ()=>{
            // Add multiple test entries
            for(let i = 0; i < 5; i++){
                await historyService.addEntry({
                    ...sampleHistoryEntry,
                    notes: `Entry ${i}`
                });
            }
        });
        it('should clear all entries', async ()=>{
            const cleared = await historyService.clearAll();
            expect(cleared).toBe(true);
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(0);
        });
        it('should export all history data', async ()=>{
            const exported = await historyService.exportHistory();
            expect(exported).toHaveLength(5);
            expect(exported[0].notes).toContain('Entry');
        });
        it('should import history data', async ()=>{
            // Clear existing entries
            await historyService.clearAll();
            // Create import data
            const importData = [
                {
                    id: 'import-1',
                    timestamp: new Date().toISOString(),
                    generatedImage: 'imported-generated',
                    modelImage: 'imported-model',
                    apparelImages: [
                        'imported-apparel'
                    ],
                    tags: [
                        'imported'
                    ],
                    notes: 'Imported entry',
                    isFavorite: false
                }
            ];
            const importedCount = await historyService.importHistory(importData);
            expect(importedCount).toBe(1);
            const result = await historyService.getEntries();
            expect(result.entries).toHaveLength(1);
            expect(result.entries[0].id).toBe('import-1');
        });
        it('should not import duplicate entries', async ()=>{
            const existingEntries = await historyService.exportHistory();
            const duplicateImport = existingEntries.slice(0, 2); // Try to import first 2 existing entries
            const importedCount = await historyService.importHistory(duplicateImport);
            expect(importedCount).toBe(0); // No new entries should be imported
        });
    });
    describe('Storage Statistics', ()=>{
        beforeEach(async ()=>{
            // Add test entries with different timestamps
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'First entry'
            });
            // Add slight delay to ensure different timestamps
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Last entry'
            });
        });
        it('should return accurate storage statistics', async ()=>{
            const stats = await historyService.getStorageStats();
            expect(stats.totalEntries).toBe(2);
            expect(stats.totalSizeKB).toBeGreaterThan(0);
            expect(stats.oldestEntry).toBeDefined();
            expect(stats.newestEntry).toBeDefined();
            expect(new Date(stats.oldestEntry).getTime()).toBeLessThanOrEqual(new Date(stats.newestEntry).getTime());
        });
    });
    describe('Configuration Management', ()=>{
        it('should update configuration correctly', ()=>{
            const newConfig = {
                maxEntries: 200,
                compressImages: false
            };
            historyService.updateConfig(newConfig);
            const config = historyService.getConfig();
            expect(config.maxEntries).toBe(200);
            expect(config.compressImages).toBe(false);
        });
        it('should perform cleanup when maxEntries is exceeded', async ()=>{
            // Set low max entries limit
            historyService.updateConfig({
                maxEntries: 2
            });
            // Add more entries than the limit with small delays to ensure different timestamps
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 1'
            });
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 2'
            });
            await new Promise((resolve)=>setTimeout(resolve, 10));
            await historyService.addEntry({
                ...sampleHistoryEntry,
                notes: 'Entry 3'
            });
            const result = await historyService.getEntries();
            // Should only keep the most recent entries (sorted by timestamp desc)
            expect(result.entries).toHaveLength(2);
            // The most recent entries should be kept (Entry 2 and Entry 3)
            // Entry 1 should be removed as it's the oldest
            const entryNotes = result.entries.map((e)=>e.notes);
            expect(entryNotes).toContain('Entry 2');
            expect(entryNotes).toContain('Entry 3');
            expect(entryNotes).not.toContain('Entry 1');
        });
    });
    describe('Error Handling', ()=>{
        it('should handle localStorage write errors gracefully', async ()=>{
            // Mock localStorage.setItem to throw an error
            mockLocalStorage.setItem.mockImplementationOnce(()=>{
                throw new Error('localStorage full');
            });
            await expect(historyService.addEntry(sampleHistoryEntry)).rejects.toThrow('History storage initialization failed');
        });
        it('should handle corrupted localStorage data', ()=>{
            // Set corrupted data in localStorage
            mockLocalStorage.getItem.mockReturnValueOnce('invalid-json');
            // Should return empty array instead of throwing
            const entries = historyService.getStoredEntries();
            expect(entries).toEqual([]);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2J1c2luZXNzLWxheWVyL3NlcnZpY2VzL3RyeW9uSGlzdG9yeVNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBqZXN0LWVudmlyb25tZW50IGpzZG9tXG4gKi9cblxuaW1wb3J0IHsgTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci9zZXJ2aWNlcy90cnlvbkhpc3RvcnlTZXJ2aWNlJztcbmltcG9ydCB0eXBlIHtcbiAgQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zLFxuICBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMsXG4gIFRyeW9uSGlzdG9yeVN0b3JhZ2VDb25maWdcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2J1c2luZXNzLWxheWVyL3R5cGVzL2hpc3RvcnkudHlwZXMnO1xuXG4vLyBNb2NrIGxvY2FsU3RvcmFnZSB3aXRoIGNvbXBsZXRlIGludGVyZmFjZVxuY29uc3QgbW9ja0xvY2FsU3RvcmFnZSA9ICgoKSA9PiB7XG4gIGxldCBzdG9yZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBcbiAgcmV0dXJuIHtcbiAgICBnZXRJdGVtOiBqZXN0LmZuKChrZXk6IHN0cmluZykgPT4gc3RvcmVba2V5XSB8fCBudWxsKSxcbiAgICBzZXRJdGVtOiBqZXN0LmZuKChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIH0pLFxuICAgIHJlbW92ZUl0ZW06IGplc3QuZm4oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICB9KSxcbiAgICBjbGVhcjogamVzdC5mbigoKSA9PiB7XG4gICAgICBzdG9yZSA9IHt9O1xuICAgIH0pLFxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmUpLmxlbmd0aDtcbiAgICB9LFxuICAgIGtleTogamVzdC5mbigoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0b3JlKTtcbiAgICAgIHJldHVybiBrZXlzW2luZGV4XSB8fCBudWxsO1xuICAgIH0pXG4gIH07XG59KSgpO1xuXG4vLyBFbnN1cmUgbG9jYWxTdG9yYWdlIGlzIHByb3Blcmx5IGF2YWlsYWJsZSBmb3IgdGhlIHNlcnZpY2UncyBleGlzdGVuY2UgY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XG4gIHZhbHVlOiBtb2NrTG9jYWxTdG9yYWdlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcblxuLy8gQWxzbyBzZXQgb24gZ2xvYmFsIGZvciBleHRyYSBjb21wYXRpYmlsaXR5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAnbG9jYWxTdG9yYWdlJywge1xuICB2YWx1ZTogbW9ja0xvY2FsU3RvcmFnZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5cbi8vIE1vY2sgY29tcHJlc3Npb24gdXRpbGl0aWVzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9idXNpbmVzcy1sYXllci91dGlscy9pbWFnZVByb2Nlc3NpbmcnLCAoKSA9PiAoe1xuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigoYmFzZTY0OiBzdHJpbmcpID0+IFByb21pc2UucmVzb2x2ZShiYXNlNjQpKSxcbiAgZ2V0QmFzZTY0U2l6ZTogamVzdC5mbigoKSA9PiAxMDI0KSxcbiAgQ29tcHJlc3Npb25GYWlsZWRFcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJztcbiAgICB9XG4gIH1cbn0pKTtcblxuZGVzY3JpYmUoJ0xvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBoaXN0b3J5U2VydmljZTogTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZTtcblxuICBjb25zdCBzYW1wbGVIaXN0b3J5RW50cnk6IENyZWF0ZVRyeW9uSGlzdG9yeUVudHJ5T3B0aW9ucyA9IHtcbiAgICBnZW5lcmF0ZWRJbWFnZTogJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsZ2VuZXJhdGVkLWltYWdlLWRhdGEnLFxuICAgIG1vZGVsSW1hZ2U6ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LG1vZGVsLWltYWdlLWRhdGEnLFxuICAgIGFwcGFyZWxJbWFnZXM6IFsnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxhcHBhcmVsLWltYWdlLWRhdGEnXSxcbiAgICBwcm9jZXNzaW5nVGltZTogNTAwMCxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbW9kZWxWZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgYXBwbGllZFF1YWxpdHk6ICdoaWdoJ1xuICAgIH0sXG4gICAgdGFnczogWyd0ZXN0JywgJ3NhbXBsZSddLFxuICAgIG5vdGVzOiAnVGVzdCBoaXN0b3J5IGVudHJ5J1xuICB9O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZVxuICAgIG1vY2tMb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgbmV3IHNlcnZpY2UgaW5zdGFuY2VcbiAgICBoaXN0b3J5U2VydmljZSA9IG5ldyBMb2NhbFN0b3JhZ2VUcnlvbkhpc3RvcnlTZXJ2aWNlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgbG9jYWxTdG9yYWdlIHdpdGggZGVmYXVsdCB2YWx1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBGb3JjZSBpbml0aWFsaXphdGlvbiBieSBjYWxsaW5nIGEgbWV0aG9kXG4gICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnc3VzZml0X3RyeW9uX2hpc3RvcnlfY29uZmlnJyxcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2xvY2FsU3RvcmFnZScpXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdzdXNmaXRfdHJ5b25faGlzdG9yeV9lbnRyaWVzJyxcbiAgICAgICAgJ1tdJ1xuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnc3VzZml0X3RyeW9uX2hpc3RvcnlfbWV0YWRhdGEnLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygndmVyc2lvbicpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgY3VzdG9tIGNvbmZpZ3VyYXRpb24gd2hlbiBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbUNvbmZpZzogUGFydGlhbDxUcnlvbkhpc3RvcnlTdG9yYWdlQ29uZmlnPiA9IHtcbiAgICAgICAgbWF4RW50cmllczogMTAwLFxuICAgICAgICBjb21wcmVzc0ltYWdlczogZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGN1c3RvbVNlcnZpY2UgPSBuZXcgTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZShjdXN0b21Db25maWcpO1xuICAgICAgZXhwZWN0KGN1c3RvbVNlcnZpY2UuZ2V0Q29uZmlnKCkubWF4RW50cmllcykudG9CZSgxMDApO1xuICAgICAgZXhwZWN0KGN1c3RvbVNlcnZpY2UuZ2V0Q29uZmlnKCkuY29tcHJlc3NJbWFnZXMpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9jYWxTdG9yYWdlIHVuYXZhaWxhYmlsaXR5IGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGxvY2FsU3RvcmFnZSBhcyB1bmRlZmluZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRlc3RTZXJ2aWNlID0gbmV3IExvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UoKTtcbiAgICAgIGF3YWl0IGV4cGVjdCh0ZXN0U2VydmljZS5nZXRFbnRyaWVzKCkpLnJlamVjdHMudG9UaHJvdygnSGlzdG9yeSBzdG9yYWdlIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuXG4gICAgICAvLyBSZXN0b3JlIGxvY2FsU3RvcmFnZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2xvY2FsU3RvcmFnZScsIHtcbiAgICAgICAgdmFsdWU6IG1vY2tMb2NhbFN0b3JhZ2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBZGRpbmcgSGlzdG9yeSBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWRkIGEgbmV3IGhpc3RvcnkgZW50cnkgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuXG4gICAgICBleHBlY3QoZW50cnkuaWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZW50cnkudGltZXN0YW1wKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVudHJ5LmdlbmVyYXRlZEltYWdlKS50b0JlKHNhbXBsZUhpc3RvcnlFbnRyeS5nZW5lcmF0ZWRJbWFnZSk7XG4gICAgICBleHBlY3QoZW50cnkubW9kZWxJbWFnZSkudG9CZShzYW1wbGVIaXN0b3J5RW50cnkubW9kZWxJbWFnZSk7XG4gICAgICBleHBlY3QoZW50cnkuYXBwYXJlbEltYWdlcykudG9FcXVhbChzYW1wbGVIaXN0b3J5RW50cnkuYXBwYXJlbEltYWdlcyk7XG4gICAgICBleHBlY3QoZW50cnkucHJvY2Vzc2luZ1RpbWUpLnRvQmUoc2FtcGxlSGlzdG9yeUVudHJ5LnByb2Nlc3NpbmdUaW1lKTtcbiAgICAgIGV4cGVjdChlbnRyeS50YWdzKS50b0VxdWFsKHNhbXBsZUhpc3RvcnlFbnRyeS50YWdzKTtcbiAgICAgIGV4cGVjdChlbnRyeS5ub3RlcykudG9CZShzYW1wbGVIaXN0b3J5RW50cnkubm90ZXMpO1xuXG4gICAgICAvLyBWZXJpZnkgbG9jYWxTdG9yYWdlIHdhcyB1cGRhdGVkXG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ3N1c2ZpdF90cnlvbl9oaXN0b3J5X2VudHJpZXMnLFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhlbnRyeS5pZClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHVuaXF1ZSBJRHMgZm9yIGVudHJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeTEgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuICAgICAgY29uc3QgZW50cnkyID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoc2FtcGxlSGlzdG9yeUVudHJ5KTtcblxuICAgICAgZXhwZWN0KGVudHJ5MS5pZCkubm90LnRvQmUoZW50cnkyLmlkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1pbmltYWxFbnRyeTogQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zID0ge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZTogJ2dlbmVyYXRlZCcsXG4gICAgICAgIG1vZGVsSW1hZ2U6ICdtb2RlbCcsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnYXBwYXJlbCddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KG1pbmltYWxFbnRyeSk7XG5cbiAgICAgIGV4cGVjdChlbnRyeS50YWdzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChlbnRyeS5pc0Zhdm9yaXRlKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChlbnRyeS5ub3RlcykudG9CZSgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wcmVzc2lvbiB3aGVuIGVuYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wcmVzc0VuYWJsZWRTZXJ2aWNlID0gbmV3IExvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2Uoe1xuICAgICAgICBjb21wcmVzc0ltYWdlczogdHJ1ZSxcbiAgICAgICAgY29tcHJlc3Npb25RdWFsaXR5OiAwLjhcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGNvbXByZXNzRW5hYmxlZFNlcnZpY2UuYWRkRW50cnkoc2FtcGxlSGlzdG9yeUVudHJ5KTtcblxuICAgICAgZXhwZWN0KGVudHJ5LmlkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgLy8gQ29tcHJlc3Npb24gbW9jayBzaG91bGQgaGF2ZSBiZWVuIGNhbGxlZCAtIGFjY2VzcyB2aWEgamVzdC5tb2NrZWRcbiAgICAgIGNvbnN0IGltYWdlVXRpbHMgPSBqZXN0Lm1vY2tlZChyZXF1aXJlKCcuLi8uLi8uLi9zcmMvYnVzaW5lc3MtbGF5ZXIvdXRpbHMvaW1hZ2VQcm9jZXNzaW5nJykpO1xuICAgICAgZXhwZWN0KGltYWdlVXRpbHMuY29tcHJlc3NCYXNlNjQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JldHJpZXZpbmcgSGlzdG9yeSBFbnRyaWVzJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIHNvbWUgdGVzdCBlbnRyaWVzXG4gICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeSh7XG4gICAgICAgIC4uLnNhbXBsZUhpc3RvcnlFbnRyeSxcbiAgICAgICAgdGFnczogWyd0YWcxJ10sXG4gICAgICAgIG5vdGVzOiAnRmlyc3QgZW50cnknXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICB0YWdzOiBbJ3RhZzInXSxcbiAgICAgICAgbm90ZXM6ICdTZWNvbmQgZW50cnknLFxuICAgICAgICBpc0Zhdm9yaXRlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICB0YWdzOiBbJ3RhZzEnLCAndGFnMiddLFxuICAgICAgICBub3RlczogJ1RoaXJkIGVudHJ5J1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHJpZXZlIGFsbCBlbnRyaWVzIHdpdGhvdXQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LnRvdGFsQ291bnQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRQYWdlKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5oYXNNb3JlKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgcGFnaW5hdGlvbiBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgIHBhZ2U6IDAsXG4gICAgICAgIHBhZ2VTaXplOiAyXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKG9wdGlvbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmVudHJpZXMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG90YWxDb3VudCkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFBhZ2UpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnBhZ2VTaXplKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5oYXNNb3JlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgZmF2b3JpdGVzIG9ubHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBUcnlvbkhpc3RvcnlRdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgIGZhdm9yaXRlc09ubHk6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMob3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLmlzRmF2b3JpdGUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBzZWFyY2ggdGVybScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFRyeW9uSGlzdG9yeVF1ZXJ5T3B0aW9ucyA9IHtcbiAgICAgICAgc2VhcmNoVGVybTogJ1NlY29uZCdcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMob3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLm5vdGVzKS50b0NvbnRhaW4oJ1NlY29uZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzb3J0IGVudHJpZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogVHJ5b25IaXN0b3J5UXVlcnlPcHRpb25zID0ge1xuICAgICAgICBzb3J0Qnk6ICd0aW1lc3RhbXAnLFxuICAgICAgICBzb3J0RGlyZWN0aW9uOiAnYXNjJ1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZ2V0RW50cmllcyhvcHRpb25zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAvLyBTaG91bGQgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICBjb25zdCB0aW1lc3RhbXBzID0gcmVzdWx0LmVudHJpZXMubWFwKGUgPT4gbmV3IERhdGUoZS50aW1lc3RhbXApLmdldFRpbWUoKSk7XG4gICAgICBleHBlY3QodGltZXN0YW1wc1swXSkudG9CZUxlc3NUaGFuT3JFcXVhbCh0aW1lc3RhbXBzWzFdKTtcbiAgICAgIGV4cGVjdCh0aW1lc3RhbXBzWzFdKS50b0JlTGVzc1RoYW5PckVxdWFsKHRpbWVzdGFtcHNbMl0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2luZ2xlIEVudHJ5IE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgbGV0IGVudHJ5SWQ6IHN0cmluZztcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeShzYW1wbGVIaXN0b3J5RW50cnkpO1xuICAgICAgZW50cnlJZCA9IGVudHJ5LmlkO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBhIHNwZWNpZmljIGVudHJ5IGJ5IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyeShlbnRyeUlkKTtcblxuICAgICAgZXhwZWN0KGVudHJ5KS5ub3QudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChlbnRyeSEuaWQpLnRvQmUoZW50cnlJZCk7XG4gICAgICBleHBlY3QoZW50cnkhLmdlbmVyYXRlZEltYWdlKS50b0JlKHNhbXBsZUhpc3RvcnlFbnRyeS5nZW5lcmF0ZWRJbWFnZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBub24tZXhpc3RlbnQgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJ5KCdub24tZXhpc3RlbnQtaWQnKTtcblxuICAgICAgZXhwZWN0KGVudHJ5KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgYW4gZXhpc3RpbmcgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgICBub3RlczogJ1VwZGF0ZWQgbm90ZXMnLFxuICAgICAgICBpc0Zhdm9yaXRlOiB0cnVlLFxuICAgICAgICB0YWdzOiBbJ3VwZGF0ZWQnLCAndGFncyddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVkRW50cnkgPSBhd2FpdCBoaXN0b3J5U2VydmljZS51cGRhdGVFbnRyeShlbnRyeUlkLCB1cGRhdGVzKTtcblxuICAgICAgZXhwZWN0KHVwZGF0ZWRFbnRyeS5pZCkudG9CZShlbnRyeUlkKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkubm90ZXMpLnRvQmUoJ1VwZGF0ZWQgbm90ZXMnKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkuaXNGYXZvcml0ZSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkRW50cnkudGFncykudG9FcXVhbChbJ3VwZGF0ZWQnLCAndGFncyddKTtcbiAgICAgIC8vIE9yaWdpbmFsIGRhdGEgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgZXhwZWN0KHVwZGF0ZWRFbnRyeS5nZW5lcmF0ZWRJbWFnZSkudG9CZShzYW1wbGVIaXN0b3J5RW50cnkuZ2VuZXJhdGVkSW1hZ2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIHVwZGF0aW5nIG5vbi1leGlzdGVudCBlbnRyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgaGlzdG9yeVNlcnZpY2UudXBkYXRlRW50cnkoJ25vbi1leGlzdGVudC1pZCcsIHsgbm90ZXM6ICd0ZXN0JyB9KVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0hpc3RvcnkgZW50cnkgd2l0aCBJRCBub24tZXhpc3RlbnQtaWQgbm90IGZvdW5kJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhbiBlbnRyeSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZGVsZXRlRW50cnkoZW50cnlJZCk7XG5cbiAgICAgIGV4cGVjdChkZWxldGVkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBFbnRyeSBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJ5KGVudHJ5SWQpO1xuICAgICAgZXhwZWN0KGVudHJ5KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiBkZWxldGluZyBub24tZXhpc3RlbnQgZW50cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZGVsZXRlRW50cnkoJ25vbi1leGlzdGVudC1pZCcpO1xuXG4gICAgICBleHBlY3QoZGVsZXRlZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCdWxrIE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgbXVsdGlwbGUgdGVzdCBlbnRyaWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBhd2FpdCBoaXN0b3J5U2VydmljZS5hZGRFbnRyeSh7XG4gICAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICAgIG5vdGVzOiBgRW50cnkgJHtpfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFyIGFsbCBlbnRyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xlYXJlZCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmNsZWFyQWxsKCk7XG5cbiAgICAgIGV4cGVjdChjbGVhcmVkKS50b0JlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRFbnRyaWVzKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmVudHJpZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhwb3J0IGFsbCBoaXN0b3J5IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBvcnRlZCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmV4cG9ydEhpc3RvcnkoKTtcblxuICAgICAgZXhwZWN0KGV4cG9ydGVkKS50b0hhdmVMZW5ndGgoNSk7XG4gICAgICBleHBlY3QoZXhwb3J0ZWRbMF0ubm90ZXMpLnRvQ29udGFpbignRW50cnknKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW1wb3J0IGhpc3RvcnkgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGVudHJpZXNcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmNsZWFyQWxsKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBpbXBvcnQgZGF0YVxuICAgICAgY29uc3QgaW1wb3J0RGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnaW1wb3J0LTEnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGdlbmVyYXRlZEltYWdlOiAnaW1wb3J0ZWQtZ2VuZXJhdGVkJyxcbiAgICAgICAgICBtb2RlbEltYWdlOiAnaW1wb3J0ZWQtbW9kZWwnLFxuICAgICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnaW1wb3J0ZWQtYXBwYXJlbCddLFxuICAgICAgICAgIHRhZ3M6IFsnaW1wb3J0ZWQnXSxcbiAgICAgICAgICBub3RlczogJ0ltcG9ydGVkIGVudHJ5JyxcbiAgICAgICAgICBpc0Zhdm9yaXRlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBpbXBvcnRlZENvdW50ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuaW1wb3J0SGlzdG9yeShpbXBvcnREYXRhKTtcblxuICAgICAgZXhwZWN0KGltcG9ydGVkQ291bnQpLnRvQmUoMSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZW50cmllcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzWzBdLmlkKS50b0JlKCdpbXBvcnQtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgaW1wb3J0IGR1cGxpY2F0ZSBlbnRyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdFbnRyaWVzID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuZXhwb3J0SGlzdG9yeSgpO1xuICAgICAgY29uc3QgZHVwbGljYXRlSW1wb3J0ID0gZXhpc3RpbmdFbnRyaWVzLnNsaWNlKDAsIDIpOyAvLyBUcnkgdG8gaW1wb3J0IGZpcnN0IDIgZXhpc3RpbmcgZW50cmllc1xuXG4gICAgICBjb25zdCBpbXBvcnRlZENvdW50ID0gYXdhaXQgaGlzdG9yeVNlcnZpY2UuaW1wb3J0SGlzdG9yeShkdXBsaWNhdGVJbXBvcnQpO1xuXG4gICAgICBleHBlY3QoaW1wb3J0ZWRDb3VudCkudG9CZSgwKTsgLy8gTm8gbmV3IGVudHJpZXMgc2hvdWxkIGJlIGltcG9ydGVkXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdG9yYWdlIFN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgdGVzdCBlbnRyaWVzIHdpdGggZGlmZmVyZW50IHRpbWVzdGFtcHNcbiAgICAgIGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHtcbiAgICAgICAgLi4uc2FtcGxlSGlzdG9yeUVudHJ5LFxuICAgICAgICBub3RlczogJ0ZpcnN0IGVudHJ5J1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBzbGlnaHQgZGVsYXkgdG8gZW5zdXJlIGRpZmZlcmVudCB0aW1lc3RhbXBzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoe1xuICAgICAgICAuLi5zYW1wbGVIaXN0b3J5RW50cnksXG4gICAgICAgIG5vdGVzOiAnTGFzdCBlbnRyeSdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYWNjdXJhdGUgc3RvcmFnZSBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBoaXN0b3J5U2VydmljZS5nZXRTdG9yYWdlU3RhdHMoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsRW50cmllcykudG9CZSgyKTtcbiAgICAgIGV4cGVjdChzdGF0cy50b3RhbFNpemVLQikudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHN0YXRzLm9sZGVzdEVudHJ5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHN0YXRzLm5ld2VzdEVudHJ5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG5ldyBEYXRlKHN0YXRzLm9sZGVzdEVudHJ5ISkuZ2V0VGltZSgpKS50b0JlTGVzc1RoYW5PckVxdWFsKFxuICAgICAgICBuZXcgRGF0ZShzdGF0cy5uZXdlc3RFbnRyeSEpLmdldFRpbWUoKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmZpZ3VyYXRpb24gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBjb25maWd1cmF0aW9uIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHtcbiAgICAgICAgbWF4RW50cmllczogMjAwLFxuICAgICAgICBjb21wcmVzc0ltYWdlczogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGhpc3RvcnlTZXJ2aWNlLnVwZGF0ZUNvbmZpZyhuZXdDb25maWcpO1xuXG4gICAgICBjb25zdCBjb25maWcgPSBoaXN0b3J5U2VydmljZS5nZXRDb25maWcoKTtcbiAgICAgIGV4cGVjdChjb25maWcubWF4RW50cmllcykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGNvbmZpZy5jb21wcmVzc0ltYWdlcykudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHBlcmZvcm0gY2xlYW51cCB3aGVuIG1heEVudHJpZXMgaXMgZXhjZWVkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXQgbG93IG1heCBlbnRyaWVzIGxpbWl0XG4gICAgICBoaXN0b3J5U2VydmljZS51cGRhdGVDb25maWcoeyBtYXhFbnRyaWVzOiAyIH0pO1xuXG4gICAgICAvLyBBZGQgbW9yZSBlbnRyaWVzIHRoYW4gdGhlIGxpbWl0IHdpdGggc21hbGwgZGVsYXlzIHRvIGVuc3VyZSBkaWZmZXJlbnQgdGltZXN0YW1wc1xuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMScgfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMicgfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgIFxuICAgICAgYXdhaXQgaGlzdG9yeVNlcnZpY2UuYWRkRW50cnkoeyAuLi5zYW1wbGVIaXN0b3J5RW50cnksIG5vdGVzOiAnRW50cnkgMycgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvcnlTZXJ2aWNlLmdldEVudHJpZXMoKTtcblxuICAgICAgLy8gU2hvdWxkIG9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllcyAoc29ydGVkIGJ5IHRpbWVzdGFtcCBkZXNjKVxuICAgICAgZXhwZWN0KHJlc3VsdC5lbnRyaWVzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBcbiAgICAgIC8vIFRoZSBtb3N0IHJlY2VudCBlbnRyaWVzIHNob3VsZCBiZSBrZXB0IChFbnRyeSAyIGFuZCBFbnRyeSAzKVxuICAgICAgLy8gRW50cnkgMSBzaG91bGQgYmUgcmVtb3ZlZCBhcyBpdCdzIHRoZSBvbGRlc3RcbiAgICAgIGNvbnN0IGVudHJ5Tm90ZXMgPSByZXN1bHQuZW50cmllcy5tYXAoZSA9PiBlLm5vdGVzKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS50b0NvbnRhaW4oJ0VudHJ5IDInKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS50b0NvbnRhaW4oJ0VudHJ5IDMnKTtcbiAgICAgIGV4cGVjdChlbnRyeU5vdGVzKS5ub3QudG9Db250YWluKCdFbnRyeSAxJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsb2NhbFN0b3JhZ2Ugd3JpdGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGxvY2FsU3RvcmFnZS5zZXRJdGVtIHRvIHRocm93IGFuIGVycm9yXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0ubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIGZ1bGwnKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGhpc3RvcnlTZXJ2aWNlLmFkZEVudHJ5KHNhbXBsZUhpc3RvcnlFbnRyeSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdIaXN0b3J5IHN0b3JhZ2UgaW5pdGlhbGl6YXRpb24gZmFpbGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb3JydXB0ZWQgbG9jYWxTdG9yYWdlIGRhdGEnLCAoKSA9PiB7XG4gICAgICAvLyBTZXQgY29ycnVwdGVkIGRhdGEgaW4gbG9jYWxTdG9yYWdlXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlT25jZSgnaW52YWxpZC1qc29uJyk7XG5cbiAgICAgIC8vIFNob3VsZCByZXR1cm4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiB0aHJvd2luZ1xuICAgICAgY29uc3QgZW50cmllcyA9IChoaXN0b3J5U2VydmljZSBhcyBhbnkpLmdldFN0b3JlZEVudHJpZXMoKTtcbiAgICAgIGV4cGVjdChlbnRyaWVzKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJjb21wcmVzc0Jhc2U2NCIsImZuIiwiYmFzZTY0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJnZXRCYXNlNjRTaXplIiwiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIm1vY2tMb2NhbFN0b3JhZ2UiLCJzdG9yZSIsImdldEl0ZW0iLCJrZXkiLCJzZXRJdGVtIiwidmFsdWUiLCJyZW1vdmVJdGVtIiwiY2xlYXIiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwiaW5kZXgiLCJkZWZpbmVQcm9wZXJ0eSIsIndpbmRvdyIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdsb2JhbCIsImRlc2NyaWJlIiwiaGlzdG9yeVNlcnZpY2UiLCJzYW1wbGVIaXN0b3J5RW50cnkiLCJnZW5lcmF0ZWRJbWFnZSIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwicHJvY2Vzc2luZ1RpbWUiLCJtZXRhZGF0YSIsIm1vZGVsVmVyc2lvbiIsImFwcGxpZWRRdWFsaXR5IiwidGFncyIsIm5vdGVzIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJMb2NhbFN0b3JhZ2VUcnlvbkhpc3RvcnlTZXJ2aWNlIiwiaXQiLCJnZXRFbnRyaWVzIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJzdHJpbmdDb250YWluaW5nIiwiY3VzdG9tQ29uZmlnIiwibWF4RW50cmllcyIsImNvbXByZXNzSW1hZ2VzIiwiY3VzdG9tU2VydmljZSIsImdldENvbmZpZyIsInRvQmUiLCJ1bmRlZmluZWQiLCJ0ZXN0U2VydmljZSIsInJlamVjdHMiLCJ0b1Rocm93IiwiZW50cnkiLCJhZGRFbnRyeSIsImlkIiwidG9CZURlZmluZWQiLCJ0aW1lc3RhbXAiLCJ0b0VxdWFsIiwiZW50cnkxIiwiZW50cnkyIiwibm90IiwibWluaW1hbEVudHJ5IiwiaXNGYXZvcml0ZSIsImNvbXByZXNzRW5hYmxlZFNlcnZpY2UiLCJjb21wcmVzc2lvblF1YWxpdHkiLCJpbWFnZVV0aWxzIiwibW9ja2VkIiwicmVxdWlyZSIsInRvSGF2ZUJlZW5DYWxsZWQiLCJyZXN1bHQiLCJlbnRyaWVzIiwidG9IYXZlTGVuZ3RoIiwidG90YWxDb3VudCIsImN1cnJlbnRQYWdlIiwiaGFzTW9yZSIsIm9wdGlvbnMiLCJwYWdlIiwicGFnZVNpemUiLCJmYXZvcml0ZXNPbmx5Iiwic2VhcmNoVGVybSIsInRvQ29udGFpbiIsInNvcnRCeSIsInNvcnREaXJlY3Rpb24iLCJ0aW1lc3RhbXBzIiwibWFwIiwiZSIsIkRhdGUiLCJnZXRUaW1lIiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsImVudHJ5SWQiLCJnZXRFbnRyeSIsInRvQmVOdWxsIiwidXBkYXRlcyIsInVwZGF0ZWRFbnRyeSIsInVwZGF0ZUVudHJ5IiwiZGVsZXRlZCIsImRlbGV0ZUVudHJ5IiwiaSIsImNsZWFyZWQiLCJjbGVhckFsbCIsImV4cG9ydGVkIiwiZXhwb3J0SGlzdG9yeSIsImltcG9ydERhdGEiLCJ0b0lTT1N0cmluZyIsImltcG9ydGVkQ291bnQiLCJpbXBvcnRIaXN0b3J5IiwiZXhpc3RpbmdFbnRyaWVzIiwiZHVwbGljYXRlSW1wb3J0Iiwic2xpY2UiLCJzZXRUaW1lb3V0Iiwic3RhdHMiLCJnZXRTdG9yYWdlU3RhdHMiLCJ0b3RhbEVudHJpZXMiLCJ0b3RhbFNpemVLQiIsInRvQmVHcmVhdGVyVGhhbiIsIm9sZGVzdEVudHJ5IiwibmV3ZXN0RW50cnkiLCJuZXdDb25maWciLCJ1cGRhdGVDb25maWciLCJjb25maWciLCJlbnRyeU5vdGVzIiwibW9ja0ltcGxlbWVudGF0aW9uT25jZSIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJnZXRTdG9yZWRFbnRyaWVzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQWtERCw2QkFBNkI7QUFDN0JBLEtBQUtDLElBQUksQ0FBQyxxREFBcUQsSUFBTyxDQUFBO1FBQ3BFQyxnQkFBZ0JGLEtBQUtHLEVBQUUsQ0FBQyxDQUFDQyxTQUFtQkMsUUFBUUMsT0FBTyxDQUFDRjtRQUM1REcsZUFBZVAsS0FBS0csRUFBRSxDQUFDLElBQU07UUFDN0JLLHdCQUF3QixjQUFjQztZQUNwQ0MsWUFBWUMsT0FBZSxDQUFFO2dCQUMzQixLQUFLLENBQUNBO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1lBQ2Q7UUFDRjtJQUNGLENBQUE7Ozs7cUNBMURnRDtBQU9oRCw0Q0FBNEM7QUFDNUMsTUFBTUMsbUJBQW1CLEFBQUMsQ0FBQTtJQUN4QixJQUFJQyxRQUFnQyxDQUFDO0lBRXJDLE9BQU87UUFDTEMsU0FBU2YsS0FBS0csRUFBRSxDQUFDLENBQUNhLE1BQWdCRixLQUFLLENBQUNFLElBQUksSUFBSTtRQUNoREMsU0FBU2pCLEtBQUtHLEVBQUUsQ0FBQyxDQUFDYSxLQUFhRTtZQUM3QkosS0FBSyxDQUFDRSxJQUFJLEdBQUdFO1FBQ2Y7UUFDQUMsWUFBWW5CLEtBQUtHLEVBQUUsQ0FBQyxDQUFDYTtZQUNuQixPQUFPRixLQUFLLENBQUNFLElBQUk7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