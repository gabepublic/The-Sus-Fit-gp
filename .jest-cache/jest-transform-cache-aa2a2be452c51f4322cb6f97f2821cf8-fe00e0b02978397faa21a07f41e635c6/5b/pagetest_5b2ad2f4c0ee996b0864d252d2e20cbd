87849c7daa13e7e2b0ba6be03e3d5e08
"use strict";
// Mock the utility functions
jest.mock('@/utils/image', ()=>({
        fileToBase64: jest.fn(),
        compressBase64: jest.fn(),
        CompressionFailedError: class CompressionFailedError extends Error {
            constructor(message){
                super(message);
                this.name = 'CompressionFailedError';
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _image = require("../../src/utils/image");
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
// Mock console methods
const mockConsoleLog = jest.spyOn(console, 'log').mockImplementation();
const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();
// Mock File constructor
global.File = jest.fn().mockImplementation((content, name, options)=>({
        name,
        size: content.length,
        type: options?.type || 'image/jpeg',
        arrayBuffer: jest.fn().mockResolvedValue(new ArrayBuffer(content.length)),
        stream: jest.fn(),
        text: jest.fn().mockResolvedValue(''),
        slice: jest.fn(),
        lastModified: Date.now()
    }));
// Mock AbortController
global.AbortController = jest.fn().mockImplementation(()=>({
        signal: 'mock-signal',
        abort: jest.fn()
    }));
// Mock setTimeout and clearTimeout
jest.useFakeTimers();
const mockSetTimeout = jest.spyOn(global, 'setTimeout');
const mockClearTimeout = jest.spyOn(global, 'clearTimeout');
describe('handleCameraButtonClick Logic Tests', ()=>{
    let mockUserFile;
    let mockApparelFile;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Create mock files
        mockUserFile = new File([
            'user-image-content'
        ], 'user.jpg', {
            type: 'image/jpeg'
        });
        mockApparelFile = new File([
            'apparel-image-content'
        ], 'apparel.jpg', {
            type: 'image/jpeg'
        });
        _image.fileToBase64.mockResolvedValue('mock-base64-string');
        _image.compressBase64.mockResolvedValue('compressed-base64-string');
        mockFetch.mockClear();
    });
    afterEach(()=>{
        jest.clearAllTimers();
    });
    // Test the core logic function that would be extracted from handleCameraButtonClick
    const processImagesAndCallAPI = async (userFile, apparelFile)=>{
        try {
            // Process images concurrently
            const [modelB64, apparelB64] = await Promise.all([
                (0, _image.fileToBase64)(userFile),
                (0, _image.fileToBase64)(apparelFile)
            ]);
            // Compress both images
            const [compressedModel, compressedApparel] = await Promise.all([
                (0, _image.compressBase64)(modelB64, 2048),
                (0, _image.compressBase64)(apparelB64, 2048)
            ]);
            // Create AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(()=>controller.abort(), 30000);
            try {
                // Make API call
                const response = await fetch('/api/tryon', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        modelImage: compressedModel,
                        apparelImages: [
                            compressedApparel
                        ]
                    }),
                    signal: controller.signal
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API request failed: ${response.status} ${errorText}`);
                }
                const { img_generated } = await response.json();
                console.log('Successfully received generated image from API');
                return {
                    success: true,
                    img_generated
                };
            } finally{
                clearTimeout(timeoutId);
            }
        } catch (error) {
            console.error('Error in processImagesAndCallAPI:', error);
            throw error;
        }
    };
    describe('Success Path', ()=>{
        it('should successfully process images and make API call', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'generated-image-base64'
                })
            });
            // Act
            const result = await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockUserFile);
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockApparelFile);
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelImage: 'compressed-base64-string',
                    apparelImages: [
                        'compressed-base64-string'
                    ]
                }),
                signal: 'mock-signal'
            });
            expect(mockConsoleLog).toHaveBeenCalledWith('Successfully received generated image from API');
            expect(result).toEqual({
                success: true,
                img_generated: 'generated-image-base64'
            });
        });
    });
    describe('Error Handling', ()=>{
        it('should handle compression failures', async ()=>{
            // Arrange
            ;
            _image.compressBase64.mockRejectedValueOnce(new _image.CompressionFailedError('Compression failed'));
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('Compression failed');
        });
        it('should handle API request failures', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                text: jest.fn().mockResolvedValue('Bad request')
            });
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('API request failed: 400 Bad request');
        });
        it('should handle timeout errors', async ()=>{
            // Arrange
            const abortError = new Error('Request aborted');
            abortError.name = 'AbortError';
            mockFetch.mockRejectedValueOnce(abortError);
            // Act & Assert
            await expect(processImagesAndCallAPI(mockUserFile, mockApparelFile)).rejects.toThrow('Request aborted');
        });
    });
    describe('Timeout Management', ()=>{
        it('should create AbortController with 30-second timeout', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(global.AbortController).toHaveBeenCalled();
            expect(mockSetTimeout).toHaveBeenCalledWith(expect.any(Function), 30000);
        });
        it('should clear timeout on successful completion', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(mockClearTimeout).toHaveBeenCalled();
        });
    });
    describe('Image Processing', ()=>{
        it('should process both images concurrently', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockUserFile);
            expect(_image.fileToBase64).toHaveBeenCalledWith(mockApparelFile);
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
        });
        it('should use correct compression limit', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(_image.compressBase64).toHaveBeenCalledWith('mock-base64-string', 2048);
        });
    });
    describe('API Request Format', ()=>{
        it('should send correct request body format', async ()=>{
            // Arrange
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    img_generated: 'test'
                })
            });
            // Act
            await processImagesAndCallAPI(mockUserFile, mockApparelFile);
            // Assert
            expect(mockFetch).toHaveBeenCalledWith('/api/tryon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelImage: 'compressed-base64-string',
                    apparelImages: [
                        'compressed-base64-string'
                    ]
                }),
                signal: 'mock-signal'
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2NvbXBvbmVudHMvcGFnZS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaWxlVG9CYXNlNjQsIGNvbXByZXNzQmFzZTY0LCBDb21wcmVzc2lvbkZhaWxlZEVycm9yIH0gZnJvbSAnQC91dGlscy9pbWFnZSdcblxuLy8gTW9jayB0aGUgdXRpbGl0eSBmdW5jdGlvbnNcbmplc3QubW9jaygnQC91dGlscy9pbWFnZScsICgpID0+ICh7XG4gIGZpbGVUb0Jhc2U2NDogamVzdC5mbigpLFxuICBjb21wcmVzc0Jhc2U2NDogamVzdC5mbigpLFxuICBDb21wcmVzc2lvbkZhaWxlZEVycm9yOiBjbGFzcyBDb21wcmVzc2lvbkZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICAgIHRoaXMubmFtZSA9ICdDb21wcmVzc2lvbkZhaWxlZEVycm9yJ1xuICAgIH1cbiAgfVxufSkpXG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKVxuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBtb2NrQ29uc29sZUxvZyA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG5jb25zdCBtb2NrQ29uc29sZUVycm9yID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKVxuXG4vLyBNb2NrIEZpbGUgY29uc3RydWN0b3Jcbmdsb2JhbC5GaWxlID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoY29udGVudCwgbmFtZSwgb3B0aW9ucykgPT4gKHtcbiAgbmFtZSxcbiAgc2l6ZTogY29udGVudC5sZW5ndGgsXG4gIHR5cGU6IG9wdGlvbnM/LnR5cGUgfHwgJ2ltYWdlL2pwZWcnLFxuICBhcnJheUJ1ZmZlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG5ldyBBcnJheUJ1ZmZlcihjb250ZW50Lmxlbmd0aCkpLFxuICBzdHJlYW06IGplc3QuZm4oKSxcbiAgdGV4dDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCcnKSxcbiAgc2xpY2U6IGplc3QuZm4oKSxcbiAgbGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxufSkpXG5cbi8vIE1vY2sgQWJvcnRDb250cm9sbGVyXG5nbG9iYWwuQWJvcnRDb250cm9sbGVyID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICBzaWduYWw6ICdtb2NrLXNpZ25hbCcsXG4gIGFib3J0OiBqZXN0LmZuKCksXG59KSlcblxuLy8gTW9jayBzZXRUaW1lb3V0IGFuZCBjbGVhclRpbWVvdXRcbmplc3QudXNlRmFrZVRpbWVycygpXG5jb25zdCBtb2NrU2V0VGltZW91dCA9IGplc3Quc3B5T24oZ2xvYmFsLCAnc2V0VGltZW91dCcpXG5jb25zdCBtb2NrQ2xlYXJUaW1lb3V0ID0gamVzdC5zcHlPbihnbG9iYWwsICdjbGVhclRpbWVvdXQnKVxuXG5kZXNjcmliZSgnaGFuZGxlQ2FtZXJhQnV0dG9uQ2xpY2sgTG9naWMgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBtb2NrVXNlckZpbGU6IEZpbGVcbiAgbGV0IG1vY2tBcHBhcmVsRmlsZTogRmlsZVxuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gICAgXG4gICAgLy8gQ3JlYXRlIG1vY2sgZmlsZXNcbiAgICBtb2NrVXNlckZpbGUgPSBuZXcgRmlsZShbJ3VzZXItaW1hZ2UtY29udGVudCddLCAndXNlci5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgIG1vY2tBcHBhcmVsRmlsZSA9IG5ldyBGaWxlKFsnYXBwYXJlbC1pbWFnZS1jb250ZW50J10sICdhcHBhcmVsLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgXG4gICAgLy8gUmVzZXQgbW9jayBpbXBsZW1lbnRhdGlvbnNcbiAgICA7KGZpbGVUb0Jhc2U2NCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKCdtb2NrLWJhc2U2NC1zdHJpbmcnKVxuICAgIDsoY29tcHJlc3NCYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnY29tcHJlc3NlZC1iYXNlNjQtc3RyaW5nJylcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKClcbiAgfSlcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxUaW1lcnMoKVxuICB9KVxuXG4gIC8vIFRlc3QgdGhlIGNvcmUgbG9naWMgZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSBleHRyYWN0ZWQgZnJvbSBoYW5kbGVDYW1lcmFCdXR0b25DbGlja1xuICBjb25zdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSSA9IGFzeW5jICh1c2VyRmlsZTogRmlsZSwgYXBwYXJlbEZpbGU6IEZpbGUpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gUHJvY2VzcyBpbWFnZXMgY29uY3VycmVudGx5XG4gICAgICBjb25zdCBbbW9kZWxCNjQsIGFwcGFyZWxCNjRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBmaWxlVG9CYXNlNjQodXNlckZpbGUpLFxuICAgICAgICBmaWxlVG9CYXNlNjQoYXBwYXJlbEZpbGUpXG4gICAgICBdKVxuXG4gICAgICAvLyBDb21wcmVzcyBib3RoIGltYWdlc1xuICAgICAgY29uc3QgW2NvbXByZXNzZWRNb2RlbCwgY29tcHJlc3NlZEFwcGFyZWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBjb21wcmVzc0Jhc2U2NChtb2RlbEI2NCwgMjA0OCksXG4gICAgICAgIGNvbXByZXNzQmFzZTY0KGFwcGFyZWxCNjQsIDIwNDgpXG4gICAgICBdKVxuXG4gICAgICAvLyBDcmVhdGUgQWJvcnRDb250cm9sbGVyIGZvciB0aW1lb3V0XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgMzAwMDApXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE1ha2UgQVBJIGNhbGxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS90cnlvbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBtb2RlbEltYWdlOiBjb21wcmVzc2VkTW9kZWwsXG4gICAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbY29tcHJlc3NlZEFwcGFyZWxdXG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3JUZXh0fWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGltZ19nZW5lcmF0ZWQgfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHJlY2VpdmVkIGdlbmVyYXRlZCBpbWFnZSBmcm9tIEFQSScpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBpbWdfZ2VuZXJhdGVkIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBkZXNjcmliZSgnU3VjY2VzcyBQYXRoJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IHByb2Nlc3MgaW1hZ2VzIGFuZCBtYWtlIEFQSSBjYWxsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpbWdfZ2VuZXJhdGVkOiAnZ2VuZXJhdGVkLWltYWdlLWJhc2U2NCcgfSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkobW9ja1VzZXJGaWxlLCBtb2NrQXBwYXJlbEZpbGUpXG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGZpbGVUb0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXJGaWxlKVxuICAgICAgZXhwZWN0KGZpbGVUb0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0FwcGFyZWxGaWxlKVxuICAgICAgZXhwZWN0KGNvbXByZXNzQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnbW9jay1iYXNlNjQtc3RyaW5nJywgMjA0OClcbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL3RyeW9uJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBtb2RlbEltYWdlOiAnY29tcHJlc3NlZC1iYXNlNjQtc3RyaW5nJyxcbiAgICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbJ2NvbXByZXNzZWQtYmFzZTY0LXN0cmluZyddXG4gICAgICAgIH0pLFxuICAgICAgICBzaWduYWw6ICdtb2NrLXNpZ25hbCdcbiAgICAgIH0pXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGVMb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdTdWNjZXNzZnVsbHkgcmVjZWl2ZWQgZ2VuZXJhdGVkIGltYWdlIGZyb20gQVBJJylcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlLCBpbWdfZ2VuZXJhdGVkOiAnZ2VuZXJhdGVkLWltYWdlLWJhc2U2NCcgfSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wcmVzc2lvbiBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIDsoY29tcHJlc3NCYXNlNjQgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IENvbXByZXNzaW9uRmFpbGVkRXJyb3IoJ0NvbXByZXNzaW9uIGZhaWxlZCcpKVxuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0NvbXByZXNzaW9uIGZhaWxlZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEFQSSByZXF1ZXN0IGZhaWx1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgIHRleHQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnQmFkIHJlcXVlc3QnKVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QocHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkobW9ja1VzZXJGaWxlLCBtb2NrQXBwYXJlbEZpbGUpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdBUEkgcmVxdWVzdCBmYWlsZWQ6IDQwMCBCYWQgcmVxdWVzdCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRpbWVvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignUmVxdWVzdCBhYm9ydGVkJylcbiAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZWplY3RlZFZhbHVlT25jZShhYm9ydEVycm9yKVxuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ1JlcXVlc3QgYWJvcnRlZCcpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVGltZW91dCBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIEFib3J0Q29udHJvbGxlciB3aXRoIDMwLXNlY29uZCB0aW1lb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpbWdfZ2VuZXJhdGVkOiAndGVzdCcgfSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgcHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkobW9ja1VzZXJGaWxlLCBtb2NrQXBwYXJlbEZpbGUpXG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGdsb2JhbC5BYm9ydENvbnRyb2xsZXIpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KG1vY2tTZXRUaW1lb3V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3QuYW55KEZ1bmN0aW9uKSwgMzAwMDApXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgY2xlYXIgdGltZW91dCBvbiBzdWNjZXNzZnVsIGNvbXBsZXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICd0ZXN0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0NsZWFyVGltZW91dCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnSW1hZ2UgUHJvY2Vzc2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgYm90aCBpbWFnZXMgY29uY3VycmVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpbWdfZ2VuZXJhdGVkOiAndGVzdCcgfSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgcHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkobW9ja1VzZXJGaWxlLCBtb2NrQXBwYXJlbEZpbGUpXG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGZpbGVUb0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXJGaWxlKVxuICAgICAgZXhwZWN0KGZpbGVUb0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0FwcGFyZWxGaWxlKVxuICAgICAgZXhwZWN0KGNvbXByZXNzQmFzZTY0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnbW9jay1iYXNlNjQtc3RyaW5nJywgMjA0OClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB1c2UgY29ycmVjdCBjb21wcmVzc2lvbiBsaW1pdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaW1nX2dlbmVyYXRlZDogJ3Rlc3QnIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBBY3RcbiAgICAgIGF3YWl0IHByb2Nlc3NJbWFnZXNBbmRDYWxsQVBJKG1vY2tVc2VyRmlsZSwgbW9ja0FwcGFyZWxGaWxlKVxuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChjb21wcmVzc0Jhc2U2NCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ21vY2stYmFzZTY0LXN0cmluZycsIDIwNDgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnQVBJIFJlcXVlc3QgRm9ybWF0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc2VuZCBjb3JyZWN0IHJlcXVlc3QgYm9keSBmb3JtYXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGltZ19nZW5lcmF0ZWQ6ICd0ZXN0JyB9KVxuICAgICAgfSlcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBwcm9jZXNzSW1hZ2VzQW5kQ2FsbEFQSShtb2NrVXNlckZpbGUsIG1vY2tBcHBhcmVsRmlsZSlcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS90cnlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbW9kZWxJbWFnZTogJ2NvbXByZXNzZWQtYmFzZTY0LXN0cmluZycsXG4gICAgICAgICAgYXBwYXJlbEltYWdlczogWydjb21wcmVzc2VkLWJhc2U2NC1zdHJpbmcnXVxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmFsOiAnbW9jay1zaWduYWwnXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59KSAiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJmaWxlVG9CYXNlNjQiLCJmbiIsImNvbXByZXNzQmFzZTY0IiwiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIm1vY2tGZXRjaCIsImdsb2JhbCIsImZldGNoIiwibW9ja0NvbnNvbGVMb2ciLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJtb2NrQ29uc29sZUVycm9yIiwiRmlsZSIsImNvbnRlbnQiLCJvcHRpb25zIiwic2l6ZSIsImxlbmd0aCIsInR5cGUiLCJhcnJheUJ1ZmZlciIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiQXJyYXlCdWZmZXIiLCJzdHJlYW0iLCJ0ZXh0Iiwic2xpY2UiLCJsYXN0TW9kaWZpZWQiLCJEYXRlIiwibm93IiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwiYWJvcnQiLCJ1c2VGYWtlVGltZXJzIiwibW9ja1NldFRpbWVvdXQiLCJtb2NrQ2xlYXJUaW1lb3V0IiwiZGVzY3JpYmUiLCJtb2NrVXNlckZpbGUiLCJtb2NrQXBwYXJlbEZpbGUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyRWFjaCIsImNsZWFyQWxsVGltZXJzIiwicHJvY2Vzc0ltYWdlc0FuZENhbGxBUEkiLCJ1c2VyRmlsZSIsImFwcGFyZWxGaWxlIiwibW9kZWxCNjQiLCJhcHBhcmVsQjY0IiwiUHJvbWlzZSIsImFsbCIsImNvbXByZXNzZWRNb2RlbCIsImNvbXByZXNzZWRBcHBhcmVsIiwiY29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJyZXNwb25zZSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwib2siLCJlcnJvclRleHQiLCJzdGF0dXMiLCJpbWdfZ2VuZXJhdGVkIiwianNvbiIsImxvZyIsInN1Y2Nlc3MiLCJjbGVhclRpbWVvdXQiLCJlcnJvciIsIml0IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwicmVzdWx0IiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0VxdWFsIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJhYm9ydEVycm9yIiwidG9IYXZlQmVlbkNhbGxlZCIsImFueSIsIkZ1bmN0aW9uIl0sIm1hcHBp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