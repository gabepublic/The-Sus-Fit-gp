de8756cc80f3cc98b036423f9f5b8a0c
/**
 * Unit tests for generateTryOn wrapper function
 * 
 * Tests the OpenAI service wrapper to ensure it validates I/O,
 * returns expected data, and properly propagates errors.
 */ "use strict";
// Mock getEnv first
jest.mock('../src/lib/getEnv', ()=>({
        getEnv: jest.fn(()=>({
                key: 'test-api-key',
                model: 'gpt-image-1'
            }))
    }));
// Mock OpenAI
jest.mock('openai', ()=>{
    const mockImagesEdit = jest.fn();
    return jest.fn().mockImplementation(()=>({
            images: {
                edit: mockImagesEdit
            }
        }));
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _zod = require("zod");
const _openaiClient = require("../src/lib/openaiClient");
describe('generateTryOn', ()=>{
    const validBase64Image = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    const mockOpenAIResponse = {
        data: [
            {
                b64_json: 'ZmFrZUJhc2U2NA=='
            }
        ]
    };
    // Get the mock function from the mocked module
    const getMockImagesEdit = ()=>{
        const OpenAI = require('openai');
        const mockInstance = new OpenAI();
        return mockInstance.images.edit;
    };
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Happy Path', ()=>{
        it('should successfully generate try-on image with valid inputs', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            mockImagesEdit.mockResolvedValue(mockOpenAIResponse);
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act
            const result = await (0, _openaiClient.generateTryOn)(params);
            // Assert
            expect(result).toBe('ZmFrZUJhc2U2NA==');
            expect(mockImagesEdit).toHaveBeenCalledTimes(1);
            expect(mockImagesEdit).toHaveBeenCalledWith({
                model: 'gpt-image-1',
                image: expect.arrayContaining([
                    expect.any(File),
                    expect.any(File)
                ]),
                prompt: 'Change the garment of the model in the first image with the garment from the second image.',
                n: 1,
                size: '1024x1024',
                quality: 'low'
            });
            // Verify File objects have correct names
            const callArgs = mockImagesEdit.mock.calls[0][0];
            expect(callArgs.image[0].name).toBe('model.png');
            expect(callArgs.image[1].name).toBe('apparel.png');
        });
        it('should use the first apparel image when multiple are provided', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            mockImagesEdit.mockResolvedValue(mockOpenAIResponse);
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image,
                    validBase64Image,
                    validBase64Image
                ]
            };
            // Act
            const result = await (0, _openaiClient.generateTryOn)(params);
            // Assert
            expect(result).toBe('ZmFrZUJhc2U2NA==');
            expect(mockImagesEdit).toHaveBeenCalledWith(expect.objectContaining({
                image: expect.arrayContaining([
                    expect.any(File),
                    expect.any(File)
                ])
            }));
            // Verify only first apparel image is used
            const callArgs = mockImagesEdit.mock.calls[0][0];
            expect(callArgs.image).toHaveLength(2);
            expect(callArgs.image[0].name).toBe('model.png');
            expect(callArgs.image[1].name).toBe('apparel.png');
        });
    });
    describe('Input Validation', ()=>{
        it('should throw ZodError for invalid base64 model image', async ()=>{
            // Arrange
            const params = {
                modelImage: 'invalid-base64-data',
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error.cause).toBeInstanceOf(_zod.ZodError);
                const mockImagesEdit = getMockImagesEdit();
                expect(mockImagesEdit).not.toHaveBeenCalled();
            }
        });
        it('should throw ZodError for invalid base64 apparel image', async ()=>{
            // Arrange
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    'invalid-base64-data'
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error.cause).toBeInstanceOf(_zod.ZodError);
                const mockImagesEdit = getMockImagesEdit();
                expect(mockImagesEdit).not.toHaveBeenCalled();
            }
        });
        it('should throw ZodError for empty apparel images array', async ()=>{
            // Arrange
            const params = {
                modelImage: validBase64Image,
                apparelImages: []
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error.cause).toBeInstanceOf(_zod.ZodError);
                const mockImagesEdit = getMockImagesEdit();
                expect(mockImagesEdit).not.toHaveBeenCalled();
            }
        });
        it('should throw ZodError for missing apparel images', async ()=>{
            // Arrange
            const params = {
                modelImage: validBase64Image,
                apparelImages: undefined
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error.cause).toBeInstanceOf(_zod.ZodError);
                const mockImagesEdit = getMockImagesEdit();
                expect(mockImagesEdit).not.toHaveBeenCalled();
            }
        });
    });
    describe('OpenAI API Error Handling', ()=>{
        it('should propagate OpenAI API errors with custom context', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            const apiError = new Error('OpenAI API error');
            mockImagesEdit.mockRejectedValue(apiError);
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed: OpenAI API error');
                expect(error.cause).toBe(apiError);
            }
        });
        it('should handle OpenAI API errors with non-Error objects', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            const apiError = 'String error';
            mockImagesEdit.mockRejectedValue(apiError);
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed: Unknown error occurred');
                expect(error.cause).toBe(apiError);
            }
        });
        it('should handle OpenAI API timeout errors', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            const timeoutError = new Error('Request timeout');
            timeoutError.name = 'AbortError';
            mockImagesEdit.mockRejectedValue(timeoutError);
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed: Request timeout');
                expect(error.cause).toBe(timeoutError);
            }
        });
    });
    describe('Response Validation', ()=>{
        it('should throw error when OpenAI returns no data', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            mockImagesEdit.mockResolvedValue({
                data: []
            });
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed: No response data received from OpenAI API');
            }
        });
        it('should throw error when OpenAI returns undefined data', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            mockImagesEdit.mockResolvedValue({
                data: undefined
            });
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed: No response data received from OpenAI API');
            }
        });
        it('should throw error when OpenAI returns invalid base64 in response', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            mockImagesEdit.mockResolvedValue({
                data: [
                    {
                        b64_json: 'invalid-base64'
                    }
                ]
            });
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed');
                expect(error.cause).toBeInstanceOf(_zod.ZodError);
            }
        });
        it('should throw error when OpenAI returns no b64_json in response', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            mockImagesEdit.mockResolvedValue({
                data: [
                    {}
                ]
            });
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed: No image data received from OpenAI API');
            }
        });
    });
    describe('Timeout and Promise Handling', ()=>{
        it('should not swallow timeout errors', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            const timeoutError = new Error('Request timeout');
            mockImagesEdit.mockRejectedValue(timeoutError);
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toContain('generateTryOn failed: Request timeout');
                expect(error.cause).toBe(timeoutError);
            }
        });
    });
    describe('Error Context Preservation', ()=>{
        it('should preserve original error as cause', async ()=>{
            // Arrange
            const mockImagesEdit = getMockImagesEdit();
            const originalError = new Error('Original error');
            mockImagesEdit.mockRejectedValue(originalError);
            const params = {
                modelImage: validBase64Image,
                apparelImages: [
                    validBase64Image
                ]
            };
            // Act & Assert
            try {
                await (0, _openaiClient.generateTryOn)(params);
                fail('Expected function to throw an error');
            } catch (error) {
                expect(error.cause).toBe(originalError);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3AvX190ZXN0c19fL2dlbmVyYXRlVHJ5T24uc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaXQgdGVzdHMgZm9yIGdlbmVyYXRlVHJ5T24gd3JhcHBlciBmdW5jdGlvblxuICogXG4gKiBUZXN0cyB0aGUgT3BlbkFJIHNlcnZpY2Ugd3JhcHBlciB0byBlbnN1cmUgaXQgdmFsaWRhdGVzIEkvTyxcbiAqIHJldHVybnMgZXhwZWN0ZWQgZGF0YSwgYW5kIHByb3Blcmx5IHByb3BhZ2F0ZXMgZXJyb3JzLlxuICovXG5cbmltcG9ydCB7IFpvZEVycm9yIH0gZnJvbSAnem9kJztcblxuLy8gTW9jayBnZXRFbnYgZmlyc3Rcbmplc3QubW9jaygnLi4vc3JjL2xpYi9nZXRFbnYnLCAoKSA9PiAoe1xuICBnZXRFbnY6IGplc3QuZm4oKCkgPT4gKHtcbiAgICBrZXk6ICd0ZXN0LWFwaS1rZXknLFxuICAgIG1vZGVsOiAnZ3B0LWltYWdlLTEnXG4gIH0pKVxufSkpO1xuXG4vLyBNb2NrIE9wZW5BSVxuamVzdC5tb2NrKCdvcGVuYWknLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gamVzdC5mbigpO1xuICByZXR1cm4gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICAgIGltYWdlczoge1xuICAgICAgZWRpdDogbW9ja0ltYWdlc0VkaXRcbiAgICB9XG4gIH0pKTtcbn0pO1xuXG4vLyBJbXBvcnQgYWZ0ZXIgbW9ja3MgYXJlIHNldCB1cFxuaW1wb3J0IHsgZ2VuZXJhdGVUcnlPbiB9IGZyb20gJy4uL3NyYy9saWIvb3BlbmFpQ2xpZW50JztcblxuZGVzY3JpYmUoJ2dlbmVyYXRlVHJ5T24nLCAoKSA9PiB7XG4gIGNvbnN0IHZhbGlkQmFzZTY0SW1hZ2UgPSAnaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBRFVsRVFWUjQybU5rWVBoZkR3QUNod0dBNjBlNmtnQUFBQUJKUlU1RXJrSmdnZz09JztcbiAgXG4gIGNvbnN0IG1vY2tPcGVuQUlSZXNwb25zZSA9IHtcbiAgICBkYXRhOiBbXG4gICAgICB7XG4gICAgICAgIGI2NF9qc29uOiAnWm1GclpVSmhjMlUyTkE9PSdcbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgLy8gR2V0IHRoZSBtb2NrIGZ1bmN0aW9uIGZyb20gdGhlIG1vY2tlZCBtb2R1bGVcbiAgY29uc3QgZ2V0TW9ja0ltYWdlc0VkaXQgPSAoKSA9PiB7XG4gICAgY29uc3QgT3BlbkFJID0gcmVxdWlyZSgnb3BlbmFpJyk7XG4gICAgY29uc3QgbW9ja0luc3RhbmNlID0gbmV3IE9wZW5BSSgpO1xuICAgIHJldHVybiBtb2NrSW5zdGFuY2UuaW1hZ2VzLmVkaXQ7XG4gIH07XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdIYXBweSBQYXRoJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlIHRyeS1vbiBpbWFnZSB3aXRoIHZhbGlkIGlucHV0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgIG1vY2tJbWFnZXNFZGl0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tPcGVuQUlSZXNwb25zZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdabUZyWlVKaGMyVTJOQT09Jyk7XG4gICAgICBleHBlY3QobW9ja0ltYWdlc0VkaXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBtb2RlbDogJ2dwdC1pbWFnZS0xJyxcbiAgICAgICAgaW1hZ2U6IGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICAgICAgIGV4cGVjdC5hbnkoRmlsZSksXG4gICAgICAgICAgZXhwZWN0LmFueShGaWxlKVxuICAgICAgICBdKSxcbiAgICAgICAgcHJvbXB0OiAnQ2hhbmdlIHRoZSBnYXJtZW50IG9mIHRoZSBtb2RlbCBpbiB0aGUgZmlyc3QgaW1hZ2Ugd2l0aCB0aGUgZ2FybWVudCBmcm9tIHRoZSBzZWNvbmQgaW1hZ2UuJyxcbiAgICAgICAgbjogMSxcbiAgICAgICAgc2l6ZTogJzEwMjR4MTAyNCcsXG4gICAgICAgIHF1YWxpdHk6ICdsb3cnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IEZpbGUgb2JqZWN0cyBoYXZlIGNvcnJlY3QgbmFtZXNcbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gbW9ja0ltYWdlc0VkaXQubW9jay5jYWxsc1swXVswXTtcbiAgICAgIGV4cGVjdChjYWxsQXJncy5pbWFnZVswXS5uYW1lKS50b0JlKCdtb2RlbC5wbmcnKTtcbiAgICAgIGV4cGVjdChjYWxsQXJncy5pbWFnZVsxXS5uYW1lKS50b0JlKCdhcHBhcmVsLnBuZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgdGhlIGZpcnN0IGFwcGFyZWwgaW1hZ2Ugd2hlbiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrT3BlbkFJUmVzcG9uc2UpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFt2YWxpZEJhc2U2NEltYWdlLCB2YWxpZEJhc2U2NEltYWdlLCB2YWxpZEJhc2U2NEltYWdlXVxuICAgICAgfTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZVRyeU9uKHBhcmFtcyk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnWm1GclpVSmhjMlUyTkE9PScpO1xuICAgICAgZXhwZWN0KG1vY2tJbWFnZXNFZGl0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGltYWdlOiBleHBlY3QuYXJyYXlDb250YWluaW5nKFtcbiAgICAgICAgICAgIGV4cGVjdC5hbnkoRmlsZSksXG4gICAgICAgICAgICBleHBlY3QuYW55KEZpbGUpXG4gICAgICAgICAgXSlcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBvbmx5IGZpcnN0IGFwcGFyZWwgaW1hZ2UgaXMgdXNlZFxuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBtb2NrSW1hZ2VzRWRpdC5tb2NrLmNhbGxzWzBdWzBdO1xuICAgICAgZXhwZWN0KGNhbGxBcmdzLmltYWdlKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QoY2FsbEFyZ3MuaW1hZ2VbMF0ubmFtZSkudG9CZSgnbW9kZWwucG5nJyk7XG4gICAgICBleHBlY3QoY2FsbEFyZ3MuaW1hZ2VbMV0ubmFtZSkudG9CZSgnYXBwYXJlbC5wbmcnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0lucHV0IFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBab2RFcnJvciBmb3IgaW52YWxpZCBiYXNlNjQgbW9kZWwgaW1hZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6ICdpbnZhbGlkLWJhc2U2NC1kYXRhJyxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgYW55KS5jYXVzZSkudG9CZUluc3RhbmNlT2YoWm9kRXJyb3IpO1xuICAgICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgWm9kRXJyb3IgZm9yIGludmFsaWQgYmFzZTY0IGFwcGFyZWwgaW1hZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFsnaW52YWxpZC1iYXNlNjQtZGF0YSddXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgYW55KS5jYXVzZSkudG9CZUluc3RhbmNlT2YoWm9kRXJyb3IpO1xuICAgICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgWm9kRXJyb3IgZm9yIGVtcHR5IGFwcGFyZWwgaW1hZ2VzIGFycmF5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbXVxuICAgICAgfTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBnZW5lcmF0ZVRyeU9uKHBhcmFtcyk7XG4gICAgICAgIGZhaWwoJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIGVycm9yJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBleHBlY3QoKGVycm9yIGFzIGFueSkuY2F1c2UpLnRvQmVJbnN0YW5jZU9mKFpvZEVycm9yKTtcbiAgICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgICBleHBlY3QobW9ja0ltYWdlc0VkaXQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IFpvZEVycm9yIGZvciBtaXNzaW5nIGFwcGFyZWwgaW1hZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiB1bmRlZmluZWQgYXMgYW55XG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgYW55KS5jYXVzZSkudG9CZUluc3RhbmNlT2YoWm9kRXJyb3IpO1xuICAgICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICAgIGV4cGVjdChtb2NrSW1hZ2VzRWRpdCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ09wZW5BSSBBUEkgRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcm9wYWdhdGUgT3BlbkFJIEFQSSBlcnJvcnMgd2l0aCBjdXN0b20gY29udGV4dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEVycm9yKCdPcGVuQUkgQVBJIGVycm9yJyk7XG4gICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVqZWN0ZWRWYWx1ZShhcGlFcnJvcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgICBleHBlY3QoKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlKS50b0NvbnRhaW4oJ2dlbmVyYXRlVHJ5T24gZmFpbGVkOiBPcGVuQUkgQVBJIGVycm9yJyk7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgYW55KS5jYXVzZSkudG9CZShhcGlFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBPcGVuQUkgQVBJIGVycm9ycyB3aXRoIG5vbi1FcnJvciBvYmplY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgY29uc3QgYXBpRXJyb3IgPSAnU3RyaW5nIGVycm9yJztcbiAgICAgIG1vY2tJbWFnZXNFZGl0Lm1vY2tSZWplY3RlZFZhbHVlKGFwaUVycm9yKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZV1cbiAgICAgIH07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVUcnlPbihwYXJhbXMpO1xuICAgICAgICBmYWlsKCdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBlcnJvcicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UpLnRvQ29udGFpbignZ2VuZXJhdGVUcnlPbiBmYWlsZWQ6IFVua25vd24gZXJyb3Igb2NjdXJyZWQnKTtcbiAgICAgICAgZXhwZWN0KChlcnJvciBhcyBhbnkpLmNhdXNlKS50b0JlKGFwaUVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIE9wZW5BSSBBUEkgdGltZW91dCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICBjb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpO1xuICAgICAgdGltZW91dEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICBtb2NrSW1hZ2VzRWRpdC5tb2NrUmVqZWN0ZWRWYWx1ZSh0aW1lb3V0RXJyb3IpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG1vZGVsSW1hZ2U6IHZhbGlkQmFzZTY0SW1hZ2UsXG4gICAgICAgIGFwcGFyZWxJbWFnZXM6IFt2YWxpZEJhc2U2NEltYWdlXVxuICAgICAgfTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBnZW5lcmF0ZVRyeU9uKHBhcmFtcyk7XG4gICAgICAgIGZhaWwoJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIGVycm9yJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgICAgZXhwZWN0KChlcnJvciBhcyBFcnJvcikubWVzc2FnZSkudG9Db250YWluKCdnZW5lcmF0ZVRyeU9uIGZhaWxlZDogUmVxdWVzdCB0aW1lb3V0Jyk7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgYW55KS5jYXVzZSkudG9CZSh0aW1lb3V0RXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVzcG9uc2UgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIHdoZW4gT3BlbkFJIHJldHVybnMgbm8gZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tJbWFnZXNFZGl0ID0gZ2V0TW9ja0ltYWdlc0VkaXQoKTtcbiAgICAgIG1vY2tJbWFnZXNFZGl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogW10gfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgICBleHBlY3QoKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlKS50b0NvbnRhaW4oJ2dlbmVyYXRlVHJ5T24gZmFpbGVkOiBObyByZXNwb25zZSBkYXRhIHJlY2VpdmVkIGZyb20gT3BlbkFJIEFQSScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIE9wZW5BSSByZXR1cm5zIHVuZGVmaW5lZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiB1bmRlZmluZWQgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgICBleHBlY3QoKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlKS50b0NvbnRhaW4oJ2dlbmVyYXRlVHJ5T24gZmFpbGVkOiBObyByZXNwb25zZSBkYXRhIHJlY2VpdmVkIGZyb20gT3BlbkFJIEFQSScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIE9wZW5BSSByZXR1cm5zIGludmFsaWQgYmFzZTY0IGluIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbeyBiNjRfanNvbjogJ2ludmFsaWQtYmFzZTY0JyB9XVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgICBleHBlY3QoKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlKS50b0NvbnRhaW4oJ2dlbmVyYXRlVHJ5T24gZmFpbGVkJyk7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgYW55KS5jYXVzZSkudG9CZUluc3RhbmNlT2YoWm9kRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIE9wZW5BSSByZXR1cm5zIG5vIGI2NF9qc29uIGluIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja0ltYWdlc0VkaXQgPSBnZXRNb2NrSW1hZ2VzRWRpdCgpO1xuICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbe31dXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZV1cbiAgICAgIH07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVUcnlPbihwYXJhbXMpO1xuICAgICAgICBmYWlsKCdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBlcnJvcicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UpLnRvQ29udGFpbignZ2VuZXJhdGVUcnlPbiBmYWlsZWQ6IE5vIGltYWdlIGRhdGEgcmVjZWl2ZWQgZnJvbSBPcGVuQUkgQVBJJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUaW1lb3V0IGFuZCBQcm9taXNlIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbm90IHN3YWxsb3cgdGltZW91dCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICBjb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpO1xuICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1JlamVjdGVkVmFsdWUodGltZW91dEVycm9yKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBtb2RlbEltYWdlOiB2YWxpZEJhc2U2NEltYWdlLFxuICAgICAgICBhcHBhcmVsSW1hZ2VzOiBbdmFsaWRCYXNlNjRJbWFnZV1cbiAgICAgIH07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVUcnlPbihwYXJhbXMpO1xuICAgICAgICBmYWlsKCdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBlcnJvcicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UpLnRvQ29udGFpbignZ2VuZXJhdGVUcnlPbiBmYWlsZWQ6IFJlcXVlc3QgdGltZW91dCcpO1xuICAgICAgICBleHBlY3QoKGVycm9yIGFzIGFueSkuY2F1c2UpLnRvQmUodGltZW91dEVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIENvbnRleHQgUHJlc2VydmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJlc2VydmUgb3JpZ2luYWwgZXJyb3IgYXMgY2F1c2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrSW1hZ2VzRWRpdCA9IGdldE1vY2tJbWFnZXNFZGl0KCk7XG4gICAgICBjb25zdCBvcmlnaW5hbEVycm9yID0gbmV3IEVycm9yKCdPcmlnaW5hbCBlcnJvcicpO1xuICAgICAgbW9ja0ltYWdlc0VkaXQubW9ja1JlamVjdGVkVmFsdWUob3JpZ2luYWxFcnJvcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbW9kZWxJbWFnZTogdmFsaWRCYXNlNjRJbWFnZSxcbiAgICAgICAgYXBwYXJlbEltYWdlczogW3ZhbGlkQmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ5T24ocGFyYW1zKTtcbiAgICAgICAgZmFpbCgnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGV4cGVjdCgoZXJyb3IgYXMgYW55KS5jYXVzZSkudG9CZShvcmlnaW5hbEVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTsgIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZ2V0RW52IiwiZm4iLCJrZXkiLCJtb2RlbCIsIm1vY2tJbWFnZXNFZGl0IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiaW1hZ2VzIiwiZWRpdCIsImRlc2NyaWJlIiwidmFsaWRCYXNlNjRJbWFnZSIsIm1vY2tPcGVuQUlSZXNwb25zZSIsImRhdGEiLCJiNjRfanNvbiIsImdldE1vY2tJbWFnZXNFZGl0IiwiT3BlbkFJIiwicmVxdWlyZSIsIm1vY2tJbnN0YW5jZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInBhcmFtcyIsIm1vZGVsSW1hZ2UiLCJhcHBhcmVsSW1hZ2VzIiwicmVzdWx0IiwiZ2VuZXJhdGVUcnlPbiIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImltYWdlIiwiYXJyYXlDb250YWluaW5nIiwiYW55IiwiRmlsZSIsInByb21wdCIsIm4iLCJzaXplIiwicXVhbGl0eSIsImNhbGxBcmdzIiwiY2FsbHMiLCJuYW1lIiwib2JqZWN0Q29udGFpbmluZyIsInRvSGF2ZUxlbmd0aCIsImZhaWwiLCJlcnJvciIsImNhdXNlIiwidG9CZUluc3RhbmNlT2YiLCJab2RFcnJvciIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ1bmRlZmluZWQiLCJhcGlFcnJvciIsIkVycm9yIiwibW9ja1JlamVjdGVkVmFsdWUiLCJtZXNzYWdlIiwidG9Db250YWluIiwidGltZW91dEVycm9yIiwib3JpZ2luYWxFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7QUFJRCxvQkFBb0I7QUFDcEJBLEtBQUtDLElBQUksQ0FBQyxxQkFBcUIsSUFBTyxDQUFBO1FBQ3BDQyxRQUFRRixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO2dCQUNyQkMsS0FBSztnQkFDTEMsT0FBTztZQUNULENBQUE7SUFDRixDQUFBO0FBRUEsY0FBYztBQUNkTCxLQUFLQyxJQUFJLENBQUMsVUFBVTtJQUNsQixNQUFNSyxpQkFBaUJOLEtBQUtHLEVBQUU7SUFDOUIsT0FBT0gsS0FBS0csRUFBRSxHQUFHSSxrQkFBa0IsQ0FBQyxJQUFPLENBQUE7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