e93390485e82194ae36e3bd4f64b125a
// Try-On History Storage Service
// Implements persistent storage for try-on history using localStorage with compression
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    LocalStorageTryonHistoryService: function() {
        return LocalStorageTryonHistoryService;
    },
    defaultHistoryService: function() {
        return defaultHistoryService;
    }
});
const _image = require("../../utils/image");
/**
 * Default configuration for history storage
 */ const DEFAULT_CONFIG = {
    storageType: 'localStorage',
    maxEntries: 50,
    maxEntrySizeKB: 2048,
    compressImages: true,
    compressionQuality: 0.8,
    autoCleanup: true,
    encryptionKey: ''
};
/**
 * Storage keys for localStorage
 */ const STORAGE_KEYS = {
    ENTRIES: 'susfit_tryon_history_entries',
    CONFIG: 'susfit_tryon_history_config',
    METADATA: 'susfit_tryon_history_metadata'
};
/**
 * Generate a unique ID for history entries
 */ function generateHistoryId() {
    return `tryon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
/**
 * Calculate the size of a history entry in KB
 */ function calculateEntrySize(entry) {
    const json = JSON.stringify(entry);
    return new Blob([
        json
    ]).size / 1024;
}
/**
 * Compress images in a history entry
 */ async function compressHistoryEntry(entry, config) {
    if (!config.compressImages) {
        return entry;
    }
    try {
        const maxSizeKB = config.maxEntrySizeKB / (2 + entry.apparelImages.length);
        const quality = config.compressionQuality;
        // Compress generated image
        const compressedGenerated = await (0, _image.compressBase64)(entry.generatedImage, maxSizeKB, quality);
        // Compress model image
        const compressedModel = await (0, _image.compressBase64)(entry.modelImage, maxSizeKB, quality);
        // Compress apparel images
        const compressedApparel = await Promise.all(entry.apparelImages.map((img)=>(0, _image.compressBase64)(img, maxSizeKB, quality)));
        return {
            ...entry,
            generatedImage: compressedGenerated,
            modelImage: compressedModel,
            apparelImages: compressedApparel,
            metadata: {
                ...entry.metadata,
                imageProcessingResults: {
                    ...entry.metadata?.imageProcessingResults,
                    finalImageSizes: {
                        modelImageSize: (0, _image.getBase64Size)(compressedModel),
                        apparelImageSizes: compressedApparel.map((img)=>(0, _image.getBase64Size)(img))
                    }
                }
            }
        };
    } catch (error) {
        if (error instanceof _image.CompressionFailedError) {
            console.warn('Failed to compress history entry images, using original', error);
            return entry;
        }
        throw error;
    }
}
class LocalStorageTryonHistoryService {
    constructor(config = {}){
        this.config = {
            ...DEFAULT_CONFIG,
            ...config
        };
        this.initializeStorage();
    }
    /**
   * Initialize localStorage storage
   */ initializeStorage() {
        try {
            // Check if localStorage is available
            if (typeof window === 'undefined' || !window.localStorage) {
                throw new Error('localStorage is not available');
            }
            // Initialize config if not exists
            if (!localStorage.getItem(STORAGE_KEYS.CONFIG)) {
                localStorage.setItem(STORAGE_KEYS.CONFIG, JSON.stringify(this.config));
            }
            // Initialize entries array if not exists
            if (!localStorage.getItem(STORAGE_KEYS.ENTRIES)) {
                localStorage.setItem(STORAGE_KEYS.ENTRIES, JSON.stringify([]));
            }
            // Initialize metadata if not exists
            if (!localStorage.getItem(STORAGE_KEYS.METADATA)) {
                const metadata = {
                    version: '1.0.0',
                    createdAt: new Date().toISOString(),
                    lastUpdated: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEYS.METADATA, JSON.stringify(metadata));
            }
        } catch (error) {
            console.error('Failed to initialize history storage:', error);
            throw new Error('History storage initialization failed');
        }
    }
    /**
   * Get all stored entries from localStorage
   */ getStoredEntries() {
        try {
            const entriesJson = localStorage.getItem(STORAGE_KEYS.ENTRIES);
            return entriesJson ? JSON.parse(entriesJson) : [];
        } catch (error) {
            console.error('Failed to parse stored entries:', error);
            return [];
        }
    }
    /**
   * Save entries to localStorage
   */ saveEntries(entries) {
        try {
            localStorage.setItem(STORAGE_KEYS.ENTRIES, JSON.stringify(entries));
            // Update metadata
            const metadata = JSON.parse(localStorage.getItem(STORAGE_KEYS.METADATA) || '{}');
            metadata.lastUpdated = new Date().toISOString();
            localStorage.setItem(STORAGE_KEYS.METADATA, JSON.stringify(metadata));
        } catch (error) {
            console.error('Failed to save entries to localStorage:', error);
            throw new Error('Failed to save history entries');
        }
    }
    /**
   * Perform cleanup if needed
   */ performCleanupIfNeeded(entries) {
        if (!this.config.autoCleanup || entries.length <= this.config.maxEntries) {
            return entries;
        }
        // Sort by timestamp and keep only the most recent entries
        const sorted = [
            ...entries
        ].sort((a, b)=>new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
        return sorted.slice(0, this.config.maxEntries);
    }
    /**
   * Filter and sort entries based on query options
   */ filterAndSortEntries(entries, options = {}) {
        let filtered = [
            ...entries
        ];
        // Apply favorites filter
        if (options.favoritesOnly) {
            filtered = filtered.filter((entry)=>entry.isFavorite);
        }
        // Apply date range filter
        if (options.dateRange) {
            const startDate = new Date(options.dateRange.startDate);
            const endDate = new Date(options.dateRange.endDate);
            filtered = filtered.filter((entry)=>{
                const entryDate = new Date(entry.timestamp);
                return entryDate >= startDate && entryDate <= endDate;
            });
        }
        // Apply search term filter
        if (options.searchTerm) {
            const searchTerm = options.searchTerm.toLowerCase();
            filtered = filtered.filter((entry)=>entry.tags?.some((tag)=>tag.toLowerCase().includes(searchTerm)) || entry.notes?.toLowerCase().includes(searchTerm));
        }
        // Apply sorting
        const sortBy = options.sortBy || 'timestamp';
        const sortDirection = options.sortDirection || 'desc';
        filtered.sort((a, b)=>{
            let aValue, bValue;
            switch(sortBy){
                case 'timestamp':
                    aValue = new Date(a.timestamp);
                    bValue = new Date(b.timestamp);
                    break;
                case 'processingTime':
                    aValue = a.processingTime || 0;
                    bValue = b.processingTime || 0;
                    break;
                case 'isFavorite':
                    aValue = a.isFavorite ? 1 : 0;
                    bValue = b.isFavorite ? 1 : 0;
                    break;
                default:
                    aValue = a.timestamp;
                    bValue = b.timestamp;
            }
            if (sortDirection === 'asc') {
                return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
            } else {
                return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
            }
        });
        return filtered;
    }
    /**
   * Add a new history entry
   */ async addEntry(options) {
        const entry = {
            id: generateHistoryId(),
            timestamp: new Date().toISOString(),
            generatedImage: options.generatedImage,
            modelImage: options.modelImage,
            apparelImages: options.apparelImages,
            processingTime: options.processingTime,
            metadata: options.metadata,
            tags: options.tags || [],
            isFavorite: options.isFavorite || false,
            notes: options.notes || ''
        };
        // Compress entry if enabled
        const compressedEntry = await compressHistoryEntry(entry, this.config);
        // Check entry size
        const entrySize = calculateEntrySize(compressedEntry);
        if (entrySize > this.config.maxEntrySizeKB) {
            throw new Error(`History entry too large: ${entrySize.toFixed(2)}KB exceeds limit of ${this.config.maxEntrySizeKB}KB`);
        }
        // Get current entries and add the new one
        let entries = this.getStoredEntries();
        entries.push(compressedEntry);
        // Perform cleanup if needed
        entries = this.performCleanupIfNeeded(entries);
        // Save updated entries
        this.saveEntries(entries);
        return compressedEntry;
    }
    /**
   * Get history entries with filtering and pagination
   */ async getEntries(options = {}) {
        const allEntries = this.getStoredEntries();
        const filteredEntries = this.filterAndSortEntries(allEntries, options);
        // Apply pagination
        const page = options.page || 0;
        const pageSize = options.pageSize || 20;
        const startIndex = page * pageSize;
        const endIndex = startIndex + pageSize;
        const paginatedEntries = filteredEntries.slice(startIndex, endIndex);
        return {
            entries: paginatedEntries,
            totalCount: filteredEntries.length,
            currentPage: page,
            pageSize,
            hasMore: endIndex < filteredEntries.length,
            lastUpdated: new Date().toISOString()
        };
    }
    /**
   * Get a specific history entry by ID
   */ async getEntry(id) {
        const entries = this.getStoredEntries();
        return entries.find((entry)=>entry.id === id) || null;
    }
    /**
   * Update an existing history entry
   */ async updateEntry(id, updates) {
        const entries = this.getStoredEntries();
        const entryIndex = entries.findIndex((entry)=>entry.id === id);
        if (entryIndex === -1) {
            throw new Error(`History entry with ID ${id} not found`);
        }
        // Apply updates
        const updatedEntry = {
            ...entries[entryIndex],
            ...updates,
            // Preserve ID and timestamp, update only if explicitly provided
            id: entries[entryIndex].id,
            timestamp: updates.timestamp || entries[entryIndex].timestamp
        };
        entries[entryIndex] = updatedEntry;
        this.saveEntries(entries);
        return updatedEntry;
    }
    /**
   * Delete a history entry
   */ async deleteEntry(id) {
        const entries = this.getStoredEntries();
        const filteredEntries = entries.filter((entry)=>entry.id !== id);
        if (filteredEntries.length === entries.length) {
            return false; // Entry not found
        }
        this.saveEntries(filteredEntries);
        return true;
    }
    /**
   * Clear all history entries
   */ async clearAll() {
        try {
            localStorage.setItem(STORAGE_KEYS.ENTRIES, JSON.stringify([]));
            return true;
        } catch (error) {
            console.error('Failed to clear history:', error);
            return false;
        }
    }
    /**
   * Get storage statistics
   */ async getStorageStats() {
        const entries = this.getStoredEntries();
        let totalSizeKB = 0;
        entries.forEach((entry)=>{
            totalSizeKB += calculateEntrySize(entry);
        });
        const timestamps = entries.map((entry)=>entry.timestamp).sort();
        return {
            totalEntries: entries.length,
            totalSizeKB,
            oldestEntry: timestamps[0],
            newestEntry: timestamps[timestamps.length - 1]
        };
    }
    /**
   * Export history data
   */ async exportHistory() {
        return this.getStoredEntries();
    }
    /**
   * Import history data
   */ async importHistory(entries) {
        try {
            // Validate entries
            const validEntries = entries.filter((entry)=>entry.id && entry.generatedImage && entry.modelImage && entry.apparelImages);
            // Get existing entries and merge with imports
            const existingEntries = this.getStoredEntries();
            const existingIds = new Set(existingEntries.map((entry)=>entry.id));
            // Only import entries that don't already exist
            const newEntries = validEntries.filter((entry)=>!existingIds.has(entry.id));
            if (newEntries.length === 0) {
                return 0;
            }
            // Merge and save
            const mergedEntries = [
                ...existingEntries,
                ...newEntries
            ];
            const cleanedEntries = this.performCleanupIfNeeded(mergedEntries);
            this.saveEntries(cleanedEntries);
            return newEntries.length;
        } catch (error) {
            console.error('Failed to import history:', error);
            throw new Error('History import failed');
        }
    }
    /**
   * Update service configuration
   */ updateConfig(newConfig) {
        this.config = {
            ...this.config,
            ...newConfig
        };
        try {
            localStorage.setItem(STORAGE_KEYS.CONFIG, JSON.stringify(this.config));
        } catch (error) {
            console.error('Failed to save config:', error);
        }
    }
    /**
   * Get current configuration
   */ getConfig() {
        return {
            ...this.config
        };
    }
}
const defaultHistoryService = new LocalStorageTryonHistoryService();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy93aWxsc3RyZWV0ZXIvV2Vic3Rvcm1Qcm9qZWN0cy92aWJlLWNvZGluZy90aG9zZS1wZW9wbGUvVGhlLVN1cy1GaXQtZ3Avc3JjL2J1c2luZXNzLWxheWVyL3NlcnZpY2VzL3RyeW9uSGlzdG9yeVNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVHJ5LU9uIEhpc3RvcnkgU3RvcmFnZSBTZXJ2aWNlXG4vLyBJbXBsZW1lbnRzIHBlcnNpc3RlbnQgc3RvcmFnZSBmb3IgdHJ5LW9uIGhpc3RvcnkgdXNpbmcgbG9jYWxTdG9yYWdlIHdpdGggY29tcHJlc3Npb25cblxuaW1wb3J0IHsgXG4gIGNvbXByZXNzQmFzZTY0LCBcbiAgZ2V0QmFzZTY0U2l6ZSwgXG4gIENvbXByZXNzaW9uRmFpbGVkRXJyb3IgXG59IGZyb20gJy4uLy4uL3V0aWxzL2ltYWdlJztcbmltcG9ydCB0eXBlIHtcbiAgVHJ5b25IaXN0b3J5RW50cnksXG4gIFRyeW9uSGlzdG9yeUNvbGxlY3Rpb24sXG4gIFRyeW9uSGlzdG9yeVF1ZXJ5T3B0aW9ucyxcbiAgQ3JlYXRlVHJ5b25IaXN0b3J5RW50cnlPcHRpb25zLFxuICBUcnlvbkhpc3RvcnlTZXJ2aWNlLFxuICBUcnlvbkhpc3RvcnlTdG9yYWdlQ29uZmlnXG59IGZyb20gJy4uL3R5cGVzL2hpc3RvcnkudHlwZXMnO1xuXG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgaGlzdG9yeSBzdG9yYWdlXG4gKi9cbmNvbnN0IERFRkFVTFRfQ09ORklHOiBSZXF1aXJlZDxUcnlvbkhpc3RvcnlTdG9yYWdlQ29uZmlnPiA9IHtcbiAgc3RvcmFnZVR5cGU6ICdsb2NhbFN0b3JhZ2UnLFxuICBtYXhFbnRyaWVzOiA1MCxcbiAgbWF4RW50cnlTaXplS0I6IDIwNDgsIC8vIDJNQiBwZXIgZW50cnlcbiAgY29tcHJlc3NJbWFnZXM6IHRydWUsXG4gIGNvbXByZXNzaW9uUXVhbGl0eTogMC44LFxuICBhdXRvQ2xlYW51cDogdHJ1ZSxcbiAgZW5jcnlwdGlvbktleTogJydcbn07XG5cbi8qKlxuICogU3RvcmFnZSBrZXlzIGZvciBsb2NhbFN0b3JhZ2VcbiAqL1xuY29uc3QgU1RPUkFHRV9LRVlTID0ge1xuICBFTlRSSUVTOiAnc3VzZml0X3RyeW9uX2hpc3RvcnlfZW50cmllcycsXG4gIENPTkZJRzogJ3N1c2ZpdF90cnlvbl9oaXN0b3J5X2NvbmZpZycsXG4gIE1FVEFEQVRBOiAnc3VzZml0X3RyeW9uX2hpc3RvcnlfbWV0YWRhdGEnXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBoaXN0b3J5IGVudHJpZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVIaXN0b3J5SWQoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGB0cnlvbl8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGEgaGlzdG9yeSBlbnRyeSBpbiBLQlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVFbnRyeVNpemUoZW50cnk6IFRyeW9uSGlzdG9yeUVudHJ5KTogbnVtYmVyIHtcbiAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGVudHJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKFtqc29uXSkuc2l6ZSAvIDEwMjQ7XG59XG5cbi8qKlxuICogQ29tcHJlc3MgaW1hZ2VzIGluIGEgaGlzdG9yeSBlbnRyeVxuICovXG5hc3luYyBmdW5jdGlvbiBjb21wcmVzc0hpc3RvcnlFbnRyeShcbiAgZW50cnk6IFRyeW9uSGlzdG9yeUVudHJ5LCBcbiAgY29uZmlnOiBUcnlvbkhpc3RvcnlTdG9yYWdlQ29uZmlnXG4pOiBQcm9taXNlPFRyeW9uSGlzdG9yeUVudHJ5PiB7XG4gIGlmICghY29uZmlnLmNvbXByZXNzSW1hZ2VzKSB7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBtYXhTaXplS0IgPSBjb25maWcubWF4RW50cnlTaXplS0IhIC8gKDIgKyBlbnRyeS5hcHBhcmVsSW1hZ2VzLmxlbmd0aCk7XG4gICAgY29uc3QgcXVhbGl0eSA9IGNvbmZpZy5jb21wcmVzc2lvblF1YWxpdHkhO1xuXG4gICAgLy8gQ29tcHJlc3MgZ2VuZXJhdGVkIGltYWdlXG4gICAgY29uc3QgY29tcHJlc3NlZEdlbmVyYXRlZCA9IGF3YWl0IGNvbXByZXNzQmFzZTY0KFxuICAgICAgZW50cnkuZ2VuZXJhdGVkSW1hZ2UsIFxuICAgICAgbWF4U2l6ZUtCLCBcbiAgICAgIHF1YWxpdHlcbiAgICApO1xuXG4gICAgLy8gQ29tcHJlc3MgbW9kZWwgaW1hZ2VcbiAgICBjb25zdCBjb21wcmVzc2VkTW9kZWwgPSBhd2FpdCBjb21wcmVzc0Jhc2U2NChcbiAgICAgIGVudHJ5Lm1vZGVsSW1hZ2UsIFxuICAgICAgbWF4U2l6ZUtCLCBcbiAgICAgIHF1YWxpdHlcbiAgICApO1xuXG4gICAgLy8gQ29tcHJlc3MgYXBwYXJlbCBpbWFnZXNcbiAgICBjb25zdCBjb21wcmVzc2VkQXBwYXJlbCA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgZW50cnkuYXBwYXJlbEltYWdlcy5tYXAoaW1nID0+IGNvbXByZXNzQmFzZTY0KGltZywgbWF4U2l6ZUtCLCBxdWFsaXR5KSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmVudHJ5LFxuICAgICAgZ2VuZXJhdGVkSW1hZ2U6IGNvbXByZXNzZWRHZW5lcmF0ZWQsXG4gICAgICBtb2RlbEltYWdlOiBjb21wcmVzc2VkTW9kZWwsXG4gICAgICBhcHBhcmVsSW1hZ2VzOiBjb21wcmVzc2VkQXBwYXJlbCxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIC4uLmVudHJ5Lm1ldGFkYXRhLFxuICAgICAgICBpbWFnZVByb2Nlc3NpbmdSZXN1bHRzOiB7XG4gICAgICAgICAgLi4uZW50cnkubWV0YWRhdGE/LmltYWdlUHJvY2Vzc2luZ1Jlc3VsdHMsXG4gICAgICAgICAgZmluYWxJbWFnZVNpemVzOiB7XG4gICAgICAgICAgICBtb2RlbEltYWdlU2l6ZTogZ2V0QmFzZTY0U2l6ZShjb21wcmVzc2VkTW9kZWwpLFxuICAgICAgICAgICAgYXBwYXJlbEltYWdlU2l6ZXM6IGNvbXByZXNzZWRBcHBhcmVsLm1hcChpbWcgPT4gZ2V0QmFzZTY0U2l6ZShpbWcpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29tcHJlc3Npb25GYWlsZWRFcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY29tcHJlc3MgaGlzdG9yeSBlbnRyeSBpbWFnZXMsIHVzaW5nIG9yaWdpbmFsJywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIGxvY2FsU3RvcmFnZS1iYXNlZCBUcnktT24gSGlzdG9yeSBTZXJ2aWNlIGltcGxlbWVudGF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2NhbFN0b3JhZ2VUcnlvbkhpc3RvcnlTZXJ2aWNlIGltcGxlbWVudHMgVHJ5b25IaXN0b3J5U2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBSZXF1aXJlZDxUcnlvbkhpc3RvcnlTdG9yYWdlQ29uZmlnPjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8VHJ5b25IaXN0b3J5U3RvcmFnZUNvbmZpZz4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0geyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH07XG4gICAgdGhpcy5pbml0aWFsaXplU3RvcmFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgbG9jYWxTdG9yYWdlIHN0b3JhZ2VcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVN0b3JhZ2UoKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIGxvY2FsU3RvcmFnZSBpcyBhdmFpbGFibGVcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgY29uZmlnIGlmIG5vdCBleGlzdHNcbiAgICAgIGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLkNPTkZJRykpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLkNPTkZJRywgSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSBlbnRyaWVzIGFycmF5IGlmIG5vdCBleGlzdHNcbiAgICAgIGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLkVOVFJJRVMpKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5FTlRSSUVTLCBKU09OLnN0cmluZ2lmeShbXSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIG1ldGFkYXRhIGlmIG5vdCBleGlzdHNcbiAgICAgIGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLk1FVEFEQVRBKSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLk1FVEFEQVRBLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBoaXN0b3J5IHN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5IHN0b3JhZ2UgaW5pdGlhbGl6YXRpb24gZmFpbGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgc3RvcmVkIGVudHJpZXMgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICovXG4gIHByaXZhdGUgZ2V0U3RvcmVkRW50cmllcygpOiBUcnlvbkhpc3RvcnlFbnRyeVtdIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50cmllc0pzb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuRU5UUklFUyk7XG4gICAgICByZXR1cm4gZW50cmllc0pzb24gPyBKU09OLnBhcnNlKGVudHJpZXNKc29uKSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3RvcmVkIGVudHJpZXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIGVudHJpZXMgdG8gbG9jYWxTdG9yYWdlXG4gICAqL1xuICBwcml2YXRlIHNhdmVFbnRyaWVzKGVudHJpZXM6IFRyeW9uSGlzdG9yeUVudHJ5W10pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLkVOVFJJRVMsIEpTT04uc3RyaW5naWZ5KGVudHJpZXMpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIG1ldGFkYXRhXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLk1FVEFEQVRBKSB8fCAne30nKTtcbiAgICAgIG1ldGFkYXRhLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLk1FVEFEQVRBLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBlbnRyaWVzIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGhpc3RvcnkgZW50cmllcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGNsZWFudXAgaWYgbmVlZGVkXG4gICAqL1xuICBwcml2YXRlIHBlcmZvcm1DbGVhbnVwSWZOZWVkZWQoZW50cmllczogVHJ5b25IaXN0b3J5RW50cnlbXSk6IFRyeW9uSGlzdG9yeUVudHJ5W10ge1xuICAgIGlmICghdGhpcy5jb25maWcuYXV0b0NsZWFudXAgfHwgZW50cmllcy5sZW5ndGggPD0gdGhpcy5jb25maWcubWF4RW50cmllcykge1xuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfVxuXG4gICAgLy8gU29ydCBieSB0aW1lc3RhbXAgYW5kIGtlZXAgb25seSB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5lbnRyaWVzXS5zb3J0KChhLCBiKSA9PiBcbiAgICAgIG5ldyBEYXRlKGIudGltZXN0YW1wKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnRpbWVzdGFtcCkuZ2V0VGltZSgpXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gc29ydGVkLnNsaWNlKDAsIHRoaXMuY29uZmlnLm1heEVudHJpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlciBhbmQgc29ydCBlbnRyaWVzIGJhc2VkIG9uIHF1ZXJ5IG9wdGlvbnNcbiAgICovXG4gIHByaXZhdGUgZmlsdGVyQW5kU29ydEVudHJpZXMoXG4gICAgZW50cmllczogVHJ5b25IaXN0b3J5RW50cnlbXSwgXG4gICAgb3B0aW9uczogVHJ5b25IaXN0b3J5UXVlcnlPcHRpb25zID0ge31cbiAgKTogVHJ5b25IaXN0b3J5RW50cnlbXSB7XG4gICAgbGV0IGZpbHRlcmVkID0gWy4uLmVudHJpZXNdO1xuXG4gICAgLy8gQXBwbHkgZmF2b3JpdGVzIGZpbHRlclxuICAgIGlmIChvcHRpb25zLmZhdm9yaXRlc09ubHkpIHtcbiAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmlzRmF2b3JpdGUpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGRhdGUgcmFuZ2UgZmlsdGVyXG4gICAgaWYgKG9wdGlvbnMuZGF0ZVJhbmdlKSB7XG4gICAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShvcHRpb25zLmRhdGVSYW5nZS5zdGFydERhdGUpO1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKG9wdGlvbnMuZGF0ZVJhbmdlLmVuZERhdGUpO1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBlbnRyeURhdGUgPSBuZXcgRGF0ZShlbnRyeS50aW1lc3RhbXApO1xuICAgICAgICByZXR1cm4gZW50cnlEYXRlID49IHN0YXJ0RGF0ZSAmJiBlbnRyeURhdGUgPD0gZW5kRGF0ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHNlYXJjaCB0ZXJtIGZpbHRlclxuICAgIGlmIChvcHRpb25zLnNlYXJjaFRlcm0pIHtcbiAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSBvcHRpb25zLnNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKTtcbiAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKGVudHJ5ID0+IFxuICAgICAgICBlbnRyeS50YWdzPy5zb21lKHRhZyA9PiB0YWcudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtKSkgfHxcbiAgICAgICAgZW50cnkubm90ZXM/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgc29ydGluZ1xuICAgIGNvbnN0IHNvcnRCeSA9IG9wdGlvbnMuc29ydEJ5IHx8ICd0aW1lc3RhbXAnO1xuICAgIGNvbnN0IHNvcnREaXJlY3Rpb24gPSBvcHRpb25zLnNvcnREaXJlY3Rpb24gfHwgJ2Rlc2MnO1xuICAgIFxuICAgIGZpbHRlcmVkLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGxldCBhVmFsdWU6IERhdGUgfCBudW1iZXIsIGJWYWx1ZTogRGF0ZSB8IG51bWJlcjtcbiAgICAgIFxuICAgICAgc3dpdGNoIChzb3J0QnkpIHtcbiAgICAgICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgICAgICBhVmFsdWUgPSBuZXcgRGF0ZShhLnRpbWVzdGFtcCk7XG4gICAgICAgICAgYlZhbHVlID0gbmV3IERhdGUoYi50aW1lc3RhbXApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcm9jZXNzaW5nVGltZSc6XG4gICAgICAgICAgYVZhbHVlID0gYS5wcm9jZXNzaW5nVGltZSB8fCAwO1xuICAgICAgICAgIGJWYWx1ZSA9IGIucHJvY2Vzc2luZ1RpbWUgfHwgMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXNGYXZvcml0ZSc6XG4gICAgICAgICAgYVZhbHVlID0gYS5pc0Zhdm9yaXRlID8gMSA6IDA7XG4gICAgICAgICAgYlZhbHVlID0gYi5pc0Zhdm9yaXRlID8gMSA6IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYVZhbHVlID0gYS50aW1lc3RhbXA7XG4gICAgICAgICAgYlZhbHVlID0gYi50aW1lc3RhbXA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzb3J0RGlyZWN0aW9uID09PSAnYXNjJykge1xuICAgICAgICByZXR1cm4gYVZhbHVlIDwgYlZhbHVlID8gLTEgOiBhVmFsdWUgPiBiVmFsdWUgPyAxIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUgPiBiVmFsdWUgPyAtMSA6IGFWYWx1ZSA8IGJWYWx1ZSA/IDEgOiAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBoaXN0b3J5IGVudHJ5XG4gICAqL1xuICBhc3luYyBhZGRFbnRyeShvcHRpb25zOiBDcmVhdGVUcnlvbkhpc3RvcnlFbnRyeU9wdGlvbnMpOiBQcm9taXNlPFRyeW9uSGlzdG9yeUVudHJ5PiB7XG4gICAgY29uc3QgZW50cnk6IFRyeW9uSGlzdG9yeUVudHJ5ID0ge1xuICAgICAgaWQ6IGdlbmVyYXRlSGlzdG9yeUlkKCksXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGdlbmVyYXRlZEltYWdlOiBvcHRpb25zLmdlbmVyYXRlZEltYWdlLFxuICAgICAgbW9kZWxJbWFnZTogb3B0aW9ucy5tb2RlbEltYWdlLFxuICAgICAgYXBwYXJlbEltYWdlczogb3B0aW9ucy5hcHBhcmVsSW1hZ2VzLFxuICAgICAgcHJvY2Vzc2luZ1RpbWU6IG9wdGlvbnMucHJvY2Vzc2luZ1RpbWUsXG4gICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyB8fCBbXSxcbiAgICAgIGlzRmF2b3JpdGU6IG9wdGlvbnMuaXNGYXZvcml0ZSB8fCBmYWxzZSxcbiAgICAgIG5vdGVzOiBvcHRpb25zLm5vdGVzIHx8ICcnXG4gICAgfTtcblxuICAgIC8vIENvbXByZXNzIGVudHJ5IGlmIGVuYWJsZWRcbiAgICBjb25zdCBjb21wcmVzc2VkRW50cnkgPSBhd2FpdCBjb21wcmVzc0hpc3RvcnlFbnRyeShlbnRyeSwgdGhpcy5jb25maWcpO1xuXG4gICAgLy8gQ2hlY2sgZW50cnkgc2l6ZVxuICAgIGNvbnN0IGVudHJ5U2l6ZSA9IGNhbGN1bGF0ZUVudHJ5U2l6ZShjb21wcmVzc2VkRW50cnkpO1xuICAgIGlmIChlbnRyeVNpemUgPiB0aGlzLmNvbmZpZy5tYXhFbnRyeVNpemVLQikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSGlzdG9yeSBlbnRyeSB0b28gbGFyZ2U6ICR7ZW50cnlTaXplLnRvRml4ZWQoMil9S0IgZXhjZWVkcyBsaW1pdCBvZiAke3RoaXMuY29uZmlnLm1heEVudHJ5U2l6ZUtCfUtCYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCBlbnRyaWVzIGFuZCBhZGQgdGhlIG5ldyBvbmVcbiAgICBsZXQgZW50cmllcyA9IHRoaXMuZ2V0U3RvcmVkRW50cmllcygpO1xuICAgIGVudHJpZXMucHVzaChjb21wcmVzc2VkRW50cnkpO1xuXG4gICAgLy8gUGVyZm9ybSBjbGVhbnVwIGlmIG5lZWRlZFxuICAgIGVudHJpZXMgPSB0aGlzLnBlcmZvcm1DbGVhbnVwSWZOZWVkZWQoZW50cmllcyk7XG5cbiAgICAvLyBTYXZlIHVwZGF0ZWQgZW50cmllc1xuICAgIHRoaXMuc2F2ZUVudHJpZXMoZW50cmllcyk7XG5cbiAgICByZXR1cm4gY29tcHJlc3NlZEVudHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBoaXN0b3J5IGVudHJpZXMgd2l0aCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb25cbiAgICovXG4gIGFzeW5jIGdldEVudHJpZXMob3B0aW9uczogVHJ5b25IaXN0b3J5UXVlcnlPcHRpb25zID0ge30pOiBQcm9taXNlPFRyeW9uSGlzdG9yeUNvbGxlY3Rpb24+IHtcbiAgICBjb25zdCBhbGxFbnRyaWVzID0gdGhpcy5nZXRTdG9yZWRFbnRyaWVzKCk7XG4gICAgY29uc3QgZmlsdGVyZWRFbnRyaWVzID0gdGhpcy5maWx0ZXJBbmRTb3J0RW50cmllcyhhbGxFbnRyaWVzLCBvcHRpb25zKTtcblxuICAgIC8vIEFwcGx5IHBhZ2luYXRpb25cbiAgICBjb25zdCBwYWdlID0gb3B0aW9ucy5wYWdlIHx8IDA7XG4gICAgY29uc3QgcGFnZVNpemUgPSBvcHRpb25zLnBhZ2VTaXplIHx8IDIwO1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBwYWdlICogcGFnZVNpemU7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgcGFnZVNpemU7XG4gICAgY29uc3QgcGFnaW5hdGVkRW50cmllcyA9IGZpbHRlcmVkRW50cmllcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW50cmllczogcGFnaW5hdGVkRW50cmllcyxcbiAgICAgIHRvdGFsQ291bnQ6IGZpbHRlcmVkRW50cmllcy5sZW5ndGgsXG4gICAgICBjdXJyZW50UGFnZTogcGFnZSxcbiAgICAgIHBhZ2VTaXplLFxuICAgICAgaGFzTW9yZTogZW5kSW5kZXggPCBmaWx0ZXJlZEVudHJpZXMubGVuZ3RoLFxuICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3BlY2lmaWMgaGlzdG9yeSBlbnRyeSBieSBJRFxuICAgKi9cbiAgYXN5bmMgZ2V0RW50cnkoaWQ6IHN0cmluZyk6IFByb21pc2U8VHJ5b25IaXN0b3J5RW50cnkgfCBudWxsPiB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuZ2V0U3RvcmVkRW50cmllcygpO1xuICAgIHJldHVybiBlbnRyaWVzLmZpbmQoZW50cnkgPT4gZW50cnkuaWQgPT09IGlkKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBoaXN0b3J5IGVudHJ5XG4gICAqL1xuICBhc3luYyB1cGRhdGVFbnRyeShpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFRyeW9uSGlzdG9yeUVudHJ5Pik6IFByb21pc2U8VHJ5b25IaXN0b3J5RW50cnk+IHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5nZXRTdG9yZWRFbnRyaWVzKCk7XG4gICAgY29uc3QgZW50cnlJbmRleCA9IGVudHJpZXMuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5LmlkID09PSBpZCk7XG4gICAgXG4gICAgaWYgKGVudHJ5SW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhpc3RvcnkgZW50cnkgd2l0aCBJRCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSB1cGRhdGVzXG4gICAgY29uc3QgdXBkYXRlZEVudHJ5ID0geyBcbiAgICAgIC4uLmVudHJpZXNbZW50cnlJbmRleF0sIFxuICAgICAgLi4udXBkYXRlcyxcbiAgICAgIC8vIFByZXNlcnZlIElEIGFuZCB0aW1lc3RhbXAsIHVwZGF0ZSBvbmx5IGlmIGV4cGxpY2l0bHkgcHJvdmlkZWRcbiAgICAgIGlkOiBlbnRyaWVzW2VudHJ5SW5kZXhdLmlkLFxuICAgICAgdGltZXN0YW1wOiB1cGRhdGVzLnRpbWVzdGFtcCB8fCBlbnRyaWVzW2VudHJ5SW5kZXhdLnRpbWVzdGFtcFxuICAgIH07XG5cbiAgICBlbnRyaWVzW2VudHJ5SW5kZXhdID0gdXBkYXRlZEVudHJ5O1xuICAgIHRoaXMuc2F2ZUVudHJpZXMoZW50cmllcyk7XG5cbiAgICByZXR1cm4gdXBkYXRlZEVudHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGhpc3RvcnkgZW50cnlcbiAgICovXG4gIGFzeW5jIGRlbGV0ZUVudHJ5KGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5nZXRTdG9yZWRFbnRyaWVzKCk7XG4gICAgY29uc3QgZmlsdGVyZWRFbnRyaWVzID0gZW50cmllcy5maWx0ZXIoZW50cnkgPT4gZW50cnkuaWQgIT09IGlkKTtcbiAgICBcbiAgICBpZiAoZmlsdGVyZWRFbnRyaWVzLmxlbmd0aCA9PT0gZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gRW50cnkgbm90IGZvdW5kXG4gICAgfVxuXG4gICAgdGhpcy5zYXZlRW50cmllcyhmaWx0ZXJlZEVudHJpZXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBoaXN0b3J5IGVudHJpZXNcbiAgICovXG4gIGFzeW5jIGNsZWFyQWxsKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuRU5UUklFUywgSlNPTi5zdHJpbmdpZnkoW10pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2xlYXIgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdG9yYWdlIHN0YXRpc3RpY3NcbiAgICovXG4gIGFzeW5jIGdldFN0b3JhZ2VTdGF0cygpOiBQcm9taXNlPHtcbiAgICB0b3RhbEVudHJpZXM6IG51bWJlcjtcbiAgICB0b3RhbFNpemVLQjogbnVtYmVyO1xuICAgIG9sZGVzdEVudHJ5Pzogc3RyaW5nO1xuICAgIG5ld2VzdEVudHJ5Pzogc3RyaW5nO1xuICB9PiB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuZ2V0U3RvcmVkRW50cmllcygpO1xuICAgIFxuICAgIGxldCB0b3RhbFNpemVLQiA9IDA7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIHRvdGFsU2l6ZUtCICs9IGNhbGN1bGF0ZUVudHJ5U2l6ZShlbnRyeSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gZW50cmllcy5tYXAoZW50cnkgPT4gZW50cnkudGltZXN0YW1wKS5zb3J0KCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsRW50cmllczogZW50cmllcy5sZW5ndGgsXG4gICAgICB0b3RhbFNpemVLQixcbiAgICAgIG9sZGVzdEVudHJ5OiB0aW1lc3RhbXBzWzBdLFxuICAgICAgbmV3ZXN0RW50cnk6IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0IGhpc3RvcnkgZGF0YVxuICAgKi9cbiAgYXN5bmMgZXhwb3J0SGlzdG9yeSgpOiBQcm9taXNlPFRyeW9uSGlzdG9yeUVudHJ5W10+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdG9yZWRFbnRyaWVzKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IGhpc3RvcnkgZGF0YVxuICAgKi9cbiAgYXN5bmMgaW1wb3J0SGlzdG9yeShlbnRyaWVzOiBUcnlvbkhpc3RvcnlFbnRyeVtdKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVmFsaWRhdGUgZW50cmllc1xuICAgICAgY29uc3QgdmFsaWRFbnRyaWVzID0gZW50cmllcy5maWx0ZXIoZW50cnkgPT4gXG4gICAgICAgIGVudHJ5LmlkICYmIGVudHJ5LmdlbmVyYXRlZEltYWdlICYmIGVudHJ5Lm1vZGVsSW1hZ2UgJiYgZW50cnkuYXBwYXJlbEltYWdlc1xuICAgICAgKTtcblxuICAgICAgLy8gR2V0IGV4aXN0aW5nIGVudHJpZXMgYW5kIG1lcmdlIHdpdGggaW1wb3J0c1xuICAgICAgY29uc3QgZXhpc3RpbmdFbnRyaWVzID0gdGhpcy5nZXRTdG9yZWRFbnRyaWVzKCk7XG4gICAgICBjb25zdCBleGlzdGluZ0lkcyA9IG5ldyBTZXQoZXhpc3RpbmdFbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5pZCkpO1xuICAgICAgXG4gICAgICAvLyBPbmx5IGltcG9ydCBlbnRyaWVzIHRoYXQgZG9uJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgY29uc3QgbmV3RW50cmllcyA9IHZhbGlkRW50cmllcy5maWx0ZXIoZW50cnkgPT4gIWV4aXN0aW5nSWRzLmhhcyhlbnRyeS5pZCkpO1xuICAgICAgXG4gICAgICBpZiAobmV3RW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIE1lcmdlIGFuZCBzYXZlXG4gICAgICBjb25zdCBtZXJnZWRFbnRyaWVzID0gWy4uLmV4aXN0aW5nRW50cmllcywgLi4ubmV3RW50cmllc107XG4gICAgICBjb25zdCBjbGVhbmVkRW50cmllcyA9IHRoaXMucGVyZm9ybUNsZWFudXBJZk5lZWRlZChtZXJnZWRFbnRyaWVzKTtcbiAgICAgIFxuICAgICAgdGhpcy5zYXZlRW50cmllcyhjbGVhbmVkRW50cmllcyk7XG4gICAgICByZXR1cm4gbmV3RW50cmllcy5sZW5ndGg7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbXBvcnQgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkgaW1wb3J0IGZhaWxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2VydmljZSBjb25maWd1cmF0aW9uXG4gICAqL1xuICB1cGRhdGVDb25maWcobmV3Q29uZmlnOiBQYXJ0aWFsPFRyeW9uSGlzdG9yeVN0b3JhZ2VDb25maWc+KTogdm9pZCB7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5uZXdDb25maWcgfTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLkNPTkZJRywgSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgY29uZmlnOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0Q29uZmlnKCk6IFRyeW9uSGlzdG9yeVN0b3JhZ2VDb25maWcge1xuICAgIHJldHVybiB7IC4uLnRoaXMuY29uZmlnIH07XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IGhpc3Rvcnkgc2VydmljZSBpbnN0YW5jZVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEhpc3RvcnlTZXJ2aWNlID0gbmV3IExvY2FsU3RvcmFnZVRyeW9uSGlzdG9yeVNlcnZpY2UoKTsiXSwibmFtZXMiOlsiTG9jYWxTdG9yYWdlVHJ5b25IaXN0b3J5U2VydmljZSIsImRlZmF1bHRIaXN0b3J5U2VydmljZSIsIkRFRkFVTFRfQ09ORklHIiwic3RvcmFnZVR5cGUiLCJtYXhFbnRyaWVzIiwibWF4RW50cnlTaXplS0IiLCJjb21wcmVzc0ltYWdlcyIsImNvbXByZXNzaW9uUXVhbGl0eSIsImF1dG9DbGVhbnVwIiwiZW5jcnlwdGlvbktleSIsIlNUT1JBR0VfS0VZUyIsIkVOVFJJRVMiLCJDT05GSUciLCJNRVRBREFUQSIsImdlbmVyYXRlSGlzdG9yeUlkIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImNhbGN1bGF0ZUVudHJ5U2l6ZSIsImVudHJ5IiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJCbG9iIiwic2l6ZSIsImNvbXByZXNzSGlzdG9yeUVudHJ5IiwiY29uZmlnIiwibWF4U2l6ZUtCIiwiYXBwYXJlbEltYWdlcyIsImxlbmd0aCIsInF1YWxpdHkiLCJjb21wcmVzc2VkR2VuZXJhdGVkIiwiY29tcHJlc3NCYXNlNjQiLCJnZW5lcmF0ZWRJbWFnZSIsImNvbXByZXNzZWRNb2RlbCIsIm1vZGVsSW1hZ2UiLCJjb21wcmVzc2VkQXBwYXJlbCIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJpbWciLCJtZXRhZGF0YSIsImltYWdlUHJvY2Vzc2luZ1Jlc3VsdHMiLCJmaW5hbEltYWdlU2l6ZXMiLCJtb2RlbEltYWdlU2l6ZSIsImdldEJhc2U2NFNpemUiLCJhcHBhcmVsSW1hZ2VTaXplcyIsImVycm9yIiwiQ29tcHJlc3Npb25GYWlsZWRFcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiY29uc3RydWN0b3IiLCJpbml0aWFsaXplU3RvcmFnZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsIkVycm9yIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJ2ZXJzaW9uIiwiY3JlYXRlZEF0IiwidG9JU09TdHJpbmciLCJsYXN0VXBkYXRlZCIsImdldFN0b3JlZEVudHJpZXMiLCJlbnRyaWVzSnNvbiIsInBhcnNlIiwic2F2ZUVudHJpZXMiLCJlbnRyaWVzIiwicGVyZm9ybUNsZWFudXBJZk5lZWRlZCIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsInRpbWVzdGFtcCIsImdldFRpbWUiLCJzbGljZSIsImZpbHRlckFuZFNvcnRFbnRyaWVzIiwib3B0aW9ucyIsImZpbHRlcmVkIiwiZmF2b3JpdGVzT25seSIsImZpbHRlciIsImlzRmF2b3JpdGUiLCJkYXRlUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZW50cnlEYXRlIiwic2VhcmNoVGVybSIsInRvTG93ZXJDYXNlIiwidGFncyIsInNvbWUiLCJ0YWciLCJpbmNsdWRlcyIsIm5vdGVzIiwic29ydEJ5Iiwic29ydERpcmVjdGlvbiIsImFWYWx1ZSIsImJWYWx1ZSIsInByb2Nlc3NpbmdUaW1lIiwiYWRkRW50cnkiLCJpZCIsImNvbXByZXNzZWRFbnRyeSIsImVudHJ5U2l6ZSIsInRvRml4ZWQiLCJwdXNoIiwiZ2V0RW50cmllcyIsImFsbEVudHJpZXMiLCJmaWx0ZXJlZEVudHJpZXMiLCJwYWdlIiwicGFnZVNpemUiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJwYWdpbmF0ZWRFbnRyaWVzIiwidG90YWxDb3VudCIsImN1cnJlbnRQYWdlIiwiaGFzTW9yZSIsImdldEVudHJ5IiwiZmluZCIsInVwZGF0ZUVudHJ5IiwidXBkYXRlcyIsImVudHJ5SW5kZXgiLCJmaW5kSW5kZXgiLCJ1cGRhdGVkRW50cnkiLCJkZWxldGVFbnRyeSIsImNsZWFyQWxsIiwiZ2V0U3RvcmFnZVN0YXRzIiwidG90YWxTaXplS0IiLCJmb3JFYWNoIiwidGltZXN0YW1wcyIsInRvdGFsRW50cmllcyIsIm9sZGVzdEVudHJ5IiwibmV3ZXN0RW50cnkiLCJleHBvcnRIaXN0b3J5IiwiaW1wb3J0SGlzdG9yeSIsInZhbGlkRW50cmllcyIsImV4aXN0aW5nRW50cmllcyIsImV4aXN0aW5nSWRzIiwiU2V0IiwibmV3RW50cmllcyIsImhhcyIsIm1lcmdlZEVudHJpZXMiLCJjbGVhbmVkRW50cmllcyIsInVwZGF0ZUNvbmZpZyIsIm5ld0NvbmZpZyIsImdldENvbmZpZyJdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDO0FBQ2pDLHVGQUF1Rjs7Ozs7Ozs7Ozs7O0lBbUgxRUEsK0JBQStCO2VBQS9CQTs7SUFzWEFDLHFCQUFxQjtlQUFyQkE7Ozt1QkFuZU47QUFVUDs7Q0FFQyxHQUNELE1BQU1DLGlCQUFzRDtJQUMxREMsYUFBYTtJQUNiQyxZQUFZO0lBQ1pDLGdCQUFnQjtJQUNoQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLGFBQWE7SUFDYkMsZUFBZTtBQUNqQjtBQUVBOztDQUVDLEdBQ0QsTUFBTUMsZUFBZTtJQUNuQkMsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLFVBQVU7QUFDWjtBQUVBOztDQUVDLEdBQ0QsU0FBU0M7SUFDUCxPQUFPLENBQUMsTUFBTSxFQUFFQyxLQUFLQyxHQUFHLEdBQUcsQ0FBQyxFQUFFQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRyxJQUFJO0FBQ3pFO0FBRUE7O0NBRUMsR0FDRCxTQUFTQyxtQkFBbUJDLEtBQXdCO0lBQ2xELE1BQU1DLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0g7SUFDNUIsT0FBTyxJQUFJSSxLQUFLO1FBQUNIO0tBQUssRUFBRUksSUFBSSxHQUFHO0FBQ2pDO0FBRUE7O0NBRUMsR0FDRCxlQUFlQyxxQkFDYk4sS0FBd0IsRUFDeEJPLE1BQWlDO0lBRWpDLElBQUksQ0FBQ0EsT0FBT3ZCLGNBQWMsRUFBRTtRQUMxQixPQUFPZ0I7SUFDVDtJQUVBLElBQUk7UUFDRixNQUFNUSxZQUFZRCxPQUFPeEIsY0FBYyxHQUFLLENB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